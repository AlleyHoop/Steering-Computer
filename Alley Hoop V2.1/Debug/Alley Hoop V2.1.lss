
Alley Hoop V2.1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000224  00800200  00001a90  00001b24  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001a90  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000052  00800424  00800424  00001d48  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001d48  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001d78  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000238  00000000  00000000  00001db8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004593  00000000  00000000  00001ff0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000179d  00000000  00000000  00006583  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001727  00000000  00000000  00007d20  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000006ac  00000000  00000000  00009448  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000112f  00000000  00000000  00009af4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001fa9  00000000  00000000  0000ac23  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001f0  00000000  00000000  0000cbcc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	7d c0       	rjmp	.+250    	; 0xfc <__ctors_end>
       2:	00 00       	nop
       4:	ab c0       	rjmp	.+342    	; 0x15c <__bad_interrupt>
       6:	00 00       	nop
       8:	a9 c0       	rjmp	.+338    	; 0x15c <__bad_interrupt>
       a:	00 00       	nop
       c:	a7 c0       	rjmp	.+334    	; 0x15c <__bad_interrupt>
       e:	00 00       	nop
      10:	a5 c0       	rjmp	.+330    	; 0x15c <__bad_interrupt>
      12:	00 00       	nop
      14:	a3 c0       	rjmp	.+326    	; 0x15c <__bad_interrupt>
      16:	00 00       	nop
      18:	a1 c0       	rjmp	.+322    	; 0x15c <__bad_interrupt>
      1a:	00 00       	nop
      1c:	9f c0       	rjmp	.+318    	; 0x15c <__bad_interrupt>
      1e:	00 00       	nop
      20:	9d c0       	rjmp	.+314    	; 0x15c <__bad_interrupt>
      22:	00 00       	nop
      24:	9b c0       	rjmp	.+310    	; 0x15c <__bad_interrupt>
      26:	00 00       	nop
      28:	99 c0       	rjmp	.+306    	; 0x15c <__bad_interrupt>
      2a:	00 00       	nop
      2c:	97 c0       	rjmp	.+302    	; 0x15c <__bad_interrupt>
      2e:	00 00       	nop
      30:	95 c0       	rjmp	.+298    	; 0x15c <__bad_interrupt>
      32:	00 00       	nop
      34:	93 c0       	rjmp	.+294    	; 0x15c <__bad_interrupt>
      36:	00 00       	nop
      38:	91 c0       	rjmp	.+290    	; 0x15c <__bad_interrupt>
      3a:	00 00       	nop
      3c:	8f c0       	rjmp	.+286    	; 0x15c <__bad_interrupt>
      3e:	00 00       	nop
      40:	8d c0       	rjmp	.+282    	; 0x15c <__bad_interrupt>
      42:	00 00       	nop
      44:	8b c0       	rjmp	.+278    	; 0x15c <__bad_interrupt>
      46:	00 00       	nop
      48:	89 c0       	rjmp	.+274    	; 0x15c <__bad_interrupt>
      4a:	00 00       	nop
      4c:	87 c0       	rjmp	.+270    	; 0x15c <__bad_interrupt>
      4e:	00 00       	nop
      50:	85 c0       	rjmp	.+266    	; 0x15c <__bad_interrupt>
      52:	00 00       	nop
      54:	83 c0       	rjmp	.+262    	; 0x15c <__bad_interrupt>
      56:	00 00       	nop
      58:	81 c0       	rjmp	.+258    	; 0x15c <__bad_interrupt>
      5a:	00 00       	nop
      5c:	7f c0       	rjmp	.+254    	; 0x15c <__bad_interrupt>
      5e:	00 00       	nop
      60:	7d c0       	rjmp	.+250    	; 0x15c <__bad_interrupt>
      62:	00 00       	nop
      64:	7b c0       	rjmp	.+246    	; 0x15c <__bad_interrupt>
      66:	00 00       	nop
      68:	79 c0       	rjmp	.+242    	; 0x15c <__bad_interrupt>
      6a:	00 00       	nop
      6c:	77 c0       	rjmp	.+238    	; 0x15c <__bad_interrupt>
      6e:	00 00       	nop
      70:	75 c0       	rjmp	.+234    	; 0x15c <__bad_interrupt>
      72:	00 00       	nop
      74:	73 c0       	rjmp	.+230    	; 0x15c <__bad_interrupt>
      76:	00 00       	nop
      78:	71 c0       	rjmp	.+226    	; 0x15c <__bad_interrupt>
      7a:	00 00       	nop
      7c:	6f c0       	rjmp	.+222    	; 0x15c <__bad_interrupt>
      7e:	00 00       	nop
      80:	6d c0       	rjmp	.+218    	; 0x15c <__bad_interrupt>
      82:	00 00       	nop
      84:	6b c0       	rjmp	.+214    	; 0x15c <__bad_interrupt>
      86:	00 00       	nop
      88:	69 c0       	rjmp	.+210    	; 0x15c <__bad_interrupt>
      8a:	00 00       	nop
      8c:	67 c0       	rjmp	.+206    	; 0x15c <__bad_interrupt>
      8e:	00 00       	nop
      90:	65 c0       	rjmp	.+202    	; 0x15c <__bad_interrupt>
      92:	00 00       	nop
      94:	63 c0       	rjmp	.+198    	; 0x15c <__bad_interrupt>
      96:	00 00       	nop
      98:	61 c0       	rjmp	.+194    	; 0x15c <__bad_interrupt>
      9a:	00 00       	nop
      9c:	5f c0       	rjmp	.+190    	; 0x15c <__bad_interrupt>
      9e:	00 00       	nop
      a0:	5d c0       	rjmp	.+186    	; 0x15c <__bad_interrupt>
      a2:	00 00       	nop
      a4:	5b c0       	rjmp	.+182    	; 0x15c <__bad_interrupt>
      a6:	00 00       	nop
      a8:	59 c0       	rjmp	.+178    	; 0x15c <__bad_interrupt>
      aa:	00 00       	nop
      ac:	57 c0       	rjmp	.+174    	; 0x15c <__bad_interrupt>
      ae:	00 00       	nop
      b0:	55 c0       	rjmp	.+170    	; 0x15c <__bad_interrupt>
      b2:	00 00       	nop
      b4:	53 c0       	rjmp	.+166    	; 0x15c <__bad_interrupt>
      b6:	00 00       	nop
      b8:	51 c0       	rjmp	.+162    	; 0x15c <__bad_interrupt>
      ba:	00 00       	nop
      bc:	4f c0       	rjmp	.+158    	; 0x15c <__bad_interrupt>
      be:	00 00       	nop
      c0:	4d c0       	rjmp	.+154    	; 0x15c <__bad_interrupt>
      c2:	00 00       	nop
      c4:	4b c0       	rjmp	.+150    	; 0x15c <__bad_interrupt>
      c6:	00 00       	nop
      c8:	49 c0       	rjmp	.+146    	; 0x15c <__bad_interrupt>
      ca:	00 00       	nop
      cc:	47 c0       	rjmp	.+142    	; 0x15c <__bad_interrupt>
      ce:	00 00       	nop
      d0:	45 c0       	rjmp	.+138    	; 0x15c <__bad_interrupt>
      d2:	00 00       	nop
      d4:	43 c0       	rjmp	.+134    	; 0x15c <__bad_interrupt>
      d6:	00 00       	nop
      d8:	41 c0       	rjmp	.+130    	; 0x15c <__bad_interrupt>
      da:	00 00       	nop
      dc:	3f c0       	rjmp	.+126    	; 0x15c <__bad_interrupt>
      de:	00 00       	nop
      e0:	3d c0       	rjmp	.+122    	; 0x15c <__bad_interrupt>
      e2:	00 00       	nop
      e4:	6d 04       	cpc	r6, r13
      e6:	72 04       	cpc	r7, r2
      e8:	77 04       	cpc	r7, r7
      ea:	79 04       	cpc	r7, r9
      ec:	7e 04       	cpc	r7, r14
      ee:	83 04       	cpc	r8, r3
      f0:	88 04       	cpc	r8, r8
      f2:	8d 04       	cpc	r8, r13
      f4:	90 04       	cpc	r9, r0
      f6:	93 04       	cpc	r9, r3
      f8:	98 04       	cpc	r9, r8

000000fa <__ctors_start>:
      fa:	34 07       	cpc	r19, r20

000000fc <__ctors_end>:
      fc:	11 24       	eor	r1, r1
      fe:	1f be       	out	0x3f, r1	; 63
     100:	cf ef       	ldi	r28, 0xFF	; 255
     102:	d1 e2       	ldi	r29, 0x21	; 33
     104:	de bf       	out	0x3e, r29	; 62
     106:	cd bf       	out	0x3d, r28	; 61
     108:	00 e0       	ldi	r16, 0x00	; 0
     10a:	0c bf       	out	0x3c, r16	; 60

0000010c <__do_copy_data>:
     10c:	14 e0       	ldi	r17, 0x04	; 4
     10e:	a0 e0       	ldi	r26, 0x00	; 0
     110:	b2 e0       	ldi	r27, 0x02	; 2
     112:	e0 e9       	ldi	r30, 0x90	; 144
     114:	fa e1       	ldi	r31, 0x1A	; 26
     116:	00 e0       	ldi	r16, 0x00	; 0
     118:	0b bf       	out	0x3b, r16	; 59
     11a:	02 c0       	rjmp	.+4      	; 0x120 <__do_copy_data+0x14>
     11c:	07 90       	elpm	r0, Z+
     11e:	0d 92       	st	X+, r0
     120:	a4 32       	cpi	r26, 0x24	; 36
     122:	b1 07       	cpc	r27, r17
     124:	d9 f7       	brne	.-10     	; 0x11c <__do_copy_data+0x10>

00000126 <__do_clear_bss>:
     126:	24 e0       	ldi	r18, 0x04	; 4
     128:	a4 e2       	ldi	r26, 0x24	; 36
     12a:	b4 e0       	ldi	r27, 0x04	; 4
     12c:	01 c0       	rjmp	.+2      	; 0x130 <.do_clear_bss_start>

0000012e <.do_clear_bss_loop>:
     12e:	1d 92       	st	X+, r1

00000130 <.do_clear_bss_start>:
     130:	a6 37       	cpi	r26, 0x76	; 118
     132:	b2 07       	cpc	r27, r18
     134:	e1 f7       	brne	.-8      	; 0x12e <.do_clear_bss_loop>

00000136 <__do_global_ctors>:
     136:	10 e0       	ldi	r17, 0x00	; 0
     138:	ce e7       	ldi	r28, 0x7E	; 126
     13a:	d0 e0       	ldi	r29, 0x00	; 0
     13c:	00 e0       	ldi	r16, 0x00	; 0
     13e:	06 c0       	rjmp	.+12     	; 0x14c <__do_global_ctors+0x16>
     140:	21 97       	sbiw	r28, 0x01	; 1
     142:	01 09       	sbc	r16, r1
     144:	80 2f       	mov	r24, r16
     146:	fe 01       	movw	r30, r28
     148:	0e 94 d9 0b 	call	0x17b2	; 0x17b2 <__tablejump2__>
     14c:	cd 37       	cpi	r28, 0x7D	; 125
     14e:	d1 07       	cpc	r29, r17
     150:	80 e0       	ldi	r24, 0x00	; 0
     152:	08 07       	cpc	r16, r24
     154:	a9 f7       	brne	.-22     	; 0x140 <__do_global_ctors+0xa>
     156:	66 d6       	rcall	.+3276   	; 0xe24 <main>
     158:	0c 94 46 0d 	jmp	0x1a8c	; 0x1a8c <_exit>

0000015c <__bad_interrupt>:
     15c:	51 cf       	rjmp	.-350    	; 0x0 <__vectors>

0000015e <_Z11mode_selectv>:
		digitalWrite(do_hv_relay,LOW);			//disengage engine relay
		braking_dv=0;							//stop braking
	}
}

void mode_remote(){
     15e:	8b e2       	ldi	r24, 0x2B	; 43
     160:	90 e0       	ldi	r25, 0x00	; 0
     162:	c0 d4       	rcall	.+2432   	; 0xae4 <_Z11digitalReadi>
     164:	88 23       	and	r24, r24
     166:	39 f0       	breq	.+14     	; 0x176 <_Z11mode_selectv+0x18>
     168:	81 e0       	ldi	r24, 0x01	; 1
     16a:	90 e0       	ldi	r25, 0x00	; 0
     16c:	90 93 53 04 	sts	0x0453, r25	; 0x800453 <drivemode+0x1>
     170:	80 93 52 04 	sts	0x0452, r24	; 0x800452 <drivemode>
     174:	08 95       	ret
     176:	88 e2       	ldi	r24, 0x28	; 40
     178:	90 e0       	ldi	r25, 0x00	; 0
     17a:	b4 d4       	rcall	.+2408   	; 0xae4 <_Z11digitalReadi>
     17c:	88 23       	and	r24, r24
     17e:	39 f0       	breq	.+14     	; 0x18e <_Z11mode_selectv+0x30>
     180:	82 e0       	ldi	r24, 0x02	; 2
     182:	90 e0       	ldi	r25, 0x00	; 0
     184:	90 93 53 04 	sts	0x0453, r25	; 0x800453 <drivemode+0x1>
     188:	80 93 52 04 	sts	0x0452, r24	; 0x800452 <drivemode>
     18c:	08 95       	ret
     18e:	89 e2       	ldi	r24, 0x29	; 41
     190:	90 e0       	ldi	r25, 0x00	; 0
     192:	a8 d4       	rcall	.+2384   	; 0xae4 <_Z11digitalReadi>
     194:	88 23       	and	r24, r24
     196:	39 f0       	breq	.+14     	; 0x1a6 <_Z11mode_selectv+0x48>
     198:	83 e0       	ldi	r24, 0x03	; 3
     19a:	90 e0       	ldi	r25, 0x00	; 0
     19c:	90 93 53 04 	sts	0x0453, r25	; 0x800453 <drivemode+0x1>
     1a0:	80 93 52 04 	sts	0x0452, r24	; 0x800452 <drivemode>
     1a4:	08 95       	ret
     1a6:	10 92 53 04 	sts	0x0453, r1	; 0x800453 <drivemode+0x1>
     1aa:	10 92 52 04 	sts	0x0452, r1	; 0x800452 <drivemode>
     1ae:	08 95       	ret

000001b0 <_Z9initDrivev>:
     1b0:	61 e0       	ldi	r22, 0x01	; 1
     1b2:	8a e1       	ldi	r24, 0x1A	; 26
     1b4:	90 e0       	ldi	r25, 0x00	; 0
     1b6:	c7 d3       	rcall	.+1934   	; 0x946 <_Z12digitalWriteib>
     1b8:	61 e0       	ldi	r22, 0x01	; 1
     1ba:	88 e1       	ldi	r24, 0x18	; 24
     1bc:	90 e0       	ldi	r25, 0x00	; 0
     1be:	c3 d3       	rcall	.+1926   	; 0x946 <_Z12digitalWriteib>
     1c0:	61 e0       	ldi	r22, 0x01	; 1
     1c2:	89 e1       	ldi	r24, 0x19	; 25
     1c4:	90 e0       	ldi	r25, 0x00	; 0
     1c6:	bf d3       	rcall	.+1918   	; 0x946 <_Z12digitalWriteib>
     1c8:	61 e0       	ldi	r22, 0x01	; 1
     1ca:	86 e1       	ldi	r24, 0x16	; 22
     1cc:	90 e0       	ldi	r25, 0x00	; 0
     1ce:	bb d3       	rcall	.+1910   	; 0x946 <_Z12digitalWriteib>
     1d0:	61 e0       	ldi	r22, 0x01	; 1
     1d2:	87 e1       	ldi	r24, 0x17	; 23
     1d4:	90 e0       	ldi	r25, 0x00	; 0
     1d6:	b7 d3       	rcall	.+1902   	; 0x946 <_Z12digitalWriteib>
     1d8:	c2 cf       	rjmp	.-124    	; 0x15e <_Z11mode_selectv>
     1da:	08 95       	ret

000001dc <_Z13mode_joystickv>:
     1dc:	0f 93       	push	r16
     1de:	1f 93       	push	r17
     1e0:	61 e0       	ldi	r22, 0x01	; 1
     1e2:	82 e2       	ldi	r24, 0x22	; 34
     1e4:	90 e0       	ldi	r25, 0x00	; 0
     1e6:	af d3       	rcall	.+1886   	; 0x946 <_Z12digitalWriteib>
     1e8:	61 e0       	ldi	r22, 0x01	; 1
     1ea:	8f e1       	ldi	r24, 0x1F	; 31
     1ec:	90 e0       	ldi	r25, 0x00	; 0
     1ee:	ab d3       	rcall	.+1878   	; 0x946 <_Z12digitalWriteib>
     1f0:	80 91 2a 04 	lds	r24, 0x042A	; 0x80042a <engine_rpm>
     1f4:	90 91 2b 04 	lds	r25, 0x042B	; 0x80042b <engine_rpm+0x1>
     1f8:	89 2b       	or	r24, r25
     1fa:	29 f4       	brne	.+10     	; 0x206 <_Z13mode_joystickv+0x2a>
     1fc:	8a e2       	ldi	r24, 0x2A	; 42
     1fe:	90 e0       	ldi	r25, 0x00	; 0
     200:	71 d4       	rcall	.+2274   	; 0xae4 <_Z11digitalReadi>
     202:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
     206:	84 e0       	ldi	r24, 0x04	; 4
     208:	90 e0       	ldi	r25, 0x00	; 0
     20a:	e8 d4       	rcall	.+2512   	; 0xbdc <_Z10analogReadi>
     20c:	dc 01       	movw	r26, r24
     20e:	ad 5f       	subi	r26, 0xFD	; 253
     210:	b1 40       	sbci	r27, 0x01	; 1
     212:	2e e0       	ldi	r18, 0x0E	; 14
     214:	31 e0       	ldi	r19, 0x01	; 1
     216:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <__usmulhisi3>
     21a:	99 23       	and	r25, r25
     21c:	7c f0       	brlt	.+30     	; 0x23c <_Z13mode_joystickv+0x60>
     21e:	2c e8       	ldi	r18, 0x8C	; 140
     220:	30 e0       	ldi	r19, 0x00	; 0
     222:	40 e0       	ldi	r20, 0x00	; 0
     224:	50 e0       	ldi	r21, 0x00	; 0
     226:	0e 94 bd 0b 	call	0x177a	; 0x177a <__divmodsi4>
     22a:	20 93 4a 04 	sts	0x044A, r18	; 0x80044a <steering_dv>
     22e:	30 93 4b 04 	sts	0x044B, r19	; 0x80044b <steering_dv+0x1>
     232:	40 93 4c 04 	sts	0x044C, r20	; 0x80044c <steering_dv+0x2>
     236:	50 93 4d 04 	sts	0x044D, r21	; 0x80044d <steering_dv+0x3>
     23a:	0e c0       	rjmp	.+28     	; 0x258 <_Z13mode_joystickv+0x7c>
     23c:	2f e7       	ldi	r18, 0x7F	; 127
     23e:	30 e0       	ldi	r19, 0x00	; 0
     240:	40 e0       	ldi	r20, 0x00	; 0
     242:	50 e0       	ldi	r21, 0x00	; 0
     244:	0e 94 bd 0b 	call	0x177a	; 0x177a <__divmodsi4>
     248:	20 93 4a 04 	sts	0x044A, r18	; 0x80044a <steering_dv>
     24c:	30 93 4b 04 	sts	0x044B, r19	; 0x80044b <steering_dv+0x1>
     250:	40 93 4c 04 	sts	0x044C, r20	; 0x80044c <steering_dv+0x2>
     254:	50 93 4d 04 	sts	0x044D, r21	; 0x80044d <steering_dv+0x3>
     258:	82 e0       	ldi	r24, 0x02	; 2
     25a:	90 e0       	ldi	r25, 0x00	; 0
     25c:	bf d4       	rcall	.+2430   	; 0xbdc <_Z10analogReadi>
     25e:	dc 01       	movw	r26, r24
     260:	ae 5f       	subi	r26, 0xFE	; 254
     262:	b1 40       	sbci	r27, 0x01	; 1
     264:	2f ef       	ldi	r18, 0xFF	; 255
     266:	30 e0       	ldi	r19, 0x00	; 0
     268:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <__usmulhisi3>
     26c:	60 93 4e 04 	sts	0x044E, r22	; 0x80044e <driving_dv>
     270:	70 93 4f 04 	sts	0x044F, r23	; 0x80044f <driving_dv+0x1>
     274:	80 93 50 04 	sts	0x0450, r24	; 0x800450 <driving_dv+0x2>
     278:	90 93 51 04 	sts	0x0451, r25	; 0x800451 <driving_dv+0x3>
     27c:	10 92 3b 04 	sts	0x043B, r1	; 0x80043b <engine_dv>
     280:	10 92 3c 04 	sts	0x043C, r1	; 0x80043c <engine_dv+0x1>
     284:	10 92 3d 04 	sts	0x043D, r1	; 0x80043d <engine_dv+0x2>
     288:	10 92 3e 04 	sts	0x043E, r1	; 0x80043e <engine_dv+0x3>
     28c:	10 92 37 04 	sts	0x0437, r1	; 0x800437 <braking_dv>
     290:	10 92 38 04 	sts	0x0438, r1	; 0x800438 <braking_dv+0x1>
     294:	10 92 39 04 	sts	0x0439, r1	; 0x800439 <braking_dv+0x2>
     298:	10 92 3a 04 	sts	0x043A, r1	; 0x80043a <braking_dv+0x3>
     29c:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
     2a0:	22 23       	and	r18, r18
     2a2:	c1 f1       	breq	.+112    	; 0x314 <_Z13mode_joystickv+0x138>
     2a4:	16 16       	cp	r1, r22
     2a6:	17 06       	cpc	r1, r23
     2a8:	18 06       	cpc	r1, r24
     2aa:	19 06       	cpc	r1, r25
     2ac:	7c f4       	brge	.+30     	; 0x2cc <_Z13mode_joystickv+0xf0>
     2ae:	2e e7       	ldi	r18, 0x7E	; 126
     2b0:	30 e0       	ldi	r19, 0x00	; 0
     2b2:	40 e0       	ldi	r20, 0x00	; 0
     2b4:	50 e0       	ldi	r21, 0x00	; 0
     2b6:	0e 94 bd 0b 	call	0x177a	; 0x177a <__divmodsi4>
     2ba:	20 93 3b 04 	sts	0x043B, r18	; 0x80043b <engine_dv>
     2be:	30 93 3c 04 	sts	0x043C, r19	; 0x80043c <engine_dv+0x1>
     2c2:	40 93 3d 04 	sts	0x043D, r20	; 0x80043d <engine_dv+0x2>
     2c6:	50 93 3e 04 	sts	0x043E, r21	; 0x80043e <engine_dv+0x3>
     2ca:	5b c0       	rjmp	.+182    	; 0x382 <_Z13mode_joystickv+0x1a6>
     2cc:	8b 01       	movw	r16, r22
     2ce:	9c 01       	movw	r18, r24
     2d0:	99 23       	and	r25, r25
     2d2:	24 f4       	brge	.+8      	; 0x2dc <_Z13mode_joystickv+0x100>
     2d4:	01 58       	subi	r16, 0x81	; 129
     2d6:	1f 4f       	sbci	r17, 0xFF	; 255
     2d8:	2f 4f       	sbci	r18, 0xFF	; 255
     2da:	3f 4f       	sbci	r19, 0xFF	; 255
     2dc:	68 94       	set
     2de:	16 f8       	bld	r1, 6
     2e0:	35 95       	asr	r19
     2e2:	27 95       	ror	r18
     2e4:	17 95       	ror	r17
     2e6:	07 95       	ror	r16
     2e8:	16 94       	lsr	r1
     2ea:	d1 f7       	brne	.-12     	; 0x2e0 <_Z13mode_joystickv+0x104>
     2ec:	c8 01       	movw	r24, r16
     2ee:	99 23       	and	r25, r25
     2f0:	24 f4       	brge	.+8      	; 0x2fa <_Z13mode_joystickv+0x11e>
     2f2:	88 27       	eor	r24, r24
     2f4:	99 27       	eor	r25, r25
     2f6:	80 1b       	sub	r24, r16
     2f8:	91 0b       	sbc	r25, r17
     2fa:	09 2e       	mov	r0, r25
     2fc:	00 0c       	add	r0, r0
     2fe:	aa 0b       	sbc	r26, r26
     300:	bb 0b       	sbc	r27, r27
     302:	80 93 37 04 	sts	0x0437, r24	; 0x800437 <braking_dv>
     306:	90 93 38 04 	sts	0x0438, r25	; 0x800438 <braking_dv+0x1>
     30a:	a0 93 39 04 	sts	0x0439, r26	; 0x800439 <braking_dv+0x2>
     30e:	b0 93 3a 04 	sts	0x043A, r27	; 0x80043a <braking_dv+0x3>
     312:	37 c0       	rjmp	.+110    	; 0x382 <_Z13mode_joystickv+0x1a6>
     314:	16 16       	cp	r1, r22
     316:	17 06       	cpc	r1, r23
     318:	18 06       	cpc	r1, r24
     31a:	19 06       	cpc	r1, r25
     31c:	cc f4       	brge	.+50     	; 0x350 <_Z13mode_joystickv+0x174>
     31e:	8b 01       	movw	r16, r22
     320:	9c 01       	movw	r18, r24
     322:	99 23       	and	r25, r25
     324:	24 f4       	brge	.+8      	; 0x32e <_Z13mode_joystickv+0x152>
     326:	01 58       	subi	r16, 0x81	; 129
     328:	1f 4f       	sbci	r17, 0xFF	; 255
     32a:	2f 4f       	sbci	r18, 0xFF	; 255
     32c:	3f 4f       	sbci	r19, 0xFF	; 255
     32e:	68 94       	set
     330:	16 f8       	bld	r1, 6
     332:	35 95       	asr	r19
     334:	27 95       	ror	r18
     336:	17 95       	ror	r17
     338:	07 95       	ror	r16
     33a:	16 94       	lsr	r1
     33c:	d1 f7       	brne	.-12     	; 0x332 <_Z13mode_joystickv+0x156>
     33e:	00 93 37 04 	sts	0x0437, r16	; 0x800437 <braking_dv>
     342:	10 93 38 04 	sts	0x0438, r17	; 0x800438 <braking_dv+0x1>
     346:	20 93 39 04 	sts	0x0439, r18	; 0x800439 <braking_dv+0x2>
     34a:	30 93 3a 04 	sts	0x043A, r19	; 0x80043a <braking_dv+0x3>
     34e:	19 c0       	rjmp	.+50     	; 0x382 <_Z13mode_joystickv+0x1a6>
     350:	2e e7       	ldi	r18, 0x7E	; 126
     352:	30 e0       	ldi	r19, 0x00	; 0
     354:	40 e0       	ldi	r20, 0x00	; 0
     356:	50 e0       	ldi	r21, 0x00	; 0
     358:	0e 94 bd 0b 	call	0x177a	; 0x177a <__divmodsi4>
     35c:	c9 01       	movw	r24, r18
     35e:	99 23       	and	r25, r25
     360:	24 f4       	brge	.+8      	; 0x36a <_Z13mode_joystickv+0x18e>
     362:	88 27       	eor	r24, r24
     364:	99 27       	eor	r25, r25
     366:	82 1b       	sub	r24, r18
     368:	93 0b       	sbc	r25, r19
     36a:	09 2e       	mov	r0, r25
     36c:	00 0c       	add	r0, r0
     36e:	aa 0b       	sbc	r26, r26
     370:	bb 0b       	sbc	r27, r27
     372:	80 93 3b 04 	sts	0x043B, r24	; 0x80043b <engine_dv>
     376:	90 93 3c 04 	sts	0x043C, r25	; 0x80043c <engine_dv+0x1>
     37a:	a0 93 3d 04 	sts	0x043D, r26	; 0x80043d <engine_dv+0x2>
     37e:	b0 93 3e 04 	sts	0x043E, r27	; 0x80043e <engine_dv+0x3>
     382:	80 91 37 04 	lds	r24, 0x0437	; 0x800437 <braking_dv>
     386:	90 91 38 04 	lds	r25, 0x0438	; 0x800438 <braking_dv+0x1>
     38a:	a0 91 39 04 	lds	r26, 0x0439	; 0x800439 <braking_dv+0x2>
     38e:	b0 91 3a 04 	lds	r27, 0x043A	; 0x80043a <braking_dv+0x3>
     392:	8f 3f       	cpi	r24, 0xFF	; 255
     394:	91 05       	cpc	r25, r1
     396:	a1 05       	cpc	r26, r1
     398:	b1 05       	cpc	r27, r1
     39a:	29 f0       	breq	.+10     	; 0x3a6 <_Z13mode_joystickv+0x1ca>
     39c:	24 f0       	brlt	.+8      	; 0x3a6 <_Z13mode_joystickv+0x1ca>
     39e:	8f ef       	ldi	r24, 0xFF	; 255
     3a0:	90 e0       	ldi	r25, 0x00	; 0
     3a2:	a0 e0       	ldi	r26, 0x00	; 0
     3a4:	b0 e0       	ldi	r27, 0x00	; 0
     3a6:	bb 23       	and	r27, r27
     3a8:	1c f4       	brge	.+6      	; 0x3b0 <_Z13mode_joystickv+0x1d4>
     3aa:	80 e0       	ldi	r24, 0x00	; 0
     3ac:	90 e0       	ldi	r25, 0x00	; 0
     3ae:	dc 01       	movw	r26, r24
     3b0:	80 93 37 04 	sts	0x0437, r24	; 0x800437 <braking_dv>
     3b4:	90 93 38 04 	sts	0x0438, r25	; 0x800438 <braking_dv+0x1>
     3b8:	a0 93 39 04 	sts	0x0439, r26	; 0x800439 <braking_dv+0x2>
     3bc:	b0 93 3a 04 	sts	0x043A, r27	; 0x80043a <braking_dv+0x3>
     3c0:	1f 91       	pop	r17
     3c2:	0f 91       	pop	r16
     3c4:	08 95       	ret

000003c6 <_Z9mode_idlev>:
     3c6:	10 92 3b 04 	sts	0x043B, r1	; 0x80043b <engine_dv>
     3ca:	10 92 3c 04 	sts	0x043C, r1	; 0x80043c <engine_dv+0x1>
     3ce:	10 92 3d 04 	sts	0x043D, r1	; 0x80043d <engine_dv+0x2>
     3d2:	10 92 3e 04 	sts	0x043E, r1	; 0x80043e <engine_dv+0x3>
     3d6:	10 92 4a 04 	sts	0x044A, r1	; 0x80044a <steering_dv>
     3da:	10 92 4b 04 	sts	0x044B, r1	; 0x80044b <steering_dv+0x1>
     3de:	10 92 4c 04 	sts	0x044C, r1	; 0x80044c <steering_dv+0x2>
     3e2:	10 92 4d 04 	sts	0x044D, r1	; 0x80044d <steering_dv+0x3>
     3e6:	84 e6       	ldi	r24, 0x64	; 100
     3e8:	90 e0       	ldi	r25, 0x00	; 0
     3ea:	a0 e0       	ldi	r26, 0x00	; 0
     3ec:	b0 e0       	ldi	r27, 0x00	; 0
     3ee:	80 93 37 04 	sts	0x0437, r24	; 0x800437 <braking_dv>
     3f2:	90 93 38 04 	sts	0x0438, r25	; 0x800438 <braking_dv+0x1>
     3f6:	a0 93 39 04 	sts	0x0439, r26	; 0x800439 <braking_dv+0x2>
     3fa:	b0 93 3a 04 	sts	0x043A, r27	; 0x80043a <braking_dv+0x3>
     3fe:	80 91 2a 04 	lds	r24, 0x042A	; 0x80042a <engine_rpm>
     402:	90 91 2b 04 	lds	r25, 0x042B	; 0x80042b <engine_rpm+0x1>
     406:	89 2b       	or	r24, r25
     408:	61 f4       	brne	.+24     	; 0x422 <__LOCK_REGION_LENGTH__+0x22>
     40a:	60 e0       	ldi	r22, 0x00	; 0
     40c:	8f e1       	ldi	r24, 0x1F	; 31
     40e:	90 e0       	ldi	r25, 0x00	; 0
     410:	9a d2       	rcall	.+1332   	; 0x946 <_Z12digitalWriteib>
     412:	10 92 37 04 	sts	0x0437, r1	; 0x800437 <braking_dv>
     416:	10 92 38 04 	sts	0x0438, r1	; 0x800438 <braking_dv+0x1>
     41a:	10 92 39 04 	sts	0x0439, r1	; 0x800439 <braking_dv+0x2>
     41e:	10 92 3a 04 	sts	0x043A, r1	; 0x80043a <braking_dv+0x3>
     422:	08 95       	ret

00000424 <_Z9run_brakev>:
	//digitalWrite(do_hv_relay,HIGH);
	//not (yet) implemented
}

void run_brake(){
	braking_cv = (long(analogRead(ai_brake_pressure) - braking_sensor_offset) * (250 / 1023));				//retrieve the current value of the brake pressure sensor
     424:	81 e0       	ldi	r24, 0x01	; 1
     426:	90 e0       	ldi	r25, 0x00	; 0
     428:	d9 d3       	rcall	.+1970   	; 0xbdc <_Z10analogReadi>
     42a:	10 92 2f 04 	sts	0x042F, r1	; 0x80042f <braking_cv>
     42e:	10 92 30 04 	sts	0x0430, r1	; 0x800430 <braking_cv+0x1>
     432:	10 92 31 04 	sts	0x0431, r1	; 0x800431 <braking_cv+0x2>
     436:	10 92 32 04 	sts	0x0432, r1	; 0x800432 <braking_cv+0x3>
	braking_delta = braking_dv - braking_cv;
     43a:	40 91 37 04 	lds	r20, 0x0437	; 0x800437 <braking_dv>
     43e:	50 91 38 04 	lds	r21, 0x0438	; 0x800438 <braking_dv+0x1>
     442:	60 91 39 04 	lds	r22, 0x0439	; 0x800439 <braking_dv+0x2>
     446:	70 91 3a 04 	lds	r23, 0x043A	; 0x80043a <braking_dv+0x3>
	if(abs(braking_delta)<10)
     44a:	ca 01       	movw	r24, r20
     44c:	09 96       	adiw	r24, 0x09	; 9
     44e:	43 97       	sbiw	r24, 0x13	; 19
     450:	48 f0       	brcs	.+18     	; 0x464 <_Z9run_brakev+0x40>
	//not (yet) implemented
}

void run_brake(){
	braking_cv = (long(analogRead(ai_brake_pressure) - braking_sensor_offset) * (250 / 1023));				//retrieve the current value of the brake pressure sensor
	braking_delta = braking_dv - braking_cv;
     452:	40 93 33 04 	sts	0x0433, r20	; 0x800433 <braking_delta>
     456:	50 93 34 04 	sts	0x0434, r21	; 0x800434 <braking_delta+0x1>
     45a:	60 93 35 04 	sts	0x0435, r22	; 0x800435 <braking_delta+0x2>
     45e:	70 93 36 04 	sts	0x0436, r23	; 0x800436 <braking_delta+0x3>
     462:	08 c0       	rjmp	.+16     	; 0x474 <_Z9run_brakev+0x50>
	if(abs(braking_delta)<10)
		braking_delta = 0;
     464:	10 92 33 04 	sts	0x0433, r1	; 0x800433 <braking_delta>
     468:	10 92 34 04 	sts	0x0434, r1	; 0x800434 <braking_delta+0x1>
     46c:	10 92 35 04 	sts	0x0435, r1	; 0x800435 <braking_delta+0x2>
     470:	10 92 36 04 	sts	0x0436, r1	; 0x800436 <braking_delta+0x3>
	braking_ov = constrain(braking_dv * braking_kp, 0, 255);
     474:	db 01       	movw	r26, r22
     476:	ca 01       	movw	r24, r20
     478:	88 0f       	add	r24, r24
     47a:	99 1f       	adc	r25, r25
     47c:	aa 1f       	adc	r26, r26
     47e:	bb 1f       	adc	r27, r27
     480:	84 0f       	add	r24, r20
     482:	95 1f       	adc	r25, r21
     484:	a6 1f       	adc	r26, r22
     486:	b7 1f       	adc	r27, r23
     488:	bb 23       	and	r27, r27
     48a:	5c f0       	brlt	.+22     	; 0x4a2 <_Z9run_brakev+0x7e>
     48c:	8f 3f       	cpi	r24, 0xFF	; 255
     48e:	91 05       	cpc	r25, r1
     490:	a1 05       	cpc	r26, r1
     492:	b1 05       	cpc	r27, r1
     494:	39 f0       	breq	.+14     	; 0x4a4 <_Z9run_brakev+0x80>
     496:	34 f0       	brlt	.+12     	; 0x4a4 <_Z9run_brakev+0x80>
     498:	8f ef       	ldi	r24, 0xFF	; 255
     49a:	90 e0       	ldi	r25, 0x00	; 0
     49c:	a0 e0       	ldi	r26, 0x00	; 0
     49e:	b0 e0       	ldi	r27, 0x00	; 0
     4a0:	01 c0       	rjmp	.+2      	; 0x4a4 <_Z9run_brakev+0x80>
     4a2:	80 e0       	ldi	r24, 0x00	; 0
     4a4:	80 93 2e 04 	sts	0x042E, r24	; 0x80042e <braking_ov>
	analogWrite(pwm_brake_pump, braking_dv);															//Write op to brake pump
     4a8:	ba 01       	movw	r22, r20
     4aa:	87 e0       	ldi	r24, 0x07	; 7
     4ac:	90 e0       	ldi	r25, 0x00	; 0
     4ae:	05 c2       	rjmp	.+1034   	; 0x8ba <_Z11analogWriteii>
     4b0:	08 95       	ret

000004b2 <_Z9run_steerv>:
}

void run_steer(){
     4b2:	8f 92       	push	r8
     4b4:	9f 92       	push	r9
     4b6:	af 92       	push	r10
     4b8:	bf 92       	push	r11
     4ba:	cf 92       	push	r12
     4bc:	df 92       	push	r13
     4be:	ef 92       	push	r14
     4c0:	ff 92       	push	r15
     4c2:	0f 93       	push	r16
     4c4:	1f 93       	push	r17
     4c6:	cf 93       	push	r28
     4c8:	df 93       	push	r29
	steering_cv = (analogRead(ai_steer_pot)-steering_sensor_offset);							//get the offset from the default position by subtracting the offset from the retrieved value
     4ca:	80 e0       	ldi	r24, 0x00	; 0
     4cc:	90 e0       	ldi	r25, 0x00	; 0
     4ce:	86 d3       	rcall	.+1804   	; 0xbdc <_Z10analogReadi>
	steering_cv = -steering_cv;																	//because the potentiometer gives it value the other way(left = max, right is minimum), invert this.
	steering_cv *= steering_max_deg;															//convert to degrees
	steering_cv /= steering_sensor_maximum;														//divide by the maximum to get the ratio between 0-1
     4d0:	ac 01       	movw	r20, r24
     4d2:	52 50       	subi	r21, 0x02	; 2
     4d4:	95 2f       	mov	r25, r21
     4d6:	99 0f       	add	r25, r25
     4d8:	99 0b       	sbc	r25, r25
     4da:	24 2f       	mov	r18, r20
     4dc:	35 2f       	mov	r19, r21
     4de:	49 2f       	mov	r20, r25
     4e0:	59 2f       	mov	r21, r25
     4e2:	69 2f       	mov	r22, r25
     4e4:	79 2f       	mov	r23, r25
     4e6:	89 2f       	mov	r24, r25
     4e8:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <__negdi2>
     4ec:	01 e0       	ldi	r16, 0x01	; 1
     4ee:	0e 94 b7 0c 	call	0x196e	; 0x196e <__ashldi3>
     4f2:	82 2e       	mov	r8, r18
     4f4:	93 2e       	mov	r9, r19
     4f6:	d4 2f       	mov	r29, r20
     4f8:	c5 2f       	mov	r28, r21
     4fa:	b6 2f       	mov	r27, r22
     4fc:	a7 2f       	mov	r26, r23
     4fe:	f8 2f       	mov	r31, r24
     500:	e9 2f       	mov	r30, r25
     502:	03 e0       	ldi	r16, 0x03	; 3
     504:	0e 94 b7 0c 	call	0x196e	; 0x196e <__ashldi3>
     508:	a2 2e       	mov	r10, r18
     50a:	b3 2e       	mov	r11, r19
     50c:	c4 2e       	mov	r12, r20
     50e:	d5 2e       	mov	r13, r21
     510:	e6 2e       	mov	r14, r22
     512:	f7 2e       	mov	r15, r23
     514:	08 2f       	mov	r16, r24
     516:	19 2f       	mov	r17, r25
     518:	28 2d       	mov	r18, r8
     51a:	39 2d       	mov	r19, r9
     51c:	4d 2f       	mov	r20, r29
     51e:	5c 2f       	mov	r21, r28
     520:	6b 2f       	mov	r22, r27
     522:	7a 2f       	mov	r23, r26
     524:	8f 2f       	mov	r24, r31
     526:	9e 2f       	mov	r25, r30
     528:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <__adddi3>
     52c:	a2 2e       	mov	r10, r18
     52e:	b3 2e       	mov	r11, r19
     530:	c4 2e       	mov	r12, r20
     532:	d5 2e       	mov	r13, r21
     534:	e6 2e       	mov	r14, r22
     536:	f7 2e       	mov	r15, r23
     538:	e8 2f       	mov	r30, r24
     53a:	19 2f       	mov	r17, r25
     53c:	04 e0       	ldi	r16, 0x04	; 4
     53e:	0e 94 b7 0c 	call	0x196e	; 0x196e <__ashldi3>
     542:	0e 2f       	mov	r16, r30
     544:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <__subdi3>
     548:	0f 2e       	mov	r0, r31
     54a:	fc e2       	ldi	r31, 0x2C	; 44
     54c:	af 2e       	mov	r10, r31
     54e:	f0 2d       	mov	r31, r0
     550:	bb 24       	eor	r11, r11
     552:	b3 94       	inc	r11
     554:	c1 2c       	mov	r12, r1
     556:	d1 2c       	mov	r13, r1
     558:	e1 2c       	mov	r14, r1
     55a:	f1 2c       	mov	r15, r1
     55c:	00 e0       	ldi	r16, 0x00	; 0
     55e:	10 e0       	ldi	r17, 0x00	; 0
     560:	0e 94 e9 0b 	call	0x17d2	; 0x17d2 <__divdi3>
     564:	d2 2f       	mov	r29, r18
     566:	c3 2f       	mov	r28, r19
     568:	b4 2f       	mov	r27, r20
     56a:	a5 2f       	mov	r26, r21
     56c:	f6 2f       	mov	r31, r22
     56e:	e7 2f       	mov	r30, r23
     570:	02 2f       	mov	r16, r18
     572:	13 2f       	mov	r17, r19
     574:	d0 93 40 04 	sts	0x0440, r29	; 0x800440 <steering_cv>
     578:	c0 93 41 04 	sts	0x0441, r28	; 0x800441 <steering_cv+0x1>
     57c:	b0 93 42 04 	sts	0x0442, r27	; 0x800442 <steering_cv+0x2>
     580:	a0 93 43 04 	sts	0x0443, r26	; 0x800443 <steering_cv+0x3>
     584:	f0 93 44 04 	sts	0x0444, r31	; 0x800444 <steering_cv+0x4>
     588:	e0 93 45 04 	sts	0x0445, r30	; 0x800445 <steering_cv+0x5>
     58c:	80 93 46 04 	sts	0x0446, r24	; 0x800446 <steering_cv+0x6>
     590:	90 93 47 04 	sts	0x0447, r25	; 0x800447 <steering_cv+0x7>
	
	if(abs(steering_dv)<steering_deadzone)														//create a dead zone around default joystick position, desired value must at least be bigger then dead zone value (makes going straight easier
     594:	80 91 4a 04 	lds	r24, 0x044A	; 0x80044a <steering_dv>
     598:	90 91 4b 04 	lds	r25, 0x044B	; 0x80044b <steering_dv+0x1>
     59c:	a0 91 4c 04 	lds	r26, 0x044C	; 0x80044c <steering_dv+0x2>
     5a0:	b0 91 4d 04 	lds	r27, 0x044D	; 0x80044d <steering_dv+0x3>
     5a4:	fc 01       	movw	r30, r24
     5a6:	73 96       	adiw	r30, 0x13	; 19
     5a8:	b7 97       	sbiw	r30, 0x27	; 39
     5aa:	80 f4       	brcc	.+32     	; 0x5cc <_Z9run_steerv+0x11a>
		steering_dv = 0;
     5ac:	10 92 4a 04 	sts	0x044A, r1	; 0x80044a <steering_dv>
     5b0:	10 92 4b 04 	sts	0x044B, r1	; 0x80044b <steering_dv+0x1>
     5b4:	10 92 4c 04 	sts	0x044C, r1	; 0x80044c <steering_dv+0x2>
     5b8:	10 92 4d 04 	sts	0x044D, r1	; 0x80044d <steering_dv+0x3>
	steering_delta = steering_dv - steering_cv;													//difference between desired value and current value
     5bc:	11 95       	neg	r17
     5be:	01 95       	neg	r16
     5c0:	11 09       	sbc	r17, r1
     5c2:	10 93 49 04 	sts	0x0449, r17	; 0x800449 <steering_delta+0x1>
     5c6:	00 93 48 04 	sts	0x0448, r16	; 0x800448 <steering_delta>
     5ca:	19 c0       	rjmp	.+50     	; 0x5fe <_Z9run_steerv+0x14c>
     5cc:	9c 01       	movw	r18, r24
     5ce:	20 1b       	sub	r18, r16
     5d0:	31 0b       	sbc	r19, r17
     5d2:	30 93 49 04 	sts	0x0449, r19	; 0x800449 <steering_delta+0x1>
     5d6:	20 93 48 04 	sts	0x0448, r18	; 0x800448 <steering_delta>
	if((abs(steering_delta)<10) && (steering_dv!= 0))											//if the two are too close together except the default position, don't steer, this to prevent the motor from constantly trying to make small correcting movements which it is not capable of, so it starts screeching
     5da:	27 5f       	subi	r18, 0xF7	; 247
     5dc:	3f 4f       	sbci	r19, 0xFF	; 255
     5de:	23 31       	cpi	r18, 0x13	; 19
     5e0:	31 05       	cpc	r19, r1
     5e2:	68 f4       	brcc	.+26     	; 0x5fe <_Z9run_steerv+0x14c>
     5e4:	89 2b       	or	r24, r25
     5e6:	8a 2b       	or	r24, r26
     5e8:	8b 2b       	or	r24, r27
     5ea:	49 f0       	breq	.+18     	; 0x5fe <_Z9run_steerv+0x14c>
		steering_delta=0;
     5ec:	10 92 49 04 	sts	0x0449, r1	; 0x800449 <steering_delta+0x1>
     5f0:	10 92 48 04 	sts	0x0448, r1	; 0x800448 <steering_delta>
	steering_ov = constrain((abs(steering_delta) * steering_kp), 0, 255);						//determine the output PMW value in such a way that the smaller the delta, the slower it goes to smooth out steering
     5f4:	60 e0       	ldi	r22, 0x00	; 0
     5f6:	70 e0       	ldi	r23, 0x00	; 0
     5f8:	80 e0       	ldi	r24, 0x00	; 0
     5fa:	90 e0       	ldi	r25, 0x00	; 0
     5fc:	15 c0       	rjmp	.+42     	; 0x628 <_Z9run_steerv+0x176>
     5fe:	80 91 48 04 	lds	r24, 0x0448	; 0x800448 <steering_delta>
     602:	90 91 49 04 	lds	r25, 0x0449	; 0x800449 <steering_delta+0x1>
     606:	9c 01       	movw	r18, r24
     608:	99 23       	and	r25, r25
     60a:	24 f4       	brge	.+8      	; 0x614 <_Z9run_steerv+0x162>
     60c:	22 27       	eor	r18, r18
     60e:	33 27       	eor	r19, r19
     610:	28 1b       	sub	r18, r24
     612:	39 0b       	sbc	r19, r25
     614:	b9 01       	movw	r22, r18
     616:	66 0f       	add	r22, r22
     618:	77 1f       	adc	r23, r23
     61a:	66 0f       	add	r22, r22
     61c:	77 1f       	adc	r23, r23
     61e:	66 0f       	add	r22, r22
     620:	77 1f       	adc	r23, r23
     622:	62 1b       	sub	r22, r18
     624:	73 0b       	sbc	r23, r19
     626:	3a f0       	brmi	.+14     	; 0x636 <_Z9run_steerv+0x184>
     628:	6f 3f       	cpi	r22, 0xFF	; 255
     62a:	71 05       	cpc	r23, r1
     62c:	29 f0       	breq	.+10     	; 0x638 <_Z9run_steerv+0x186>
     62e:	24 f0       	brlt	.+8      	; 0x638 <_Z9run_steerv+0x186>
     630:	6f ef       	ldi	r22, 0xFF	; 255
     632:	70 e0       	ldi	r23, 0x00	; 0
     634:	01 c0       	rjmp	.+2      	; 0x638 <_Z9run_steerv+0x186>
     636:	60 e0       	ldi	r22, 0x00	; 0
     638:	60 93 3f 04 	sts	0x043F, r22	; 0x80043f <steering_ov>
		
	if (steering_delta > 0) {																	//H bridge settings, let the engine turn the correct way
     63c:	18 16       	cp	r1, r24
     63e:	19 06       	cpc	r1, r25
     640:	54 f4       	brge	.+20     	; 0x656 <_Z9run_steerv+0x1a4>
		analogWrite(pwm_steer_rpwm, steering_ov);												//if the delta is smaller than 0, turn to the right		
     642:	70 e0       	ldi	r23, 0x00	; 0
     644:	82 e0       	ldi	r24, 0x02	; 2
     646:	90 e0       	ldi	r25, 0x00	; 0
     648:	38 d1       	rcall	.+624    	; 0x8ba <_Z11analogWriteii>
		analogWrite(pwm_steer_lpwm, 0);
     64a:	60 e0       	ldi	r22, 0x00	; 0
     64c:	70 e0       	ldi	r23, 0x00	; 0
     64e:	83 e0       	ldi	r24, 0x03	; 3
     650:	90 e0       	ldi	r25, 0x00	; 0
     652:	33 d1       	rcall	.+614    	; 0x8ba <_Z11analogWriteii>
     654:	18 c0       	rjmp	.+48     	; 0x686 <_Z9run_steerv+0x1d4>
	}
	else if (steering_delta < 0) {
     656:	99 23       	and	r25, r25
     658:	64 f4       	brge	.+24     	; 0x672 <_Z9run_steerv+0x1c0>
		analogWrite(pwm_steer_rpwm, 0);															//if the delta is larger than 0
     65a:	60 e0       	ldi	r22, 0x00	; 0
     65c:	70 e0       	ldi	r23, 0x00	; 0
     65e:	82 e0       	ldi	r24, 0x02	; 2
     660:	90 e0       	ldi	r25, 0x00	; 0
     662:	2b d1       	rcall	.+598    	; 0x8ba <_Z11analogWriteii>
		analogWrite(pwm_steer_lpwm, steering_ov);
     664:	60 91 3f 04 	lds	r22, 0x043F	; 0x80043f <steering_ov>
     668:	70 e0       	ldi	r23, 0x00	; 0
     66a:	83 e0       	ldi	r24, 0x03	; 3
     66c:	90 e0       	ldi	r25, 0x00	; 0
     66e:	25 d1       	rcall	.+586    	; 0x8ba <_Z11analogWriteii>
     670:	0a c0       	rjmp	.+20     	; 0x686 <_Z9run_steerv+0x1d4>
	}
	else {
		analogWrite(pwm_steer_rpwm, 0);															//if neither, do nothing
     672:	60 e0       	ldi	r22, 0x00	; 0
     674:	70 e0       	ldi	r23, 0x00	; 0
     676:	82 e0       	ldi	r24, 0x02	; 2
     678:	90 e0       	ldi	r25, 0x00	; 0
     67a:	1f d1       	rcall	.+574    	; 0x8ba <_Z11analogWriteii>
		analogWrite(pwm_steer_lpwm, 0);
     67c:	60 e0       	ldi	r22, 0x00	; 0
     67e:	70 e0       	ldi	r23, 0x00	; 0
     680:	83 e0       	ldi	r24, 0x03	; 3
     682:	90 e0       	ldi	r25, 0x00	; 0
     684:	1a d1       	rcall	.+564    	; 0x8ba <_Z11analogWriteii>
     686:	df 91       	pop	r29
	}	
}
     688:	cf 91       	pop	r28
     68a:	1f 91       	pop	r17
     68c:	0f 91       	pop	r16
     68e:	ff 90       	pop	r15
     690:	ef 90       	pop	r14
     692:	df 90       	pop	r13
     694:	cf 90       	pop	r12
     696:	bf 90       	pop	r11
     698:	af 90       	pop	r10
     69a:	9f 90       	pop	r9
     69c:	8f 90       	pop	r8
     69e:	08 95       	ret

000006a0 <_Z10run_curtisv>:
     6a0:	60 91 00 02 	lds	r22, 0x0200	; 0x800200 <__data_start>

void run_curtis(){
	digitalWrite(do_engine_forward, driving_direction);											//give the Curtis the correct driving direction
     6a4:	8b e1       	ldi	r24, 0x1B	; 27
     6a6:	90 e0       	ldi	r25, 0x00	; 0
     6a8:	4e d1       	rcall	.+668    	; 0x946 <_Z12digitalWriteib>
	digitalWrite(do_engine_reverse, !driving_direction);
     6aa:	60 91 00 02 	lds	r22, 0x0200	; 0x800200 <__data_start>
     6ae:	81 e0       	ldi	r24, 0x01	; 1
     6b0:	68 27       	eor	r22, r24
     6b2:	8c e1       	ldi	r24, 0x1C	; 28
     6b4:	90 e0       	ldi	r25, 0x00	; 0
     6b6:	47 d1       	rcall	.+654    	; 0x946 <_Z12digitalWriteib>
	
	if(abs(engine_dv)<driving_deadzone)														//create a dead zone around the standing still position, desired value must at least be bigger then dead zone value (makes standing still easier)
     6b8:	80 91 3b 04 	lds	r24, 0x043B	; 0x80043b <engine_dv>
     6bc:	90 91 3c 04 	lds	r25, 0x043C	; 0x80043c <engine_dv+0x1>
     6c0:	43 96       	adiw	r24, 0x13	; 19
     6c2:	87 97       	sbiw	r24, 0x27	; 39
     6c4:	40 f4       	brcc	.+16     	; 0x6d6 <_Z10run_curtisv+0x36>
		engine_dv = 0;
     6c6:	10 92 3b 04 	sts	0x043B, r1	; 0x80043b <engine_dv>
     6ca:	10 92 3c 04 	sts	0x043C, r1	; 0x80043c <engine_dv+0x1>
     6ce:	10 92 3d 04 	sts	0x043D, r1	; 0x80043d <engine_dv+0x2>
     6d2:	10 92 3e 04 	sts	0x043E, r1	; 0x80043e <engine_dv+0x3>
     6d6:	80 91 3b 04 	lds	r24, 0x043B	; 0x80043b <engine_dv>
     6da:	90 91 3c 04 	lds	r25, 0x043C	; 0x80043c <engine_dv+0x1>
     6de:	a0 91 3d 04 	lds	r26, 0x043D	; 0x80043d <engine_dv+0x2>
     6e2:	b0 91 3e 04 	lds	r27, 0x043E	; 0x80043e <engine_dv+0x3>
     6e6:	8f 3f       	cpi	r24, 0xFF	; 255
     6e8:	91 05       	cpc	r25, r1
     6ea:	a1 05       	cpc	r26, r1
     6ec:	b1 05       	cpc	r27, r1
     6ee:	29 f0       	breq	.+10     	; 0x6fa <_Z10run_curtisv+0x5a>
     6f0:	24 f0       	brlt	.+8      	; 0x6fa <_Z10run_curtisv+0x5a>
     6f2:	8f ef       	ldi	r24, 0xFF	; 255
     6f4:	90 e0       	ldi	r25, 0x00	; 0
     6f6:	a0 e0       	ldi	r26, 0x00	; 0
     6f8:	b0 e0       	ldi	r27, 0x00	; 0
     6fa:	bb 23       	and	r27, r27
     6fc:	1c f4       	brge	.+6      	; 0x704 <_Z10run_curtisv+0x64>
     6fe:	80 e0       	ldi	r24, 0x00	; 0
     700:	90 e0       	ldi	r25, 0x00	; 0
     702:	dc 01       	movw	r26, r24
		engine_dv = constrain(engine_dv, 0, drive_max_PWM);	//constrain the value, preventing an integer overflow if a too high of a value was supplied
     704:	80 93 3b 04 	sts	0x043B, r24	; 0x80043b <engine_dv>
     708:	90 93 3c 04 	sts	0x043C, r25	; 0x80043c <engine_dv+0x1>
     70c:	a0 93 3d 04 	sts	0x043D, r26	; 0x80043d <engine_dv+0x2>
     710:	b0 93 3e 04 	sts	0x043E, r27	; 0x80043e <engine_dv+0x3>

			
	//Set the Curtis in the right mode for braking, driving or neutral																		//if we want to brake
		digitalWrite(do_engine_throttleswitch, engine_dv);				//if there is an engine signal, enable listening to the throttle
     714:	61 e0       	ldi	r22, 0x01	; 1
     716:	89 2b       	or	r24, r25
     718:	8a 2b       	or	r24, r26
     71a:	8b 2b       	or	r24, r27
     71c:	09 f4       	brne	.+2      	; 0x720 <_Z10run_curtisv+0x80>
     71e:	60 e0       	ldi	r22, 0x00	; 0
     720:	8e e1       	ldi	r24, 0x1E	; 30
     722:	90 e0       	ldi	r25, 0x00	; 0
     724:	10 d1       	rcall	.+544    	; 0x946 <_Z12digitalWriteib>
		digitalWrite(do_engine_brake, braking_dv);						//if there is an braking signal, turn on the braking 
     726:	61 e0       	ldi	r22, 0x01	; 1
     728:	80 91 37 04 	lds	r24, 0x0437	; 0x800437 <braking_dv>
     72c:	90 91 38 04 	lds	r25, 0x0438	; 0x800438 <braking_dv+0x1>
     730:	a0 91 39 04 	lds	r26, 0x0439	; 0x800439 <braking_dv+0x2>
     734:	b0 91 3a 04 	lds	r27, 0x043A	; 0x80043a <braking_dv+0x3>
     738:	89 2b       	or	r24, r25
     73a:	8a 2b       	or	r24, r26
     73c:	8b 2b       	or	r24, r27
     73e:	09 f4       	brne	.+2      	; 0x742 <_Z10run_curtisv+0xa2>
     740:	60 e0       	ldi	r22, 0x00	; 0
     742:	8d e1       	ldi	r24, 0x1D	; 29
     744:	90 e0       	ldi	r25, 0x00	; 0
     746:	ff d0       	rcall	.+510    	; 0x946 <_Z12digitalWriteib>

	analogWrite(pwm_drive_throttle, engine_dv);								//Write op to throttle signal of Curtis
     748:	60 91 3b 04 	lds	r22, 0x043B	; 0x80043b <engine_dv>
     74c:	70 91 3c 04 	lds	r23, 0x043C	; 0x80043c <engine_dv+0x1>
     750:	88 e0       	ldi	r24, 0x08	; 8
     752:	90 e0       	ldi	r25, 0x00	; 0
     754:	b2 c0       	rjmp	.+356    	; 0x8ba <_Z11analogWriteii>
     756:	08 95       	ret

00000758 <_Z5drivev>:
	}
}

void drive(){
	//get correct driving input parameters from selected source (remote and auto not implemented, thus being interpreted as idle)
	mode_select();
     758:	02 dd       	rcall	.-1532   	; 0x15e <_Z11mode_selectv>
	switch(drivemode){
     75a:	80 91 52 04 	lds	r24, 0x0452	; 0x800452 <drivemode>
     75e:	90 91 53 04 	lds	r25, 0x0453	; 0x800453 <drivemode+0x1>
     762:	81 30       	cpi	r24, 0x01	; 1
     764:	91 05       	cpc	r25, r1
     766:	51 f0       	breq	.+20     	; 0x77c <_Z5drivev+0x24>
     768:	1c f4       	brge	.+6      	; 0x770 <_Z5drivev+0x18>
     76a:	89 2b       	or	r24, r25
     76c:	49 f0       	breq	.+18     	; 0x780 <_Z5drivev+0x28>
     76e:	0d c0       	rjmp	.+26     	; 0x78a <_Z5drivev+0x32>
     770:	82 30       	cpi	r24, 0x02	; 2
     772:	91 05       	cpc	r25, r1
     774:	49 f0       	breq	.+18     	; 0x788 <_Z5drivev+0x30>
     776:	03 97       	sbiw	r24, 0x03	; 3
     778:	29 f0       	breq	.+10     	; 0x784 <_Z5drivev+0x2c>
		case drivemode_joystick:
			mode_joystick();
     77a:	07 c0       	rjmp	.+14     	; 0x78a <_Z5drivev+0x32>
			break;
     77c:	2f dd       	rcall	.-1442   	; 0x1dc <_Z13mode_joystickv>
		case drivemode_idle:
			mode_idle();		
     77e:	05 c0       	rjmp	.+10     	; 0x78a <_Z5drivev+0x32>
			break;
		case drivemode_auto:
			mode_idle();		//not yet implemented
     780:	22 de       	rcall	.-956    	; 0x3c6 <_Z9mode_idlev>
			break;
		case drivemode_remote:
			mode_idle();		//not yet implemented
     782:	03 c0       	rjmp	.+6      	; 0x78a <_Z5drivev+0x32>
     784:	20 de       	rcall	.-960    	; 0x3c6 <_Z9mode_idlev>
			break;	
	}
	run_steer();				//update the steering system
     786:	01 c0       	rjmp	.+2      	; 0x78a <_Z5drivev+0x32>
     788:	1e de       	rcall	.-964    	; 0x3c6 <_Z9mode_idlev>
	run_brake();				//update the braking system
     78a:	93 de       	rcall	.-730    	; 0x4b2 <_Z9run_steerv>
     78c:	4b de       	rcall	.-874    	; 0x424 <_Z9run_brakev>
	run_curtis();				//update the Curtis
     78e:	88 cf       	rjmp	.-240    	; 0x6a0 <_Z10run_curtisv>
     790:	08 95       	ret

00000792 <_Z6initIOv>:
     792:	cf 93       	push	r28
#include "IOPins.h"

//this funcion should be called when initializng the program. It writes the correct settings to the registry, allowing the use of analog and digital reading and writing of pins.
void initIO(){
     794:	df 93       	push	r29
	Serial.println("Applying IO settings...");
     796:	61 e0       	ldi	r22, 0x01	; 1
     798:	72 e0       	ldi	r23, 0x02	; 2
     79a:	83 e7       	ldi	r24, 0x73	; 115
     79c:	94 e0       	ldi	r25, 0x04	; 4
     79e:	b4 d7       	rcall	.+3944   	; 0x1708 <_ZN5USART7printlnEPKc>
	//Read/Write pins
	//////////////////////////////////////
	//Disable the pullup resistor in these pins, making them output by writing a 1 to their respective registry entries. Pins not written to default to input pins.
	//when adding/altering pins, alter them in the respective switch case as well.
	//digitalwrite
	DDRA |= 0b11111111;
     7a0:	81 b1       	in	r24, 0x01	; 1
     7a2:	8f ef       	ldi	r24, 0xFF	; 255
     7a4:	81 b9       	out	0x01, r24	; 1
	//B pins are reserved for SPI, don't touch those
	DDRC |= 0b11111111;
     7a6:	97 b1       	in	r25, 0x07	; 7
     7a8:	87 b9       	out	0x07, r24	; 7
	DDRD |= 0b10000000;
     7aa:	57 9a       	sbi	0x0a, 7	; 10
	DDRG |= 0b00000111;
     7ac:	83 b3       	in	r24, 0x13	; 19
     7ae:	87 60       	ori	r24, 0x07	; 7
     7b0:	83 bb       	out	0x13, r24	; 19
	//DDRL |= 0b11111111;
	
	//analogwrite, Not all pins support PWM signals, please consult datasheets before altering.
	DDRB |= 0b11110000;
     7b2:	84 b1       	in	r24, 0x04	; 4
     7b4:	80 6f       	ori	r24, 0xF0	; 240
     7b6:	84 b9       	out	0x04, r24	; 4
	DDRE |= 0b00111000;
     7b8:	8d b1       	in	r24, 0x0d	; 13
     7ba:	88 63       	ori	r24, 0x38	; 56
     7bc:	8d b9       	out	0x0d, r24	; 13
	DDRG |= 0b00100000;
     7be:	9d 9a       	sbi	0x13, 5	; 19
	DDRH |= 0b01111000;
     7c0:	e1 e0       	ldi	r30, 0x01	; 1
     7c2:	f1 e0       	ldi	r31, 0x01	; 1
     7c4:	80 81       	ld	r24, Z
     7c6:	88 67       	ori	r24, 0x78	; 120
     7c8:	80 83       	st	Z, r24
	DDRL |= 0b00111000;
     7ca:	ea e0       	ldi	r30, 0x0A	; 10
     7cc:	f1 e0       	ldi	r31, 0x01	; 1
     7ce:	80 81       	ld	r24, Z
     7d0:	88 63       	ori	r24, 0x38	; 56
     7d2:	80 83       	st	Z, r24
	//when something is unclear or you want to change some setting, please consult the datasheet first.
	
	//Compare output mode
	//determines how the PWN behaves, now it Clears OCxx on compare match. This makes it so that low value OCRxx will result in short pulses, while higher result in longer ones
	//COM0xx0 will make OCxx toggle on compare match, both will set om compare match. Neither will disable the pmw by disconnecting OCxx.
	TCCR0A |= (( 1 << COM0A1) | (1 << COM0B1));
     7d4:	84 b5       	in	r24, 0x24	; 36
     7d6:	80 6a       	ori	r24, 0xA0	; 160
     7d8:	84 bd       	out	0x24, r24	; 36
	TCCR1A |= (( 1 << COM1A1) | (1 << COM1B1));
     7da:	c0 e8       	ldi	r28, 0x80	; 128
     7dc:	d0 e0       	ldi	r29, 0x00	; 0
     7de:	88 81       	ld	r24, Y
     7e0:	80 6a       	ori	r24, 0xA0	; 160
     7e2:	88 83       	st	Y, r24
	TCCR2A |= (( 1 << COM2A1) | (1 << COM2B1));
     7e4:	a0 eb       	ldi	r26, 0xB0	; 176
     7e6:	b0 e0       	ldi	r27, 0x00	; 0
     7e8:	8c 91       	ld	r24, X
     7ea:	80 6a       	ori	r24, 0xA0	; 160
     7ec:	8c 93       	st	X, r24
	TCCR3A |= (( 1 << COM3A1) | (1 << COM3B1));
     7ee:	e0 e9       	ldi	r30, 0x90	; 144
     7f0:	f0 e0       	ldi	r31, 0x00	; 0
     7f2:	80 81       	ld	r24, Z
     7f4:	80 6a       	ori	r24, 0xA0	; 160
     7f6:	80 83       	st	Z, r24
	//TCCR4A |= (( 1 << COM4A1) | (1 << COM4B1));
	
	//Waveform Generation
	//note that here OCRxA and OCRxB use the same registry and thus also use the same waveform.
	//the current PWM is Fast PMW, but in this case the PWM mode isn't really important.
	TCCR0A |= ((1 << WGM01) | (1 << WGM00));
     7f8:	84 b5       	in	r24, 0x24	; 36
     7fa:	83 60       	ori	r24, 0x03	; 3
     7fc:	84 bd       	out	0x24, r24	; 36
	TCCR1A |= ((1 << WGM12) | (1 << WGM10));		//16 bit timer, scaled back to 8 bit. (TCCR0x and TCCR2x are 8 bit already)
     7fe:	88 81       	ld	r24, Y
     800:	89 60       	ori	r24, 0x09	; 9
     802:	88 83       	st	Y, r24
	TCCR2A |= ((1 << WGM21) | (1 << WGM20));
     804:	8c 91       	ld	r24, X
     806:	83 60       	ori	r24, 0x03	; 3
     808:	8c 93       	st	X, r24
	TCCR3A |= ((1 << WGM32) | (1 << WGM30));		//16 bit
     80a:	80 81       	ld	r24, Z
     80c:	89 60       	ori	r24, 0x09	; 9
     80e:	80 83       	st	Z, r24
	
	//clock Select
	//currently selected, Internal clock, /8 prescaler. this starts the PWM as well
	//F_CPU=16000000 / 256 / 8 ~= 7812Hz wave
	//again as with the OCRxx, these use the same registry as well and are thus linked
	TCCR0B |= (1 << CS01);
     810:	85 b5       	in	r24, 0x25	; 37
     812:	82 60       	ori	r24, 0x02	; 2
     814:	85 bd       	out	0x25, r24	; 37
	TCCR1B |= (1 << CS11);
     816:	e1 e8       	ldi	r30, 0x81	; 129
     818:	f0 e0       	ldi	r31, 0x00	; 0
     81a:	80 81       	ld	r24, Z
     81c:	82 60       	ori	r24, 0x02	; 2
     81e:	80 83       	st	Z, r24
	TCCR2B |= (1 << CS21);
     820:	e1 eb       	ldi	r30, 0xB1	; 177
     822:	f0 e0       	ldi	r31, 0x00	; 0
     824:	80 81       	ld	r24, Z
     826:	82 60       	ori	r24, 0x02	; 2
     828:	80 83       	st	Z, r24
	TCCR3B |= (1 << CS31);
     82a:	e1 e9       	ldi	r30, 0x91	; 145
     82c:	f0 e0       	ldi	r31, 0x00	; 0
     82e:	80 81       	ld	r24, Z
     830:	82 60       	ori	r24, 0x02	; 2
     832:	80 83       	st	Z, r24
	TCCR4B |= (1 << CS41);
     834:	e1 ea       	ldi	r30, 0xA1	; 161
     836:	f0 e0       	ldi	r31, 0x00	; 0
     838:	80 81       	ld	r24, Z
     83a:	82 60       	ori	r24, 0x02	; 2
     83c:	80 83       	st	Z, r24
	
	//initialize each pwm as 0
	OCR3B=0;	//pin 2
     83e:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <__TEXT_REGION_LENGTH__+0x70009b>
     842:	10 92 9a 00 	sts	0x009A, r1	; 0x80009a <__TEXT_REGION_LENGTH__+0x70009a>
	OCR3C=0;	//pin 3
     846:	10 92 9d 00 	sts	0x009D, r1	; 0x80009d <__TEXT_REGION_LENGTH__+0x70009d>
     84a:	10 92 9c 00 	sts	0x009C, r1	; 0x80009c <__TEXT_REGION_LENGTH__+0x70009c>
	OCR0B=0;	//pin 4
     84e:	18 bc       	out	0x28, r1	; 40
	OCR3A=0;	//pin 5
     850:	10 92 99 00 	sts	0x0099, r1	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
     854:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
	OCR4A=0;	//pin 6
     858:	10 92 a9 00 	sts	0x00A9, r1	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
     85c:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
	OCR4B=0;	//pin 7
     860:	10 92 ab 00 	sts	0x00AB, r1	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
     864:	10 92 aa 00 	sts	0x00AA, r1	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
	OCR4C=0;	//pin 8
     868:	10 92 ad 00 	sts	0x00AD, r1	; 0x8000ad <__TEXT_REGION_LENGTH__+0x7000ad>
     86c:	10 92 ac 00 	sts	0x00AC, r1	; 0x8000ac <__TEXT_REGION_LENGTH__+0x7000ac>
	OCR2B=0;	//pin 9
     870:	10 92 b4 00 	sts	0x00B4, r1	; 0x8000b4 <__TEXT_REGION_LENGTH__+0x7000b4>
	OCR2A=0;	//pin 10
     874:	10 92 b3 00 	sts	0x00B3, r1	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
	OCR1A=0;	//pin 11
     878:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     87c:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
	OCR1B=0;	//pin 12
     880:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     884:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
	OCR1C=0;	//pin 13
     888:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
     88c:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
	//Analog Digital Converter, analogread
	//////////////////////////////////////
	
	//Analog Digital Multiplexer Selection Register, voltage reference selection
	//Current setting: AVcc with external capacitor at AREF pin (internal 5v)
	ADMUX |= (1 << REFS0);
     890:	ec e7       	ldi	r30, 0x7C	; 124
     892:	f0 e0       	ldi	r31, 0x00	; 0
     894:	80 81       	ld	r24, Z
     896:	80 64       	ori	r24, 0x40	; 64
     898:	80 83       	st	Z, r24
	
	// 1/128 prescaler
	ADCSRA |= (1 << ADPS0) | (1 << ADPS1) | (1 << ADPS2);
     89a:	ea e7       	ldi	r30, 0x7A	; 122
     89c:	f0 e0       	ldi	r31, 0x00	; 0
     89e:	80 81       	ld	r24, Z
     8a0:	87 60       	ori	r24, 0x07	; 7
     8a2:	80 83       	st	Z, r24
	
	//enable the ADC convector, and disable GPIO functionality on the ADC pins
	ADCSRA |= (1 << ADEN);
     8a4:	80 81       	ld	r24, Z
     8a6:	80 68       	ori	r24, 0x80	; 128
     8a8:	80 83       	st	Z, r24
	Serial.println("IO setting generated");
     8aa:	69 e1       	ldi	r22, 0x19	; 25
     8ac:	72 e0       	ldi	r23, 0x02	; 2
     8ae:	83 e7       	ldi	r24, 0x73	; 115
     8b0:	94 e0       	ldi	r25, 0x04	; 4
     8b2:	2a d7       	rcall	.+3668   	; 0x1708 <_ZN5USART7printlnEPKc>
	return;
}
     8b4:	df 91       	pop	r29
     8b6:	cf 91       	pop	r28
     8b8:	08 95       	ret

000008ba <_Z11analogWriteii>:


//writes a value between 0 and 255 to the correct output compare register
//analogWrite(pin numer, value it should receive).
void analogWrite(int pin,int val){
     8ba:	6f 3f       	cpi	r22, 0xFF	; 255
     8bc:	71 05       	cpc	r23, r1
     8be:	19 f0       	breq	.+6      	; 0x8c6 <_Z11analogWriteii+0xc>
     8c0:	14 f0       	brlt	.+4      	; 0x8c6 <_Z11analogWriteii+0xc>
     8c2:	6f ef       	ldi	r22, 0xFF	; 255
     8c4:	70 e0       	ldi	r23, 0x00	; 0
	if(val>255)			//if the given value exeeds 255, make it 255
	val=255;
	switch(pin){
     8c6:	fc 01       	movw	r30, r24
     8c8:	32 97       	sbiw	r30, 0x02	; 2
     8ca:	eb 30       	cpi	r30, 0x0B	; 11
     8cc:	f1 05       	cpc	r31, r1
     8ce:	a8 f5       	brcc	.+106    	; 0x93a <_Z11analogWriteii+0x80>
     8d0:	88 27       	eor	r24, r24
     8d2:	ee 58       	subi	r30, 0x8E	; 142
     8d4:	ff 4f       	sbci	r31, 0xFF	; 255
     8d6:	8f 4f       	sbci	r24, 0xFF	; 255
     8d8:	6c c7       	rjmp	.+3800   	; 0x17b2 <__tablejump2__>
		case 2:
		OCR3B=val;
     8da:	70 93 9b 00 	sts	0x009B, r23	; 0x80009b <__TEXT_REGION_LENGTH__+0x70009b>
     8de:	60 93 9a 00 	sts	0x009A, r22	; 0x80009a <__TEXT_REGION_LENGTH__+0x70009a>
		return;
     8e2:	08 95       	ret
		case 3:
		OCR3C=val;
     8e4:	70 93 9d 00 	sts	0x009D, r23	; 0x80009d <__TEXT_REGION_LENGTH__+0x70009d>
     8e8:	60 93 9c 00 	sts	0x009C, r22	; 0x80009c <__TEXT_REGION_LENGTH__+0x70009c>
		return;
     8ec:	08 95       	ret
		case 4:
		OCR0B=val;
     8ee:	68 bd       	out	0x28, r22	; 40
		return;
     8f0:	08 95       	ret
		case 5:
		OCR3A=val;
     8f2:	70 93 99 00 	sts	0x0099, r23	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
     8f6:	60 93 98 00 	sts	0x0098, r22	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
		return;
     8fa:	08 95       	ret
		case 6:
		OCR4A=val;
     8fc:	70 93 a9 00 	sts	0x00A9, r23	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
     900:	60 93 a8 00 	sts	0x00A8, r22	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
		return;
     904:	08 95       	ret
		case 7:
		OCR4B=val;
     906:	70 93 ab 00 	sts	0x00AB, r23	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
     90a:	60 93 aa 00 	sts	0x00AA, r22	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
		return;
     90e:	08 95       	ret
		case 8:
		OCR4C=val;
     910:	70 93 ad 00 	sts	0x00AD, r23	; 0x8000ad <__TEXT_REGION_LENGTH__+0x7000ad>
     914:	60 93 ac 00 	sts	0x00AC, r22	; 0x8000ac <__TEXT_REGION_LENGTH__+0x7000ac>
		return;
     918:	08 95       	ret
		case 9:
		OCR2B=val;
     91a:	60 93 b4 00 	sts	0x00B4, r22	; 0x8000b4 <__TEXT_REGION_LENGTH__+0x7000b4>
		return;
     91e:	08 95       	ret
		case 10:
		OCR2A=val;
     920:	60 93 b3 00 	sts	0x00B3, r22	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
		return;
     924:	08 95       	ret
		case 11:
		OCR1A=val;
     926:	70 93 89 00 	sts	0x0089, r23	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     92a:	60 93 88 00 	sts	0x0088, r22	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
		return;
     92e:	08 95       	ret
		case 12:
		OCR1B=val;
     930:	70 93 8b 00 	sts	0x008B, r23	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     934:	60 93 8a 00 	sts	0x008A, r22	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
		return;
     938:	08 95       	ret
		}
	Serial.println("ERROR: tried to write analog value to unsupported pin");
     93a:	6e e2       	ldi	r22, 0x2E	; 46
     93c:	72 e0       	ldi	r23, 0x02	; 2
     93e:	83 e7       	ldi	r24, 0x73	; 115
     940:	94 e0       	ldi	r25, 0x04	; 4
     942:	e2 c6       	rjmp	.+3524   	; 0x1708 <_ZN5USART7printlnEPKc>
     944:	08 95       	ret

00000946 <_Z12digitalWriteib>:
	return;
}

//writes a digital value to a pin.
void digitalWrite(int pin,bool val){
     946:	cf 93       	push	r28
     948:	df 93       	push	r29
	if(pin<22||pin>53){					//check if the pin is a digital IO pin
     94a:	9c 01       	movw	r18, r24
     94c:	26 51       	subi	r18, 0x16	; 22
     94e:	31 09       	sbc	r19, r1
     950:	20 32       	cpi	r18, 0x20	; 32
     952:	31 05       	cpc	r19, r1
     954:	58 f0       	brcs	.+22     	; 0x96c <_Z12digitalWriteib+0x26>
     956:	ec 01       	movw	r28, r24
		Serial.print("ERROR: tried to write digital value to unsupported digital pin");
     958:	64 e6       	ldi	r22, 0x64	; 100
     95a:	72 e0       	ldi	r23, 0x02	; 2
     95c:	83 e7       	ldi	r24, 0x73	; 115
     95e:	94 e0       	ldi	r25, 0x04	; 4
     960:	ba d6       	rcall	.+3444   	; 0x16d6 <_ZN5USART5printEPKc>
		Serial.println(pin);
     962:	be 01       	movw	r22, r28
     964:	83 e7       	ldi	r24, 0x73	; 115
     966:	94 e0       	ldi	r25, 0x04	; 4
     968:	fd d6       	rcall	.+3578   	; 0x1764 <_ZN5USART7printlnEi>
     96a:	b9 c0       	rjmp	.+370    	; 0xade <_Z12digitalWriteib+0x198>
	}
	else if(pin<30){					//check if pin is in the A register
     96c:	8e 31       	cpi	r24, 0x1E	; 30
     96e:	91 05       	cpc	r25, r1
     970:	f4 f4       	brge	.+60     	; 0x9ae <_Z12digitalWriteib+0x68>
		pin-=22;						//make pinrange 0-7
     972:	46 97       	sbiw	r24, 0x16	; 22
		if(val) PORTA |= (1<<pin);		//set correct bit in A register is val==true
     974:	66 23       	and	r22, r22
     976:	69 f0       	breq	.+26     	; 0x992 <_Z12digitalWriteib+0x4c>
     978:	42 b1       	in	r20, 0x02	; 2
     97a:	21 e0       	ldi	r18, 0x01	; 1
     97c:	30 e0       	ldi	r19, 0x00	; 0
     97e:	b9 01       	movw	r22, r18
     980:	02 c0       	rjmp	.+4      	; 0x986 <_Z12digitalWriteib+0x40>
     982:	66 0f       	add	r22, r22
     984:	77 1f       	adc	r23, r23
     986:	8a 95       	dec	r24
     988:	e2 f7       	brpl	.-8      	; 0x982 <_Z12digitalWriteib+0x3c>
     98a:	cb 01       	movw	r24, r22
     98c:	84 2b       	or	r24, r20
     98e:	82 b9       	out	0x02, r24	; 2
     990:	a6 c0       	rjmp	.+332    	; 0xade <_Z12digitalWriteib+0x198>
		else PORTA &= ~(1<<pin);		//unset bit if false
     992:	42 b1       	in	r20, 0x02	; 2
     994:	21 e0       	ldi	r18, 0x01	; 1
     996:	30 e0       	ldi	r19, 0x00	; 0
     998:	b9 01       	movw	r22, r18
     99a:	02 c0       	rjmp	.+4      	; 0x9a0 <_Z12digitalWriteib+0x5a>
     99c:	66 0f       	add	r22, r22
     99e:	77 1f       	adc	r23, r23
     9a0:	8a 95       	dec	r24
     9a2:	e2 f7       	brpl	.-8      	; 0x99c <_Z12digitalWriteib+0x56>
     9a4:	cb 01       	movw	r24, r22
     9a6:	80 95       	com	r24
     9a8:	84 23       	and	r24, r20
     9aa:	82 b9       	out	0x02, r24	; 2
     9ac:	98 c0       	rjmp	.+304    	; 0xade <_Z12digitalWriteib+0x198>
	}
	else if(pin<38){
     9ae:	86 32       	cpi	r24, 0x26	; 38
     9b0:	91 05       	cpc	r25, r1
     9b2:	1c f5       	brge	.+70     	; 0x9fa <_Z12digitalWriteib+0xb4>
		pin=(37-pin);
     9b4:	25 e2       	ldi	r18, 0x25	; 37
     9b6:	30 e0       	ldi	r19, 0x00	; 0
     9b8:	a9 01       	movw	r20, r18
     9ba:	48 1b       	sub	r20, r24
     9bc:	59 0b       	sbc	r21, r25
     9be:	ca 01       	movw	r24, r20
		if(val) PORTC |= (1<<pin);
     9c0:	66 23       	and	r22, r22
     9c2:	69 f0       	breq	.+26     	; 0x9de <_Z12digitalWriteib+0x98>
     9c4:	48 b1       	in	r20, 0x08	; 8
     9c6:	21 e0       	ldi	r18, 0x01	; 1
     9c8:	30 e0       	ldi	r19, 0x00	; 0
     9ca:	b9 01       	movw	r22, r18
     9cc:	02 c0       	rjmp	.+4      	; 0x9d2 <_Z12digitalWriteib+0x8c>
     9ce:	66 0f       	add	r22, r22
     9d0:	77 1f       	adc	r23, r23
     9d2:	8a 95       	dec	r24
     9d4:	e2 f7       	brpl	.-8      	; 0x9ce <_Z12digitalWriteib+0x88>
     9d6:	cb 01       	movw	r24, r22
     9d8:	84 2b       	or	r24, r20
     9da:	88 b9       	out	0x08, r24	; 8
     9dc:	80 c0       	rjmp	.+256    	; 0xade <_Z12digitalWriteib+0x198>
		else PORTC &= ~(1<<pin);
     9de:	48 b1       	in	r20, 0x08	; 8
     9e0:	21 e0       	ldi	r18, 0x01	; 1
     9e2:	30 e0       	ldi	r19, 0x00	; 0
     9e4:	b9 01       	movw	r22, r18
     9e6:	02 c0       	rjmp	.+4      	; 0x9ec <_Z12digitalWriteib+0xa6>
     9e8:	66 0f       	add	r22, r22
     9ea:	77 1f       	adc	r23, r23
     9ec:	8a 95       	dec	r24
     9ee:	e2 f7       	brpl	.-8      	; 0x9e8 <_Z12digitalWriteib+0xa2>
     9f0:	cb 01       	movw	r24, r22
     9f2:	80 95       	com	r24
     9f4:	84 23       	and	r24, r20
     9f6:	88 b9       	out	0x08, r24	; 8
     9f8:	72 c0       	rjmp	.+228    	; 0xade <_Z12digitalWriteib+0x198>
	}
	else if(pin==38){
     9fa:	86 32       	cpi	r24, 0x26	; 38
     9fc:	91 05       	cpc	r25, r1
     9fe:	31 f4       	brne	.+12     	; 0xa0c <_Z12digitalWriteib+0xc6>
		if(val) PORTD |= (1<<PIND7);
     a00:	66 23       	and	r22, r22
     a02:	11 f0       	breq	.+4      	; 0xa08 <_Z12digitalWriteib+0xc2>
     a04:	5f 9a       	sbi	0x0b, 7	; 11
     a06:	6b c0       	rjmp	.+214    	; 0xade <_Z12digitalWriteib+0x198>
		else PORTD &= ~(1<<PIND7);
     a08:	5f 98       	cbi	0x0b, 7	; 11
     a0a:	69 c0       	rjmp	.+210    	; 0xade <_Z12digitalWriteib+0x198>
	}
	else if(pin<42){
     a0c:	8a 32       	cpi	r24, 0x2A	; 42
     a0e:	91 05       	cpc	r25, r1
     a10:	ec f4       	brge	.+58     	; 0xa4c <_Z12digitalWriteib+0x106>
		pin=(41-pin);
     a12:	29 e2       	ldi	r18, 0x29	; 41
     a14:	30 e0       	ldi	r19, 0x00	; 0
     a16:	28 1b       	sub	r18, r24
     a18:	39 0b       	sbc	r19, r25
		if(val) PORTG |= (1<<pin);
     a1a:	66 23       	and	r22, r22
     a1c:	59 f0       	breq	.+22     	; 0xa34 <_Z12digitalWriteib+0xee>
     a1e:	34 b3       	in	r19, 0x14	; 20
     a20:	81 e0       	ldi	r24, 0x01	; 1
     a22:	90 e0       	ldi	r25, 0x00	; 0
     a24:	02 c0       	rjmp	.+4      	; 0xa2a <_Z12digitalWriteib+0xe4>
     a26:	88 0f       	add	r24, r24
     a28:	99 1f       	adc	r25, r25
     a2a:	2a 95       	dec	r18
     a2c:	e2 f7       	brpl	.-8      	; 0xa26 <_Z12digitalWriteib+0xe0>
     a2e:	83 2b       	or	r24, r19
     a30:	84 bb       	out	0x14, r24	; 20
     a32:	55 c0       	rjmp	.+170    	; 0xade <_Z12digitalWriteib+0x198>
		else PORTG &= ~(1<<pin);
     a34:	34 b3       	in	r19, 0x14	; 20
     a36:	81 e0       	ldi	r24, 0x01	; 1
     a38:	90 e0       	ldi	r25, 0x00	; 0
     a3a:	02 c0       	rjmp	.+4      	; 0xa40 <_Z12digitalWriteib+0xfa>
     a3c:	88 0f       	add	r24, r24
     a3e:	99 1f       	adc	r25, r25
     a40:	2a 95       	dec	r18
     a42:	e2 f7       	brpl	.-8      	; 0xa3c <_Z12digitalWriteib+0xf6>
     a44:	80 95       	com	r24
     a46:	83 23       	and	r24, r19
     a48:	84 bb       	out	0x14, r24	; 20
     a4a:	49 c0       	rjmp	.+146    	; 0xade <_Z12digitalWriteib+0x198>
	}
	else if(pin<50){
     a4c:	82 33       	cpi	r24, 0x32	; 50
     a4e:	91 05       	cpc	r25, r1
     a50:	0c f5       	brge	.+66     	; 0xa94 <_Z12digitalWriteib+0x14e>
		pin=(49-pin);
     a52:	21 e3       	ldi	r18, 0x31	; 49
     a54:	30 e0       	ldi	r19, 0x00	; 0
     a56:	28 1b       	sub	r18, r24
     a58:	39 0b       	sbc	r19, r25
		if(val) PORTL |= (1<<pin);
     a5a:	66 23       	and	r22, r22
     a5c:	69 f0       	breq	.+26     	; 0xa78 <_Z12digitalWriteib+0x132>
     a5e:	eb e0       	ldi	r30, 0x0B	; 11
     a60:	f1 e0       	ldi	r31, 0x01	; 1
     a62:	30 81       	ld	r19, Z
     a64:	81 e0       	ldi	r24, 0x01	; 1
     a66:	90 e0       	ldi	r25, 0x00	; 0
     a68:	02 c0       	rjmp	.+4      	; 0xa6e <_Z12digitalWriteib+0x128>
     a6a:	88 0f       	add	r24, r24
     a6c:	99 1f       	adc	r25, r25
     a6e:	2a 95       	dec	r18
     a70:	e2 f7       	brpl	.-8      	; 0xa6a <_Z12digitalWriteib+0x124>
     a72:	83 2b       	or	r24, r19
     a74:	80 83       	st	Z, r24
     a76:	33 c0       	rjmp	.+102    	; 0xade <_Z12digitalWriteib+0x198>
		else PORTL &= ~(1<<pin);
     a78:	eb e0       	ldi	r30, 0x0B	; 11
     a7a:	f1 e0       	ldi	r31, 0x01	; 1
     a7c:	30 81       	ld	r19, Z
     a7e:	81 e0       	ldi	r24, 0x01	; 1
     a80:	90 e0       	ldi	r25, 0x00	; 0
     a82:	02 c0       	rjmp	.+4      	; 0xa88 <_Z12digitalWriteib+0x142>
     a84:	88 0f       	add	r24, r24
     a86:	99 1f       	adc	r25, r25
     a88:	2a 95       	dec	r18
     a8a:	e2 f7       	brpl	.-8      	; 0xa84 <_Z12digitalWriteib+0x13e>
     a8c:	80 95       	com	r24
     a8e:	83 23       	and	r24, r19
     a90:	80 83       	st	Z, r24
     a92:	25 c0       	rjmp	.+74     	; 0xade <_Z12digitalWriteib+0x198>
	}
	else if(pin<54){
     a94:	86 33       	cpi	r24, 0x36	; 54
     a96:	91 05       	cpc	r25, r1
     a98:	14 f5       	brge	.+68     	; 0xade <_Z12digitalWriteib+0x198>
		pin=(53-pin);
     a9a:	25 e3       	ldi	r18, 0x35	; 53
     a9c:	30 e0       	ldi	r19, 0x00	; 0
     a9e:	a9 01       	movw	r20, r18
     aa0:	48 1b       	sub	r20, r24
     aa2:	59 0b       	sbc	r21, r25
     aa4:	ca 01       	movw	r24, r20
		if(val) PORTB |= (1<<pin);
     aa6:	66 23       	and	r22, r22
     aa8:	69 f0       	breq	.+26     	; 0xac4 <_Z12digitalWriteib+0x17e>
     aaa:	45 b1       	in	r20, 0x05	; 5
     aac:	21 e0       	ldi	r18, 0x01	; 1
     aae:	30 e0       	ldi	r19, 0x00	; 0
     ab0:	b9 01       	movw	r22, r18
     ab2:	02 c0       	rjmp	.+4      	; 0xab8 <_Z12digitalWriteib+0x172>
     ab4:	66 0f       	add	r22, r22
     ab6:	77 1f       	adc	r23, r23
     ab8:	8a 95       	dec	r24
     aba:	e2 f7       	brpl	.-8      	; 0xab4 <_Z12digitalWriteib+0x16e>
     abc:	cb 01       	movw	r24, r22
     abe:	84 2b       	or	r24, r20
     ac0:	85 b9       	out	0x05, r24	; 5
     ac2:	0d c0       	rjmp	.+26     	; 0xade <_Z12digitalWriteib+0x198>
		else PORTB &= ~(1<<pin);
     ac4:	45 b1       	in	r20, 0x05	; 5
     ac6:	21 e0       	ldi	r18, 0x01	; 1
     ac8:	30 e0       	ldi	r19, 0x00	; 0
     aca:	b9 01       	movw	r22, r18
     acc:	02 c0       	rjmp	.+4      	; 0xad2 <_Z12digitalWriteib+0x18c>
     ace:	66 0f       	add	r22, r22
     ad0:	77 1f       	adc	r23, r23
     ad2:	8a 95       	dec	r24
     ad4:	e2 f7       	brpl	.-8      	; 0xace <_Z12digitalWriteib+0x188>
     ad6:	cb 01       	movw	r24, r22
     ad8:	80 95       	com	r24
     ada:	84 23       	and	r24, r20
     adc:	85 b9       	out	0x05, r24	; 5
	}
	return;
}
     ade:	df 91       	pop	r29
     ae0:	cf 91       	pop	r28
     ae2:	08 95       	ret

00000ae4 <_Z11digitalReadi>:

bool digitalRead(int pin){
     ae4:	cf 93       	push	r28
     ae6:	df 93       	push	r29
	if(pin==4){
     ae8:	84 30       	cpi	r24, 0x04	; 4
     aea:	91 05       	cpc	r25, r1
     aec:	29 f4       	brne	.+10     	; 0xaf8 <_Z11digitalReadi+0x14>
		if(PING&(1<<PING5))	return true;
     aee:	82 b3       	in	r24, 0x12	; 18
     af0:	85 fb       	bst	r24, 5
     af2:	88 27       	eor	r24, r24
     af4:	80 f9       	bld	r24, 0
     af6:	6f c0       	rjmp	.+222    	; 0xbd6 <_Z11digitalReadi+0xf2>
	}
	else if(pin<30){					//check if pin is in the A register
     af8:	8e 31       	cpi	r24, 0x1E	; 30
     afa:	91 05       	cpc	r25, r1
     afc:	64 f4       	brge	.+24     	; 0xb16 <_Z11digitalReadi+0x32>
		pin-=22;						//make pinrange 0-7
		if(PINA&(1<<pin))	return true;							//break function
     afe:	20 b1       	in	r18, 0x00	; 0
     b00:	30 e0       	ldi	r19, 0x00	; 0
     b02:	46 97       	sbiw	r24, 0x16	; 22
     b04:	a9 01       	movw	r20, r18
     b06:	02 c0       	rjmp	.+4      	; 0xb0c <_Z11digitalReadi+0x28>
     b08:	55 95       	asr	r21
     b0a:	47 95       	ror	r20
     b0c:	8a 95       	dec	r24
     b0e:	e2 f7       	brpl	.-8      	; 0xb08 <_Z11digitalReadi+0x24>
     b10:	ca 01       	movw	r24, r20
     b12:	81 70       	andi	r24, 0x01	; 1
     b14:	60 c0       	rjmp	.+192    	; 0xbd6 <_Z11digitalReadi+0xf2>
	}
	else if(pin<38){
     b16:	86 32       	cpi	r24, 0x26	; 38
     b18:	91 05       	cpc	r25, r1
     b1a:	84 f4       	brge	.+32     	; 0xb3c <_Z11digitalReadi+0x58>
		pin=37-pin;
		if(PINC&(1<<pin))	return true;							//break function
     b1c:	26 b1       	in	r18, 0x06	; 6
     b1e:	30 e0       	ldi	r19, 0x00	; 0
     b20:	45 e2       	ldi	r20, 0x25	; 37
     b22:	50 e0       	ldi	r21, 0x00	; 0
     b24:	ba 01       	movw	r22, r20
     b26:	68 1b       	sub	r22, r24
     b28:	79 0b       	sbc	r23, r25
     b2a:	a9 01       	movw	r20, r18
     b2c:	02 c0       	rjmp	.+4      	; 0xb32 <_Z11digitalReadi+0x4e>
     b2e:	55 95       	asr	r21
     b30:	47 95       	ror	r20
     b32:	6a 95       	dec	r22
     b34:	e2 f7       	brpl	.-8      	; 0xb2e <_Z11digitalReadi+0x4a>
     b36:	ca 01       	movw	r24, r20
     b38:	81 70       	andi	r24, 0x01	; 1
     b3a:	4d c0       	rjmp	.+154    	; 0xbd6 <_Z11digitalReadi+0xf2>
	}
	else if(pin==38){
     b3c:	86 32       	cpi	r24, 0x26	; 38
     b3e:	91 05       	cpc	r25, r1
     b40:	29 f4       	brne	.+10     	; 0xb4c <_Z11digitalReadi+0x68>
		if(PIND&(1<<PIND7))	return true;							//break function
     b42:	89 b1       	in	r24, 0x09	; 9
     b44:	88 1f       	adc	r24, r24
     b46:	88 27       	eor	r24, r24
     b48:	88 1f       	adc	r24, r24
     b4a:	45 c0       	rjmp	.+138    	; 0xbd6 <_Z11digitalReadi+0xf2>
	}
	else if(pin<42){
     b4c:	8a 32       	cpi	r24, 0x2A	; 42
     b4e:	91 05       	cpc	r25, r1
     b50:	84 f4       	brge	.+32     	; 0xb72 <_Z11digitalReadi+0x8e>
		pin=41-pin;
		if(PING&(1<<pin))	return true;							//break function
     b52:	22 b3       	in	r18, 0x12	; 18
     b54:	30 e0       	ldi	r19, 0x00	; 0
     b56:	49 e2       	ldi	r20, 0x29	; 41
     b58:	50 e0       	ldi	r21, 0x00	; 0
     b5a:	ba 01       	movw	r22, r20
     b5c:	68 1b       	sub	r22, r24
     b5e:	79 0b       	sbc	r23, r25
     b60:	a9 01       	movw	r20, r18
     b62:	02 c0       	rjmp	.+4      	; 0xb68 <_Z11digitalReadi+0x84>
     b64:	55 95       	asr	r21
     b66:	47 95       	ror	r20
     b68:	6a 95       	dec	r22
     b6a:	e2 f7       	brpl	.-8      	; 0xb64 <_Z11digitalReadi+0x80>
     b6c:	ca 01       	movw	r24, r20
     b6e:	81 70       	andi	r24, 0x01	; 1
     b70:	32 c0       	rjmp	.+100    	; 0xbd6 <_Z11digitalReadi+0xf2>
	}
	else if(pin<50){
     b72:	82 33       	cpi	r24, 0x32	; 50
     b74:	91 05       	cpc	r25, r1
     b76:	8c f4       	brge	.+34     	; 0xb9a <_Z11digitalReadi+0xb6>
		pin=49-pin;
		if(PINL&(1<<pin))	return true;							//break function
     b78:	20 91 09 01 	lds	r18, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
     b7c:	30 e0       	ldi	r19, 0x00	; 0
     b7e:	41 e3       	ldi	r20, 0x31	; 49
     b80:	50 e0       	ldi	r21, 0x00	; 0
     b82:	ba 01       	movw	r22, r20
     b84:	68 1b       	sub	r22, r24
     b86:	79 0b       	sbc	r23, r25
     b88:	a9 01       	movw	r20, r18
     b8a:	02 c0       	rjmp	.+4      	; 0xb90 <_Z11digitalReadi+0xac>
     b8c:	55 95       	asr	r21
     b8e:	47 95       	ror	r20
     b90:	6a 95       	dec	r22
     b92:	e2 f7       	brpl	.-8      	; 0xb8c <_Z11digitalReadi+0xa8>
     b94:	ca 01       	movw	r24, r20
     b96:	81 70       	andi	r24, 0x01	; 1
     b98:	1e c0       	rjmp	.+60     	; 0xbd6 <_Z11digitalReadi+0xf2>
	}
	else if(pin<54){
     b9a:	86 33       	cpi	r24, 0x36	; 54
     b9c:	91 05       	cpc	r25, r1
     b9e:	84 f4       	brge	.+32     	; 0xbc0 <_Z11digitalReadi+0xdc>
		pin=(53-pin);
		if(PINB&(1<<pin))	return true;							//break function
     ba0:	23 b1       	in	r18, 0x03	; 3
     ba2:	30 e0       	ldi	r19, 0x00	; 0
     ba4:	45 e3       	ldi	r20, 0x35	; 53
     ba6:	50 e0       	ldi	r21, 0x00	; 0
     ba8:	ba 01       	movw	r22, r20
     baa:	68 1b       	sub	r22, r24
     bac:	79 0b       	sbc	r23, r25
     bae:	a9 01       	movw	r20, r18
     bb0:	02 c0       	rjmp	.+4      	; 0xbb6 <_Z11digitalReadi+0xd2>
     bb2:	55 95       	asr	r21
     bb4:	47 95       	ror	r20
     bb6:	6a 95       	dec	r22
     bb8:	e2 f7       	brpl	.-8      	; 0xbb2 <_Z11digitalReadi+0xce>
     bba:	ca 01       	movw	r24, r20
     bbc:	81 70       	andi	r24, 0x01	; 1
     bbe:	0b c0       	rjmp	.+22     	; 0xbd6 <_Z11digitalReadi+0xf2>
     bc0:	ec 01       	movw	r28, r24
	}
	else{					//pin unsupported
		Serial.print("ERROR: tried to read digital value from unsupported digital pin: ");
     bc2:	63 ea       	ldi	r22, 0xA3	; 163
     bc4:	72 e0       	ldi	r23, 0x02	; 2
     bc6:	83 e7       	ldi	r24, 0x73	; 115
     bc8:	94 e0       	ldi	r25, 0x04	; 4
     bca:	85 d5       	rcall	.+2826   	; 0x16d6 <_ZN5USART5printEPKc>
		Serial.println(pin);
     bcc:	be 01       	movw	r22, r28
     bce:	83 e7       	ldi	r24, 0x73	; 115
     bd0:	94 e0       	ldi	r25, 0x04	; 4
     bd2:	c8 d5       	rcall	.+2960   	; 0x1764 <_ZN5USART7printlnEi>
		return false;
     bd4:	80 e0       	ldi	r24, 0x00	; 0
	}
	return false;	
}
     bd6:	df 91       	pop	r29
     bd8:	cf 91       	pop	r28
     bda:	08 95       	ret

00000bdc <_Z10analogReadi>:

int analogRead(int pin){
     bdc:	cf 93       	push	r28
     bde:	df 93       	push	r29
	//set correct MUX registers, these determine on which pin the ADC should read it's value
	//first the MUXx bits are cleared, then filled to prevent old setting leaking though
	
	ADMUX &=(0b11100000);							//clear the bottom 4 bit
     be0:	ec e7       	ldi	r30, 0x7C	; 124
     be2:	f0 e0       	ldi	r31, 0x00	; 0
     be4:	20 81       	ld	r18, Z
     be6:	20 7e       	andi	r18, 0xE0	; 224
     be8:	20 83       	st	Z, r18
	ADCSRB &=(0b11110111);							//clear the top one bit
     bea:	eb e7       	ldi	r30, 0x7B	; 123
     bec:	f0 e0       	ldi	r31, 0x00	; 0
     bee:	20 81       	ld	r18, Z
     bf0:	27 7f       	andi	r18, 0xF7	; 247
     bf2:	20 83       	st	Z, r18
	if(pin<8)										//if adc #0-7
     bf4:	88 30       	cpi	r24, 0x08	; 8
     bf6:	91 05       	cpc	r25, r1
     bf8:	34 f4       	brge	.+12     	; 0xc06 <_Z10analogReadi+0x2a>
	ADMUX |= pin;								//write the full pin to the ADMUX registry
     bfa:	ec e7       	ldi	r30, 0x7C	; 124
     bfc:	f0 e0       	ldi	r31, 0x00	; 0
     bfe:	90 81       	ld	r25, Z
     c00:	89 2b       	or	r24, r25
     c02:	80 83       	st	Z, r24
     c04:	1c c0       	rjmp	.+56     	; 0xc3e <_Z10analogReadi+0x62>
	else if(pin<16){									//if adc #8-15
     c06:	80 31       	cpi	r24, 0x10	; 16
     c08:	91 05       	cpc	r25, r1
     c0a:	64 f4       	brge	.+24     	; 0xc24 <_Z10analogReadi+0x48>
		ADCSRB |= (1<<3);							//write upper bit to ADCSRB register
     c0c:	eb e7       	ldi	r30, 0x7B	; 123
     c0e:	f0 e0       	ldi	r31, 0x00	; 0
     c10:	90 81       	ld	r25, Z
     c12:	98 60       	ori	r25, 0x08	; 8
     c14:	90 83       	st	Z, r25
		ADMUX |= (pin-8);							//write lower bits to ADMUX registry
     c16:	ec e7       	ldi	r30, 0x7C	; 124
     c18:	f0 e0       	ldi	r31, 0x00	; 0
     c1a:	90 81       	ld	r25, Z
     c1c:	88 50       	subi	r24, 0x08	; 8
     c1e:	89 2b       	or	r24, r25
     c20:	80 83       	st	Z, r24
     c22:	0d c0       	rjmp	.+26     	; 0xc3e <_Z10analogReadi+0x62>
     c24:	ec 01       	movw	r28, r24
	}
	else{
		Serial.print("ERROR: tried to read digital value from unsupported analog pin ");
     c26:	65 ee       	ldi	r22, 0xE5	; 229
     c28:	72 e0       	ldi	r23, 0x02	; 2
     c2a:	83 e7       	ldi	r24, 0x73	; 115
     c2c:	94 e0       	ldi	r25, 0x04	; 4
     c2e:	53 d5       	rcall	.+2726   	; 0x16d6 <_ZN5USART5printEPKc>
		Serial.println(pin);
     c30:	be 01       	movw	r22, r28
     c32:	83 e7       	ldi	r24, 0x73	; 115
     c34:	94 e0       	ldi	r25, 0x04	; 4
     c36:	96 d5       	rcall	.+2860   	; 0x1764 <_ZN5USART7printlnEi>
		return 0;
     c38:	80 e0       	ldi	r24, 0x00	; 0
     c3a:	90 e0       	ldi	r25, 0x00	; 0
     c3c:	0c c0       	rjmp	.+24     	; 0xc56 <_Z10analogReadi+0x7a>
	}
	ADCSRA |= (1<<ADSC);							//start ADC conversion
     c3e:	ea e7       	ldi	r30, 0x7A	; 122
     c40:	f0 e0       	ldi	r31, 0x00	; 0
     c42:	80 81       	ld	r24, Z
     c44:	80 64       	ori	r24, 0x40	; 64
     c46:	80 83       	st	Z, r24
	while(ADCSRA & (1<<ADSC));						//wait until the ADSC is 0 again and the conversion is done
     c48:	80 81       	ld	r24, Z
     c4a:	86 fd       	sbrc	r24, 6
     c4c:	fd cf       	rjmp	.-6      	; 0xc48 <_Z10analogReadi+0x6c>
	return ADC;										//return the byte in ADLAR, the result of the ADC conversion
     c4e:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
     c52:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
}
     c56:	df 91       	pop	r29
     c58:	cf 91       	pop	r28
     c5a:	08 95       	ret

00000c5c <_Z9printinfov>:
}

#ifdef DEBUG_MODE									//only spam terminal when in debug mode
void printinfo(){

	Serial.print("DM: ");
     c5c:	65 e2       	ldi	r22, 0x25	; 37
     c5e:	73 e0       	ldi	r23, 0x03	; 3
     c60:	83 e7       	ldi	r24, 0x73	; 115
     c62:	94 e0       	ldi	r25, 0x04	; 4
     c64:	38 d5       	rcall	.+2672   	; 0x16d6 <_ZN5USART5printEPKc>
	Serial.print(drivemode);
     c66:	60 91 52 04 	lds	r22, 0x0452	; 0x800452 <drivemode>
     c6a:	70 91 53 04 	lds	r23, 0x0453	; 0x800453 <drivemode+0x1>
     c6e:	83 e7       	ldi	r24, 0x73	; 115
     c70:	94 e0       	ldi	r25, 0x04	; 4
     c72:	55 d5       	rcall	.+2730   	; 0x171e <_ZN5USART5printEi>
	Serial.print(" drive dir: ");
     c74:	6a e2       	ldi	r22, 0x2A	; 42
     c76:	73 e0       	ldi	r23, 0x03	; 3
     c78:	83 e7       	ldi	r24, 0x73	; 115
     c7a:	94 e0       	ldi	r25, 0x04	; 4
     c7c:	2c d5       	rcall	.+2648   	; 0x16d6 <_ZN5USART5printEPKc>
	Serial.print(driving_direction);
     c7e:	60 91 00 02 	lds	r22, 0x0200	; 0x800200 <__data_start>
     c82:	70 e0       	ldi	r23, 0x00	; 0
     c84:	83 e7       	ldi	r24, 0x73	; 115
     c86:	94 e0       	ldi	r25, 0x04	; 4
     c88:	4a d5       	rcall	.+2708   	; 0x171e <_ZN5USART5printEi>
	Serial.print(" engine_dv = ");
     c8a:	67 e3       	ldi	r22, 0x37	; 55
     c8c:	73 e0       	ldi	r23, 0x03	; 3
     c8e:	83 e7       	ldi	r24, 0x73	; 115
     c90:	94 e0       	ldi	r25, 0x04	; 4
     c92:	21 d5       	rcall	.+2626   	; 0x16d6 <_ZN5USART5printEPKc>
	Serial.print(engine_dv);
     c94:	60 91 3b 04 	lds	r22, 0x043B	; 0x80043b <engine_dv>
     c98:	70 91 3c 04 	lds	r23, 0x043C	; 0x80043c <engine_dv+0x1>
     c9c:	83 e7       	ldi	r24, 0x73	; 115
     c9e:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" brake_dv = ");
     ca0:	3e d5       	rcall	.+2684   	; 0x171e <_ZN5USART5printEi>
     ca2:	65 e4       	ldi	r22, 0x45	; 69
     ca4:	73 e0       	ldi	r23, 0x03	; 3
     ca6:	83 e7       	ldi	r24, 0x73	; 115
     ca8:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(braking_dv);
     caa:	15 d5       	rcall	.+2602   	; 0x16d6 <_ZN5USART5printEPKc>
     cac:	60 91 37 04 	lds	r22, 0x0437	; 0x800437 <braking_dv>
     cb0:	70 91 38 04 	lds	r23, 0x0438	; 0x800438 <braking_dv+0x1>
     cb4:	83 e7       	ldi	r24, 0x73	; 115
     cb6:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" braking_ov = ");
     cb8:	32 d5       	rcall	.+2660   	; 0x171e <_ZN5USART5printEi>
     cba:	62 e5       	ldi	r22, 0x52	; 82
     cbc:	73 e0       	ldi	r23, 0x03	; 3
     cbe:	83 e7       	ldi	r24, 0x73	; 115
     cc0:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(braking_ov);
     cc2:	09 d5       	rcall	.+2578   	; 0x16d6 <_ZN5USART5printEPKc>
     cc4:	60 91 2e 04 	lds	r22, 0x042E	; 0x80042e <braking_ov>
     cc8:	70 e0       	ldi	r23, 0x00	; 0
     cca:	83 e7       	ldi	r24, 0x73	; 115
     ccc:	94 e0       	ldi	r25, 0x04	; 4

	Serial.print(" steering_dv = ");
     cce:	27 d5       	rcall	.+2638   	; 0x171e <_ZN5USART5printEi>
     cd0:	61 e6       	ldi	r22, 0x61	; 97
     cd2:	73 e0       	ldi	r23, 0x03	; 3
     cd4:	83 e7       	ldi	r24, 0x73	; 115
     cd6:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(steering_dv);
     cd8:	fe d4       	rcall	.+2556   	; 0x16d6 <_ZN5USART5printEPKc>
     cda:	60 91 4a 04 	lds	r22, 0x044A	; 0x80044a <steering_dv>
     cde:	70 91 4b 04 	lds	r23, 0x044B	; 0x80044b <steering_dv+0x1>
     ce2:	83 e7       	ldi	r24, 0x73	; 115
     ce4:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" steering_cv = ");
     ce6:	1b d5       	rcall	.+2614   	; 0x171e <_ZN5USART5printEi>
     ce8:	61 e7       	ldi	r22, 0x71	; 113
     cea:	73 e0       	ldi	r23, 0x03	; 3
     cec:	83 e7       	ldi	r24, 0x73	; 115
     cee:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(steering_cv);
     cf0:	f2 d4       	rcall	.+2532   	; 0x16d6 <_ZN5USART5printEPKc>
     cf2:	60 91 40 04 	lds	r22, 0x0440	; 0x800440 <steering_cv>
     cf6:	70 91 41 04 	lds	r23, 0x0441	; 0x800441 <steering_cv+0x1>
     cfa:	83 e7       	ldi	r24, 0x73	; 115
     cfc:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" steering_ov = ");
     cfe:	0f d5       	rcall	.+2590   	; 0x171e <_ZN5USART5printEi>
     d00:	61 e8       	ldi	r22, 0x81	; 129
     d02:	73 e0       	ldi	r23, 0x03	; 3
     d04:	83 e7       	ldi	r24, 0x73	; 115
     d06:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(steering_ov);
     d08:	e6 d4       	rcall	.+2508   	; 0x16d6 <_ZN5USART5printEPKc>
     d0a:	60 91 3f 04 	lds	r22, 0x043F	; 0x80043f <steering_ov>
     d0e:	70 e0       	ldi	r23, 0x00	; 0
     d10:	83 e7       	ldi	r24, 0x73	; 115
     d12:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" steering_delta = ");
     d14:	04 d5       	rcall	.+2568   	; 0x171e <_ZN5USART5printEi>
     d16:	61 e9       	ldi	r22, 0x91	; 145
     d18:	73 e0       	ldi	r23, 0x03	; 3
     d1a:	83 e7       	ldi	r24, 0x73	; 115
     d1c:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(steering_delta);
     d1e:	db d4       	rcall	.+2486   	; 0x16d6 <_ZN5USART5printEPKc>
     d20:	60 91 48 04 	lds	r22, 0x0448	; 0x800448 <steering_delta>
     d24:	70 91 49 04 	lds	r23, 0x0449	; 0x800449 <steering_delta+0x1>
     d28:	83 e7       	ldi	r24, 0x73	; 115
	Serial.print(" low volt = ");
     d2a:	94 e0       	ldi	r25, 0x04	; 4
     d2c:	f8 d4       	rcall	.+2544   	; 0x171e <_ZN5USART5printEi>
     d2e:	64 ea       	ldi	r22, 0xA4	; 164
     d30:	73 e0       	ldi	r23, 0x03	; 3
     d32:	83 e7       	ldi	r24, 0x73	; 115
	Serial.print(low_voltage);
     d34:	94 e0       	ldi	r25, 0x04	; 4
     d36:	cf d4       	rcall	.+2462   	; 0x16d6 <_ZN5USART5printEPKc>
     d38:	60 91 2c 04 	lds	r22, 0x042C	; 0x80042c <low_voltage>
     d3c:	70 91 2d 04 	lds	r23, 0x042D	; 0x80042d <low_voltage+0x1>
     d40:	83 e7       	ldi	r24, 0x73	; 115
	Serial.print(" high volt = ");
     d42:	94 e0       	ldi	r25, 0x04	; 4
     d44:	ec d4       	rcall	.+2520   	; 0x171e <_ZN5USART5printEi>
     d46:	61 eb       	ldi	r22, 0xB1	; 177
     d48:	73 e0       	ldi	r23, 0x03	; 3
     d4a:	83 e7       	ldi	r24, 0x73	; 115
	Serial.print(high_voltage);
     d4c:	94 e0       	ldi	r25, 0x04	; 4
     d4e:	c3 d4       	rcall	.+2438   	; 0x16d6 <_ZN5USART5printEPKc>
     d50:	60 91 24 04 	lds	r22, 0x0424	; 0x800424 <__data_end>
     d54:	70 91 25 04 	lds	r23, 0x0425	; 0x800425 <__data_end+0x1>
     d58:	83 e7       	ldi	r24, 0x73	; 115
	Serial.print(" rpm = ");
     d5a:	94 e0       	ldi	r25, 0x04	; 4
     d5c:	e0 d4       	rcall	.+2496   	; 0x171e <_ZN5USART5printEi>
     d5e:	6f eb       	ldi	r22, 0xBF	; 191
     d60:	73 e0       	ldi	r23, 0x03	; 3
     d62:	83 e7       	ldi	r24, 0x73	; 115
	Serial.print(engine_rpm);
     d64:	94 e0       	ldi	r25, 0x04	; 4
     d66:	b7 d4       	rcall	.+2414   	; 0x16d6 <_ZN5USART5printEPKc>
     d68:	60 91 2a 04 	lds	r22, 0x042A	; 0x80042a <engine_rpm>
     d6c:	70 91 2b 04 	lds	r23, 0x042B	; 0x80042b <engine_rpm+0x1>
     d70:	83 e7       	ldi	r24, 0x73	; 115
     d72:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" temp = ");
     d74:	d4 d4       	rcall	.+2472   	; 0x171e <_ZN5USART5printEi>
     d76:	67 ec       	ldi	r22, 0xC7	; 199
     d78:	73 e0       	ldi	r23, 0x03	; 3
     d7a:	83 e7       	ldi	r24, 0x73	; 115
     d7c:	94 e0       	ldi	r25, 0x04	; 4
     d7e:	ab d4       	rcall	.+2390   	; 0x16d6 <_ZN5USART5printEPKc>
	Serial.println(engine_temp);
     d80:	60 91 28 04 	lds	r22, 0x0428	; 0x800428 <engine_temp>
     d84:	70 91 29 04 	lds	r23, 0x0429	; 0x800429 <engine_temp+0x1>
     d88:	83 e7       	ldi	r24, 0x73	; 115
     d8a:	94 e0       	ldi	r25, 0x04	; 4
     d8c:	eb c4       	rjmp	.+2518   	; 0x1764 <_ZN5USART7printlnEi>
     d8e:	08 95       	ret

00000d90 <_Z13updateCurtissv>:
     d90:	24 e5       	ldi	r18, 0x54	; 84
}
#endif

void updateCurtiss(){
	CAN_Curt.readMsgBuf(&rxId_Curt, &len_Curt, rxBuf_Curt);	// Read data: len = data length, buf = data byte(s)
     d92:	34 e0       	ldi	r19, 0x04	; 4
     d94:	4c e5       	ldi	r20, 0x5C	; 92
     d96:	54 e0       	ldi	r21, 0x04	; 4
     d98:	6d e5       	ldi	r22, 0x5D	; 93
     d9a:	74 e0       	ldi	r23, 0x04	; 4
     d9c:	81 e6       	ldi	r24, 0x61	; 97
     d9e:	94 e0       	ldi	r25, 0x04	; 4
     da0:	0d d4       	rcall	.+2074   	; 0x15bc <_ZN7MCP_CAN10readMsgBufEPmPhS1_>
	if((rxId_Curt & 0x40000000) == 0x40000000)					//Ignore remote requests
     da2:	80 91 5d 04 	lds	r24, 0x045D	; 0x80045d <rxId_Curt>
     da6:	90 91 5e 04 	lds	r25, 0x045E	; 0x80045e <rxId_Curt+0x1>
     daa:	a0 91 5f 04 	lds	r26, 0x045F	; 0x80045f <rxId_Curt+0x2>
     dae:	b0 91 60 04 	lds	r27, 0x0460	; 0x800460 <rxId_Curt+0x3>
     db2:	b6 fd       	sbrc	r27, 6
     db4:	36 c0       	rjmp	.+108    	; 0xe22 <_Z13updateCurtissv+0x92>
		return;	
	low_voltage = rxBuf_Curt[0] + (rxBuf_Curt[1] * 256);
     db6:	e4 e5       	ldi	r30, 0x54	; 84
     db8:	f4 e0       	ldi	r31, 0x04	; 4
     dba:	81 81       	ldd	r24, Z+1	; 0x01
     dbc:	90 e0       	ldi	r25, 0x00	; 0
     dbe:	98 2f       	mov	r25, r24
     dc0:	88 27       	eor	r24, r24
     dc2:	20 81       	ld	r18, Z
     dc4:	82 0f       	add	r24, r18
     dc6:	91 1d       	adc	r25, r1
     dc8:	90 93 2d 04 	sts	0x042D, r25	; 0x80042d <low_voltage+0x1>
     dcc:	80 93 2c 04 	sts	0x042C, r24	; 0x80042c <low_voltage>
	engine_rpm = rxBuf_Curt[2] + (rxBuf_Curt[3] * 256);
     dd0:	83 81       	ldd	r24, Z+3	; 0x03
     dd2:	90 e0       	ldi	r25, 0x00	; 0
     dd4:	98 2f       	mov	r25, r24
     dd6:	88 27       	eor	r24, r24
     dd8:	22 81       	ldd	r18, Z+2	; 0x02
     dda:	82 0f       	add	r24, r18
     ddc:	91 1d       	adc	r25, r1
     dde:	90 93 2b 04 	sts	0x042B, r25	; 0x80042b <engine_rpm+0x1>
     de2:	80 93 2a 04 	sts	0x042A, r24	; 0x80042a <engine_rpm>
	engine_temp = rxBuf_Curt[4] + (rxBuf_Curt[5] * 256);
     de6:	85 81       	ldd	r24, Z+5	; 0x05
     de8:	90 e0       	ldi	r25, 0x00	; 0
     dea:	98 2f       	mov	r25, r24
     dec:	88 27       	eor	r24, r24
     dee:	24 81       	ldd	r18, Z+4	; 0x04
     df0:	82 0f       	add	r24, r18
     df2:	91 1d       	adc	r25, r1
     df4:	90 93 29 04 	sts	0x0429, r25	; 0x800429 <engine_temp+0x1>
     df8:	80 93 28 04 	sts	0x0428, r24	; 0x800428 <engine_temp>
	control_temp = rxBuf_Curt[6] + (rxBuf_Curt[7] * 256);
     dfc:	87 81       	ldd	r24, Z+7	; 0x07
     dfe:	90 e0       	ldi	r25, 0x00	; 0
     e00:	98 2f       	mov	r25, r24
     e02:	88 27       	eor	r24, r24
     e04:	26 81       	ldd	r18, Z+6	; 0x06
     e06:	ac 01       	movw	r20, r24
     e08:	42 0f       	add	r20, r18
     e0a:	51 1d       	adc	r21, r1
     e0c:	50 93 27 04 	sts	0x0427, r21	; 0x800427 <control_temp+0x1>
     e10:	40 93 26 04 	sts	0x0426, r20	; 0x800426 <control_temp>
	high_voltage = rxBuf_Curt[8] + (rxBuf_Curt[7] * 256);	
     e14:	20 85       	ldd	r18, Z+8	; 0x08
     e16:	82 0f       	add	r24, r18
     e18:	91 1d       	adc	r25, r1
     e1a:	90 93 25 04 	sts	0x0425, r25	; 0x800425 <__data_end+0x1>
     e1e:	80 93 24 04 	sts	0x0424, r24	; 0x800424 <__data_end>
     e22:	08 95       	ret

00000e24 <main>:
unsigned char len_Curt;
unsigned char rxBuf_Curt[8];
char msgString_Curt[128]; 

int main(void){
	Serial.println("Alley Hoop V2.1");
     e24:	60 ed       	ldi	r22, 0xD0	; 208
     e26:	73 e0       	ldi	r23, 0x03	; 3
     e28:	83 e7       	ldi	r24, 0x73	; 115
     e2a:	94 e0       	ldi	r25, 0x04	; 4
     e2c:	6d d4       	rcall	.+2266   	; 0x1708 <_ZN5USART7printlnEPKc>
	initIO();															//initializes the IO pins
     e2e:	b1 dc       	rcall	.-1694   	; 0x792 <_Z6initIOv>
	initDrive();														//detect steering modus
     e30:	bf d9       	rcall	.-3202   	; 0x1b0 <_Z9initDrivev>
     e32:	21 e0       	ldi	r18, 0x01	; 1

	if(CAN_Curt.begin(MCP_ANY, CAN_500KBPS, MCP_16MHZ) == CAN_OK)		//initialize the CAN BUS
     e34:	4d e0       	ldi	r20, 0x0D	; 13
     e36:	63 e0       	ldi	r22, 0x03	; 3
     e38:	81 e6       	ldi	r24, 0x61	; 97
     e3a:	94 e0       	ldi	r25, 0x04	; 4
     e3c:	85 d3       	rcall	.+1802   	; 0x1548 <_ZN7MCP_CAN5beginEhhh>
     e3e:	81 11       	cpse	r24, r1
     e40:	06 c0       	rjmp	.+12     	; 0xe4e <main+0x2a>
     e42:	60 ee       	ldi	r22, 0xE0	; 224
		Serial.println("MCP2515 Initialized Successfully!");
     e44:	73 e0       	ldi	r23, 0x03	; 3
     e46:	83 e7       	ldi	r24, 0x73	; 115
     e48:	94 e0       	ldi	r25, 0x04	; 4
     e4a:	5e d4       	rcall	.+2236   	; 0x1708 <_ZN5USART7printlnEPKc>
     e4c:	05 c0       	rjmp	.+10     	; 0xe58 <main+0x34>
     e4e:	62 e0       	ldi	r22, 0x02	; 2
	else
		Serial.println("Error Initializing MCP2515...");
     e50:	74 e0       	ldi	r23, 0x04	; 4
     e52:	83 e7       	ldi	r24, 0x73	; 115
     e54:	94 e0       	ldi	r25, 0x04	; 4
     e56:	58 d4       	rcall	.+2224   	; 0x1708 <_ZN5USART7printlnEPKc>
	CAN_Curt.setMode(MCP_NORMAL);										// Set operation mode to normal so the MCP2515 sends acks to received data.
     e58:	60 e0       	ldi	r22, 0x00	; 0
     e5a:	81 e6       	ldi	r24, 0x61	; 97
     e5c:	94 e0       	ldi	r25, 0x04	; 4
     e5e:	d5 d1       	rcall	.+938    	; 0x120a <_ZN7MCP_CAN7setModeEh>

	while (1){				//main program loop	
		updateCurtiss();		//update the values retrieved from the Curtis
     e60:	97 df       	rcall	.-210    	; 0xd90 <_Z13updateCurtissv>
     e62:	7a dc       	rcall	.-1804   	; 0x758 <_Z5drivev>
		drive();				//update the values send to various components
     e64:	fb de       	rcall	.-522    	; 0xc5c <_Z9printinfov>
     e66:	fc cf       	rjmp	.-8      	; 0xe60 <main+0x3c>

00000e68 <_GLOBAL__sub_I_Serial>:
		#ifdef DEBUG_MODE
			printinfo();			//print info in the terminal, only when debug mode is enabled
     e68:	83 e7       	ldi	r24, 0x73	; 115
     e6a:	94 e0       	ldi	r25, 0x04	; 4
     e6c:	29 d4       	rcall	.+2130   	; 0x16c0 <_ZN5USARTC1Ev>
#include <util/delay.h>		//allows usage of _delay_ms()
#include "overhead.h"		//defines and standard includes
#include "Drive.h"			//takes care of driving the car

USART Serial;				//global Serial
MCP_CAN CAN_Curt(47);		//the Curtiss CAN BUS
     e6e:	6f e2       	ldi	r22, 0x2F	; 47
     e70:	81 e6       	ldi	r24, 0x61	; 97
     e72:	94 e0       	ldi	r25, 0x04	; 4
     e74:	5c c3       	rjmp	.+1720   	; 0x152e <_ZN7MCP_CANC1Eh>
     e76:	08 95       	ret

00000e78 <_ZN7MCP_CAN13mcp2515_resetEv>:
		tbufdata[MCP_EID0] = 0;
		tbufdata[MCP_EID8] = 0;
	}

	mcp2515_setRegisterS( mcp_addr, tbufdata, 4 );
}
     e78:	0f 93       	push	r16
     e7a:	1f 93       	push	r17
     e7c:	cf 93       	push	r28
     e7e:	df 93       	push	r29
     e80:	1f 92       	push	r1
     e82:	1f 92       	push	r1
     e84:	cd b7       	in	r28, 0x3d	; 61
     e86:	de b7       	in	r29, 0x3e	; 62
     e88:	00 e0       	ldi	r16, 0x00	; 0
     e8a:	21 e0       	ldi	r18, 0x01	; 1
     e8c:	40 e8       	ldi	r20, 0x80	; 128
     e8e:	56 e9       	ldi	r21, 0x96	; 150
     e90:	68 e9       	ldi	r22, 0x98	; 152
     e92:	70 e0       	ldi	r23, 0x00	; 0
     e94:	ce 01       	movw	r24, r28
     e96:	01 96       	adiw	r24, 0x01	; 1
     e98:	e3 d3       	rcall	.+1990   	; 0x1660 <_ZN11SPISettingsC1Emhh>
     e9a:	be 01       	movw	r22, r28
     e9c:	6f 5f       	subi	r22, 0xFF	; 255
     e9e:	7f 4f       	sbci	r23, 0xFF	; 255
     ea0:	85 e7       	ldi	r24, 0x75	; 117
     ea2:	94 e0       	ldi	r25, 0x04	; 4
     ea4:	01 d4       	rcall	.+2050   	; 0x16a8 <_ZN8SPIClass16beginTransactionE11SPISettings>
     ea6:	0b e0       	ldi	r16, 0x0B	; 11
     ea8:	11 e0       	ldi	r17, 0x01	; 1
     eaa:	f8 01       	movw	r30, r16
     eac:	80 81       	ld	r24, Z
     eae:	8b 7f       	andi	r24, 0xFB	; 251
     eb0:	80 83       	st	Z, r24
     eb2:	60 ec       	ldi	r22, 0xC0	; 192
     eb4:	85 e7       	ldi	r24, 0x75	; 117
     eb6:	94 e0       	ldi	r25, 0x04	; 4
     eb8:	fd d3       	rcall	.+2042   	; 0x16b4 <_ZN8SPIClass8transferEh>
     eba:	f8 01       	movw	r30, r16
     ebc:	80 81       	ld	r24, Z
     ebe:	84 60       	ori	r24, 0x04	; 4
     ec0:	80 83       	st	Z, r24
     ec2:	83 ec       	ldi	r24, 0xC3	; 195
     ec4:	99 e0       	ldi	r25, 0x09	; 9
     ec6:	01 97       	sbiw	r24, 0x01	; 1
     ec8:	f1 f7       	brne	.-4      	; 0xec6 <_ZN7MCP_CAN13mcp2515_resetEv+0x4e>
     eca:	00 c0       	rjmp	.+0      	; 0xecc <_ZN7MCP_CAN13mcp2515_resetEv+0x54>
     ecc:	00 00       	nop
     ece:	0f 90       	pop	r0
     ed0:	0f 90       	pop	r0
     ed2:	df 91       	pop	r29
     ed4:	cf 91       	pop	r28
     ed6:	1f 91       	pop	r17
     ed8:	0f 91       	pop	r16
     eda:	08 95       	ret

00000edc <_ZN7MCP_CAN20mcp2515_readRegisterEh>:
     edc:	ff 92       	push	r15
     ede:	0f 93       	push	r16
     ee0:	1f 93       	push	r17
     ee2:	cf 93       	push	r28
     ee4:	df 93       	push	r29
     ee6:	1f 92       	push	r1
     ee8:	1f 92       	push	r1
     eea:	cd b7       	in	r28, 0x3d	; 61
     eec:	de b7       	in	r29, 0x3e	; 62
     eee:	f6 2e       	mov	r15, r22
     ef0:	00 e0       	ldi	r16, 0x00	; 0
     ef2:	21 e0       	ldi	r18, 0x01	; 1
     ef4:	40 e8       	ldi	r20, 0x80	; 128
     ef6:	56 e9       	ldi	r21, 0x96	; 150
     ef8:	68 e9       	ldi	r22, 0x98	; 152
     efa:	70 e0       	ldi	r23, 0x00	; 0
     efc:	ce 01       	movw	r24, r28
     efe:	01 96       	adiw	r24, 0x01	; 1
     f00:	af d3       	rcall	.+1886   	; 0x1660 <_ZN11SPISettingsC1Emhh>
     f02:	be 01       	movw	r22, r28
     f04:	6f 5f       	subi	r22, 0xFF	; 255
     f06:	7f 4f       	sbci	r23, 0xFF	; 255
     f08:	85 e7       	ldi	r24, 0x75	; 117
     f0a:	94 e0       	ldi	r25, 0x04	; 4
     f0c:	cd d3       	rcall	.+1946   	; 0x16a8 <_ZN8SPIClass16beginTransactionE11SPISettings>
     f0e:	0b e0       	ldi	r16, 0x0B	; 11
     f10:	11 e0       	ldi	r17, 0x01	; 1
     f12:	f8 01       	movw	r30, r16
     f14:	80 81       	ld	r24, Z
     f16:	8b 7f       	andi	r24, 0xFB	; 251
     f18:	80 83       	st	Z, r24
     f1a:	63 e0       	ldi	r22, 0x03	; 3
     f1c:	85 e7       	ldi	r24, 0x75	; 117
     f1e:	94 e0       	ldi	r25, 0x04	; 4
     f20:	c9 d3       	rcall	.+1938   	; 0x16b4 <_ZN8SPIClass8transferEh>
     f22:	6f 2d       	mov	r22, r15
     f24:	85 e7       	ldi	r24, 0x75	; 117
     f26:	94 e0       	ldi	r25, 0x04	; 4
     f28:	c5 d3       	rcall	.+1930   	; 0x16b4 <_ZN8SPIClass8transferEh>
     f2a:	60 e0       	ldi	r22, 0x00	; 0
     f2c:	85 e7       	ldi	r24, 0x75	; 117
     f2e:	94 e0       	ldi	r25, 0x04	; 4
     f30:	c1 d3       	rcall	.+1922   	; 0x16b4 <_ZN8SPIClass8transferEh>
     f32:	f8 01       	movw	r30, r16
     f34:	90 81       	ld	r25, Z
     f36:	94 60       	ori	r25, 0x04	; 4
     f38:	90 83       	st	Z, r25
     f3a:	0f 90       	pop	r0
     f3c:	0f 90       	pop	r0
     f3e:	df 91       	pop	r29
     f40:	cf 91       	pop	r28
     f42:	1f 91       	pop	r17
     f44:	0f 91       	pop	r16
     f46:	ff 90       	pop	r15
     f48:	08 95       	ret

00000f4a <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh>:
     f4a:	cf 92       	push	r12
     f4c:	df 92       	push	r13
     f4e:	ef 92       	push	r14
     f50:	ff 92       	push	r15
     f52:	0f 93       	push	r16
     f54:	1f 93       	push	r17
     f56:	cf 93       	push	r28
     f58:	df 93       	push	r29
     f5a:	1f 92       	push	r1
     f5c:	1f 92       	push	r1
     f5e:	cd b7       	in	r28, 0x3d	; 61
     f60:	de b7       	in	r29, 0x3e	; 62
     f62:	16 2f       	mov	r17, r22
     f64:	6a 01       	movw	r12, r20
     f66:	f2 2e       	mov	r15, r18
     f68:	00 e0       	ldi	r16, 0x00	; 0
     f6a:	21 e0       	ldi	r18, 0x01	; 1
     f6c:	40 e8       	ldi	r20, 0x80	; 128
     f6e:	56 e9       	ldi	r21, 0x96	; 150
     f70:	68 e9       	ldi	r22, 0x98	; 152
     f72:	70 e0       	ldi	r23, 0x00	; 0
     f74:	ce 01       	movw	r24, r28
     f76:	01 96       	adiw	r24, 0x01	; 1
     f78:	73 d3       	rcall	.+1766   	; 0x1660 <_ZN11SPISettingsC1Emhh>
     f7a:	be 01       	movw	r22, r28
     f7c:	6f 5f       	subi	r22, 0xFF	; 255
     f7e:	7f 4f       	sbci	r23, 0xFF	; 255
     f80:	85 e7       	ldi	r24, 0x75	; 117
     f82:	94 e0       	ldi	r25, 0x04	; 4
     f84:	91 d3       	rcall	.+1826   	; 0x16a8 <_ZN8SPIClass16beginTransactionE11SPISettings>
     f86:	eb e0       	ldi	r30, 0x0B	; 11
     f88:	f1 e0       	ldi	r31, 0x01	; 1
     f8a:	80 81       	ld	r24, Z
     f8c:	8b 7f       	andi	r24, 0xFB	; 251
     f8e:	80 83       	st	Z, r24
     f90:	63 e0       	ldi	r22, 0x03	; 3
     f92:	85 e7       	ldi	r24, 0x75	; 117
     f94:	94 e0       	ldi	r25, 0x04	; 4
     f96:	8e d3       	rcall	.+1820   	; 0x16b4 <_ZN8SPIClass8transferEh>
     f98:	61 2f       	mov	r22, r17
     f9a:	85 e7       	ldi	r24, 0x75	; 117
     f9c:	94 e0       	ldi	r25, 0x04	; 4
     f9e:	8a d3       	rcall	.+1812   	; 0x16b4 <_ZN8SPIClass8transferEh>
     fa0:	ff 20       	and	r15, r15
     fa2:	99 f0       	breq	.+38     	; 0xfca <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh+0x80>
     fa4:	86 01       	movw	r16, r12
     fa6:	fa 94       	dec	r15
     fa8:	ef 2c       	mov	r14, r15
     faa:	f1 2c       	mov	r15, r1
     fac:	8f ef       	ldi	r24, 0xFF	; 255
     fae:	e8 1a       	sub	r14, r24
     fb0:	f8 0a       	sbc	r15, r24
     fb2:	ec 0c       	add	r14, r12
     fb4:	fd 1c       	adc	r15, r13
     fb6:	60 e0       	ldi	r22, 0x00	; 0
     fb8:	85 e7       	ldi	r24, 0x75	; 117
     fba:	94 e0       	ldi	r25, 0x04	; 4
     fbc:	7b d3       	rcall	.+1782   	; 0x16b4 <_ZN8SPIClass8transferEh>
     fbe:	f8 01       	movw	r30, r16
     fc0:	81 93       	st	Z+, r24
     fc2:	8f 01       	movw	r16, r30
     fc4:	ee 15       	cp	r30, r14
     fc6:	ff 05       	cpc	r31, r15
     fc8:	b1 f7       	brne	.-20     	; 0xfb6 <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh+0x6c>
     fca:	eb e0       	ldi	r30, 0x0B	; 11
     fcc:	f1 e0       	ldi	r31, 0x01	; 1
     fce:	80 81       	ld	r24, Z
     fd0:	84 60       	ori	r24, 0x04	; 4
     fd2:	80 83       	st	Z, r24
     fd4:	0f 90       	pop	r0
     fd6:	0f 90       	pop	r0
     fd8:	df 91       	pop	r29
     fda:	cf 91       	pop	r28
     fdc:	1f 91       	pop	r17
     fde:	0f 91       	pop	r16
     fe0:	ff 90       	pop	r15
     fe2:	ef 90       	pop	r14
     fe4:	df 90       	pop	r13
     fe6:	cf 90       	pop	r12
     fe8:	08 95       	ret

00000fea <_ZN7MCP_CAN19mcp2515_setRegisterEhh>:
     fea:	ef 92       	push	r14
     fec:	ff 92       	push	r15
     fee:	0f 93       	push	r16
     ff0:	1f 93       	push	r17
     ff2:	cf 93       	push	r28
     ff4:	df 93       	push	r29
     ff6:	1f 92       	push	r1
     ff8:	1f 92       	push	r1
     ffa:	cd b7       	in	r28, 0x3d	; 61
     ffc:	de b7       	in	r29, 0x3e	; 62
     ffe:	e6 2e       	mov	r14, r22
    1000:	f4 2e       	mov	r15, r20
    1002:	00 e0       	ldi	r16, 0x00	; 0
    1004:	21 e0       	ldi	r18, 0x01	; 1
    1006:	40 e8       	ldi	r20, 0x80	; 128
    1008:	56 e9       	ldi	r21, 0x96	; 150
    100a:	68 e9       	ldi	r22, 0x98	; 152
    100c:	70 e0       	ldi	r23, 0x00	; 0
    100e:	ce 01       	movw	r24, r28
    1010:	01 96       	adiw	r24, 0x01	; 1
    1012:	26 d3       	rcall	.+1612   	; 0x1660 <_ZN11SPISettingsC1Emhh>
    1014:	be 01       	movw	r22, r28
    1016:	6f 5f       	subi	r22, 0xFF	; 255
    1018:	7f 4f       	sbci	r23, 0xFF	; 255
    101a:	85 e7       	ldi	r24, 0x75	; 117
    101c:	94 e0       	ldi	r25, 0x04	; 4
    101e:	44 d3       	rcall	.+1672   	; 0x16a8 <_ZN8SPIClass16beginTransactionE11SPISettings>
    1020:	0b e0       	ldi	r16, 0x0B	; 11
    1022:	11 e0       	ldi	r17, 0x01	; 1
    1024:	f8 01       	movw	r30, r16
    1026:	80 81       	ld	r24, Z
    1028:	8b 7f       	andi	r24, 0xFB	; 251
    102a:	80 83       	st	Z, r24
    102c:	62 e0       	ldi	r22, 0x02	; 2
    102e:	85 e7       	ldi	r24, 0x75	; 117
    1030:	94 e0       	ldi	r25, 0x04	; 4
    1032:	40 d3       	rcall	.+1664   	; 0x16b4 <_ZN8SPIClass8transferEh>
    1034:	6e 2d       	mov	r22, r14
    1036:	85 e7       	ldi	r24, 0x75	; 117
    1038:	94 e0       	ldi	r25, 0x04	; 4
    103a:	3c d3       	rcall	.+1656   	; 0x16b4 <_ZN8SPIClass8transferEh>
    103c:	6f 2d       	mov	r22, r15
    103e:	85 e7       	ldi	r24, 0x75	; 117
    1040:	94 e0       	ldi	r25, 0x04	; 4
    1042:	38 d3       	rcall	.+1648   	; 0x16b4 <_ZN8SPIClass8transferEh>
    1044:	f8 01       	movw	r30, r16
    1046:	80 81       	ld	r24, Z
    1048:	84 60       	ori	r24, 0x04	; 4
    104a:	80 83       	st	Z, r24
    104c:	0f 90       	pop	r0
    104e:	0f 90       	pop	r0
    1050:	df 91       	pop	r29
    1052:	cf 91       	pop	r28
    1054:	1f 91       	pop	r17
    1056:	0f 91       	pop	r16
    1058:	ff 90       	pop	r15
    105a:	ef 90       	pop	r14
    105c:	08 95       	ret

0000105e <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh>:
    105e:	cf 92       	push	r12
    1060:	df 92       	push	r13
    1062:	ef 92       	push	r14
    1064:	ff 92       	push	r15
    1066:	0f 93       	push	r16
    1068:	1f 93       	push	r17
    106a:	cf 93       	push	r28
    106c:	df 93       	push	r29
    106e:	1f 92       	push	r1
    1070:	1f 92       	push	r1
    1072:	cd b7       	in	r28, 0x3d	; 61
    1074:	de b7       	in	r29, 0x3e	; 62
    1076:	16 2f       	mov	r17, r22
    1078:	6a 01       	movw	r12, r20
    107a:	f2 2e       	mov	r15, r18
    107c:	00 e0       	ldi	r16, 0x00	; 0
    107e:	21 e0       	ldi	r18, 0x01	; 1
    1080:	40 e8       	ldi	r20, 0x80	; 128
    1082:	56 e9       	ldi	r21, 0x96	; 150
    1084:	68 e9       	ldi	r22, 0x98	; 152
    1086:	70 e0       	ldi	r23, 0x00	; 0
    1088:	ce 01       	movw	r24, r28
    108a:	01 96       	adiw	r24, 0x01	; 1
    108c:	e9 d2       	rcall	.+1490   	; 0x1660 <_ZN11SPISettingsC1Emhh>
    108e:	be 01       	movw	r22, r28
    1090:	6f 5f       	subi	r22, 0xFF	; 255
    1092:	7f 4f       	sbci	r23, 0xFF	; 255
    1094:	85 e7       	ldi	r24, 0x75	; 117
    1096:	94 e0       	ldi	r25, 0x04	; 4
    1098:	07 d3       	rcall	.+1550   	; 0x16a8 <_ZN8SPIClass16beginTransactionE11SPISettings>
    109a:	eb e0       	ldi	r30, 0x0B	; 11
    109c:	f1 e0       	ldi	r31, 0x01	; 1
    109e:	80 81       	ld	r24, Z
    10a0:	8b 7f       	andi	r24, 0xFB	; 251
    10a2:	80 83       	st	Z, r24
    10a4:	62 e0       	ldi	r22, 0x02	; 2
    10a6:	85 e7       	ldi	r24, 0x75	; 117
    10a8:	94 e0       	ldi	r25, 0x04	; 4
    10aa:	04 d3       	rcall	.+1544   	; 0x16b4 <_ZN8SPIClass8transferEh>
    10ac:	61 2f       	mov	r22, r17
    10ae:	85 e7       	ldi	r24, 0x75	; 117
    10b0:	94 e0       	ldi	r25, 0x04	; 4
    10b2:	00 d3       	rcall	.+1536   	; 0x16b4 <_ZN8SPIClass8transferEh>
    10b4:	ff 20       	and	r15, r15
    10b6:	91 f0       	breq	.+36     	; 0x10dc <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh+0x7e>
    10b8:	86 01       	movw	r16, r12
    10ba:	fa 94       	dec	r15
    10bc:	ef 2c       	mov	r14, r15
    10be:	f1 2c       	mov	r15, r1
    10c0:	8f ef       	ldi	r24, 0xFF	; 255
    10c2:	e8 1a       	sub	r14, r24
    10c4:	f8 0a       	sbc	r15, r24
    10c6:	ec 0c       	add	r14, r12
    10c8:	fd 1c       	adc	r15, r13
    10ca:	f8 01       	movw	r30, r16
    10cc:	61 91       	ld	r22, Z+
    10ce:	8f 01       	movw	r16, r30
    10d0:	85 e7       	ldi	r24, 0x75	; 117
    10d2:	94 e0       	ldi	r25, 0x04	; 4
    10d4:	ef d2       	rcall	.+1502   	; 0x16b4 <_ZN8SPIClass8transferEh>
    10d6:	0e 15       	cp	r16, r14
    10d8:	1f 05       	cpc	r17, r15
    10da:	b9 f7       	brne	.-18     	; 0x10ca <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh+0x6c>
    10dc:	eb e0       	ldi	r30, 0x0B	; 11
    10de:	f1 e0       	ldi	r31, 0x01	; 1
    10e0:	80 81       	ld	r24, Z
    10e2:	84 60       	ori	r24, 0x04	; 4
    10e4:	80 83       	st	Z, r24
    10e6:	0f 90       	pop	r0
    10e8:	0f 90       	pop	r0
    10ea:	df 91       	pop	r29
    10ec:	cf 91       	pop	r28
    10ee:	1f 91       	pop	r17
    10f0:	0f 91       	pop	r16
    10f2:	ff 90       	pop	r15
    10f4:	ef 90       	pop	r14
    10f6:	df 90       	pop	r13
    10f8:	cf 90       	pop	r12
    10fa:	08 95       	ret

000010fc <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>:
    10fc:	df 92       	push	r13
    10fe:	ef 92       	push	r14
    1100:	ff 92       	push	r15
    1102:	0f 93       	push	r16
    1104:	1f 93       	push	r17
    1106:	cf 93       	push	r28
    1108:	df 93       	push	r29
    110a:	1f 92       	push	r1
    110c:	1f 92       	push	r1
    110e:	cd b7       	in	r28, 0x3d	; 61
    1110:	de b7       	in	r29, 0x3e	; 62
    1112:	d6 2e       	mov	r13, r22
    1114:	e4 2e       	mov	r14, r20
    1116:	f2 2e       	mov	r15, r18
    1118:	00 e0       	ldi	r16, 0x00	; 0
    111a:	21 e0       	ldi	r18, 0x01	; 1
    111c:	40 e8       	ldi	r20, 0x80	; 128
    111e:	56 e9       	ldi	r21, 0x96	; 150
    1120:	68 e9       	ldi	r22, 0x98	; 152
    1122:	70 e0       	ldi	r23, 0x00	; 0
    1124:	ce 01       	movw	r24, r28
    1126:	01 96       	adiw	r24, 0x01	; 1
    1128:	9b d2       	rcall	.+1334   	; 0x1660 <_ZN11SPISettingsC1Emhh>
    112a:	be 01       	movw	r22, r28
    112c:	6f 5f       	subi	r22, 0xFF	; 255
    112e:	7f 4f       	sbci	r23, 0xFF	; 255
    1130:	85 e7       	ldi	r24, 0x75	; 117
    1132:	94 e0       	ldi	r25, 0x04	; 4
    1134:	b9 d2       	rcall	.+1394   	; 0x16a8 <_ZN8SPIClass16beginTransactionE11SPISettings>
    1136:	0b e0       	ldi	r16, 0x0B	; 11
    1138:	11 e0       	ldi	r17, 0x01	; 1
    113a:	f8 01       	movw	r30, r16
    113c:	80 81       	ld	r24, Z
    113e:	8b 7f       	andi	r24, 0xFB	; 251
    1140:	80 83       	st	Z, r24
    1142:	65 e0       	ldi	r22, 0x05	; 5
    1144:	85 e7       	ldi	r24, 0x75	; 117
    1146:	94 e0       	ldi	r25, 0x04	; 4
    1148:	b5 d2       	rcall	.+1386   	; 0x16b4 <_ZN8SPIClass8transferEh>
    114a:	6d 2d       	mov	r22, r13
    114c:	85 e7       	ldi	r24, 0x75	; 117
    114e:	94 e0       	ldi	r25, 0x04	; 4
    1150:	b1 d2       	rcall	.+1378   	; 0x16b4 <_ZN8SPIClass8transferEh>
    1152:	6e 2d       	mov	r22, r14
    1154:	85 e7       	ldi	r24, 0x75	; 117
    1156:	94 e0       	ldi	r25, 0x04	; 4
    1158:	ad d2       	rcall	.+1370   	; 0x16b4 <_ZN8SPIClass8transferEh>
    115a:	6f 2d       	mov	r22, r15
    115c:	85 e7       	ldi	r24, 0x75	; 117
    115e:	94 e0       	ldi	r25, 0x04	; 4
    1160:	a9 d2       	rcall	.+1362   	; 0x16b4 <_ZN8SPIClass8transferEh>
    1162:	f8 01       	movw	r30, r16
    1164:	80 81       	ld	r24, Z
    1166:	84 60       	ori	r24, 0x04	; 4
    1168:	80 83       	st	Z, r24
    116a:	0f 90       	pop	r0
    116c:	0f 90       	pop	r0
    116e:	df 91       	pop	r29
    1170:	cf 91       	pop	r28
    1172:	1f 91       	pop	r17
    1174:	0f 91       	pop	r16
    1176:	ff 90       	pop	r15
    1178:	ef 90       	pop	r14
    117a:	df 90       	pop	r13
    117c:	08 95       	ret

0000117e <_ZN7MCP_CAN18mcp2515_readStatusEv>:
    117e:	0f 93       	push	r16
    1180:	1f 93       	push	r17
    1182:	cf 93       	push	r28
    1184:	df 93       	push	r29
    1186:	1f 92       	push	r1
    1188:	1f 92       	push	r1
    118a:	cd b7       	in	r28, 0x3d	; 61
    118c:	de b7       	in	r29, 0x3e	; 62
    118e:	00 e0       	ldi	r16, 0x00	; 0
    1190:	21 e0       	ldi	r18, 0x01	; 1
    1192:	40 e8       	ldi	r20, 0x80	; 128
    1194:	56 e9       	ldi	r21, 0x96	; 150
    1196:	68 e9       	ldi	r22, 0x98	; 152
    1198:	70 e0       	ldi	r23, 0x00	; 0
    119a:	ce 01       	movw	r24, r28
    119c:	01 96       	adiw	r24, 0x01	; 1
    119e:	60 d2       	rcall	.+1216   	; 0x1660 <_ZN11SPISettingsC1Emhh>
    11a0:	be 01       	movw	r22, r28
    11a2:	6f 5f       	subi	r22, 0xFF	; 255
    11a4:	7f 4f       	sbci	r23, 0xFF	; 255
    11a6:	85 e7       	ldi	r24, 0x75	; 117
    11a8:	94 e0       	ldi	r25, 0x04	; 4
    11aa:	7e d2       	rcall	.+1276   	; 0x16a8 <_ZN8SPIClass16beginTransactionE11SPISettings>
    11ac:	0b e0       	ldi	r16, 0x0B	; 11
    11ae:	11 e0       	ldi	r17, 0x01	; 1
    11b0:	f8 01       	movw	r30, r16
    11b2:	80 81       	ld	r24, Z
    11b4:	8b 7f       	andi	r24, 0xFB	; 251
    11b6:	80 83       	st	Z, r24
    11b8:	60 ea       	ldi	r22, 0xA0	; 160
    11ba:	85 e7       	ldi	r24, 0x75	; 117
    11bc:	94 e0       	ldi	r25, 0x04	; 4
    11be:	7a d2       	rcall	.+1268   	; 0x16b4 <_ZN8SPIClass8transferEh>
    11c0:	60 e0       	ldi	r22, 0x00	; 0
    11c2:	85 e7       	ldi	r24, 0x75	; 117
    11c4:	94 e0       	ldi	r25, 0x04	; 4
    11c6:	76 d2       	rcall	.+1260   	; 0x16b4 <_ZN8SPIClass8transferEh>
    11c8:	f8 01       	movw	r30, r16
    11ca:	90 81       	ld	r25, Z
    11cc:	94 60       	ori	r25, 0x04	; 4
    11ce:	90 83       	st	Z, r25
    11d0:	0f 90       	pop	r0
    11d2:	0f 90       	pop	r0
    11d4:	df 91       	pop	r29
    11d6:	cf 91       	pop	r28
    11d8:	1f 91       	pop	r17
    11da:	0f 91       	pop	r16
    11dc:	08 95       	ret

000011de <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>:
    11de:	0f 93       	push	r16
    11e0:	1f 93       	push	r17
    11e2:	cf 93       	push	r28
    11e4:	8c 01       	movw	r16, r24
    11e6:	c6 2f       	mov	r28, r22
    11e8:	26 2f       	mov	r18, r22
    11ea:	40 ee       	ldi	r20, 0xE0	; 224
    11ec:	6f e0       	ldi	r22, 0x0F	; 15
    11ee:	86 df       	rcall	.-244    	; 0x10fc <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    11f0:	6f e0       	ldi	r22, 0x0F	; 15
    11f2:	c8 01       	movw	r24, r16
    11f4:	73 de       	rcall	.-794    	; 0xedc <_ZN7MCP_CAN20mcp2515_readRegisterEh>
    11f6:	98 2f       	mov	r25, r24
    11f8:	90 7e       	andi	r25, 0xE0	; 224
    11fa:	81 e0       	ldi	r24, 0x01	; 1
    11fc:	9c 13       	cpse	r25, r28
    11fe:	01 c0       	rjmp	.+2      	; 0x1202 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh+0x24>
    1200:	80 e0       	ldi	r24, 0x00	; 0
    1202:	cf 91       	pop	r28
    1204:	1f 91       	pop	r17
    1206:	0f 91       	pop	r16
    1208:	08 95       	ret

0000120a <_ZN7MCP_CAN7setModeEh>:
    120a:	fc 01       	movw	r30, r24
    120c:	61 8b       	std	Z+17, r22	; 0x11
    120e:	e7 cf       	rjmp	.-50     	; 0x11de <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>
    1210:	08 95       	ret

00001212 <_ZN7MCP_CAN18mcp2515_configRateEhh>:
    1212:	cf 93       	push	r28
    1214:	df 93       	push	r29
    1216:	ec 01       	movw	r28, r24
    1218:	40 e4       	ldi	r20, 0x40	; 64
    121a:	6a e2       	ldi	r22, 0x2A	; 42
    121c:	e6 de       	rcall	.-564    	; 0xfea <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    121e:	45 ee       	ldi	r20, 0xE5	; 229
    1220:	69 e2       	ldi	r22, 0x29	; 41
    1222:	ce 01       	movw	r24, r28
    1224:	e2 de       	rcall	.-572    	; 0xfea <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1226:	43 e8       	ldi	r20, 0x83	; 131
    1228:	68 e2       	ldi	r22, 0x28	; 40
    122a:	ce 01       	movw	r24, r28
    122c:	de de       	rcall	.-580    	; 0xfea <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    122e:	80 e0       	ldi	r24, 0x00	; 0
    1230:	df 91       	pop	r29
    1232:	cf 91       	pop	r28
    1234:	08 95       	ret

00001236 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>:

/*********************************************************************************************************
** Function name:           mcp2515_write_mf
** Descriptions:            Write Masks and Filters
*********************************************************************************************************/
void MCP_CAN::mcp2515_write_mf( const uint8_t mcp_addr, const uint8_t ext, const uint32_t id ){
    1236:	0f 93       	push	r16
    1238:	1f 93       	push	r17
    123a:	cf 93       	push	r28
    123c:	df 93       	push	r29
    123e:	00 d0       	rcall	.+0      	; 0x1240 <_ZN7MCP_CAN16mcp2515_write_mfEhhm+0xa>
    1240:	1f 92       	push	r1
    1242:	cd b7       	in	r28, 0x3d	; 61
    1244:	de b7       	in	r29, 0x3e	; 62
	uint16_t canid;
	uint8_t tbufdata[4];
	canid = (uint16_t)(id & 0x0FFFF);
	if ( ext == 1){
    1246:	41 30       	cpi	r20, 0x01	; 1
    1248:	c9 f4       	brne	.+50     	; 0x127c <_ZN7MCP_CAN16mcp2515_write_mfEhhm+0x46>
		tbufdata[MCP_EID0] = (uint8_t) (canid & 0xFF);
    124a:	0c 83       	std	Y+4, r16	; 0x04
		tbufdata[MCP_EID8] = (uint8_t) (canid >> 8);
    124c:	1b 83       	std	Y+3, r17	; 0x03
		canid = (uint16_t)(id >> 16);
    124e:	89 01       	movw	r16, r18
    1250:	22 27       	eor	r18, r18
    1252:	33 27       	eor	r19, r19
		tbufdata[MCP_SIDL] = (uint8_t) (canid & 0x03);
		tbufdata[MCP_SIDL] += (uint8_t) ((canid & 0x1C) << 3);
		tbufdata[MCP_SIDL] |= MCP_TXB_EXIDE_M;
    1254:	40 2f       	mov	r20, r16
    1256:	4c 71       	andi	r20, 0x1C	; 28
    1258:	44 0f       	add	r20, r20
    125a:	44 0f       	add	r20, r20
    125c:	44 0f       	add	r20, r20
    125e:	50 2f       	mov	r21, r16
    1260:	53 70       	andi	r21, 0x03	; 3
    1262:	45 0f       	add	r20, r21
    1264:	48 60       	ori	r20, 0x08	; 8
    1266:	4a 83       	std	Y+2, r20	; 0x02
		tbufdata[MCP_SIDH] = (uint8_t) (canid >> 5 );
    1268:	16 95       	lsr	r17
    126a:	07 95       	ror	r16
    126c:	12 95       	swap	r17
    126e:	02 95       	swap	r16
    1270:	0f 70       	andi	r16, 0x0F	; 15
    1272:	01 27       	eor	r16, r17
    1274:	1f 70       	andi	r17, 0x0F	; 15
    1276:	01 27       	eor	r16, r17
    1278:	09 83       	std	Y+1, r16	; 0x01
    127a:	11 c0       	rjmp	.+34     	; 0x129e <_ZN7MCP_CAN16mcp2515_write_mfEhhm+0x68>
	} else {
		tbufdata[MCP_EID0] = (uint8_t) (canid & 0xFF);
    127c:	0c 83       	std	Y+4, r16	; 0x04
		tbufdata[MCP_EID8] = (uint8_t) (canid >> 8);
    127e:	1b 83       	std	Y+3, r17	; 0x03
		canid = (uint16_t)(id >> 16);
    1280:	89 01       	movw	r16, r18
    1282:	22 27       	eor	r18, r18
    1284:	33 27       	eor	r19, r19
		tbufdata[MCP_SIDL] = (uint8_t) ((canid & 0x07) << 5);
    1286:	40 2f       	mov	r20, r16
    1288:	42 95       	swap	r20
    128a:	44 0f       	add	r20, r20
    128c:	40 7e       	andi	r20, 0xE0	; 224
    128e:	4a 83       	std	Y+2, r20	; 0x02
		tbufdata[MCP_SIDH] = (uint8_t) (canid >> 3 );
    1290:	16 95       	lsr	r17
    1292:	07 95       	ror	r16
    1294:	16 95       	lsr	r17
    1296:	07 95       	ror	r16
    1298:	16 95       	lsr	r17
    129a:	07 95       	ror	r16
    129c:	09 83       	std	Y+1, r16	; 0x01
	}
	mcp2515_setRegisterS( mcp_addr, tbufdata, 4 );
    129e:	24 e0       	ldi	r18, 0x04	; 4
    12a0:	ae 01       	movw	r20, r28
    12a2:	4f 5f       	subi	r20, 0xFF	; 255
    12a4:	5f 4f       	sbci	r21, 0xFF	; 255
    12a6:	db de       	rcall	.-586    	; 0x105e <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh>
}
    12a8:	0f 90       	pop	r0
    12aa:	0f 90       	pop	r0
    12ac:	0f 90       	pop	r0
    12ae:	0f 90       	pop	r0
    12b0:	df 91       	pop	r29
    12b2:	cf 91       	pop	r28
    12b4:	1f 91       	pop	r17
    12b6:	0f 91       	pop	r16
    12b8:	08 95       	ret

000012ba <_ZN7MCP_CAN22mcp2515_initCANBuffersEv>:

/*********************************************************************************************************
** Function name:           mcp2515_initCANBuffers
** Descriptions:            Initialize Buffers, Masks, and Filters
*********************************************************************************************************/
void MCP_CAN::mcp2515_initCANBuffers(void){
    12ba:	ef 92       	push	r14
    12bc:	ff 92       	push	r15
    12be:	0f 93       	push	r16
    12c0:	1f 93       	push	r17
    12c2:	cf 93       	push	r28
    12c4:	7c 01       	movw	r14, r24
	uint8_t std = 0;
	uint8_t ext = 1;
	uint32_t ulMask = 0x00, ulFilt = 0x00;


	mcp2515_write_mf(MCP_RXM0SIDH, ext, ulMask);			/*Set both masks to 0           */
    12c6:	00 e0       	ldi	r16, 0x00	; 0
    12c8:	10 e0       	ldi	r17, 0x00	; 0
    12ca:	98 01       	movw	r18, r16
    12cc:	41 e0       	ldi	r20, 0x01	; 1
    12ce:	60 e2       	ldi	r22, 0x20	; 32
    12d0:	b2 df       	rcall	.-156    	; 0x1236 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXM1SIDH, ext, ulMask);			/*Mask register ignores ext bit */
    12d2:	00 e0       	ldi	r16, 0x00	; 0
    12d4:	10 e0       	ldi	r17, 0x00	; 0
    12d6:	98 01       	movw	r18, r16
    12d8:	41 e0       	ldi	r20, 0x01	; 1
    12da:	64 e2       	ldi	r22, 0x24	; 36
    12dc:	c7 01       	movw	r24, r14
    12de:	ab df       	rcall	.-170    	; 0x1236 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	
	/* Set all filters to 0         */
	mcp2515_write_mf(MCP_RXF0SIDH, ext, ulFilt);			/* RXB0: extended               */
    12e0:	00 e0       	ldi	r16, 0x00	; 0
    12e2:	10 e0       	ldi	r17, 0x00	; 0
    12e4:	98 01       	movw	r18, r16
    12e6:	41 e0       	ldi	r20, 0x01	; 1
    12e8:	60 e0       	ldi	r22, 0x00	; 0
    12ea:	c7 01       	movw	r24, r14
    12ec:	a4 df       	rcall	.-184    	; 0x1236 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF1SIDH, std, ulFilt);			/* RXB1: standard               */
    12ee:	00 e0       	ldi	r16, 0x00	; 0
    12f0:	10 e0       	ldi	r17, 0x00	; 0
    12f2:	98 01       	movw	r18, r16
    12f4:	40 e0       	ldi	r20, 0x00	; 0
    12f6:	64 e0       	ldi	r22, 0x04	; 4
    12f8:	c7 01       	movw	r24, r14
    12fa:	9d df       	rcall	.-198    	; 0x1236 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF2SIDH, ext, ulFilt);			/* RXB2: extended               */
    12fc:	00 e0       	ldi	r16, 0x00	; 0
    12fe:	10 e0       	ldi	r17, 0x00	; 0
    1300:	98 01       	movw	r18, r16
    1302:	41 e0       	ldi	r20, 0x01	; 1
    1304:	68 e0       	ldi	r22, 0x08	; 8
    1306:	c7 01       	movw	r24, r14
    1308:	96 df       	rcall	.-212    	; 0x1236 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF3SIDH, std, ulFilt);			/* RXB3: standard               */
    130a:	00 e0       	ldi	r16, 0x00	; 0
    130c:	10 e0       	ldi	r17, 0x00	; 0
    130e:	98 01       	movw	r18, r16
    1310:	40 e0       	ldi	r20, 0x00	; 0
    1312:	60 e1       	ldi	r22, 0x10	; 16
    1314:	c7 01       	movw	r24, r14
    1316:	8f df       	rcall	.-226    	; 0x1236 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF4SIDH, ext, ulFilt);
    1318:	00 e0       	ldi	r16, 0x00	; 0
    131a:	10 e0       	ldi	r17, 0x00	; 0
    131c:	98 01       	movw	r18, r16
    131e:	41 e0       	ldi	r20, 0x01	; 1
    1320:	64 e1       	ldi	r22, 0x14	; 20
    1322:	c7 01       	movw	r24, r14
    1324:	88 df       	rcall	.-240    	; 0x1236 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF5SIDH, std, ulFilt);
    1326:	00 e0       	ldi	r16, 0x00	; 0
    1328:	10 e0       	ldi	r17, 0x00	; 0
    132a:	98 01       	movw	r18, r16
    132c:	40 e0       	ldi	r20, 0x00	; 0
    132e:	68 e1       	ldi	r22, 0x18	; 24
    1330:	c7 01       	movw	r24, r14
    1332:	81 df       	rcall	.-254    	; 0x1236 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>

	/* Clear, deactivate the three  */
	/* transmit buffers             */
	/* TXBnCTRL -> TXBnD7           */
	a1 = MCP_TXB0CTRL;
    1334:	c0 e3       	ldi	r28, 0x30	; 48
	a2 = MCP_TXB1CTRL;
	a3 = MCP_TXB2CTRL;
	for (i = 0; i < 14; i++) {                                          /* in-buffer loop               */
		mcp2515_setRegister(a1, 0);
    1336:	40 e0       	ldi	r20, 0x00	; 0
    1338:	6c 2f       	mov	r22, r28
    133a:	c7 01       	movw	r24, r14
    133c:	56 de       	rcall	.-852    	; 0xfea <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		mcp2515_setRegister(a2, 0);
    133e:	60 e1       	ldi	r22, 0x10	; 16
    1340:	6c 0f       	add	r22, r28
    1342:	40 e0       	ldi	r20, 0x00	; 0
    1344:	c7 01       	movw	r24, r14
    1346:	51 de       	rcall	.-862    	; 0xfea <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		mcp2515_setRegister(a3, 0);
    1348:	60 e2       	ldi	r22, 0x20	; 32
    134a:	6c 0f       	add	r22, r28
    134c:	40 e0       	ldi	r20, 0x00	; 0
    134e:	c7 01       	movw	r24, r14
    1350:	4c de       	rcall	.-872    	; 0xfea <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		a1++;
    1352:	cf 5f       	subi	r28, 0xFF	; 255
	/* transmit buffers             */
	/* TXBnCTRL -> TXBnD7           */
	a1 = MCP_TXB0CTRL;
	a2 = MCP_TXB1CTRL;
	a3 = MCP_TXB2CTRL;
	for (i = 0; i < 14; i++) {                                          /* in-buffer loop               */
    1354:	ce 33       	cpi	r28, 0x3E	; 62
    1356:	79 f7       	brne	.-34     	; 0x1336 <_ZN7MCP_CAN22mcp2515_initCANBuffersEv+0x7c>
		mcp2515_setRegister(a3, 0);
		a1++;
		a2++;
		a3++;
	}
	mcp2515_setRegister(MCP_RXB0CTRL, 0);
    1358:	40 e0       	ldi	r20, 0x00	; 0
    135a:	60 e6       	ldi	r22, 0x60	; 96
    135c:	c7 01       	movw	r24, r14
    135e:	45 de       	rcall	.-886    	; 0xfea <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1360:	40 e0       	ldi	r20, 0x00	; 0
	mcp2515_setRegister(MCP_RXB1CTRL, 0);
    1362:	60 e7       	ldi	r22, 0x70	; 112
    1364:	c7 01       	movw	r24, r14
    1366:	41 de       	rcall	.-894    	; 0xfea <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1368:	cf 91       	pop	r28
    136a:	1f 91       	pop	r17
}
    136c:	0f 91       	pop	r16
    136e:	ff 90       	pop	r15
    1370:	ef 90       	pop	r14
    1372:	08 95       	ret

00001374 <_ZN7MCP_CAN12mcp2515_initEhhh>:
    1374:	ff 92       	push	r15
    1376:	0f 93       	push	r16

/*********************************************************************************************************
** Function name:           mcp2515_init
** Descriptions:            Initialize the controller
*********************************************************************************************************/
uint8_t MCP_CAN::mcp2515_init(const uint8_t canIDMode, const uint8_t canSpeed, const uint8_t canClock){
    1378:	1f 93       	push	r17
    137a:	cf 93       	push	r28
    137c:	df 93       	push	r29
    137e:	ec 01       	movw	r28, r24
    1380:	f6 2e       	mov	r15, r22
    1382:	14 2f       	mov	r17, r20
    1384:	02 2f       	mov	r16, r18
	uint8_t res;
	mcp2515_reset();
    1386:	78 dd       	rcall	.-1296   	; 0xe78 <_ZN7MCP_CAN13mcp2515_resetEv>
	mcpMode = MCP_LOOPBACK;
    1388:	80 e4       	ldi	r24, 0x40	; 64
    138a:	89 8b       	std	Y+17, r24	; 0x11
	res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
    138c:	60 e8       	ldi	r22, 0x80	; 128
    138e:	ce 01       	movw	r24, r28
    1390:	26 df       	rcall	.-436    	; 0x11de <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>
	if(res > 0)
    1392:	81 11       	cpse	r24, r1
    1394:	35 c0       	rjmp	.+106    	; 0x1400 <_ZN7MCP_CAN12mcp2515_initEhhh+0x8c>
	return res;
	// Set Baudrate
	if(mcp2515_configRate(canSpeed, canClock))
    1396:	40 2f       	mov	r20, r16
    1398:	61 2f       	mov	r22, r17
    139a:	ce 01       	movw	r24, r28
    139c:	3a df       	rcall	.-396    	; 0x1212 <_ZN7MCP_CAN18mcp2515_configRateEhh>
    139e:	81 11       	cpse	r24, r1
	return res;
	if ( res == MCP2515_OK ) {
		mcp2515_initCANBuffers();											//init canbuffers
    13a0:	2c c0       	rjmp	.+88     	; 0x13fa <_ZN7MCP_CAN12mcp2515_initEhhh+0x86>
    13a2:	ce 01       	movw	r24, r28
		mcp2515_setRegister(MCP_CANINTE, MCP_RX0IF | MCP_RX1IF);			//interrupt mode
    13a4:	8a df       	rcall	.-236    	; 0x12ba <_ZN7MCP_CAN22mcp2515_initCANBuffersEv>
    13a6:	43 e0       	ldi	r20, 0x03	; 3
    13a8:	6b e2       	ldi	r22, 0x2B	; 43
    13aa:	ce 01       	movw	r24, r28
		mcp2515_setRegister(MCP_BFPCTRL,MCP_BxBFS_MASK | MCP_BxBFE_MASK);	//Sets BF pins as GPO
    13ac:	1e de       	rcall	.-964    	; 0xfea <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    13ae:	4c e3       	ldi	r20, 0x3C	; 60
    13b0:	6c e0       	ldi	r22, 0x0C	; 12
    13b2:	ce 01       	movw	r24, r28
		mcp2515_setRegister(MCP_TXRTSCTRL,0x00);							//Sets RTS pins as GPI
    13b4:	1a de       	rcall	.-972    	; 0xfea <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    13b6:	40 e0       	ldi	r20, 0x00	; 0
    13b8:	6d e0       	ldi	r22, 0x0D	; 13
    13ba:	ce 01       	movw	r24, r28
    13bc:	16 de       	rcall	.-980    	; 0xfea <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		switch(canIDMode){
    13be:	ff 20       	and	r15, r15
    13c0:	71 f0       	breq	.+28     	; 0x13de <_ZN7MCP_CAN12mcp2515_initEhhh+0x6a>
    13c2:	83 e0       	ldi	r24, 0x03	; 3
    13c4:	f8 12       	cpse	r15, r24
			case (MCP_ANY):
			mcp2515_modifyRegister(MCP_RXB0CTRL,
			MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
			MCP_RXB_RX_ANY | MCP_RXB_BUKT_MASK);
    13c6:	1b c0       	rjmp	.+54     	; 0x13fe <_ZN7MCP_CAN12mcp2515_initEhhh+0x8a>
    13c8:	24 e6       	ldi	r18, 0x64	; 100
    13ca:	44 e6       	ldi	r20, 0x64	; 100
    13cc:	60 e6       	ldi	r22, 0x60	; 96
    13ce:	ce 01       	movw	r24, r28
			mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
			MCP_RXB_RX_ANY);
    13d0:	95 de       	rcall	.-726    	; 0x10fc <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    13d2:	20 e6       	ldi	r18, 0x60	; 96
    13d4:	40 e6       	ldi	r20, 0x60	; 96
    13d6:	60 e7       	ldi	r22, 0x70	; 112
    13d8:	ce 01       	movw	r24, r28
			break;
    13da:	90 de       	rcall	.-736    	; 0x10fc <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
			case (MCP_STDEXT):
			mcp2515_modifyRegister(MCP_RXB0CTRL,
			MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
			MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK );
    13dc:	0a c0       	rjmp	.+20     	; 0x13f2 <_ZN7MCP_CAN12mcp2515_initEhhh+0x7e>
    13de:	24 e0       	ldi	r18, 0x04	; 4
    13e0:	44 e6       	ldi	r20, 0x64	; 100
    13e2:	60 e6       	ldi	r22, 0x60	; 96
			mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
			MCP_RXB_RX_STDEXT);
    13e4:	ce 01       	movw	r24, r28
    13e6:	8a de       	rcall	.-748    	; 0x10fc <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    13e8:	20 e0       	ldi	r18, 0x00	; 0
    13ea:	40 e6       	ldi	r20, 0x60	; 96
    13ec:	60 e7       	ldi	r22, 0x70	; 112
    13ee:	ce 01       	movw	r24, r28
			break;
			default:
			return MCP2515_FAIL;
			break;
		}
		res = mcp2515_setCANCTRL_Mode(mcpMode);
    13f0:	85 de       	rcall	.-758    	; 0x10fc <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    13f2:	69 89       	ldd	r22, Y+17	; 0x11
    13f4:	ce 01       	movw	r24, r28
    13f6:	f3 de       	rcall	.-538    	; 0x11de <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>
    13f8:	03 c0       	rjmp	.+6      	; 0x1400 <_ZN7MCP_CAN12mcp2515_initEhhh+0x8c>
	res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
	if(res > 0)
	return res;
	// Set Baudrate
	if(mcp2515_configRate(canSpeed, canClock))
	return res;
    13fa:	80 e0       	ldi	r24, 0x00	; 0
    13fc:	01 c0       	rjmp	.+2      	; 0x1400 <_ZN7MCP_CAN12mcp2515_initEhhh+0x8c>
			MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK );
			mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
			MCP_RXB_RX_STDEXT);
			break;
			default:
			return MCP2515_FAIL;
    13fe:	81 e0       	ldi	r24, 0x01	; 1
		res = mcp2515_setCANCTRL_Mode(mcpMode);
		if(res)
		return res;
	}
	return res;
}
    1400:	df 91       	pop	r29
    1402:	cf 91       	pop	r28
    1404:	1f 91       	pop	r17
    1406:	0f 91       	pop	r16
    1408:	ff 90       	pop	r15
    140a:	08 95       	ret

0000140c <_ZN7MCP_CAN15mcp2515_read_idEhPhPm>:

/*********************************************************************************************************
** Function name:           mcp2515_read_id
** Descriptions:            Read CAN ID
*********************************************************************************************************/
void MCP_CAN::mcp2515_read_id( const uint8_t mcp_addr, uint8_t* ext, uint32_t* id ){
    140c:	ef 92       	push	r14
    140e:	ff 92       	push	r15
    1410:	0f 93       	push	r16
    1412:	1f 93       	push	r17
    1414:	cf 93       	push	r28
    1416:	df 93       	push	r29
    1418:	00 d0       	rcall	.+0      	; 0x141a <_ZN7MCP_CAN15mcp2515_read_idEhPhPm+0xe>
    141a:	1f 92       	push	r1
    141c:	cd b7       	in	r28, 0x3d	; 61
    141e:	de b7       	in	r29, 0x3e	; 62
    1420:	7a 01       	movw	r14, r20
    1422:	89 01       	movw	r16, r18
	uint8_t tbufdata[4];
	*ext = 0;
    1424:	fa 01       	movw	r30, r20
    1426:	10 82       	st	Z, r1
	*id = 0;
    1428:	f9 01       	movw	r30, r18
    142a:	10 82       	st	Z, r1
    142c:	11 82       	std	Z+1, r1	; 0x01
    142e:	12 82       	std	Z+2, r1	; 0x02
    1430:	13 82       	std	Z+3, r1	; 0x03
	mcp2515_readRegisterS( mcp_addr, tbufdata, 4 );
    1432:	24 e0       	ldi	r18, 0x04	; 4
    1434:	ae 01       	movw	r20, r28
    1436:	4f 5f       	subi	r20, 0xFF	; 255
    1438:	5f 4f       	sbci	r21, 0xFF	; 255
    143a:	87 dd       	rcall	.-1266   	; 0xf4a <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh>
	*id = (tbufdata[MCP_SIDH]<<3) + (tbufdata[MCP_SIDL]>>5);
    143c:	2a 81       	ldd	r18, Y+2	; 0x02
    143e:	39 81       	ldd	r19, Y+1	; 0x01
    1440:	82 2f       	mov	r24, r18
    1442:	90 e0       	ldi	r25, 0x00	; 0
    1444:	95 95       	asr	r25
    1446:	87 95       	ror	r24
    1448:	95 95       	asr	r25
    144a:	87 95       	ror	r24
    144c:	95 95       	asr	r25
    144e:	87 95       	ror	r24
    1450:	95 95       	asr	r25
    1452:	87 95       	ror	r24
    1454:	95 95       	asr	r25
    1456:	87 95       	ror	r24
    1458:	f8 e0       	ldi	r31, 0x08	; 8
    145a:	3f 9f       	mul	r19, r31
    145c:	80 0d       	add	r24, r0
    145e:	91 1d       	adc	r25, r1
    1460:	11 24       	eor	r1, r1
    1462:	09 2e       	mov	r0, r25
    1464:	00 0c       	add	r0, r0
    1466:	aa 0b       	sbc	r26, r26
    1468:	bb 0b       	sbc	r27, r27
    146a:	f8 01       	movw	r30, r16
    146c:	80 83       	st	Z, r24
    146e:	91 83       	std	Z+1, r25	; 0x01
    1470:	a2 83       	std	Z+2, r26	; 0x02
    1472:	b3 83       	std	Z+3, r27	; 0x03
	if ( (tbufdata[MCP_SIDL] & MCP_TXB_EXIDE_M) ==  MCP_TXB_EXIDE_M ){
    1474:	23 ff       	sbrs	r18, 3
    1476:	26 c0       	rjmp	.+76     	; 0x14c4 <_ZN7MCP_CAN15mcp2515_read_idEhPhPm+0xb8>
		/* extended id                  */
		*id = (*id<<2) + (tbufdata[MCP_SIDL] & 0x03);
		*id = (*id<<8) + tbufdata[MCP_EID8];
		*id = (*id<<8) + tbufdata[MCP_EID0];
    1478:	88 0f       	add	r24, r24
    147a:	99 1f       	adc	r25, r25
    147c:	aa 1f       	adc	r26, r26
    147e:	bb 1f       	adc	r27, r27
    1480:	88 0f       	add	r24, r24
    1482:	99 1f       	adc	r25, r25
    1484:	aa 1f       	adc	r26, r26
    1486:	bb 1f       	adc	r27, r27
    1488:	23 70       	andi	r18, 0x03	; 3
    148a:	82 0f       	add	r24, r18
    148c:	91 1d       	adc	r25, r1
    148e:	a1 1d       	adc	r26, r1
    1490:	b1 1d       	adc	r27, r1
    1492:	ba 2f       	mov	r27, r26
    1494:	a9 2f       	mov	r26, r25
    1496:	98 2f       	mov	r25, r24
    1498:	88 27       	eor	r24, r24
    149a:	2b 81       	ldd	r18, Y+3	; 0x03
    149c:	82 0f       	add	r24, r18
    149e:	91 1d       	adc	r25, r1
    14a0:	a1 1d       	adc	r26, r1
    14a2:	b1 1d       	adc	r27, r1
    14a4:	ba 2f       	mov	r27, r26
    14a6:	a9 2f       	mov	r26, r25
    14a8:	98 2f       	mov	r25, r24
    14aa:	88 27       	eor	r24, r24
    14ac:	2c 81       	ldd	r18, Y+4	; 0x04
    14ae:	82 0f       	add	r24, r18
    14b0:	91 1d       	adc	r25, r1
    14b2:	a1 1d       	adc	r26, r1
    14b4:	b1 1d       	adc	r27, r1
    14b6:	80 83       	st	Z, r24
    14b8:	91 83       	std	Z+1, r25	; 0x01
    14ba:	a2 83       	std	Z+2, r26	; 0x02
    14bc:	b3 83       	std	Z+3, r27	; 0x03
		*ext = 1;
    14be:	81 e0       	ldi	r24, 0x01	; 1
    14c0:	f7 01       	movw	r30, r14
    14c2:	80 83       	st	Z, r24
	}
}
    14c4:	0f 90       	pop	r0
    14c6:	0f 90       	pop	r0
    14c8:	0f 90       	pop	r0
    14ca:	0f 90       	pop	r0
    14cc:	df 91       	pop	r29
    14ce:	cf 91       	pop	r28
    14d0:	1f 91       	pop	r17
    14d2:	0f 91       	pop	r16
    14d4:	ff 90       	pop	r15
    14d6:	ef 90       	pop	r14
    14d8:	08 95       	ret

000014da <_ZN7MCP_CAN19mcp2515_read_canMsgEh>:

/*********************************************************************************************************
** Function name:           mcp2515_read_canMsg
** Descriptions:            Read message
*********************************************************************************************************/
void MCP_CAN::mcp2515_read_canMsg( const uint8_t buffer_sidh_addr){        /* read can msg                 */
    14da:	0f 93       	push	r16
    14dc:	1f 93       	push	r17
    14de:	cf 93       	push	r28
    14e0:	df 93       	push	r29
    14e2:	ec 01       	movw	r28, r24
    14e4:	16 2f       	mov	r17, r22
	uint8_t mcp_addr, ctrl;
	mcp_addr = buffer_sidh_addr;
	mcp2515_read_id( mcp_addr, &m_nExtFlg,&m_nID );
    14e6:	9c 01       	movw	r18, r24
    14e8:	2f 5f       	subi	r18, 0xFF	; 255
    14ea:	3f 4f       	sbci	r19, 0xFF	; 255
    14ec:	ac 01       	movw	r20, r24
    14ee:	8e df       	rcall	.-228    	; 0x140c <_ZN7MCP_CAN15mcp2515_read_idEhPhPm>
	ctrl = mcp2515_readRegister( mcp_addr-1 );
    14f0:	6f ef       	ldi	r22, 0xFF	; 255
    14f2:	61 0f       	add	r22, r17
    14f4:	ce 01       	movw	r24, r28
    14f6:	f2 dc       	rcall	.-1564   	; 0xedc <_ZN7MCP_CAN20mcp2515_readRegisterEh>
    14f8:	08 2f       	mov	r16, r24
	m_nDlc = mcp2515_readRegister( mcp_addr+4 );
    14fa:	64 e0       	ldi	r22, 0x04	; 4
    14fc:	61 0f       	add	r22, r17
    14fe:	ce 01       	movw	r24, r28
    1500:	ed dc       	rcall	.-1574   	; 0xedc <_ZN7MCP_CAN20mcp2515_readRegisterEh>
    1502:	8d 83       	std	Y+5, r24	; 0x05
	if (ctrl & 0x08)
    1504:	03 ff       	sbrs	r16, 3
    1506:	03 c0       	rjmp	.+6      	; 0x150e <_ZN7MCP_CAN19mcp2515_read_canMsgEh+0x34>
		m_nRtr = 1;
    1508:	91 e0       	ldi	r25, 0x01	; 1
    150a:	9e 87       	std	Y+14, r25	; 0x0e
    150c:	01 c0       	rjmp	.+2      	; 0x1510 <_ZN7MCP_CAN19mcp2515_read_canMsgEh+0x36>
	else
		m_nRtr = 0;
    150e:	1e 86       	std	Y+14, r1	; 0x0e
	m_nDlc &= MCP_DLC_MASK;
    1510:	28 2f       	mov	r18, r24
    1512:	2f 70       	andi	r18, 0x0F	; 15
    1514:	2d 83       	std	Y+5, r18	; 0x05
	mcp2515_readRegisterS( mcp_addr+5, &(m_nDta[0]), m_nDlc );
    1516:	ae 01       	movw	r20, r28
    1518:	4a 5f       	subi	r20, 0xFA	; 250
    151a:	5f 4f       	sbci	r21, 0xFF	; 255
    151c:	65 e0       	ldi	r22, 0x05	; 5
    151e:	61 0f       	add	r22, r17
    1520:	ce 01       	movw	r24, r28
    1522:	13 dd       	rcall	.-1498   	; 0xf4a <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh>
}
    1524:	df 91       	pop	r29
    1526:	cf 91       	pop	r28
    1528:	1f 91       	pop	r17
    152a:	0f 91       	pop	r16
    152c:	08 95       	ret

0000152e <_ZN7MCP_CANC1Eh>:
** Function name:           MCP_CAN
** Descriptions:            Public function to declare CAN class and the /CS pin.
*********************************************************************************************************/
MCP_CAN::MCP_CAN(uint8_t _CS)
{
	MCPCS = _CS;
    152e:	fc 01       	movw	r30, r24
    1530:	60 8b       	std	Z+16, r22	; 0x10
	MCP2515_UNSELECT();
    1532:	eb e0       	ldi	r30, 0x0B	; 11
    1534:	f1 e0       	ldi	r31, 0x01	; 1
    1536:	80 81       	ld	r24, Z
    1538:	84 60       	ori	r24, 0x04	; 4
    153a:	80 83       	st	Z, r24
	DDRL |= (1 << PL2);		//????
    153c:	ea e0       	ldi	r30, 0x0A	; 10
    153e:	f1 e0       	ldi	r31, 0x01	; 1
    1540:	80 81       	ld	r24, Z
    1542:	84 60       	ori	r24, 0x04	; 4
    1544:	80 83       	st	Z, r24
    1546:	08 95       	ret

00001548 <_ZN7MCP_CAN5beginEhhh>:
/*********************************************************************************************************
** Function name:           begin
** Descriptions:            Public function to declare controller initialization parameters.
*********************************************************************************************************/
uint8_t MCP_CAN::begin(uint8_t idmodeset, uint8_t speedset, uint8_t clockset)
{
    1548:	ff 92       	push	r15
    154a:	0f 93       	push	r16
    154c:	1f 93       	push	r17
    154e:	cf 93       	push	r28
    1550:	df 93       	push	r29
    1552:	ec 01       	movw	r28, r24
    1554:	16 2f       	mov	r17, r22
    1556:	04 2f       	mov	r16, r20
    1558:	f2 2e       	mov	r15, r18
	uint8_t res;

	SPI.begin();
    155a:	90 d0       	rcall	.+288    	; 0x167c <_ZN8SPIClass5beginEv>
	res = mcp2515_init(idmodeset, speedset, clockset);
    155c:	2f 2d       	mov	r18, r15
    155e:	40 2f       	mov	r20, r16
    1560:	61 2f       	mov	r22, r17
    1562:	ce 01       	movw	r24, r28
    1564:	07 df       	rcall	.-498    	; 0x1374 <_ZN7MCP_CAN12mcp2515_initEhhh>
    1566:	91 e0       	ldi	r25, 0x01	; 1
    1568:	81 11       	cpse	r24, r1
    156a:	01 c0       	rjmp	.+2      	; 0x156e <_ZN7MCP_CAN5beginEhhh+0x26>
    156c:	90 e0       	ldi	r25, 0x00	; 0
	if (res == MCP2515_OK)
	return CAN_OK;
	
	return CAN_FAILINIT;
}
    156e:	89 2f       	mov	r24, r25
    1570:	df 91       	pop	r29
    1572:	cf 91       	pop	r28
    1574:	1f 91       	pop	r17
    1576:	0f 91       	pop	r16
    1578:	ff 90       	pop	r15
    157a:	08 95       	ret

0000157c <_ZN7MCP_CAN7readMsgEv>:

/*********************************************************************************************************
** Function name:           readMsg
** Descriptions:            Read message
*********************************************************************************************************/
uint8_t MCP_CAN::readMsg(){
    157c:	cf 93       	push	r28
    157e:	df 93       	push	r29
    1580:	ec 01       	movw	r28, r24
	uint8_t stat, res;
	stat = mcp2515_readStatus();
    1582:	fd dd       	rcall	.-1030   	; 0x117e <_ZN7MCP_CAN18mcp2515_readStatusEv>

	if ( stat & MCP_STAT_RX0IF )                                        /* Msg in Buffer 0              */
    1584:	80 ff       	sbrs	r24, 0
    1586:	0a c0       	rjmp	.+20     	; 0x159c <_ZN7MCP_CAN7readMsgEv+0x20>
	{
		mcp2515_read_canMsg( MCP_RXBUF_0);
    1588:	61 e6       	ldi	r22, 0x61	; 97
    158a:	ce 01       	movw	r24, r28
    158c:	a6 df       	rcall	.-180    	; 0x14da <_ZN7MCP_CAN19mcp2515_read_canMsgEh>
		mcp2515_modifyRegister(MCP_CANINTF, MCP_RX0IF, 0);
    158e:	20 e0       	ldi	r18, 0x00	; 0
    1590:	41 e0       	ldi	r20, 0x01	; 1
    1592:	6c e2       	ldi	r22, 0x2C	; 44
    1594:	ce 01       	movw	r24, r28
    1596:	b2 dd       	rcall	.-1180   	; 0x10fc <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
		res = CAN_OK;
    1598:	80 e0       	ldi	r24, 0x00	; 0
    159a:	0d c0       	rjmp	.+26     	; 0x15b6 <_ZN7MCP_CAN7readMsgEv+0x3a>
	}
	else if ( stat & MCP_STAT_RX1IF )                                   /* Msg in Buffer 1              */
    159c:	81 ff       	sbrs	r24, 1
	{
		mcp2515_read_canMsg( MCP_RXBUF_1);
    159e:	0a c0       	rjmp	.+20     	; 0x15b4 <_ZN7MCP_CAN7readMsgEv+0x38>
    15a0:	61 e7       	ldi	r22, 0x71	; 113
    15a2:	ce 01       	movw	r24, r28
    15a4:	9a df       	rcall	.-204    	; 0x14da <_ZN7MCP_CAN19mcp2515_read_canMsgEh>
		mcp2515_modifyRegister(MCP_CANINTF, MCP_RX1IF, 0);
    15a6:	20 e0       	ldi	r18, 0x00	; 0
    15a8:	42 e0       	ldi	r20, 0x02	; 2
    15aa:	6c e2       	ldi	r22, 0x2C	; 44
    15ac:	ce 01       	movw	r24, r28
    15ae:	a6 dd       	rcall	.-1204   	; 0x10fc <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
		res = CAN_OK;
    15b0:	80 e0       	ldi	r24, 0x00	; 0
    15b2:	01 c0       	rjmp	.+2      	; 0x15b6 <_ZN7MCP_CAN7readMsgEv+0x3a>
	}
	else
	res = CAN_NOMSG;
    15b4:	84 e0       	ldi	r24, 0x04	; 4
	
	return res;
}
    15b6:	df 91       	pop	r29
    15b8:	cf 91       	pop	r28
    15ba:	08 95       	ret

000015bc <_ZN7MCP_CAN10readMsgBufEPmPhS1_>:

/*********************************************************************************************************
** Function name:           readMsgBuf
** Descriptions:            Public function, Reads message from receive buffer.
*********************************************************************************************************/
uint8_t MCP_CAN::readMsgBuf(uint32_t *id, uint8_t *len, uint8_t buf[]){
    15bc:	cf 92       	push	r12
    15be:	df 92       	push	r13
    15c0:	ef 92       	push	r14
    15c2:	ff 92       	push	r15
    15c4:	0f 93       	push	r16
    15c6:	1f 93       	push	r17
    15c8:	cf 93       	push	r28
    15ca:	df 93       	push	r29
    15cc:	ec 01       	movw	r28, r24
    15ce:	7b 01       	movw	r14, r22
    15d0:	8a 01       	movw	r16, r20
    15d2:	c2 2e       	mov	r12, r18
    15d4:	d3 2e       	mov	r13, r19
	if(readMsg() == CAN_NOMSG)
    15d6:	d2 df       	rcall	.-92     	; 0x157c <_ZN7MCP_CAN7readMsgEv>
    15d8:	84 30       	cpi	r24, 0x04	; 4
    15da:	c9 f1       	breq	.+114    	; 0x164e <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x92>
	return CAN_NOMSG;

	if (m_nExtFlg)
    15dc:	88 81       	ld	r24, Y
    15de:	88 23       	and	r24, r24
    15e0:	49 f0       	breq	.+18     	; 0x15f4 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x38>
	m_nID |= 0x80000000;
    15e2:	89 81       	ldd	r24, Y+1	; 0x01
    15e4:	9a 81       	ldd	r25, Y+2	; 0x02
    15e6:	ab 81       	ldd	r26, Y+3	; 0x03
    15e8:	bc 81       	ldd	r27, Y+4	; 0x04
    15ea:	b0 68       	ori	r27, 0x80	; 128
    15ec:	89 83       	std	Y+1, r24	; 0x01
    15ee:	9a 83       	std	Y+2, r25	; 0x02
    15f0:	ab 83       	std	Y+3, r26	; 0x03
    15f2:	bc 83       	std	Y+4, r27	; 0x04

	if (m_nRtr)
    15f4:	8e 85       	ldd	r24, Y+14	; 0x0e
    15f6:	88 23       	and	r24, r24
    15f8:	49 f0       	breq	.+18     	; 0x160c <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x50>
	m_nID |= 0x40000000;
    15fa:	89 81       	ldd	r24, Y+1	; 0x01
    15fc:	9a 81       	ldd	r25, Y+2	; 0x02
    15fe:	ab 81       	ldd	r26, Y+3	; 0x03
    1600:	bc 81       	ldd	r27, Y+4	; 0x04
    1602:	b0 64       	ori	r27, 0x40	; 64
    1604:	89 83       	std	Y+1, r24	; 0x01
    1606:	9a 83       	std	Y+2, r25	; 0x02
    1608:	ab 83       	std	Y+3, r26	; 0x03
    160a:	bc 83       	std	Y+4, r27	; 0x04
	*id  = m_nID;
    160c:	89 81       	ldd	r24, Y+1	; 0x01
    160e:	9a 81       	ldd	r25, Y+2	; 0x02
    1610:	ab 81       	ldd	r26, Y+3	; 0x03
    1612:	bc 81       	ldd	r27, Y+4	; 0x04
    1614:	f7 01       	movw	r30, r14
    1616:	80 83       	st	Z, r24
    1618:	91 83       	std	Z+1, r25	; 0x01
    161a:	a2 83       	std	Z+2, r26	; 0x02
    161c:	b3 83       	std	Z+3, r27	; 0x03
	*len = m_nDlc;
    161e:	8d 81       	ldd	r24, Y+5	; 0x05
    1620:	f8 01       	movw	r30, r16
    1622:	80 83       	st	Z, r24
	for(int i = 0; i<m_nDlc; i++)
    1624:	8d 81       	ldd	r24, Y+5	; 0x05
    1626:	88 23       	and	r24, r24
    1628:	89 f0       	breq	.+34     	; 0x164c <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x90>
    162a:	de 01       	movw	r26, r28
    162c:	16 96       	adiw	r26, 0x06	; 6
    162e:	ec 2d       	mov	r30, r12
    1630:	fd 2d       	mov	r31, r13
    1632:	20 e0       	ldi	r18, 0x00	; 0
    1634:	30 e0       	ldi	r19, 0x00	; 0
	buf[i] = m_nDta[i];
    1636:	8d 91       	ld	r24, X+
    1638:	81 93       	st	Z+, r24

	if (m_nRtr)
	m_nID |= 0x40000000;
	*id  = m_nID;
	*len = m_nDlc;
	for(int i = 0; i<m_nDlc; i++)
    163a:	2f 5f       	subi	r18, 0xFF	; 255
    163c:	3f 4f       	sbci	r19, 0xFF	; 255
    163e:	8d 81       	ldd	r24, Y+5	; 0x05
    1640:	90 e0       	ldi	r25, 0x00	; 0
    1642:	28 17       	cp	r18, r24
    1644:	39 07       	cpc	r19, r25
    1646:	bc f3       	brlt	.-18     	; 0x1636 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x7a>
	buf[i] = m_nDta[i];
	return CAN_OK;
    1648:	80 e0       	ldi	r24, 0x00	; 0
    164a:	01 c0       	rjmp	.+2      	; 0x164e <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x92>
    164c:	80 e0       	ldi	r24, 0x00	; 0
}
    164e:	df 91       	pop	r29
    1650:	cf 91       	pop	r28
    1652:	1f 91       	pop	r17
    1654:	0f 91       	pop	r16
    1656:	ff 90       	pop	r15
    1658:	ef 90       	pop	r14
    165a:	df 90       	pop	r13
    165c:	cf 90       	pop	r12
    165e:	08 95       	ret

00001660 <_ZN11SPISettingsC1Emhh>:
void SPIClass::end() {
	cli();							// Protect from a scheduler and prevent transactionBegin
	if (initialized)					// Decrease the reference counter
		initialized--;
	if (!initialized)				
		SPCR &= ~(1 << SPE);
    1660:	0f 93       	push	r16
    1662:	fc 01       	movw	r30, r24
    1664:	22 23       	and	r18, r18
    1666:	11 f0       	breq	.+4      	; 0x166c <_ZN11SPISettingsC1Emhh+0xc>
    1668:	90 e5       	ldi	r25, 0x50	; 80
    166a:	01 c0       	rjmp	.+2      	; 0x166e <_ZN11SPISettingsC1Emhh+0xe>
    166c:	90 e7       	ldi	r25, 0x70	; 112
    166e:	0c 70       	andi	r16, 0x0C	; 12
    1670:	09 2b       	or	r16, r25
    1672:	00 83       	st	Z, r16
    1674:	81 e0       	ldi	r24, 0x01	; 1
    1676:	81 83       	std	Z+1, r24	; 0x01
    1678:	0f 91       	pop	r16
    167a:	08 95       	ret

0000167c <_ZN8SPIClass5beginEv>:
    167c:	f8 94       	cli
    167e:	80 91 74 04 	lds	r24, 0x0474	; 0x800474 <_ZN8SPIClass11initializedE>
    1682:	81 11       	cpse	r24, r1
    1684:	0b c0       	rjmp	.+22     	; 0x169c <_ZN8SPIClass5beginEv+0x20>
    1686:	58 9a       	sbi	0x0b, 0	; 11
    1688:	20 9a       	sbi	0x04, 0	; 4
    168a:	84 b1       	in	r24, 0x04	; 4
    168c:	86 60       	ori	r24, 0x06	; 6
    168e:	84 b9       	out	0x04, r24	; 4
    1690:	8c b5       	in	r24, 0x2c	; 44
    1692:	80 61       	ori	r24, 0x10	; 16
    1694:	8c bd       	out	0x2c, r24	; 44
    1696:	8c b5       	in	r24, 0x2c	; 44
    1698:	80 64       	ori	r24, 0x40	; 64
    169a:	8c bd       	out	0x2c, r24	; 44
    169c:	80 91 74 04 	lds	r24, 0x0474	; 0x800474 <_ZN8SPIClass11initializedE>
    16a0:	8f 5f       	subi	r24, 0xFF	; 255
    16a2:	80 93 74 04 	sts	0x0474, r24	; 0x800474 <_ZN8SPIClass11initializedE>
    16a6:	08 95       	ret

000016a8 <_ZN8SPIClass16beginTransactionE11SPISettings>:
}

void SPIClass::beginTransaction(SPISettings settings) {
	SPCR = settings.spcr;
    16a8:	fb 01       	movw	r30, r22
    16aa:	80 81       	ld	r24, Z
    16ac:	8c bd       	out	0x2c, r24	; 44
	SPSR = settings.spsr;
    16ae:	81 81       	ldd	r24, Z+1	; 0x01
    16b0:	8d bd       	out	0x2d, r24	; 45
    16b2:	08 95       	ret

000016b4 <_ZN8SPIClass8transferEh>:
}

uint8_t SPIClass::transfer(uint8_t data) {
SPDR = data;
    16b4:	6e bd       	out	0x2e, r22	; 46
while (!(SPSR & (1 << SPIF))) ; // wait
    16b6:	0d b4       	in	r0, 0x2d	; 45
    16b8:	07 fe       	sbrs	r0, 7
    16ba:	fd cf       	rjmp	.-6      	; 0x16b6 <_ZN8SPIClass8transferEh+0x2>
return SPDR;
    16bc:	8e b5       	in	r24, 0x2e	; 46
}
    16be:	08 95       	ret

000016c0 <_ZN5USARTC1Ev>:
#include "USART.h"

//constructor with setup

USART::USART(){
	UCSR0B = (1 << TXEN0);						// Enable de USART Transmitter
    16c0:	88 e0       	ldi	r24, 0x08	; 8
    16c2:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);		// 8 data bits, 1 stop bit
    16c6:	96 e0       	ldi	r25, 0x06	; 6
    16c8:	90 93 c2 00 	sts	0x00C2, r25	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
	UBRR0H=0;									//write the baudrate (76800)
    16cc:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
	UBRR0L=8;									// "
    16d0:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    16d4:	08 95       	ret

000016d6 <_ZN5USART5printEPKc>:
}



//write a string in the Serial
void USART::print(const char st[]) {
    16d6:	cf 93       	push	r28
    16d8:	df 93       	push	r29
	for(uint8_t i = 0 ; st[i] != 0 ; i++) {		//iterate over every char in the string
    16da:	fb 01       	movw	r30, r22
    16dc:	90 81       	ld	r25, Z
    16de:	99 23       	and	r25, r25
    16e0:	81 f0       	breq	.+32     	; 0x1702 <_ZN5USART5printEPKc+0x2c>
    16e2:	20 e0       	ldi	r18, 0x00	; 0
		while(~UCSR0A & (1 << UDRE0));			//wait till the transmit buffer is empty
    16e4:	e0 ec       	ldi	r30, 0xC0	; 192
    16e6:	f0 e0       	ldi	r31, 0x00	; 0
		UDR0 = (int)st[i];						//write the char in the transmit buffer
    16e8:	c6 ec       	ldi	r28, 0xC6	; 198
    16ea:	d0 e0       	ldi	r29, 0x00	; 0


//write a string in the Serial
void USART::print(const char st[]) {
	for(uint8_t i = 0 ; st[i] != 0 ; i++) {		//iterate over every char in the string
		while(~UCSR0A & (1 << UDRE0));			//wait till the transmit buffer is empty
    16ec:	80 81       	ld	r24, Z
    16ee:	85 ff       	sbrs	r24, 5
    16f0:	fd cf       	rjmp	.-6      	; 0x16ec <_ZN5USART5printEPKc+0x16>
		UDR0 = (int)st[i];						//write the char in the transmit buffer
    16f2:	98 83       	st	Y, r25



//write a string in the Serial
void USART::print(const char st[]) {
	for(uint8_t i = 0 ; st[i] != 0 ; i++) {		//iterate over every char in the string
    16f4:	2f 5f       	subi	r18, 0xFF	; 255
    16f6:	db 01       	movw	r26, r22
    16f8:	a2 0f       	add	r26, r18
    16fa:	b1 1d       	adc	r27, r1
    16fc:	9c 91       	ld	r25, X
    16fe:	91 11       	cpse	r25, r1
    1700:	f5 cf       	rjmp	.-22     	; 0x16ec <_ZN5USART5printEPKc+0x16>
		while(~UCSR0A & (1 << UDRE0));			//wait till the transmit buffer is empty
		UDR0 = (int)st[i];						//write the char in the transmit buffer
	}
}
    1702:	df 91       	pop	r29
    1704:	cf 91       	pop	r28
    1706:	08 95       	ret

00001708 <_ZN5USART7printlnEPKc>:

void USART::println(const char st[]){
    1708:	cf 93       	push	r28
    170a:	df 93       	push	r29
    170c:	ec 01       	movw	r28, r24
	this->print(st);
    170e:	e3 df       	rcall	.-58     	; 0x16d6 <_ZN5USART5printEPKc>
	this->print("\n\r");
    1710:	60 e2       	ldi	r22, 0x20	; 32
    1712:	74 e0       	ldi	r23, 0x04	; 4
    1714:	ce 01       	movw	r24, r28
    1716:	df df       	rcall	.-66     	; 0x16d6 <_ZN5USART5printEPKc>
}
    1718:	df 91       	pop	r29
    171a:	cf 91       	pop	r28
    171c:	08 95       	ret

0000171e <_ZN5USART5printEi>:

//write an integer in the Serial
void USART::print(int i) {
    171e:	0f 93       	push	r16
    1720:	1f 93       	push	r17
    1722:	cf 93       	push	r28
    1724:	df 93       	push	r29
    1726:	cd b7       	in	r28, 0x3d	; 61
    1728:	de b7       	in	r29, 0x3e	; 62
    172a:	60 97       	sbiw	r28, 0x10	; 16
    172c:	0f b6       	in	r0, 0x3f	; 63
    172e:	f8 94       	cli
    1730:	de bf       	out	0x3e, r29	; 62
    1732:	0f be       	out	0x3f, r0	; 63
    1734:	cd bf       	out	0x3d, r28	; 61
    1736:	8c 01       	movw	r16, r24
    1738:	cb 01       	movw	r24, r22
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    173a:	4a e0       	ldi	r20, 0x0A	; 10
    173c:	be 01       	movw	r22, r28
    173e:	6f 5f       	subi	r22, 0xFF	; 255
    1740:	7f 4f       	sbci	r23, 0xFF	; 255
    1742:	71 d1       	rcall	.+738    	; 0x1a26 <__itoa_ncheck>
	char buffer[16];							//create a string
	itoa(i,buffer,10);							//parse the integer into the string
	print(buffer);						//print the string
    1744:	be 01       	movw	r22, r28
    1746:	6f 5f       	subi	r22, 0xFF	; 255
    1748:	7f 4f       	sbci	r23, 0xFF	; 255
    174a:	c8 01       	movw	r24, r16
    174c:	c4 df       	rcall	.-120    	; 0x16d6 <_ZN5USART5printEPKc>
}
    174e:	60 96       	adiw	r28, 0x10	; 16
    1750:	0f b6       	in	r0, 0x3f	; 63
    1752:	f8 94       	cli
    1754:	de bf       	out	0x3e, r29	; 62
    1756:	0f be       	out	0x3f, r0	; 63
    1758:	cd bf       	out	0x3d, r28	; 61
    175a:	df 91       	pop	r29
    175c:	cf 91       	pop	r28
    175e:	1f 91       	pop	r17
    1760:	0f 91       	pop	r16
    1762:	08 95       	ret

00001764 <_ZN5USART7printlnEi>:

void USART::println(int i){
    1764:	cf 93       	push	r28
    1766:	df 93       	push	r29
    1768:	ec 01       	movw	r28, r24
	this->print(i);
    176a:	d9 df       	rcall	.-78     	; 0x171e <_ZN5USART5printEi>
	this->print("\n\r");
    176c:	60 e2       	ldi	r22, 0x20	; 32
    176e:	74 e0       	ldi	r23, 0x04	; 4
    1770:	ce 01       	movw	r24, r28
    1772:	b1 df       	rcall	.-158    	; 0x16d6 <_ZN5USART5printEPKc>
}
    1774:	df 91       	pop	r29
    1776:	cf 91       	pop	r28
    1778:	08 95       	ret

0000177a <__divmodsi4>:
    177a:	05 2e       	mov	r0, r21
    177c:	97 fb       	bst	r25, 7
    177e:	16 f4       	brtc	.+4      	; 0x1784 <__divmodsi4+0xa>
    1780:	00 94       	com	r0
    1782:	0f d0       	rcall	.+30     	; 0x17a2 <__negsi2>
    1784:	57 fd       	sbrc	r21, 7
    1786:	05 d0       	rcall	.+10     	; 0x1792 <__divmodsi4_neg2>
    1788:	1d d1       	rcall	.+570    	; 0x19c4 <__udivmodsi4>
    178a:	07 fc       	sbrc	r0, 7
    178c:	02 d0       	rcall	.+4      	; 0x1792 <__divmodsi4_neg2>
    178e:	46 f4       	brtc	.+16     	; 0x17a0 <__divmodsi4_exit>
    1790:	08 c0       	rjmp	.+16     	; 0x17a2 <__negsi2>

00001792 <__divmodsi4_neg2>:
    1792:	50 95       	com	r21
    1794:	40 95       	com	r20
    1796:	30 95       	com	r19
    1798:	21 95       	neg	r18
    179a:	3f 4f       	sbci	r19, 0xFF	; 255
    179c:	4f 4f       	sbci	r20, 0xFF	; 255
    179e:	5f 4f       	sbci	r21, 0xFF	; 255

000017a0 <__divmodsi4_exit>:
    17a0:	08 95       	ret

000017a2 <__negsi2>:
    17a2:	90 95       	com	r25
    17a4:	80 95       	com	r24
    17a6:	70 95       	com	r23
    17a8:	61 95       	neg	r22
    17aa:	7f 4f       	sbci	r23, 0xFF	; 255
    17ac:	8f 4f       	sbci	r24, 0xFF	; 255
    17ae:	9f 4f       	sbci	r25, 0xFF	; 255
    17b0:	08 95       	ret

000017b2 <__tablejump2__>:
    17b2:	ee 0f       	add	r30, r30
    17b4:	ff 1f       	adc	r31, r31
    17b6:	88 1f       	adc	r24, r24
    17b8:	8b bf       	out	0x3b, r24	; 59
    17ba:	07 90       	elpm	r0, Z+
    17bc:	f6 91       	elpm	r31, Z
    17be:	e0 2d       	mov	r30, r0
    17c0:	19 94       	eijmp

000017c2 <__usmulhisi3>:
    17c2:	22 d1       	rcall	.+580    	; 0x1a08 <__umulhisi3>

000017c4 <__usmulhisi3_tail>:
    17c4:	b7 ff       	sbrs	r27, 7
    17c6:	08 95       	ret
    17c8:	82 1b       	sub	r24, r18
    17ca:	93 0b       	sbc	r25, r19
    17cc:	08 95       	ret

000017ce <__moddi3>:
    17ce:	68 94       	set
    17d0:	01 c0       	rjmp	.+2      	; 0x17d4 <__divdi3_moddi3>

000017d2 <__divdi3>:
    17d2:	e8 94       	clt

000017d4 <__divdi3_moddi3>:
    17d4:	f9 2f       	mov	r31, r25
    17d6:	f1 2b       	or	r31, r17
    17d8:	0a f0       	brmi	.+2      	; 0x17dc <__divdi3_moddi3+0x8>
    17da:	27 c0       	rjmp	.+78     	; 0x182a <__udivdi3_umoddi3>
    17dc:	a0 e0       	ldi	r26, 0x00	; 0
    17de:	b0 e0       	ldi	r27, 0x00	; 0
    17e0:	e3 ef       	ldi	r30, 0xF3	; 243
    17e2:	fb e0       	ldi	r31, 0x0B	; 11
    17e4:	93 c0       	rjmp	.+294    	; 0x190c <__prologue_saves__+0xc>
    17e6:	09 2e       	mov	r0, r25
    17e8:	05 94       	asr	r0
    17ea:	1a f4       	brpl	.+6      	; 0x17f2 <__divdi3_moddi3+0x1e>
    17ec:	79 d0       	rcall	.+242    	; 0x18e0 <__negdi2>
    17ee:	11 23       	and	r17, r17
    17f0:	92 f4       	brpl	.+36     	; 0x1816 <__divdi3_moddi3+0x42>
    17f2:	f0 e8       	ldi	r31, 0x80	; 128
    17f4:	0f 26       	eor	r0, r31
    17f6:	ff ef       	ldi	r31, 0xFF	; 255
    17f8:	e0 94       	com	r14
    17fa:	f0 94       	com	r15
    17fc:	00 95       	com	r16
    17fe:	10 95       	com	r17
    1800:	b0 94       	com	r11
    1802:	c0 94       	com	r12
    1804:	d0 94       	com	r13
    1806:	a1 94       	neg	r10
    1808:	bf 0a       	sbc	r11, r31
    180a:	cf 0a       	sbc	r12, r31
    180c:	df 0a       	sbc	r13, r31
    180e:	ef 0a       	sbc	r14, r31
    1810:	ff 0a       	sbc	r15, r31
    1812:	0f 0b       	sbc	r16, r31
    1814:	1f 0b       	sbc	r17, r31
    1816:	13 d0       	rcall	.+38     	; 0x183e <__udivmod64>
    1818:	07 fc       	sbrc	r0, 7
    181a:	62 d0       	rcall	.+196    	; 0x18e0 <__negdi2>
    181c:	cd b7       	in	r28, 0x3d	; 61
    181e:	de b7       	in	r29, 0x3e	; 62
    1820:	ec e0       	ldi	r30, 0x0C	; 12
    1822:	90 c0       	rjmp	.+288    	; 0x1944 <__epilogue_restores__+0xc>

00001824 <__umoddi3>:
    1824:	68 94       	set
    1826:	01 c0       	rjmp	.+2      	; 0x182a <__udivdi3_umoddi3>

00001828 <__udivdi3>:
    1828:	e8 94       	clt

0000182a <__udivdi3_umoddi3>:
    182a:	8f 92       	push	r8
    182c:	9f 92       	push	r9
    182e:	cf 93       	push	r28
    1830:	df 93       	push	r29
    1832:	05 d0       	rcall	.+10     	; 0x183e <__udivmod64>
    1834:	df 91       	pop	r29
    1836:	cf 91       	pop	r28
    1838:	9f 90       	pop	r9
    183a:	8f 90       	pop	r8
    183c:	08 95       	ret

0000183e <__udivmod64>:
    183e:	88 24       	eor	r8, r8
    1840:	99 24       	eor	r9, r9
    1842:	f4 01       	movw	r30, r8
    1844:	e4 01       	movw	r28, r8
    1846:	b0 e4       	ldi	r27, 0x40	; 64
    1848:	9f 93       	push	r25
    184a:	aa 27       	eor	r26, r26
    184c:	9a 15       	cp	r25, r10
    184e:	8b 04       	cpc	r8, r11
    1850:	9c 04       	cpc	r9, r12
    1852:	ed 05       	cpc	r30, r13
    1854:	fe 05       	cpc	r31, r14
    1856:	cf 05       	cpc	r28, r15
    1858:	d0 07       	cpc	r29, r16
    185a:	a1 07       	cpc	r26, r17
    185c:	98 f4       	brcc	.+38     	; 0x1884 <__udivmod64+0x46>
    185e:	ad 2f       	mov	r26, r29
    1860:	dc 2f       	mov	r29, r28
    1862:	cf 2f       	mov	r28, r31
    1864:	fe 2f       	mov	r31, r30
    1866:	e9 2d       	mov	r30, r9
    1868:	98 2c       	mov	r9, r8
    186a:	89 2e       	mov	r8, r25
    186c:	98 2f       	mov	r25, r24
    186e:	87 2f       	mov	r24, r23
    1870:	76 2f       	mov	r23, r22
    1872:	65 2f       	mov	r22, r21
    1874:	54 2f       	mov	r21, r20
    1876:	43 2f       	mov	r20, r19
    1878:	32 2f       	mov	r19, r18
    187a:	22 27       	eor	r18, r18
    187c:	b8 50       	subi	r27, 0x08	; 8
    187e:	31 f7       	brne	.-52     	; 0x184c <__udivmod64+0xe>
    1880:	bf 91       	pop	r27
    1882:	27 c0       	rjmp	.+78     	; 0x18d2 <__udivmod64+0x94>
    1884:	1b 2e       	mov	r1, r27
    1886:	bf 91       	pop	r27
    1888:	bb 27       	eor	r27, r27
    188a:	22 0f       	add	r18, r18
    188c:	33 1f       	adc	r19, r19
    188e:	44 1f       	adc	r20, r20
    1890:	55 1f       	adc	r21, r21
    1892:	66 1f       	adc	r22, r22
    1894:	77 1f       	adc	r23, r23
    1896:	88 1f       	adc	r24, r24
    1898:	99 1f       	adc	r25, r25
    189a:	88 1c       	adc	r8, r8
    189c:	99 1c       	adc	r9, r9
    189e:	ee 1f       	adc	r30, r30
    18a0:	ff 1f       	adc	r31, r31
    18a2:	cc 1f       	adc	r28, r28
    18a4:	dd 1f       	adc	r29, r29
    18a6:	aa 1f       	adc	r26, r26
    18a8:	bb 1f       	adc	r27, r27
    18aa:	8a 14       	cp	r8, r10
    18ac:	9b 04       	cpc	r9, r11
    18ae:	ec 05       	cpc	r30, r12
    18b0:	fd 05       	cpc	r31, r13
    18b2:	ce 05       	cpc	r28, r14
    18b4:	df 05       	cpc	r29, r15
    18b6:	a0 07       	cpc	r26, r16
    18b8:	b1 07       	cpc	r27, r17
    18ba:	48 f0       	brcs	.+18     	; 0x18ce <__udivmod64+0x90>
    18bc:	8a 18       	sub	r8, r10
    18be:	9b 08       	sbc	r9, r11
    18c0:	ec 09       	sbc	r30, r12
    18c2:	fd 09       	sbc	r31, r13
    18c4:	ce 09       	sbc	r28, r14
    18c6:	df 09       	sbc	r29, r15
    18c8:	a0 0b       	sbc	r26, r16
    18ca:	b1 0b       	sbc	r27, r17
    18cc:	21 60       	ori	r18, 0x01	; 1
    18ce:	1a 94       	dec	r1
    18d0:	e1 f6       	brne	.-72     	; 0x188a <__udivmod64+0x4c>
    18d2:	2e f4       	brtc	.+10     	; 0x18de <__udivmod64+0xa0>
    18d4:	94 01       	movw	r18, r8
    18d6:	af 01       	movw	r20, r30
    18d8:	be 01       	movw	r22, r28
    18da:	cd 01       	movw	r24, r26
    18dc:	00 0c       	add	r0, r0
    18de:	08 95       	ret

000018e0 <__negdi2>:
    18e0:	60 95       	com	r22
    18e2:	70 95       	com	r23
    18e4:	80 95       	com	r24
    18e6:	90 95       	com	r25
    18e8:	30 95       	com	r19
    18ea:	40 95       	com	r20
    18ec:	50 95       	com	r21
    18ee:	21 95       	neg	r18
    18f0:	3f 4f       	sbci	r19, 0xFF	; 255
    18f2:	4f 4f       	sbci	r20, 0xFF	; 255
    18f4:	5f 4f       	sbci	r21, 0xFF	; 255
    18f6:	6f 4f       	sbci	r22, 0xFF	; 255
    18f8:	7f 4f       	sbci	r23, 0xFF	; 255
    18fa:	8f 4f       	sbci	r24, 0xFF	; 255
    18fc:	9f 4f       	sbci	r25, 0xFF	; 255
    18fe:	08 95       	ret

00001900 <__prologue_saves__>:
    1900:	2f 92       	push	r2
    1902:	3f 92       	push	r3
    1904:	4f 92       	push	r4
    1906:	5f 92       	push	r5
    1908:	6f 92       	push	r6
    190a:	7f 92       	push	r7
    190c:	8f 92       	push	r8
    190e:	9f 92       	push	r9
    1910:	af 92       	push	r10
    1912:	bf 92       	push	r11
    1914:	cf 92       	push	r12
    1916:	df 92       	push	r13
    1918:	ef 92       	push	r14
    191a:	ff 92       	push	r15
    191c:	0f 93       	push	r16
    191e:	1f 93       	push	r17
    1920:	cf 93       	push	r28
    1922:	df 93       	push	r29
    1924:	cd b7       	in	r28, 0x3d	; 61
    1926:	de b7       	in	r29, 0x3e	; 62
    1928:	ca 1b       	sub	r28, r26
    192a:	db 0b       	sbc	r29, r27
    192c:	0f b6       	in	r0, 0x3f	; 63
    192e:	f8 94       	cli
    1930:	de bf       	out	0x3e, r29	; 62
    1932:	0f be       	out	0x3f, r0	; 63
    1934:	cd bf       	out	0x3d, r28	; 61
    1936:	19 94       	eijmp

00001938 <__epilogue_restores__>:
    1938:	2a 88       	ldd	r2, Y+18	; 0x12
    193a:	39 88       	ldd	r3, Y+17	; 0x11
    193c:	48 88       	ldd	r4, Y+16	; 0x10
    193e:	5f 84       	ldd	r5, Y+15	; 0x0f
    1940:	6e 84       	ldd	r6, Y+14	; 0x0e
    1942:	7d 84       	ldd	r7, Y+13	; 0x0d
    1944:	8c 84       	ldd	r8, Y+12	; 0x0c
    1946:	9b 84       	ldd	r9, Y+11	; 0x0b
    1948:	aa 84       	ldd	r10, Y+10	; 0x0a
    194a:	b9 84       	ldd	r11, Y+9	; 0x09
    194c:	c8 84       	ldd	r12, Y+8	; 0x08
    194e:	df 80       	ldd	r13, Y+7	; 0x07
    1950:	ee 80       	ldd	r14, Y+6	; 0x06
    1952:	fd 80       	ldd	r15, Y+5	; 0x05
    1954:	0c 81       	ldd	r16, Y+4	; 0x04
    1956:	1b 81       	ldd	r17, Y+3	; 0x03
    1958:	aa 81       	ldd	r26, Y+2	; 0x02
    195a:	b9 81       	ldd	r27, Y+1	; 0x01
    195c:	ce 0f       	add	r28, r30
    195e:	d1 1d       	adc	r29, r1
    1960:	0f b6       	in	r0, 0x3f	; 63
    1962:	f8 94       	cli
    1964:	de bf       	out	0x3e, r29	; 62
    1966:	0f be       	out	0x3f, r0	; 63
    1968:	cd bf       	out	0x3d, r28	; 61
    196a:	ed 01       	movw	r28, r26
    196c:	08 95       	ret

0000196e <__ashldi3>:
    196e:	0f 93       	push	r16
    1970:	08 30       	cpi	r16, 0x08	; 8
    1972:	90 f0       	brcs	.+36     	; 0x1998 <__ashldi3+0x2a>
    1974:	98 2f       	mov	r25, r24
    1976:	87 2f       	mov	r24, r23
    1978:	76 2f       	mov	r23, r22
    197a:	65 2f       	mov	r22, r21
    197c:	54 2f       	mov	r21, r20
    197e:	43 2f       	mov	r20, r19
    1980:	32 2f       	mov	r19, r18
    1982:	22 27       	eor	r18, r18
    1984:	08 50       	subi	r16, 0x08	; 8
    1986:	f4 cf       	rjmp	.-24     	; 0x1970 <__ashldi3+0x2>
    1988:	22 0f       	add	r18, r18
    198a:	33 1f       	adc	r19, r19
    198c:	44 1f       	adc	r20, r20
    198e:	55 1f       	adc	r21, r21
    1990:	66 1f       	adc	r22, r22
    1992:	77 1f       	adc	r23, r23
    1994:	88 1f       	adc	r24, r24
    1996:	99 1f       	adc	r25, r25
    1998:	0a 95       	dec	r16
    199a:	b2 f7       	brpl	.-20     	; 0x1988 <__ashldi3+0x1a>
    199c:	0f 91       	pop	r16
    199e:	08 95       	ret

000019a0 <__adddi3>:
    19a0:	2a 0d       	add	r18, r10
    19a2:	3b 1d       	adc	r19, r11
    19a4:	4c 1d       	adc	r20, r12
    19a6:	5d 1d       	adc	r21, r13
    19a8:	6e 1d       	adc	r22, r14
    19aa:	7f 1d       	adc	r23, r15
    19ac:	80 1f       	adc	r24, r16
    19ae:	91 1f       	adc	r25, r17
    19b0:	08 95       	ret

000019b2 <__subdi3>:
    19b2:	2a 19       	sub	r18, r10
    19b4:	3b 09       	sbc	r19, r11
    19b6:	4c 09       	sbc	r20, r12
    19b8:	5d 09       	sbc	r21, r13
    19ba:	6e 09       	sbc	r22, r14
    19bc:	7f 09       	sbc	r23, r15
    19be:	80 0b       	sbc	r24, r16
    19c0:	91 0b       	sbc	r25, r17
    19c2:	08 95       	ret

000019c4 <__udivmodsi4>:
    19c4:	a1 e2       	ldi	r26, 0x21	; 33
    19c6:	1a 2e       	mov	r1, r26
    19c8:	aa 1b       	sub	r26, r26
    19ca:	bb 1b       	sub	r27, r27
    19cc:	fd 01       	movw	r30, r26
    19ce:	0d c0       	rjmp	.+26     	; 0x19ea <__udivmodsi4_ep>

000019d0 <__udivmodsi4_loop>:
    19d0:	aa 1f       	adc	r26, r26
    19d2:	bb 1f       	adc	r27, r27
    19d4:	ee 1f       	adc	r30, r30
    19d6:	ff 1f       	adc	r31, r31
    19d8:	a2 17       	cp	r26, r18
    19da:	b3 07       	cpc	r27, r19
    19dc:	e4 07       	cpc	r30, r20
    19de:	f5 07       	cpc	r31, r21
    19e0:	20 f0       	brcs	.+8      	; 0x19ea <__udivmodsi4_ep>
    19e2:	a2 1b       	sub	r26, r18
    19e4:	b3 0b       	sbc	r27, r19
    19e6:	e4 0b       	sbc	r30, r20
    19e8:	f5 0b       	sbc	r31, r21

000019ea <__udivmodsi4_ep>:
    19ea:	66 1f       	adc	r22, r22
    19ec:	77 1f       	adc	r23, r23
    19ee:	88 1f       	adc	r24, r24
    19f0:	99 1f       	adc	r25, r25
    19f2:	1a 94       	dec	r1
    19f4:	69 f7       	brne	.-38     	; 0x19d0 <__udivmodsi4_loop>
    19f6:	60 95       	com	r22
    19f8:	70 95       	com	r23
    19fa:	80 95       	com	r24
    19fc:	90 95       	com	r25
    19fe:	9b 01       	movw	r18, r22
    1a00:	ac 01       	movw	r20, r24
    1a02:	bd 01       	movw	r22, r26
    1a04:	cf 01       	movw	r24, r30
    1a06:	08 95       	ret

00001a08 <__umulhisi3>:
    1a08:	a2 9f       	mul	r26, r18
    1a0a:	b0 01       	movw	r22, r0
    1a0c:	b3 9f       	mul	r27, r19
    1a0e:	c0 01       	movw	r24, r0
    1a10:	a3 9f       	mul	r26, r19
    1a12:	70 0d       	add	r23, r0
    1a14:	81 1d       	adc	r24, r1
    1a16:	11 24       	eor	r1, r1
    1a18:	91 1d       	adc	r25, r1
    1a1a:	b2 9f       	mul	r27, r18
    1a1c:	70 0d       	add	r23, r0
    1a1e:	81 1d       	adc	r24, r1
    1a20:	11 24       	eor	r1, r1
    1a22:	91 1d       	adc	r25, r1
    1a24:	08 95       	ret

00001a26 <__itoa_ncheck>:
    1a26:	bb 27       	eor	r27, r27
    1a28:	4a 30       	cpi	r20, 0x0A	; 10
    1a2a:	31 f4       	brne	.+12     	; 0x1a38 <__itoa_ncheck+0x12>
    1a2c:	99 23       	and	r25, r25
    1a2e:	22 f4       	brpl	.+8      	; 0x1a38 <__itoa_ncheck+0x12>
    1a30:	bd e2       	ldi	r27, 0x2D	; 45
    1a32:	90 95       	com	r25
    1a34:	81 95       	neg	r24
    1a36:	9f 4f       	sbci	r25, 0xFF	; 255
    1a38:	01 c0       	rjmp	.+2      	; 0x1a3c <__utoa_common>

00001a3a <__utoa_ncheck>:
    1a3a:	bb 27       	eor	r27, r27

00001a3c <__utoa_common>:
    1a3c:	fb 01       	movw	r30, r22
    1a3e:	55 27       	eor	r21, r21
    1a40:	aa 27       	eor	r26, r26
    1a42:	88 0f       	add	r24, r24
    1a44:	99 1f       	adc	r25, r25
    1a46:	aa 1f       	adc	r26, r26
    1a48:	a4 17       	cp	r26, r20
    1a4a:	10 f0       	brcs	.+4      	; 0x1a50 <__utoa_common+0x14>
    1a4c:	a4 1b       	sub	r26, r20
    1a4e:	83 95       	inc	r24
    1a50:	50 51       	subi	r21, 0x10	; 16
    1a52:	b9 f7       	brne	.-18     	; 0x1a42 <__utoa_common+0x6>
    1a54:	a0 5d       	subi	r26, 0xD0	; 208
    1a56:	aa 33       	cpi	r26, 0x3A	; 58
    1a58:	08 f0       	brcs	.+2      	; 0x1a5c <__utoa_common+0x20>
    1a5a:	a9 5d       	subi	r26, 0xD9	; 217
    1a5c:	a1 93       	st	Z+, r26
    1a5e:	00 97       	sbiw	r24, 0x00	; 0
    1a60:	79 f7       	brne	.-34     	; 0x1a40 <__utoa_common+0x4>
    1a62:	b1 11       	cpse	r27, r1
    1a64:	b1 93       	st	Z+, r27
    1a66:	11 92       	st	Z+, r1
    1a68:	cb 01       	movw	r24, r22
    1a6a:	00 c0       	rjmp	.+0      	; 0x1a6c <strrev>

00001a6c <strrev>:
    1a6c:	dc 01       	movw	r26, r24
    1a6e:	fc 01       	movw	r30, r24
    1a70:	67 2f       	mov	r22, r23
    1a72:	71 91       	ld	r23, Z+
    1a74:	77 23       	and	r23, r23
    1a76:	e1 f7       	brne	.-8      	; 0x1a70 <strrev+0x4>
    1a78:	32 97       	sbiw	r30, 0x02	; 2
    1a7a:	04 c0       	rjmp	.+8      	; 0x1a84 <strrev+0x18>
    1a7c:	7c 91       	ld	r23, X
    1a7e:	6d 93       	st	X+, r22
    1a80:	70 83       	st	Z, r23
    1a82:	62 91       	ld	r22, -Z
    1a84:	ae 17       	cp	r26, r30
    1a86:	bf 07       	cpc	r27, r31
    1a88:	c8 f3       	brcs	.-14     	; 0x1a7c <strrev+0x10>
    1a8a:	08 95       	ret

00001a8c <_exit>:
    1a8c:	f8 94       	cli

00001a8e <__stop_program>:
    1a8e:	ff cf       	rjmp	.-2      	; 0x1a8e <__stop_program>
