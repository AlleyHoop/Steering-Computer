
Alley Hoop V2.1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001e8  00800200  00001aaa  00001b3e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001aaa  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000049  008003e8  008003e8  00001d26  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001d26  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001d58  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000238  00000000  00000000  00001d98  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000446b  00000000  00000000  00001fd0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001782  00000000  00000000  0000643b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000171b  00000000  00000000  00007bbd  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000006a0  00000000  00000000  000092d8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000112f  00000000  00000000  00009978  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001f4f  00000000  00000000  0000aaa7  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001f0  00000000  00000000  0000c9f6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	9f c0       	rjmp	.+318    	; 0x140 <__ctors_end>
       2:	00 00       	nop
       4:	cd c0       	rjmp	.+410    	; 0x1a0 <__bad_interrupt>
       6:	00 00       	nop
       8:	cb c0       	rjmp	.+406    	; 0x1a0 <__bad_interrupt>
       a:	00 00       	nop
       c:	c9 c0       	rjmp	.+402    	; 0x1a0 <__bad_interrupt>
       e:	00 00       	nop
      10:	c7 c0       	rjmp	.+398    	; 0x1a0 <__bad_interrupt>
      12:	00 00       	nop
      14:	c5 c0       	rjmp	.+394    	; 0x1a0 <__bad_interrupt>
      16:	00 00       	nop
      18:	c3 c0       	rjmp	.+390    	; 0x1a0 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c1 c0       	rjmp	.+386    	; 0x1a0 <__bad_interrupt>
      1e:	00 00       	nop
      20:	bf c0       	rjmp	.+382    	; 0x1a0 <__bad_interrupt>
      22:	00 00       	nop
      24:	bd c0       	rjmp	.+378    	; 0x1a0 <__bad_interrupt>
      26:	00 00       	nop
      28:	bb c0       	rjmp	.+374    	; 0x1a0 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	b9 c0       	rjmp	.+370    	; 0x1a0 <__bad_interrupt>
      2e:	00 00       	nop
      30:	b7 c0       	rjmp	.+366    	; 0x1a0 <__bad_interrupt>
      32:	00 00       	nop
      34:	b5 c0       	rjmp	.+362    	; 0x1a0 <__bad_interrupt>
      36:	00 00       	nop
      38:	b3 c0       	rjmp	.+358    	; 0x1a0 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b1 c0       	rjmp	.+354    	; 0x1a0 <__bad_interrupt>
      3e:	00 00       	nop
      40:	af c0       	rjmp	.+350    	; 0x1a0 <__bad_interrupt>
      42:	00 00       	nop
      44:	ad c0       	rjmp	.+346    	; 0x1a0 <__bad_interrupt>
      46:	00 00       	nop
      48:	ab c0       	rjmp	.+342    	; 0x1a0 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	a9 c0       	rjmp	.+338    	; 0x1a0 <__bad_interrupt>
      4e:	00 00       	nop
      50:	a7 c0       	rjmp	.+334    	; 0x1a0 <__bad_interrupt>
      52:	00 00       	nop
      54:	a5 c0       	rjmp	.+330    	; 0x1a0 <__bad_interrupt>
      56:	00 00       	nop
      58:	a3 c0       	rjmp	.+326    	; 0x1a0 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a1 c0       	rjmp	.+322    	; 0x1a0 <__bad_interrupt>
      5e:	00 00       	nop
      60:	9f c0       	rjmp	.+318    	; 0x1a0 <__bad_interrupt>
      62:	00 00       	nop
      64:	9d c0       	rjmp	.+314    	; 0x1a0 <__bad_interrupt>
      66:	00 00       	nop
      68:	9b c0       	rjmp	.+310    	; 0x1a0 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	99 c0       	rjmp	.+306    	; 0x1a0 <__bad_interrupt>
      6e:	00 00       	nop
      70:	97 c0       	rjmp	.+302    	; 0x1a0 <__bad_interrupt>
      72:	00 00       	nop
      74:	95 c0       	rjmp	.+298    	; 0x1a0 <__bad_interrupt>
      76:	00 00       	nop
      78:	93 c0       	rjmp	.+294    	; 0x1a0 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	91 c0       	rjmp	.+290    	; 0x1a0 <__bad_interrupt>
      7e:	00 00       	nop
      80:	8f c0       	rjmp	.+286    	; 0x1a0 <__bad_interrupt>
      82:	00 00       	nop
      84:	8d c0       	rjmp	.+282    	; 0x1a0 <__bad_interrupt>
      86:	00 00       	nop
      88:	8b c0       	rjmp	.+278    	; 0x1a0 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	89 c0       	rjmp	.+274    	; 0x1a0 <__bad_interrupt>
      8e:	00 00       	nop
      90:	87 c0       	rjmp	.+270    	; 0x1a0 <__bad_interrupt>
      92:	00 00       	nop
      94:	85 c0       	rjmp	.+266    	; 0x1a0 <__bad_interrupt>
      96:	00 00       	nop
      98:	83 c0       	rjmp	.+262    	; 0x1a0 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	81 c0       	rjmp	.+258    	; 0x1a0 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	7f c0       	rjmp	.+254    	; 0x1a0 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	7d c0       	rjmp	.+250    	; 0x1a0 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	7b c0       	rjmp	.+246    	; 0x1a0 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	79 c0       	rjmp	.+242    	; 0x1a0 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	77 c0       	rjmp	.+238    	; 0x1a0 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	75 c0       	rjmp	.+234    	; 0x1a0 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	73 c0       	rjmp	.+230    	; 0x1a0 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	71 c0       	rjmp	.+226    	; 0x1a0 <__bad_interrupt>
      be:	00 00       	nop
      c0:	6f c0       	rjmp	.+222    	; 0x1a0 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	6d c0       	rjmp	.+218    	; 0x1a0 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	6b c0       	rjmp	.+214    	; 0x1a0 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	69 c0       	rjmp	.+210    	; 0x1a0 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	67 c0       	rjmp	.+206    	; 0x1a0 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	65 c0       	rjmp	.+202    	; 0x1a0 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	63 c0       	rjmp	.+198    	; 0x1a0 <__bad_interrupt>
      da:	00 00       	nop
      dc:	61 c0       	rjmp	.+194    	; 0x1a0 <__bad_interrupt>
      de:	00 00       	nop
      e0:	5f c0       	rjmp	.+190    	; 0x1a0 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	a5 04       	cpc	r10, r5
      e6:	aa 04       	cpc	r10, r10
      e8:	af 04       	cpc	r10, r15
      ea:	b1 04       	cpc	r11, r1
      ec:	b6 04       	cpc	r11, r6
      ee:	bb 04       	cpc	r11, r11
      f0:	c0 04       	cpc	r12, r0
      f2:	c5 04       	cpc	r12, r5
      f4:	c8 04       	cpc	r12, r8
      f6:	cb 04       	cpc	r12, r11
      f8:	da 04       	cpc	r13, r10
      fa:	da 04       	cpc	r13, r10
      fc:	da 04       	cpc	r13, r10
      fe:	da 04       	cpc	r13, r10
     100:	da 04       	cpc	r13, r10
     102:	da 04       	cpc	r13, r10
     104:	da 04       	cpc	r13, r10
     106:	da 04       	cpc	r13, r10
     108:	da 04       	cpc	r13, r10
     10a:	da 04       	cpc	r13, r10
     10c:	da 04       	cpc	r13, r10
     10e:	da 04       	cpc	r13, r10
     110:	da 04       	cpc	r13, r10
     112:	da 04       	cpc	r13, r10
     114:	da 04       	cpc	r13, r10
     116:	da 04       	cpc	r13, r10
     118:	da 04       	cpc	r13, r10
     11a:	da 04       	cpc	r13, r10
     11c:	da 04       	cpc	r13, r10
     11e:	da 04       	cpc	r13, r10
     120:	da 04       	cpc	r13, r10
     122:	da 04       	cpc	r13, r10
     124:	da 04       	cpc	r13, r10
     126:	da 04       	cpc	r13, r10
     128:	da 04       	cpc	r13, r10
     12a:	da 04       	cpc	r13, r10
     12c:	da 04       	cpc	r13, r10
     12e:	da 04       	cpc	r13, r10
     130:	da 04       	cpc	r13, r10
     132:	da 04       	cpc	r13, r10
     134:	da 04       	cpc	r13, r10
     136:	da 04       	cpc	r13, r10
     138:	cb 04       	cpc	r12, r11
     13a:	d0 04       	cpc	r13, r0
     13c:	d5 04       	cpc	r13, r5

0000013e <__ctors_start>:
     13e:	41 07       	cpc	r20, r17

00000140 <__ctors_end>:
     140:	11 24       	eor	r1, r1
     142:	1f be       	out	0x3f, r1	; 63
     144:	cf ef       	ldi	r28, 0xFF	; 255
     146:	d1 e2       	ldi	r29, 0x21	; 33
     148:	de bf       	out	0x3e, r29	; 62
     14a:	cd bf       	out	0x3d, r28	; 61
     14c:	00 e0       	ldi	r16, 0x00	; 0
     14e:	0c bf       	out	0x3c, r16	; 60

00000150 <__do_copy_data>:
     150:	13 e0       	ldi	r17, 0x03	; 3
     152:	a0 e0       	ldi	r26, 0x00	; 0
     154:	b2 e0       	ldi	r27, 0x02	; 2
     156:	ea ea       	ldi	r30, 0xAA	; 170
     158:	fa e1       	ldi	r31, 0x1A	; 26
     15a:	00 e0       	ldi	r16, 0x00	; 0
     15c:	0b bf       	out	0x3b, r16	; 59
     15e:	02 c0       	rjmp	.+4      	; 0x164 <__do_copy_data+0x14>
     160:	07 90       	elpm	r0, Z+
     162:	0d 92       	st	X+, r0
     164:	a8 3e       	cpi	r26, 0xE8	; 232
     166:	b1 07       	cpc	r27, r17
     168:	d9 f7       	brne	.-10     	; 0x160 <__do_copy_data+0x10>

0000016a <__do_clear_bss>:
     16a:	24 e0       	ldi	r18, 0x04	; 4
     16c:	a8 ee       	ldi	r26, 0xE8	; 232
     16e:	b3 e0       	ldi	r27, 0x03	; 3
     170:	01 c0       	rjmp	.+2      	; 0x174 <.do_clear_bss_start>

00000172 <.do_clear_bss_loop>:
     172:	1d 92       	st	X+, r1

00000174 <.do_clear_bss_start>:
     174:	a1 33       	cpi	r26, 0x31	; 49
     176:	b2 07       	cpc	r27, r18
     178:	e1 f7       	brne	.-8      	; 0x172 <.do_clear_bss_loop>

0000017a <__do_global_ctors>:
     17a:	10 e0       	ldi	r17, 0x00	; 0
     17c:	c0 ea       	ldi	r28, 0xA0	; 160
     17e:	d0 e0       	ldi	r29, 0x00	; 0
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	06 c0       	rjmp	.+12     	; 0x190 <__do_global_ctors+0x16>
     184:	21 97       	sbiw	r28, 0x01	; 1
     186:	01 09       	sbc	r16, r1
     188:	80 2f       	mov	r24, r16
     18a:	fe 01       	movw	r30, r28
     18c:	0e 94 e6 0b 	call	0x17cc	; 0x17cc <__tablejump2__>
     190:	cf 39       	cpi	r28, 0x9F	; 159
     192:	d1 07       	cpc	r29, r17
     194:	80 e0       	ldi	r24, 0x00	; 0
     196:	08 07       	cpc	r16, r24
     198:	a9 f7       	brne	.-22     	; 0x184 <__do_global_ctors+0xa>
     19a:	4d d6       	rcall	.+3226   	; 0xe36 <main>
     19c:	0c 94 53 0d 	jmp	0x1aa6	; 0x1aa6 <_exit>

000001a0 <__bad_interrupt>:
     1a0:	2f cf       	rjmp	.-418    	; 0x0 <__vectors>

000001a2 <_Z11mode_selectv>:
		digitalWrite(do_hv_relay,LOW);			//disengage engine relay
		braking_dv=0;							//stop braking
	}
}

void mode_remote(){
     1a2:	88 e2       	ldi	r24, 0x28	; 40
     1a4:	90 e0       	ldi	r25, 0x00	; 0
     1a6:	db d4       	rcall	.+2486   	; 0xb5e <_Z11digitalReadi>
     1a8:	88 23       	and	r24, r24
     1aa:	39 f0       	breq	.+14     	; 0x1ba <_Z11mode_selectv+0x18>
     1ac:	81 e0       	ldi	r24, 0x01	; 1
     1ae:	90 e0       	ldi	r25, 0x00	; 0
     1b0:	90 93 0e 04 	sts	0x040E, r25	; 0x80040e <drivemode+0x1>
     1b4:	80 93 0d 04 	sts	0x040D, r24	; 0x80040d <drivemode>
     1b8:	08 95       	ret
     1ba:	86 e2       	ldi	r24, 0x26	; 38
     1bc:	90 e0       	ldi	r25, 0x00	; 0
     1be:	cf d4       	rcall	.+2462   	; 0xb5e <_Z11digitalReadi>
     1c0:	88 23       	and	r24, r24
     1c2:	39 f0       	breq	.+14     	; 0x1d2 <_Z11mode_selectv+0x30>
     1c4:	82 e0       	ldi	r24, 0x02	; 2
     1c6:	90 e0       	ldi	r25, 0x00	; 0
     1c8:	90 93 0e 04 	sts	0x040E, r25	; 0x80040e <drivemode+0x1>
     1cc:	80 93 0d 04 	sts	0x040D, r24	; 0x80040d <drivemode>
     1d0:	08 95       	ret
     1d2:	8a e2       	ldi	r24, 0x2A	; 42
     1d4:	90 e0       	ldi	r25, 0x00	; 0
     1d6:	c3 d4       	rcall	.+2438   	; 0xb5e <_Z11digitalReadi>
     1d8:	88 23       	and	r24, r24
     1da:	39 f0       	breq	.+14     	; 0x1ea <_Z11mode_selectv+0x48>
     1dc:	83 e0       	ldi	r24, 0x03	; 3
     1de:	90 e0       	ldi	r25, 0x00	; 0
     1e0:	90 93 0e 04 	sts	0x040E, r25	; 0x80040e <drivemode+0x1>
     1e4:	80 93 0d 04 	sts	0x040D, r24	; 0x80040d <drivemode>
     1e8:	08 95       	ret
     1ea:	10 92 0e 04 	sts	0x040E, r1	; 0x80040e <drivemode+0x1>
     1ee:	10 92 0d 04 	sts	0x040D, r1	; 0x80040d <drivemode>
     1f2:	08 95       	ret

000001f4 <_Z9initDrivev>:
     1f4:	61 e0       	ldi	r22, 0x01	; 1
     1f6:	81 e2       	ldi	r24, 0x21	; 33
     1f8:	90 e0       	ldi	r25, 0x00	; 0
     1fa:	e2 d3       	rcall	.+1988   	; 0x9c0 <_Z12digitalWriteib>
     1fc:	61 e0       	ldi	r22, 0x01	; 1
     1fe:	83 e2       	ldi	r24, 0x23	; 35
     200:	90 e0       	ldi	r25, 0x00	; 0
     202:	de d3       	rcall	.+1980   	; 0x9c0 <_Z12digitalWriteib>
     204:	61 e0       	ldi	r22, 0x01	; 1
     206:	88 e1       	ldi	r24, 0x18	; 24
     208:	90 e0       	ldi	r25, 0x00	; 0
     20a:	da d3       	rcall	.+1972   	; 0x9c0 <_Z12digitalWriteib>
     20c:	61 e0       	ldi	r22, 0x01	; 1
     20e:	89 e1       	ldi	r24, 0x19	; 25
     210:	90 e0       	ldi	r25, 0x00	; 0
     212:	d6 d3       	rcall	.+1964   	; 0x9c0 <_Z12digitalWriteib>
     214:	c6 cf       	rjmp	.-116    	; 0x1a2 <_Z11mode_selectv>
     216:	08 95       	ret

00000218 <_Z13mode_joystickv>:
     218:	61 e0       	ldi	r22, 0x01	; 1
     21a:	82 e2       	ldi	r24, 0x22	; 34
     21c:	90 e0       	ldi	r25, 0x00	; 0
     21e:	d0 d3       	rcall	.+1952   	; 0x9c0 <_Z12digitalWriteib>
     220:	61 e0       	ldi	r22, 0x01	; 1
     222:	80 e2       	ldi	r24, 0x20	; 32
     224:	90 e0       	ldi	r25, 0x00	; 0
     226:	cc d3       	rcall	.+1944   	; 0x9c0 <_Z12digitalWriteib>
     228:	80 91 ee 03 	lds	r24, 0x03EE	; 0x8003ee <engine_rpm>
     22c:	90 91 ef 03 	lds	r25, 0x03EF	; 0x8003ef <engine_rpm+0x1>
     230:	89 2b       	or	r24, r25
     232:	29 f4       	brne	.+10     	; 0x23e <_Z13mode_joystickv+0x26>
     234:	8c e2       	ldi	r24, 0x2C	; 44
     236:	90 e0       	ldi	r25, 0x00	; 0
     238:	92 d4       	rcall	.+2340   	; 0xb5e <_Z11digitalReadi>
     23a:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
     23e:	8e e0       	ldi	r24, 0x0E	; 14
     240:	90 e0       	ldi	r25, 0x00	; 0
     242:	09 d5       	rcall	.+2578   	; 0xc56 <_Z10analogReadi>
     244:	dc 01       	movw	r26, r24
     246:	b2 50       	subi	r27, 0x02	; 2
     248:	2e e0       	ldi	r18, 0x0E	; 14
     24a:	31 e0       	ldi	r19, 0x01	; 1
     24c:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <__usmulhisi3>
     250:	99 23       	and	r25, r25
     252:	7c f0       	brlt	.+30     	; 0x272 <_Z13mode_joystickv+0x5a>
     254:	28 e5       	ldi	r18, 0x58	; 88
     256:	30 e0       	ldi	r19, 0x00	; 0
     258:	40 e0       	ldi	r20, 0x00	; 0
     25a:	50 e0       	ldi	r21, 0x00	; 0
     25c:	0e 94 ca 0b 	call	0x1794	; 0x1794 <__divmodsi4>
     260:	20 93 05 04 	sts	0x0405, r18	; 0x800405 <steering_dv>
     264:	30 93 06 04 	sts	0x0406, r19	; 0x800406 <steering_dv+0x1>
     268:	40 93 07 04 	sts	0x0407, r20	; 0x800407 <steering_dv+0x2>
     26c:	50 93 08 04 	sts	0x0408, r21	; 0x800408 <steering_dv+0x3>
     270:	0e c0       	rjmp	.+28     	; 0x28e <_Z13mode_joystickv+0x76>
     272:	20 e5       	ldi	r18, 0x50	; 80
     274:	30 e0       	ldi	r19, 0x00	; 0
     276:	40 e0       	ldi	r20, 0x00	; 0
     278:	50 e0       	ldi	r21, 0x00	; 0
     27a:	0e 94 ca 0b 	call	0x1794	; 0x1794 <__divmodsi4>
     27e:	20 93 05 04 	sts	0x0405, r18	; 0x800405 <steering_dv>
     282:	30 93 06 04 	sts	0x0406, r19	; 0x800406 <steering_dv+0x1>
     286:	40 93 07 04 	sts	0x0407, r20	; 0x800407 <steering_dv+0x2>
     28a:	50 93 08 04 	sts	0x0408, r21	; 0x800408 <steering_dv+0x3>
     28e:	8d e0       	ldi	r24, 0x0D	; 13
     290:	90 e0       	ldi	r25, 0x00	; 0
     292:	e1 d4       	rcall	.+2498   	; 0xc56 <_Z10analogReadi>
     294:	dc 01       	movw	r26, r24
     296:	b2 50       	subi	r27, 0x02	; 2
     298:	2f ef       	ldi	r18, 0xFF	; 255
     29a:	30 e0       	ldi	r19, 0x00	; 0
     29c:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <__usmulhisi3>
     2a0:	60 93 09 04 	sts	0x0409, r22	; 0x800409 <driving_dv>
     2a4:	70 93 0a 04 	sts	0x040A, r23	; 0x80040a <driving_dv+0x1>
     2a8:	80 93 0b 04 	sts	0x040B, r24	; 0x80040b <driving_dv+0x2>
     2ac:	90 93 0c 04 	sts	0x040C, r25	; 0x80040c <driving_dv+0x3>
     2b0:	10 92 f6 03 	sts	0x03F6, r1	; 0x8003f6 <engine_dv>
     2b4:	10 92 f7 03 	sts	0x03F7, r1	; 0x8003f7 <engine_dv+0x1>
     2b8:	10 92 f8 03 	sts	0x03F8, r1	; 0x8003f8 <engine_dv+0x2>
     2bc:	10 92 f9 03 	sts	0x03F9, r1	; 0x8003f9 <engine_dv+0x3>
     2c0:	10 92 f2 03 	sts	0x03F2, r1	; 0x8003f2 <braking_dv>
     2c4:	10 92 f3 03 	sts	0x03F3, r1	; 0x8003f3 <braking_dv+0x1>
     2c8:	10 92 f4 03 	sts	0x03F4, r1	; 0x8003f4 <braking_dv+0x2>
     2cc:	10 92 f5 03 	sts	0x03F5, r1	; 0x8003f5 <braking_dv+0x3>
     2d0:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
     2d4:	22 23       	and	r18, r18
     2d6:	71 f1       	breq	.+92     	; 0x334 <_Z13mode_joystickv+0x11c>
     2d8:	16 16       	cp	r1, r22
     2da:	17 06       	cpc	r1, r23
     2dc:	18 06       	cpc	r1, r24
     2de:	19 06       	cpc	r1, r25
     2e0:	7c f4       	brge	.+30     	; 0x300 <_Z13mode_joystickv+0xe8>
     2e2:	20 e5       	ldi	r18, 0x50	; 80
     2e4:	30 e0       	ldi	r19, 0x00	; 0
     2e6:	40 e0       	ldi	r20, 0x00	; 0
     2e8:	50 e0       	ldi	r21, 0x00	; 0
     2ea:	0e 94 ca 0b 	call	0x1794	; 0x1794 <__divmodsi4>
     2ee:	20 93 f6 03 	sts	0x03F6, r18	; 0x8003f6 <engine_dv>
     2f2:	30 93 f7 03 	sts	0x03F7, r19	; 0x8003f7 <engine_dv+0x1>
     2f6:	40 93 f8 03 	sts	0x03F8, r20	; 0x8003f8 <engine_dv+0x2>
     2fa:	50 93 f9 03 	sts	0x03F9, r21	; 0x8003f9 <engine_dv+0x3>
     2fe:	47 c0       	rjmp	.+142    	; 0x38e <_Z13mode_joystickv+0x176>
     300:	20 e5       	ldi	r18, 0x50	; 80
     302:	30 e0       	ldi	r19, 0x00	; 0
     304:	40 e0       	ldi	r20, 0x00	; 0
     306:	50 e0       	ldi	r21, 0x00	; 0
     308:	0e 94 ca 0b 	call	0x1794	; 0x1794 <__divmodsi4>
     30c:	c9 01       	movw	r24, r18
     30e:	99 23       	and	r25, r25
     310:	24 f4       	brge	.+8      	; 0x31a <_Z13mode_joystickv+0x102>
     312:	88 27       	eor	r24, r24
     314:	99 27       	eor	r25, r25
     316:	82 1b       	sub	r24, r18
     318:	93 0b       	sbc	r25, r19
     31a:	09 2e       	mov	r0, r25
     31c:	00 0c       	add	r0, r0
     31e:	aa 0b       	sbc	r26, r26
     320:	bb 0b       	sbc	r27, r27
     322:	80 93 f2 03 	sts	0x03F2, r24	; 0x8003f2 <braking_dv>
     326:	90 93 f3 03 	sts	0x03F3, r25	; 0x8003f3 <braking_dv+0x1>
     32a:	a0 93 f4 03 	sts	0x03F4, r26	; 0x8003f4 <braking_dv+0x2>
     32e:	b0 93 f5 03 	sts	0x03F5, r27	; 0x8003f5 <braking_dv+0x3>
     332:	2d c0       	rjmp	.+90     	; 0x38e <_Z13mode_joystickv+0x176>
     334:	16 16       	cp	r1, r22
     336:	17 06       	cpc	r1, r23
     338:	18 06       	cpc	r1, r24
     33a:	19 06       	cpc	r1, r25
     33c:	7c f4       	brge	.+30     	; 0x35c <_Z13mode_joystickv+0x144>
     33e:	20 e5       	ldi	r18, 0x50	; 80
     340:	30 e0       	ldi	r19, 0x00	; 0
     342:	40 e0       	ldi	r20, 0x00	; 0
     344:	50 e0       	ldi	r21, 0x00	; 0
     346:	0e 94 ca 0b 	call	0x1794	; 0x1794 <__divmodsi4>
     34a:	20 93 f2 03 	sts	0x03F2, r18	; 0x8003f2 <braking_dv>
     34e:	30 93 f3 03 	sts	0x03F3, r19	; 0x8003f3 <braking_dv+0x1>
     352:	40 93 f4 03 	sts	0x03F4, r20	; 0x8003f4 <braking_dv+0x2>
     356:	50 93 f5 03 	sts	0x03F5, r21	; 0x8003f5 <braking_dv+0x3>
     35a:	19 c0       	rjmp	.+50     	; 0x38e <_Z13mode_joystickv+0x176>
     35c:	20 e5       	ldi	r18, 0x50	; 80
     35e:	30 e0       	ldi	r19, 0x00	; 0
     360:	40 e0       	ldi	r20, 0x00	; 0
     362:	50 e0       	ldi	r21, 0x00	; 0
     364:	0e 94 ca 0b 	call	0x1794	; 0x1794 <__divmodsi4>
     368:	c9 01       	movw	r24, r18
     36a:	99 23       	and	r25, r25
     36c:	24 f4       	brge	.+8      	; 0x376 <_Z13mode_joystickv+0x15e>
     36e:	88 27       	eor	r24, r24
     370:	99 27       	eor	r25, r25
     372:	82 1b       	sub	r24, r18
     374:	93 0b       	sbc	r25, r19
     376:	09 2e       	mov	r0, r25
     378:	00 0c       	add	r0, r0
     37a:	aa 0b       	sbc	r26, r26
     37c:	bb 0b       	sbc	r27, r27
     37e:	80 93 f6 03 	sts	0x03F6, r24	; 0x8003f6 <engine_dv>
     382:	90 93 f7 03 	sts	0x03F7, r25	; 0x8003f7 <engine_dv+0x1>
     386:	a0 93 f8 03 	sts	0x03F8, r26	; 0x8003f8 <engine_dv+0x2>
     38a:	b0 93 f9 03 	sts	0x03F9, r27	; 0x8003f9 <engine_dv+0x3>
     38e:	80 91 f2 03 	lds	r24, 0x03F2	; 0x8003f2 <braking_dv>
     392:	90 91 f3 03 	lds	r25, 0x03F3	; 0x8003f3 <braking_dv+0x1>
     396:	a0 91 f4 03 	lds	r26, 0x03F4	; 0x8003f4 <braking_dv+0x2>
     39a:	b0 91 f5 03 	lds	r27, 0x03F5	; 0x8003f5 <braking_dv+0x3>
     39e:	8f 3f       	cpi	r24, 0xFF	; 255
     3a0:	91 05       	cpc	r25, r1
     3a2:	a1 05       	cpc	r26, r1
     3a4:	b1 05       	cpc	r27, r1
     3a6:	29 f0       	breq	.+10     	; 0x3b2 <_Z13mode_joystickv+0x19a>
     3a8:	24 f0       	brlt	.+8      	; 0x3b2 <_Z13mode_joystickv+0x19a>
     3aa:	8f ef       	ldi	r24, 0xFF	; 255
     3ac:	90 e0       	ldi	r25, 0x00	; 0
     3ae:	a0 e0       	ldi	r26, 0x00	; 0
     3b0:	b0 e0       	ldi	r27, 0x00	; 0
     3b2:	bb 23       	and	r27, r27
     3b4:	1c f4       	brge	.+6      	; 0x3bc <_Z13mode_joystickv+0x1a4>
     3b6:	80 e0       	ldi	r24, 0x00	; 0
     3b8:	90 e0       	ldi	r25, 0x00	; 0
     3ba:	dc 01       	movw	r26, r24
     3bc:	80 93 f2 03 	sts	0x03F2, r24	; 0x8003f2 <braking_dv>
     3c0:	90 93 f3 03 	sts	0x03F3, r25	; 0x8003f3 <braking_dv+0x1>
     3c4:	a0 93 f4 03 	sts	0x03F4, r26	; 0x8003f4 <braking_dv+0x2>
     3c8:	b0 93 f5 03 	sts	0x03F5, r27	; 0x8003f5 <braking_dv+0x3>
     3cc:	08 95       	ret

000003ce <_Z9mode_idlev>:
     3ce:	10 92 f6 03 	sts	0x03F6, r1	; 0x8003f6 <engine_dv>
     3d2:	10 92 f7 03 	sts	0x03F7, r1	; 0x8003f7 <engine_dv+0x1>
     3d6:	10 92 f8 03 	sts	0x03F8, r1	; 0x8003f8 <engine_dv+0x2>
     3da:	10 92 f9 03 	sts	0x03F9, r1	; 0x8003f9 <engine_dv+0x3>
     3de:	10 92 05 04 	sts	0x0405, r1	; 0x800405 <steering_dv>
     3e2:	10 92 06 04 	sts	0x0406, r1	; 0x800406 <steering_dv+0x1>
     3e6:	10 92 07 04 	sts	0x0407, r1	; 0x800407 <steering_dv+0x2>
     3ea:	10 92 08 04 	sts	0x0408, r1	; 0x800408 <steering_dv+0x3>
     3ee:	84 e6       	ldi	r24, 0x64	; 100
     3f0:	90 e0       	ldi	r25, 0x00	; 0
     3f2:	a0 e0       	ldi	r26, 0x00	; 0
     3f4:	b0 e0       	ldi	r27, 0x00	; 0
     3f6:	80 93 f2 03 	sts	0x03F2, r24	; 0x8003f2 <braking_dv>
     3fa:	90 93 f3 03 	sts	0x03F3, r25	; 0x8003f3 <braking_dv+0x1>
     3fe:	a0 93 f4 03 	sts	0x03F4, r26	; 0x8003f4 <braking_dv+0x2>
     402:	b0 93 f5 03 	sts	0x03F5, r27	; 0x8003f5 <braking_dv+0x3>
     406:	80 91 ee 03 	lds	r24, 0x03EE	; 0x8003ee <engine_rpm>
     40a:	90 91 ef 03 	lds	r25, 0x03EF	; 0x8003ef <engine_rpm+0x1>
     40e:	89 2b       	or	r24, r25
     410:	61 f4       	brne	.+24     	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
     412:	60 e0       	ldi	r22, 0x00	; 0
     414:	80 e2       	ldi	r24, 0x20	; 32
     416:	90 e0       	ldi	r25, 0x00	; 0
     418:	d3 d2       	rcall	.+1446   	; 0x9c0 <_Z12digitalWriteib>
     41a:	10 92 f2 03 	sts	0x03F2, r1	; 0x8003f2 <braking_dv>
     41e:	10 92 f3 03 	sts	0x03F3, r1	; 0x8003f3 <braking_dv+0x1>
     422:	10 92 f4 03 	sts	0x03F4, r1	; 0x8003f4 <braking_dv+0x2>
     426:	10 92 f5 03 	sts	0x03F5, r1	; 0x8003f5 <braking_dv+0x3>
     42a:	08 95       	ret

0000042c <_Z9run_brakev>:
	//digitalWrite(do_hv_relay,HIGH);
	//not (yet) implemented
}

void run_brake(){
	braking_dv = (braking_dv<brake_min ? brake_min : braking_dv);		//if smaller than the minium value to upkeep base pressure, increase to base pressure
     42c:	60 91 f2 03 	lds	r22, 0x03F2	; 0x8003f2 <braking_dv>
     430:	70 91 f3 03 	lds	r23, 0x03F3	; 0x8003f3 <braking_dv+0x1>
     434:	80 91 f4 03 	lds	r24, 0x03F4	; 0x8003f4 <braking_dv+0x2>
     438:	90 91 f5 03 	lds	r25, 0x03F5	; 0x8003f5 <braking_dv+0x3>
     43c:	99 23       	and	r25, r25
     43e:	1c f4       	brge	.+6      	; 0x446 <_Z9run_brakev+0x1a>
     440:	60 e0       	ldi	r22, 0x00	; 0
     442:	70 e0       	ldi	r23, 0x00	; 0
     444:	cb 01       	movw	r24, r22
     446:	60 93 f2 03 	sts	0x03F2, r22	; 0x8003f2 <braking_dv>
     44a:	70 93 f3 03 	sts	0x03F3, r23	; 0x8003f3 <braking_dv+0x1>
     44e:	80 93 f4 03 	sts	0x03F4, r24	; 0x8003f4 <braking_dv+0x2>
     452:	90 93 f5 03 	sts	0x03F5, r25	; 0x8003f5 <braking_dv+0x3>
	analogWrite(pwm_brake_pump, braking_dv);															//Write op to brake pump
     456:	86 e0       	ldi	r24, 0x06	; 6
     458:	90 e0       	ldi	r25, 0x00	; 0
     45a:	67 c2       	rjmp	.+1230   	; 0x92a <_Z11analogWriteii>
     45c:	08 95       	ret

0000045e <_Z9run_steerv>:
}

void run_steer(){
     45e:	8f 92       	push	r8
     460:	9f 92       	push	r9
     462:	af 92       	push	r10
     464:	bf 92       	push	r11
     466:	cf 92       	push	r12
     468:	df 92       	push	r13
     46a:	ef 92       	push	r14
     46c:	ff 92       	push	r15
     46e:	0f 93       	push	r16
     470:	1f 93       	push	r17
     472:	cf 93       	push	r28
     474:	df 93       	push	r29
	steering_cv = (analogRead(ai_steer_pot)-steering_sensor_offset);							//get the offset from the default position by subtracting the offset from the retrieved value
     476:	8f e0       	ldi	r24, 0x0F	; 15
     478:	90 e0       	ldi	r25, 0x00	; 0
     47a:	ed d3       	rcall	.+2010   	; 0xc56 <_Z10analogReadi>
	steering_cv = -steering_cv;																	//because the potentiometer gives it value the other way(left = max, right is minimum), invert this.
	steering_cv *= steering_max_deg;															//convert to degrees
	steering_cv /= steering_sensor_maximum;														//divide by the maximum to get the ratio between 0-1
     47c:	ac 01       	movw	r20, r24
     47e:	43 51       	subi	r20, 0x13	; 19
     480:	52 40       	sbci	r21, 0x02	; 2
     482:	95 2f       	mov	r25, r21
     484:	99 0f       	add	r25, r25
     486:	99 0b       	sbc	r25, r25
     488:	24 2f       	mov	r18, r20
     48a:	35 2f       	mov	r19, r21
     48c:	49 2f       	mov	r20, r25
     48e:	59 2f       	mov	r21, r25
     490:	69 2f       	mov	r22, r25
     492:	79 2f       	mov	r23, r25
     494:	89 2f       	mov	r24, r25
     496:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <__negdi2>
     49a:	01 e0       	ldi	r16, 0x01	; 1
     49c:	0e 94 c4 0c 	call	0x1988	; 0x1988 <__ashldi3>
     4a0:	82 2e       	mov	r8, r18
     4a2:	93 2e       	mov	r9, r19
     4a4:	d4 2f       	mov	r29, r20
     4a6:	c5 2f       	mov	r28, r21
     4a8:	b6 2f       	mov	r27, r22
     4aa:	a7 2f       	mov	r26, r23
     4ac:	f8 2f       	mov	r31, r24
     4ae:	e9 2f       	mov	r30, r25
     4b0:	03 e0       	ldi	r16, 0x03	; 3
     4b2:	0e 94 c4 0c 	call	0x1988	; 0x1988 <__ashldi3>
     4b6:	a2 2e       	mov	r10, r18
     4b8:	b3 2e       	mov	r11, r19
     4ba:	c4 2e       	mov	r12, r20
     4bc:	d5 2e       	mov	r13, r21
     4be:	e6 2e       	mov	r14, r22
     4c0:	f7 2e       	mov	r15, r23
     4c2:	08 2f       	mov	r16, r24
     4c4:	19 2f       	mov	r17, r25
     4c6:	28 2d       	mov	r18, r8
     4c8:	39 2d       	mov	r19, r9
     4ca:	4d 2f       	mov	r20, r29
     4cc:	5c 2f       	mov	r21, r28
     4ce:	6b 2f       	mov	r22, r27
     4d0:	7a 2f       	mov	r23, r26
     4d2:	8f 2f       	mov	r24, r31
     4d4:	9e 2f       	mov	r25, r30
     4d6:	0e 94 dd 0c 	call	0x19ba	; 0x19ba <__adddi3>
     4da:	a2 2e       	mov	r10, r18
     4dc:	b3 2e       	mov	r11, r19
     4de:	c4 2e       	mov	r12, r20
     4e0:	d5 2e       	mov	r13, r21
     4e2:	e6 2e       	mov	r14, r22
     4e4:	f7 2e       	mov	r15, r23
     4e6:	e8 2f       	mov	r30, r24
     4e8:	19 2f       	mov	r17, r25
     4ea:	04 e0       	ldi	r16, 0x04	; 4
     4ec:	0e 94 c4 0c 	call	0x1988	; 0x1988 <__ashldi3>
     4f0:	0e 2f       	mov	r16, r30
     4f2:	0e 94 e6 0c 	call	0x19cc	; 0x19cc <__subdi3>
     4f6:	0f 2e       	mov	r0, r31
     4f8:	fe e5       	ldi	r31, 0x5E	; 94
     4fa:	af 2e       	mov	r10, r31
     4fc:	f0 2d       	mov	r31, r0
     4fe:	bb 24       	eor	r11, r11
     500:	b3 94       	inc	r11
     502:	c1 2c       	mov	r12, r1
     504:	d1 2c       	mov	r13, r1
     506:	e1 2c       	mov	r14, r1
     508:	f1 2c       	mov	r15, r1
     50a:	00 e0       	ldi	r16, 0x00	; 0
     50c:	10 e0       	ldi	r17, 0x00	; 0
     50e:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <__divdi3>
     512:	d2 2f       	mov	r29, r18
     514:	c3 2f       	mov	r28, r19
     516:	b4 2f       	mov	r27, r20
     518:	a5 2f       	mov	r26, r21
     51a:	f6 2f       	mov	r31, r22
     51c:	e7 2f       	mov	r30, r23
     51e:	02 2f       	mov	r16, r18
     520:	13 2f       	mov	r17, r19
     522:	d0 93 fb 03 	sts	0x03FB, r29	; 0x8003fb <steering_cv>
     526:	c0 93 fc 03 	sts	0x03FC, r28	; 0x8003fc <steering_cv+0x1>
     52a:	b0 93 fd 03 	sts	0x03FD, r27	; 0x8003fd <steering_cv+0x2>
     52e:	a0 93 fe 03 	sts	0x03FE, r26	; 0x8003fe <steering_cv+0x3>
     532:	f0 93 ff 03 	sts	0x03FF, r31	; 0x8003ff <steering_cv+0x4>
     536:	e0 93 00 04 	sts	0x0400, r30	; 0x800400 <steering_cv+0x5>
     53a:	80 93 01 04 	sts	0x0401, r24	; 0x800401 <steering_cv+0x6>
     53e:	90 93 02 04 	sts	0x0402, r25	; 0x800402 <steering_cv+0x7>
	
	if(abs(steering_dv)<steering_deadzone)														//create a dead zone around default joystick position, desired value must at least be bigger then dead zone value (makes going straight easier
     542:	80 91 05 04 	lds	r24, 0x0405	; 0x800405 <steering_dv>
     546:	90 91 06 04 	lds	r25, 0x0406	; 0x800406 <steering_dv+0x1>
     54a:	43 96       	adiw	r24, 0x13	; 19
     54c:	87 97       	sbiw	r24, 0x27	; 39
     54e:	90 f4       	brcc	.+36     	; 0x574 <_Z9run_steerv+0x116>
		steering_dv = 0;
     550:	10 92 05 04 	sts	0x0405, r1	; 0x800405 <steering_dv>
     554:	10 92 06 04 	sts	0x0406, r1	; 0x800406 <steering_dv+0x1>
     558:	10 92 07 04 	sts	0x0407, r1	; 0x800407 <steering_dv+0x2>
     55c:	10 92 08 04 	sts	0x0408, r1	; 0x800408 <steering_dv+0x3>
	steering_delta = steering_dv - steering_cv;													//difference between desired value and current value
     560:	80 e0       	ldi	r24, 0x00	; 0
     562:	90 e0       	ldi	r25, 0x00	; 0
     564:	9c 01       	movw	r18, r24
     566:	20 1b       	sub	r18, r16
     568:	31 0b       	sbc	r19, r17
     56a:	30 93 04 04 	sts	0x0404, r19	; 0x800404 <steering_delta+0x1>
     56e:	20 93 03 04 	sts	0x0403, r18	; 0x800403 <steering_delta>
     572:	1f c0       	rjmp	.+62     	; 0x5b2 <_Z9run_steerv+0x154>
     574:	c0 90 05 04 	lds	r12, 0x0405	; 0x800405 <steering_dv>
     578:	d0 90 06 04 	lds	r13, 0x0406	; 0x800406 <steering_dv+0x1>
     57c:	e0 90 07 04 	lds	r14, 0x0407	; 0x800407 <steering_dv+0x2>
     580:	f0 90 08 04 	lds	r15, 0x0408	; 0x800408 <steering_dv+0x3>
     584:	c6 01       	movw	r24, r12
     586:	80 1b       	sub	r24, r16
     588:	91 0b       	sbc	r25, r17
     58a:	9c 01       	movw	r18, r24
     58c:	90 93 04 04 	sts	0x0404, r25	; 0x800404 <steering_delta+0x1>
     590:	80 93 03 04 	sts	0x0403, r24	; 0x800403 <steering_delta>
	if((abs(steering_delta)<10) && (steering_dv!= 0))											//if the two are too close together except the default position, don't steer, this to prevent the motor from constantly trying to make small correcting movements which it is not capable of, so it starts screeching
     594:	09 96       	adiw	r24, 0x09	; 9
     596:	43 97       	sbiw	r24, 0x13	; 19
     598:	60 f4       	brcc	.+24     	; 0x5b2 <_Z9run_steerv+0x154>
     59a:	cd 28       	or	r12, r13
     59c:	ce 28       	or	r12, r14
     59e:	cf 28       	or	r12, r15
     5a0:	41 f0       	breq	.+16     	; 0x5b2 <_Z9run_steerv+0x154>
		steering_delta=0;
     5a2:	10 92 04 04 	sts	0x0404, r1	; 0x800404 <steering_delta+0x1>
     5a6:	10 92 03 04 	sts	0x0403, r1	; 0x800403 <steering_delta>
	steering_ov = constrain((abs(steering_delta) * steering_kp), 0, 255);						//determine the output PMW value in such a way that the smaller the delta, the slower it goes to smooth out steering
     5aa:	20 e0       	ldi	r18, 0x00	; 0
     5ac:	30 e0       	ldi	r19, 0x00	; 0
     5ae:	90 e0       	ldi	r25, 0x00	; 0
     5b0:	1b c0       	rjmp	.+54     	; 0x5e8 <_Z9run_steerv+0x18a>
     5b2:	a9 01       	movw	r20, r18
     5b4:	33 23       	and	r19, r19
     5b6:	24 f4       	brge	.+8      	; 0x5c0 <_Z9run_steerv+0x162>
     5b8:	44 27       	eor	r20, r20
     5ba:	55 27       	eor	r21, r21
     5bc:	42 1b       	sub	r20, r18
     5be:	53 0b       	sbc	r21, r19
     5c0:	ca 01       	movw	r24, r20
     5c2:	88 0f       	add	r24, r24
     5c4:	99 1f       	adc	r25, r25
     5c6:	88 0f       	add	r24, r24
     5c8:	99 1f       	adc	r25, r25
     5ca:	88 0f       	add	r24, r24
     5cc:	99 1f       	adc	r25, r25
     5ce:	84 1b       	sub	r24, r20
     5d0:	95 0b       	sbc	r25, r21
     5d2:	c2 f1       	brmi	.+112    	; 0x644 <_Z9run_steerv+0x1e6>
     5d4:	8f 3f       	cpi	r24, 0xFF	; 255
     5d6:	91 05       	cpc	r25, r1
     5d8:	19 f0       	breq	.+6      	; 0x5e0 <_Z9run_steerv+0x182>
     5da:	14 f0       	brlt	.+4      	; 0x5e0 <_Z9run_steerv+0x182>
     5dc:	8f ef       	ldi	r24, 0xFF	; 255
     5de:	90 e0       	ldi	r25, 0x00	; 0
     5e0:	98 2f       	mov	r25, r24
	if(steering_ov<steering_engine_minimum&&steering_ov!=0)
     5e2:	81 50       	subi	r24, 0x01	; 1
     5e4:	85 39       	cpi	r24, 0x95	; 149
     5e6:	18 f0       	brcs	.+6      	; 0x5ee <_Z9run_steerv+0x190>
	if(abs(steering_dv)<steering_deadzone)														//create a dead zone around default joystick position, desired value must at least be bigger then dead zone value (makes going straight easier
		steering_dv = 0;
	steering_delta = steering_dv - steering_cv;													//difference between desired value and current value
	if((abs(steering_delta)<10) && (steering_dv!= 0))											//if the two are too close together except the default position, don't steer, this to prevent the motor from constantly trying to make small correcting movements which it is not capable of, so it starts screeching
		steering_delta=0;
	steering_ov = constrain((abs(steering_delta) * steering_kp), 0, 255);						//determine the output PMW value in such a way that the smaller the delta, the slower it goes to smooth out steering
     5e8:	90 93 fa 03 	sts	0x03FA, r25	; 0x8003fa <steering_ov>
     5ec:	03 c0       	rjmp	.+6      	; 0x5f4 <_Z9run_steerv+0x196>
	if(steering_ov<steering_engine_minimum&&steering_ov!=0)
		steering_ov=steering_engine_minimum;
     5ee:	86 e9       	ldi	r24, 0x96	; 150
     5f0:	80 93 fa 03 	sts	0x03FA, r24	; 0x8003fa <steering_ov>
		
	if (steering_delta > 0) {																	//H bridge settings, let the engine turn the correct way
     5f4:	12 16       	cp	r1, r18
     5f6:	13 06       	cpc	r1, r19
     5f8:	64 f4       	brge	.+24     	; 0x612 <_Z9run_steerv+0x1b4>
		analogWrite(pwm_steer_rpwm, steering_ov);												//if the delta is smaller than 0, turn to the right by changing the polarity of the H-bridge
     5fa:	60 91 fa 03 	lds	r22, 0x03FA	; 0x8003fa <steering_ov>
     5fe:	70 e0       	ldi	r23, 0x00	; 0
     600:	87 e0       	ldi	r24, 0x07	; 7
     602:	90 e0       	ldi	r25, 0x00	; 0
     604:	92 d1       	rcall	.+804    	; 0x92a <_Z11analogWriteii>
		analogWrite(pwm_steer_lpwm, 0);															//
     606:	60 e0       	ldi	r22, 0x00	; 0
     608:	70 e0       	ldi	r23, 0x00	; 0
     60a:	88 e0       	ldi	r24, 0x08	; 8
     60c:	90 e0       	ldi	r25, 0x00	; 0
     60e:	8d d1       	rcall	.+794    	; 0x92a <_Z11analogWriteii>
     610:	1c c0       	rjmp	.+56     	; 0x64a <_Z9run_steerv+0x1ec>
	}
	else if (steering_delta < 0) {
     612:	33 23       	and	r19, r19
     614:	64 f4       	brge	.+24     	; 0x62e <_Z9run_steerv+0x1d0>
		analogWrite(pwm_steer_rpwm, 0);															//if the delta is larger than 0
     616:	60 e0       	ldi	r22, 0x00	; 0
     618:	70 e0       	ldi	r23, 0x00	; 0
     61a:	87 e0       	ldi	r24, 0x07	; 7
     61c:	90 e0       	ldi	r25, 0x00	; 0
     61e:	85 d1       	rcall	.+778    	; 0x92a <_Z11analogWriteii>
		analogWrite(pwm_steer_lpwm, steering_ov);
     620:	60 91 fa 03 	lds	r22, 0x03FA	; 0x8003fa <steering_ov>
     624:	70 e0       	ldi	r23, 0x00	; 0
     626:	88 e0       	ldi	r24, 0x08	; 8
     628:	90 e0       	ldi	r25, 0x00	; 0
     62a:	7f d1       	rcall	.+766    	; 0x92a <_Z11analogWriteii>
     62c:	0e c0       	rjmp	.+28     	; 0x64a <_Z9run_steerv+0x1ec>

	}
	else {
		analogWrite(pwm_steer_rpwm, 0);															//if neither, do nothing
     62e:	60 e0       	ldi	r22, 0x00	; 0
     630:	70 e0       	ldi	r23, 0x00	; 0
     632:	87 e0       	ldi	r24, 0x07	; 7
     634:	90 e0       	ldi	r25, 0x00	; 0
     636:	79 d1       	rcall	.+754    	; 0x92a <_Z11analogWriteii>
		analogWrite(pwm_steer_lpwm, 0);
     638:	60 e0       	ldi	r22, 0x00	; 0
     63a:	70 e0       	ldi	r23, 0x00	; 0
     63c:	88 e0       	ldi	r24, 0x08	; 8
     63e:	90 e0       	ldi	r25, 0x00	; 0
     640:	74 d1       	rcall	.+744    	; 0x92a <_Z11analogWriteii>
     642:	03 c0       	rjmp	.+6      	; 0x64a <_Z9run_steerv+0x1ec>
	}	
}
     644:	10 92 fa 03 	sts	0x03FA, r1	; 0x8003fa <steering_ov>
	if(abs(steering_dv)<steering_deadzone)														//create a dead zone around default joystick position, desired value must at least be bigger then dead zone value (makes going straight easier
		steering_dv = 0;
	steering_delta = steering_dv - steering_cv;													//difference between desired value and current value
	if((abs(steering_delta)<10) && (steering_dv!= 0))											//if the two are too close together except the default position, don't steer, this to prevent the motor from constantly trying to make small correcting movements which it is not capable of, so it starts screeching
		steering_delta=0;
	steering_ov = constrain((abs(steering_delta) * steering_kp), 0, 255);						//determine the output PMW value in such a way that the smaller the delta, the slower it goes to smooth out steering
     648:	d5 cf       	rjmp	.-86     	; 0x5f4 <_Z9run_steerv+0x196>
     64a:	df 91       	pop	r29
	}
	else {
		analogWrite(pwm_steer_rpwm, 0);															//if neither, do nothing
		analogWrite(pwm_steer_lpwm, 0);
	}	
}
     64c:	cf 91       	pop	r28
     64e:	1f 91       	pop	r17
     650:	0f 91       	pop	r16
     652:	ff 90       	pop	r15
     654:	ef 90       	pop	r14
     656:	df 90       	pop	r13
     658:	cf 90       	pop	r12
     65a:	bf 90       	pop	r11
     65c:	af 90       	pop	r10
     65e:	9f 90       	pop	r9
     660:	8f 90       	pop	r8
     662:	08 95       	ret

00000664 <_Z10run_curtisv>:
     664:	60 91 00 02 	lds	r22, 0x0200	; 0x800200 <__data_start>

void run_curtis(){
	digitalWrite(do_engine_forward, driving_direction);											//give the Curtis the correct driving direction
     668:	8e e1       	ldi	r24, 0x1E	; 30
     66a:	90 e0       	ldi	r25, 0x00	; 0
     66c:	a9 d1       	rcall	.+850    	; 0x9c0 <_Z12digitalWriteib>
	digitalWrite(do_engine_reverse, !driving_direction);
     66e:	60 91 00 02 	lds	r22, 0x0200	; 0x800200 <__data_start>
     672:	81 e0       	ldi	r24, 0x01	; 1
     674:	68 27       	eor	r22, r24
     676:	8f e1       	ldi	r24, 0x1F	; 31
     678:	90 e0       	ldi	r25, 0x00	; 0
     67a:	a2 d1       	rcall	.+836    	; 0x9c0 <_Z12digitalWriteib>
	
	if(abs(engine_dv)<driving_deadzone)														//create a dead zone around the standing still position, desired value must at least be bigger then dead zone value (makes standing still easier)
     67c:	80 91 f6 03 	lds	r24, 0x03F6	; 0x8003f6 <engine_dv>
     680:	90 91 f7 03 	lds	r25, 0x03F7	; 0x8003f7 <engine_dv+0x1>
     684:	43 96       	adiw	r24, 0x13	; 19
     686:	87 97       	sbiw	r24, 0x27	; 39
     688:	40 f4       	brcc	.+16     	; 0x69a <_Z10run_curtisv+0x36>
		engine_dv = 0;
     68a:	10 92 f6 03 	sts	0x03F6, r1	; 0x8003f6 <engine_dv>
     68e:	10 92 f7 03 	sts	0x03F7, r1	; 0x8003f7 <engine_dv+0x1>
     692:	10 92 f8 03 	sts	0x03F8, r1	; 0x8003f8 <engine_dv+0x2>
     696:	10 92 f9 03 	sts	0x03F9, r1	; 0x8003f9 <engine_dv+0x3>
     69a:	80 91 f6 03 	lds	r24, 0x03F6	; 0x8003f6 <engine_dv>
     69e:	90 91 f7 03 	lds	r25, 0x03F7	; 0x8003f7 <engine_dv+0x1>
     6a2:	a0 91 f8 03 	lds	r26, 0x03F8	; 0x8003f8 <engine_dv+0x2>
     6a6:	b0 91 f9 03 	lds	r27, 0x03F9	; 0x8003f9 <engine_dv+0x3>
     6aa:	8f 3f       	cpi	r24, 0xFF	; 255
     6ac:	91 05       	cpc	r25, r1
     6ae:	a1 05       	cpc	r26, r1
     6b0:	b1 05       	cpc	r27, r1
     6b2:	29 f0       	breq	.+10     	; 0x6be <_Z10run_curtisv+0x5a>
     6b4:	24 f0       	brlt	.+8      	; 0x6be <_Z10run_curtisv+0x5a>
     6b6:	8f ef       	ldi	r24, 0xFF	; 255
     6b8:	90 e0       	ldi	r25, 0x00	; 0
     6ba:	a0 e0       	ldi	r26, 0x00	; 0
     6bc:	b0 e0       	ldi	r27, 0x00	; 0
     6be:	bb 23       	and	r27, r27
     6c0:	1c f4       	brge	.+6      	; 0x6c8 <_Z10run_curtisv+0x64>
     6c2:	80 e0       	ldi	r24, 0x00	; 0
     6c4:	90 e0       	ldi	r25, 0x00	; 0
     6c6:	dc 01       	movw	r26, r24
		engine_dv = constrain(engine_dv, 0, drive_max_PWM);	//constrain the value, preventing an integer overflow if a too high of a value was supplied
     6c8:	80 93 f6 03 	sts	0x03F6, r24	; 0x8003f6 <engine_dv>
     6cc:	90 93 f7 03 	sts	0x03F7, r25	; 0x8003f7 <engine_dv+0x1>
     6d0:	a0 93 f8 03 	sts	0x03F8, r26	; 0x8003f8 <engine_dv+0x2>
     6d4:	b0 93 f9 03 	sts	0x03F9, r27	; 0x8003f9 <engine_dv+0x3>

			
	//Set the Curtis in the right mode for braking, driving or neutral																		//if we want to brake
		digitalWrite(do_engine_throttleswitch, engine_dv);				//if there is an engine signal, enable listening to the throttle
     6d8:	61 e0       	ldi	r22, 0x01	; 1
     6da:	89 2b       	or	r24, r25
     6dc:	8a 2b       	or	r24, r26
     6de:	8b 2b       	or	r24, r27
     6e0:	09 f4       	brne	.+2      	; 0x6e4 <_Z10run_curtisv+0x80>
     6e2:	60 e0       	ldi	r22, 0x00	; 0
     6e4:	8d e1       	ldi	r24, 0x1D	; 29
     6e6:	90 e0       	ldi	r25, 0x00	; 0
     6e8:	6b d1       	rcall	.+726    	; 0x9c0 <_Z12digitalWriteib>
		digitalWrite(do_engine_brake, braking_dv);						//if there is an braking signal, turn on the braking 
     6ea:	61 e0       	ldi	r22, 0x01	; 1
     6ec:	80 91 f2 03 	lds	r24, 0x03F2	; 0x8003f2 <braking_dv>
     6f0:	90 91 f3 03 	lds	r25, 0x03F3	; 0x8003f3 <braking_dv+0x1>
     6f4:	a0 91 f4 03 	lds	r26, 0x03F4	; 0x8003f4 <braking_dv+0x2>
     6f8:	b0 91 f5 03 	lds	r27, 0x03F5	; 0x8003f5 <braking_dv+0x3>
     6fc:	89 2b       	or	r24, r25
     6fe:	8a 2b       	or	r24, r26
     700:	8b 2b       	or	r24, r27
     702:	09 f4       	brne	.+2      	; 0x706 <_Z10run_curtisv+0xa2>
     704:	60 e0       	ldi	r22, 0x00	; 0
     706:	8c e1       	ldi	r24, 0x1C	; 28
     708:	90 e0       	ldi	r25, 0x00	; 0
     70a:	5a d1       	rcall	.+692    	; 0x9c0 <_Z12digitalWriteib>

	analogWrite(pwm_drive_throttle, engine_dv);								//Write op to throttle signal of Curtis
     70c:	60 91 f6 03 	lds	r22, 0x03F6	; 0x8003f6 <engine_dv>
     710:	70 91 f7 03 	lds	r23, 0x03F7	; 0x8003f7 <engine_dv+0x1>
     714:	84 e0       	ldi	r24, 0x04	; 4
     716:	90 e0       	ldi	r25, 0x00	; 0
     718:	08 c1       	rjmp	.+528    	; 0x92a <_Z11analogWriteii>
     71a:	08 95       	ret

0000071c <_Z5drivev>:
	}
}

void drive(){
	//get correct driving input parameters from selected source (remote and auto not implemented, thus being interpreted as idle)
	mode_select();
     71c:	42 dd       	rcall	.-1404   	; 0x1a2 <_Z11mode_selectv>
	switch(drivemode){
     71e:	80 91 0d 04 	lds	r24, 0x040D	; 0x80040d <drivemode>
     722:	90 91 0e 04 	lds	r25, 0x040E	; 0x80040e <drivemode+0x1>
     726:	81 30       	cpi	r24, 0x01	; 1
     728:	91 05       	cpc	r25, r1
     72a:	51 f0       	breq	.+20     	; 0x740 <_Z5drivev+0x24>
     72c:	1c f4       	brge	.+6      	; 0x734 <_Z5drivev+0x18>
     72e:	89 2b       	or	r24, r25
     730:	49 f0       	breq	.+18     	; 0x744 <_Z5drivev+0x28>
     732:	0d c0       	rjmp	.+26     	; 0x74e <_Z5drivev+0x32>
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	91 05       	cpc	r25, r1
     738:	49 f0       	breq	.+18     	; 0x74c <_Z5drivev+0x30>
     73a:	03 97       	sbiw	r24, 0x03	; 3
     73c:	29 f0       	breq	.+10     	; 0x748 <_Z5drivev+0x2c>
		case drivemode_joystick:
			mode_joystick();
     73e:	07 c0       	rjmp	.+14     	; 0x74e <_Z5drivev+0x32>
			break;
     740:	6b dd       	rcall	.-1322   	; 0x218 <_Z13mode_joystickv>
		case drivemode_idle:
			mode_idle();		
     742:	05 c0       	rjmp	.+10     	; 0x74e <_Z5drivev+0x32>
			break;
		case drivemode_auto:
			mode_idle();		//not yet implemented
     744:	44 de       	rcall	.-888    	; 0x3ce <_Z9mode_idlev>
     746:	03 c0       	rjmp	.+6      	; 0x74e <_Z5drivev+0x32>
			break;
     748:	42 de       	rcall	.-892    	; 0x3ce <_Z9mode_idlev>
		case drivemode_remote:
			mode_idle();		//not yet implemented
     74a:	01 c0       	rjmp	.+2      	; 0x74e <_Z5drivev+0x32>
     74c:	40 de       	rcall	.-896    	; 0x3ce <_Z9mode_idlev>
			break;	
	}
	//prevent values past the maximum values being send, just a safety precaution
	if(steering_dv>steering_max_deg)		//if the value exeeds the set maximum value
     74e:	80 91 05 04 	lds	r24, 0x0405	; 0x800405 <steering_dv>
     752:	90 91 06 04 	lds	r25, 0x0406	; 0x800406 <steering_dv+0x1>
     756:	a0 91 07 04 	lds	r26, 0x0407	; 0x800407 <steering_dv+0x2>
     75a:	b0 91 08 04 	lds	r27, 0x0408	; 0x800408 <steering_dv+0x3>
     75e:	8f 30       	cpi	r24, 0x0F	; 15
     760:	21 e0       	ldi	r18, 0x01	; 1
     762:	92 07       	cpc	r25, r18
     764:	a1 05       	cpc	r26, r1
     766:	b1 05       	cpc	r27, r1
     768:	6c f0       	brlt	.+26     	; 0x784 <_Z5drivev+0x68>
		steering_dv=steering_max_deg;		//make it it maximum allowed value
     76a:	8e e0       	ldi	r24, 0x0E	; 14
     76c:	91 e0       	ldi	r25, 0x01	; 1
     76e:	a0 e0       	ldi	r26, 0x00	; 0
     770:	b0 e0       	ldi	r27, 0x00	; 0
     772:	80 93 05 04 	sts	0x0405, r24	; 0x800405 <steering_dv>
     776:	90 93 06 04 	sts	0x0406, r25	; 0x800406 <steering_dv+0x1>
     77a:	a0 93 07 04 	sts	0x0407, r26	; 0x800407 <steering_dv+0x2>
     77e:	b0 93 08 04 	sts	0x0408, r27	; 0x800408 <steering_dv+0x3>
     782:	11 c0       	rjmp	.+34     	; 0x7a6 <_Z5drivev+0x8a>
	if(steering_dv<-steering_max_deg)
     784:	82 3f       	cpi	r24, 0xF2	; 242
     786:	9e 4f       	sbci	r25, 0xFE	; 254
     788:	af 4f       	sbci	r26, 0xFF	; 255
     78a:	bf 4f       	sbci	r27, 0xFF	; 255
     78c:	64 f4       	brge	.+24     	; 0x7a6 <_Z5drivev+0x8a>
		steering_dv=-steering_max_deg;
     78e:	82 ef       	ldi	r24, 0xF2	; 242
     790:	9e ef       	ldi	r25, 0xFE	; 254
     792:	af ef       	ldi	r26, 0xFF	; 255
     794:	bf ef       	ldi	r27, 0xFF	; 255
     796:	80 93 05 04 	sts	0x0405, r24	; 0x800405 <steering_dv>
     79a:	90 93 06 04 	sts	0x0406, r25	; 0x800406 <steering_dv+0x1>
     79e:	a0 93 07 04 	sts	0x0407, r26	; 0x800407 <steering_dv+0x2>
	
	run_steer();				//update the steering system
     7a2:	b0 93 08 04 	sts	0x0408, r27	; 0x800408 <steering_dv+0x3>
	run_brake();				//update the braking system
     7a6:	5b de       	rcall	.-842    	; 0x45e <_Z9run_steerv>
	run_curtis();				//update the Curtis
     7a8:	41 de       	rcall	.-894    	; 0x42c <_Z9run_brakev>
     7aa:	5c cf       	rjmp	.-328    	; 0x664 <_Z10run_curtisv>
     7ac:	08 95       	ret

000007ae <_Z6initIOv>:
#include "IOPins.h"

//this function should be called when initializing the program. It writes the correct settings to the registry, allowing the use of analog and digital reading and writing of pins.
void initIO(){
     7ae:	cf 93       	push	r28
     7b0:	df 93       	push	r29
	/*Parts of these pins are used for different functions, don't just attach them to the pins:
	Timer1: 
	
	*/
	Serial.println("Applying IO settings...");
     7b2:	61 e0       	ldi	r22, 0x01	; 1
     7b4:	72 e0       	ldi	r23, 0x02	; 2
     7b6:	8e e2       	ldi	r24, 0x2E	; 46
     7b8:	94 e0       	ldi	r25, 0x04	; 4
     7ba:	b3 d7       	rcall	.+3942   	; 0x1722 <_ZN5USART7printlnEPKc>
	//////////////////////////////////////
	//Designate output pins: Disable the pull up resistor in these pins and making them output by writing a 1 to their respective registry entries. Pins not written to default to input pins.
	//when adding/altering pins, alter them in their respective switch case as well.
	//digitalwrite
	//		  76543210
	DDRA |= 0b11110111;				//pin 22-29
     7bc:	81 b1       	in	r24, 0x01	; 1
     7be:	87 6f       	ori	r24, 0xF7	; 247
     7c0:	81 b9       	out	0x01, r24	; 1
	DDRB |= 0b00000000;				//PB0-3 are reserved for SPI, don't use those
     7c2:	84 b1       	in	r24, 0x04	; 4
     7c4:	84 b9       	out	0x04, r24	; 4
	DDRC |= 0b10011000;				
     7c6:	87 b1       	in	r24, 0x07	; 7
     7c8:	88 69       	ori	r24, 0x98	; 152
     7ca:	87 b9       	out	0x07, r24	; 7
	DDRD |= 0b00000000;
     7cc:	8a b1       	in	r24, 0x0a	; 10
     7ce:	8a b9       	out	0x0a, r24	; 10
	DDRE |= 0b00110000;
     7d0:	8d b1       	in	r24, 0x0d	; 13
     7d2:	80 63       	ori	r24, 0x30	; 48
     7d4:	8d b9       	out	0x0d, r24	; 13
	DDRF |= 0b00000000;				//analog pins A0-A7
     7d6:	80 b3       	in	r24, 0x10	; 16
     7d8:	80 bb       	out	0x10, r24	; 16
	DDRG |= 0b00000000;
     7da:	83 b3       	in	r24, 0x13	; 19
     7dc:	83 bb       	out	0x13, r24	; 19
	DDRH |= 0b00110000;
     7de:	a1 e0       	ldi	r26, 0x01	; 1
     7e0:	b1 e0       	ldi	r27, 0x01	; 1
     7e2:	8c 91       	ld	r24, X
     7e4:	80 63       	ori	r24, 0x30	; 48
     7e6:	8c 93       	st	X, r24
	DDRJ |= 0b00000000;				//only used for Serial3
     7e8:	e4 e0       	ldi	r30, 0x04	; 4
     7ea:	f1 e0       	ldi	r31, 0x01	; 1
     7ec:	80 81       	ld	r24, Z
     7ee:	80 83       	st	Z, r24
	//DDRI doesnt exist
	DDRK |= 0b00000000;				// analog pins A8-A15
     7f0:	e7 e0       	ldi	r30, 0x07	; 7
     7f2:	f1 e0       	ldi	r31, 0x01	; 1
     7f4:	80 81       	ld	r24, Z
     7f6:	80 83       	st	Z, r24
	DDRL |= 0b00000000;				// digital pins 49-42
     7f8:	ea e0       	ldi	r30, 0x0A	; 10
     7fa:	f1 e0       	ldi	r31, 0x01	; 1
     7fc:	80 81       	ld	r24, Z
     7fe:	80 83       	st	Z, r24
	//analogwrite, Not all pins support PWM signals, please consult data sheets before altering.
	
	
	DDRG |= 0b00100000;
     800:	9d 9a       	sbi	0x13, 5	; 19
	DDRH |= 0b01111000;
     802:	8c 91       	ld	r24, X
     804:	88 67       	ori	r24, 0x78	; 120
     806:	8c 93       	st	X, r24
	DDRL |= 0b00111000;
     808:	80 81       	ld	r24, Z
     80a:	88 63       	ori	r24, 0x38	; 56
     80c:	80 83       	st	Z, r24
	//when something is unclear or you want to change some setting, please consult the data sheet first.
	
	//Compare Output Mode
	//determines how the PWN behaves, now it Clears OCxx on compare match. This makes it so that low value OCRxx will result in short pulses, while higher result in longer ones
	//COM0xx0 will make OCxx toggle on compare match, both will set om compare match. Neither will disable the pmw by disconnecting OCxx.
	TCCR0A |= (( 1 << COM0A1) | (1 << COM0B1));			//Timer0, used for PB7, PG5
     80e:	84 b5       	in	r24, 0x24	; 36
     810:	80 6a       	ori	r24, 0xA0	; 160
     812:	84 bd       	out	0x24, r24	; 36
	//TCCR1A |= (( 1 << COM1A1) | (1 << COM1B1));		//Timer1, used PulseIn command, measuring pulse lenghts. Because we don't use it for PWM it is disabled as such 
	TCCR2A |= (( 1 << COM2A1) | (1 << COM2B1));			//Timer2, used for PB4, PH6
     814:	80 eb       	ldi	r24, 0xB0	; 176
     816:	90 e0       	ldi	r25, 0x00	; 0
     818:	fc 01       	movw	r30, r24
     81a:	20 81       	ld	r18, Z
     81c:	20 6a       	ori	r18, 0xA0	; 160
     81e:	20 83       	st	Z, r18
	TCCR3A |= (( 1 << COM3A1) | (1 << COM3B1));			//TImer3, used for PE3, PE4, PE5
     820:	c0 e9       	ldi	r28, 0x90	; 144
     822:	d0 e0       	ldi	r29, 0x00	; 0
     824:	28 81       	ld	r18, Y
     826:	20 6a       	ori	r18, 0xA0	; 160
     828:	28 83       	st	Y, r18
	TCCR4A |= (( 1 << COM4A1) | (1 << COM4B1));			//Timer4, used for PH3, PH5, PH6
     82a:	a0 ea       	ldi	r26, 0xA0	; 160
     82c:	b0 e0       	ldi	r27, 0x00	; 0
     82e:	2c 91       	ld	r18, X
     830:	20 6a       	ori	r18, 0xA0	; 160
     832:	2c 93       	st	X, r18
	TCCR5A |= (( 1 << COM5A1) | (1 << COM5B1));			//Timer5, used for PL3, PL4, PL5
     834:	60 e2       	ldi	r22, 0x20	; 32
     836:	71 e0       	ldi	r23, 0x01	; 1
     838:	fb 01       	movw	r30, r22
     83a:	20 81       	ld	r18, Z
     83c:	20 6a       	ori	r18, 0xA0	; 160
     83e:	20 83       	st	Z, r18
	
	//Waveform Generation Mode
	//note that here OCRxA, OCRxB and OCRxC use the same registry and thus also use the same waveform.
	//the current PWM is Fast PMW, but in this case the PWM mode isn't really important.
	TCCR0A |= ((1 << WGM01) | (1 << WGM00));									//8 bit
     840:	24 b5       	in	r18, 0x24	; 36
     842:	23 60       	ori	r18, 0x03	; 3
     844:	24 bd       	out	0x24, r18	; 36
	TCCR1A |= ((1 << WGM13) | (1 << WGM12) | (1 << WGM11) | (1 << WGM10));		//16 bit, TOP=OCR1A
     846:	40 e8       	ldi	r20, 0x80	; 128
     848:	50 e0       	ldi	r21, 0x00	; 0
     84a:	fa 01       	movw	r30, r20
     84c:	20 81       	ld	r18, Z
     84e:	2b 61       	ori	r18, 0x1B	; 27
     850:	20 83       	st	Z, r18
	TCCR2A |= ((1 << WGM21) | (1 << WGM20));									//8 bit
     852:	fc 01       	movw	r30, r24
     854:	20 81       	ld	r18, Z
     856:	23 60       	ori	r18, 0x03	; 3
     858:	20 83       	st	Z, r18
	TCCR3A |= ((1 << WGM32) | (1 << WGM30));									//16 bit timer, scaled back to 8 bit. 
     85a:	88 81       	ld	r24, Y
     85c:	89 60       	ori	r24, 0x09	; 9
     85e:	88 83       	st	Y, r24
	TCCR4A |= ((1 << WGM42) | (1 << WGM40));									//16 bit timer, scaled back to 8 bit. 
     860:	8c 91       	ld	r24, X
     862:	89 60       	ori	r24, 0x09	; 9
     864:	8c 93       	st	X, r24
	TCCR5A |= ((1 << WGM52) | (1 << WGM50));									//16 bit timer, scaled back to 8 bit. 
     866:	fb 01       	movw	r30, r22
     868:	80 81       	ld	r24, Z
     86a:	89 60       	ori	r24, 0x09	; 9
     86c:	80 83       	st	Z, r24
	
	//Clock Select
	//currently selected, Internal clock, /8 prescaler. this starts the PWM as well
	//F_CPU=16000000 / 256 / 8 ~= 7812Hz wave
	//again as with the OCRxx, these use the same registry as well and are thus linked
	TCCR0B |= (1 << CS01);
     86e:	85 b5       	in	r24, 0x25	; 37
     870:	82 60       	ori	r24, 0x02	; 2
     872:	85 bd       	out	0x25, r24	; 37
	TCCR1B |= ((1 << CS10) | (1 << CS12));		//no prescaling
     874:	e1 e8       	ldi	r30, 0x81	; 129
     876:	f0 e0       	ldi	r31, 0x00	; 0
     878:	80 81       	ld	r24, Z
     87a:	85 60       	ori	r24, 0x05	; 5
     87c:	80 83       	st	Z, r24
	TCCR2B |= (1 << CS21);
     87e:	e1 eb       	ldi	r30, 0xB1	; 177
     880:	f0 e0       	ldi	r31, 0x00	; 0
     882:	80 81       	ld	r24, Z
     884:	82 60       	ori	r24, 0x02	; 2
     886:	80 83       	st	Z, r24
	TCCR3B |= (1 << CS31);
     888:	e1 e9       	ldi	r30, 0x91	; 145
     88a:	f0 e0       	ldi	r31, 0x00	; 0
     88c:	80 81       	ld	r24, Z
     88e:	82 60       	ori	r24, 0x02	; 2
     890:	80 83       	st	Z, r24
	TCCR4B |= (1 << CS41);
     892:	e1 ea       	ldi	r30, 0xA1	; 161
     894:	f0 e0       	ldi	r31, 0x00	; 0
     896:	80 81       	ld	r24, Z
     898:	82 60       	ori	r24, 0x02	; 2
     89a:	80 83       	st	Z, r24
	TCCR5B |= (1 << CS51);
     89c:	e1 e2       	ldi	r30, 0x21	; 33
     89e:	f1 e0       	ldi	r31, 0x01	; 1
     8a0:	80 81       	ld	r24, Z
     8a2:	82 60       	ori	r24, 0x02	; 2
     8a4:	80 83       	st	Z, r24
	//Timer/Counter Interrupt Mask Register
	TIMSK1 |= (1 << TOIE1);
	
	sei();	//enable global interrupts*/
	//initialize each PWM as 0
	OCR3B=0;	//pin 2
     8a6:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <__TEXT_REGION_LENGTH__+0x70009b>
     8aa:	10 92 9a 00 	sts	0x009A, r1	; 0x80009a <__TEXT_REGION_LENGTH__+0x70009a>
	OCR3C=0;	//pin 3
     8ae:	10 92 9d 00 	sts	0x009D, r1	; 0x80009d <__TEXT_REGION_LENGTH__+0x70009d>
     8b2:	10 92 9c 00 	sts	0x009C, r1	; 0x80009c <__TEXT_REGION_LENGTH__+0x70009c>
	OCR0B=0;	//pin 4
     8b6:	18 bc       	out	0x28, r1	; 40
	OCR3A=0;	//pin 5
     8b8:	10 92 99 00 	sts	0x0099, r1	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
     8bc:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
	OCR4A=0;	//pin 6
     8c0:	10 92 a9 00 	sts	0x00A9, r1	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
     8c4:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
	OCR4B=0;	//pin 7
     8c8:	10 92 ab 00 	sts	0x00AB, r1	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
     8cc:	10 92 aa 00 	sts	0x00AA, r1	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
	OCR4C=0;	//pin 8
     8d0:	10 92 ad 00 	sts	0x00AD, r1	; 0x8000ad <__TEXT_REGION_LENGTH__+0x7000ad>
     8d4:	10 92 ac 00 	sts	0x00AC, r1	; 0x8000ac <__TEXT_REGION_LENGTH__+0x7000ac>
	OCR2B=0;	//pin 9
     8d8:	10 92 b4 00 	sts	0x00B4, r1	; 0x8000b4 <__TEXT_REGION_LENGTH__+0x7000b4>
	OCR2A=0;	//pin 10
     8dc:	10 92 b3 00 	sts	0x00B3, r1	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
	OCR1A=0;	//pin 11
     8e0:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     8e4:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
	//OCR1B=0;	//pin 12
	//OCR1C=0;	//pin 13
	OCR5A=0;	//pin 44
     8e8:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
     8ec:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
	OCR5B=0;	//pin 45
     8f0:	10 92 2b 01 	sts	0x012B, r1	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
     8f4:	10 92 2a 01 	sts	0x012A, r1	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
	OCR5C=0;	//pin 46
     8f8:	10 92 2d 01 	sts	0x012D, r1	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
     8fc:	10 92 2c 01 	sts	0x012C, r1	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
	//Analog Digital Converter, analogread
	//////////////////////////////////////
	
	//Analog Digital Multiplexer Selection Register, voltage reference selection
	//Current setting: AVcc with external capacitor at AREF pin (internal 5v)
	ADMUX |= (1 << REFS0);
     900:	ec e7       	ldi	r30, 0x7C	; 124
     902:	f0 e0       	ldi	r31, 0x00	; 0
     904:	80 81       	ld	r24, Z
     906:	80 64       	ori	r24, 0x40	; 64
     908:	80 83       	st	Z, r24
	
	// 1/128 prescaler
	ADCSRA |= (1 << ADPS0) | (1 << ADPS1) | (1 << ADPS2);
     90a:	ea e7       	ldi	r30, 0x7A	; 122
     90c:	f0 e0       	ldi	r31, 0x00	; 0
     90e:	80 81       	ld	r24, Z
     910:	87 60       	ori	r24, 0x07	; 7
     912:	80 83       	st	Z, r24
	
	//enable the ADC convector
	ADCSRA |= (1 << ADEN);
     914:	80 81       	ld	r24, Z
     916:	80 68       	ori	r24, 0x80	; 128
     918:	80 83       	st	Z, r24
	Serial.println("IO setting generated");
     91a:	69 e1       	ldi	r22, 0x19	; 25
     91c:	72 e0       	ldi	r23, 0x02	; 2
     91e:	8e e2       	ldi	r24, 0x2E	; 46
     920:	94 e0       	ldi	r25, 0x04	; 4
     922:	ff d6       	rcall	.+3582   	; 0x1722 <_ZN5USART7printlnEPKc>
	return;
}
     924:	df 91       	pop	r29
     926:	cf 91       	pop	r28
     928:	08 95       	ret

0000092a <_Z11analogWriteii>:


//writes a value between 0 and 255 to the correct output compare register
//analogWrite(pin number, value it should receive).
void analogWrite(int pin,int val){
     92a:	6f 3f       	cpi	r22, 0xFF	; 255
     92c:	71 05       	cpc	r23, r1
     92e:	19 f0       	breq	.+6      	; 0x936 <_Z11analogWriteii+0xc>
     930:	14 f0       	brlt	.+4      	; 0x936 <_Z11analogWriteii+0xc>
     932:	6f ef       	ldi	r22, 0xFF	; 255
     934:	70 e0       	ldi	r23, 0x00	; 0
	if(val>255)			//if the given value exceeds 255, make it 255
	val=255;
	switch(pin){
     936:	fc 01       	movw	r30, r24
     938:	32 97       	sbiw	r30, 0x02	; 2
     93a:	ed 32       	cpi	r30, 0x2D	; 45
     93c:	f1 05       	cpc	r31, r1
     93e:	d0 f5       	brcc	.+116    	; 0x9b4 <_Z11analogWriteii+0x8a>
     940:	88 27       	eor	r24, r24
     942:	ee 58       	subi	r30, 0x8E	; 142
     944:	ff 4f       	sbci	r31, 0xFF	; 255
     946:	8f 4f       	sbci	r24, 0xFF	; 255
     948:	41 c7       	rjmp	.+3714   	; 0x17cc <__tablejump2__>
		case 2:
		OCR3B=val;
     94a:	70 93 9b 00 	sts	0x009B, r23	; 0x80009b <__TEXT_REGION_LENGTH__+0x70009b>
     94e:	60 93 9a 00 	sts	0x009A, r22	; 0x80009a <__TEXT_REGION_LENGTH__+0x70009a>
		return;
     952:	08 95       	ret
		case 3:
		OCR3C=val;
     954:	70 93 9d 00 	sts	0x009D, r23	; 0x80009d <__TEXT_REGION_LENGTH__+0x70009d>
     958:	60 93 9c 00 	sts	0x009C, r22	; 0x80009c <__TEXT_REGION_LENGTH__+0x70009c>
		return;
     95c:	08 95       	ret
		case 4:
		OCR0B=val;
     95e:	68 bd       	out	0x28, r22	; 40
		return;
     960:	08 95       	ret
		case 5:
		OCR3A=val;
     962:	70 93 99 00 	sts	0x0099, r23	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
     966:	60 93 98 00 	sts	0x0098, r22	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
		return;
     96a:	08 95       	ret
		case 6:
		OCR4A=val;
     96c:	70 93 a9 00 	sts	0x00A9, r23	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
     970:	60 93 a8 00 	sts	0x00A8, r22	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
		return;
     974:	08 95       	ret
		case 7:
		OCR4B=val;
     976:	70 93 ab 00 	sts	0x00AB, r23	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
     97a:	60 93 aa 00 	sts	0x00AA, r22	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
		return;
     97e:	08 95       	ret
		case 8:
		OCR4C=val;
     980:	70 93 ad 00 	sts	0x00AD, r23	; 0x8000ad <__TEXT_REGION_LENGTH__+0x7000ad>
     984:	60 93 ac 00 	sts	0x00AC, r22	; 0x8000ac <__TEXT_REGION_LENGTH__+0x7000ac>
		return;
     988:	08 95       	ret
		case 9:
		OCR2B=val;
     98a:	60 93 b4 00 	sts	0x00B4, r22	; 0x8000b4 <__TEXT_REGION_LENGTH__+0x7000b4>
		return;
     98e:	08 95       	ret
		case 10:
		OCR2A=val;
     990:	60 93 b3 00 	sts	0x00B3, r22	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
		return;
     994:	08 95       	ret
// 		return;
// 		case 12:
// 		OCR1B=val;
// 		return;
		case 44:
		OCR5C=val;
     996:	70 93 2d 01 	sts	0x012D, r23	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
     99a:	60 93 2c 01 	sts	0x012C, r22	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
		return;
     99e:	08 95       	ret
		case 45:
		OCR5B=val;
     9a0:	70 93 2b 01 	sts	0x012B, r23	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
     9a4:	60 93 2a 01 	sts	0x012A, r22	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
		return;
     9a8:	08 95       	ret
		case 46:
		OCR5C=val;
     9aa:	70 93 2d 01 	sts	0x012D, r23	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
     9ae:	60 93 2c 01 	sts	0x012C, r22	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
		return;
     9b2:	08 95       	ret
		}
	Serial.println("ERROR: tried to write analog value to unsupported pin");
     9b4:	6e e2       	ldi	r22, 0x2E	; 46
     9b6:	72 e0       	ldi	r23, 0x02	; 2
     9b8:	8e e2       	ldi	r24, 0x2E	; 46
     9ba:	94 e0       	ldi	r25, 0x04	; 4
     9bc:	b2 c6       	rjmp	.+3428   	; 0x1722 <_ZN5USART7printlnEPKc>
     9be:	08 95       	ret

000009c0 <_Z12digitalWriteib>:
	return;
}

//writes a digital value to a pin.
void digitalWrite(int pin,bool val){
     9c0:	cf 93       	push	r28
     9c2:	df 93       	push	r29
	if(pin<22||pin>53){					//check if the pin is a digital IO pin and supported as such
     9c4:	9c 01       	movw	r18, r24
     9c6:	26 51       	subi	r18, 0x16	; 22
     9c8:	31 09       	sbc	r19, r1
     9ca:	20 32       	cpi	r18, 0x20	; 32
     9cc:	31 05       	cpc	r19, r1
     9ce:	58 f0       	brcs	.+22     	; 0x9e6 <_Z12digitalWriteib+0x26>
     9d0:	ec 01       	movw	r28, r24
		Serial.print("ERROR: tried to write digital value to unsupported digital pin");
     9d2:	64 e6       	ldi	r22, 0x64	; 100
     9d4:	72 e0       	ldi	r23, 0x02	; 2
     9d6:	8e e2       	ldi	r24, 0x2E	; 46
     9d8:	94 e0       	ldi	r25, 0x04	; 4
     9da:	8a d6       	rcall	.+3348   	; 0x16f0 <_ZN5USART5printEPKc>
		Serial.println(pin);
     9dc:	be 01       	movw	r22, r28
     9de:	8e e2       	ldi	r24, 0x2E	; 46
     9e0:	94 e0       	ldi	r25, 0x04	; 4
     9e2:	cd d6       	rcall	.+3482   	; 0x177e <_ZN5USART7printlnEi>
     9e4:	b9 c0       	rjmp	.+370    	; 0xb58 <_Z12digitalWriteib+0x198>
	}
	else if(pin<30){					//check if pin is in the A register
     9e6:	8e 31       	cpi	r24, 0x1E	; 30
     9e8:	91 05       	cpc	r25, r1
     9ea:	f4 f4       	brge	.+60     	; 0xa28 <_Z12digitalWriteib+0x68>
		pin-=22;						//make pin range 0-7
     9ec:	46 97       	sbiw	r24, 0x16	; 22
		if(val) PORTA |= (1<<pin);		//set correct bit in A register is val==true
     9ee:	66 23       	and	r22, r22
     9f0:	69 f0       	breq	.+26     	; 0xa0c <_Z12digitalWriteib+0x4c>
     9f2:	42 b1       	in	r20, 0x02	; 2
     9f4:	21 e0       	ldi	r18, 0x01	; 1
     9f6:	30 e0       	ldi	r19, 0x00	; 0
     9f8:	b9 01       	movw	r22, r18
     9fa:	02 c0       	rjmp	.+4      	; 0xa00 <_Z12digitalWriteib+0x40>
     9fc:	66 0f       	add	r22, r22
     9fe:	77 1f       	adc	r23, r23
     a00:	8a 95       	dec	r24
     a02:	e2 f7       	brpl	.-8      	; 0x9fc <_Z12digitalWriteib+0x3c>
     a04:	cb 01       	movw	r24, r22
     a06:	84 2b       	or	r24, r20
     a08:	82 b9       	out	0x02, r24	; 2
     a0a:	a6 c0       	rjmp	.+332    	; 0xb58 <_Z12digitalWriteib+0x198>
		else PORTA &= ~(1<<pin);		//unset bit if false
     a0c:	42 b1       	in	r20, 0x02	; 2
     a0e:	21 e0       	ldi	r18, 0x01	; 1
     a10:	30 e0       	ldi	r19, 0x00	; 0
     a12:	b9 01       	movw	r22, r18
     a14:	02 c0       	rjmp	.+4      	; 0xa1a <_Z12digitalWriteib+0x5a>
     a16:	66 0f       	add	r22, r22
     a18:	77 1f       	adc	r23, r23
     a1a:	8a 95       	dec	r24
     a1c:	e2 f7       	brpl	.-8      	; 0xa16 <_Z12digitalWriteib+0x56>
     a1e:	cb 01       	movw	r24, r22
     a20:	80 95       	com	r24
     a22:	84 23       	and	r24, r20
     a24:	82 b9       	out	0x02, r24	; 2
     a26:	98 c0       	rjmp	.+304    	; 0xb58 <_Z12digitalWriteib+0x198>
	}
	else if(pin<38){
     a28:	86 32       	cpi	r24, 0x26	; 38
     a2a:	91 05       	cpc	r25, r1
     a2c:	1c f5       	brge	.+70     	; 0xa74 <_Z12digitalWriteib+0xb4>
		pin=(37-pin);
     a2e:	25 e2       	ldi	r18, 0x25	; 37
     a30:	30 e0       	ldi	r19, 0x00	; 0
     a32:	a9 01       	movw	r20, r18
     a34:	48 1b       	sub	r20, r24
     a36:	59 0b       	sbc	r21, r25
     a38:	ca 01       	movw	r24, r20
		if(val) PORTC |= (1<<pin);
     a3a:	66 23       	and	r22, r22
     a3c:	69 f0       	breq	.+26     	; 0xa58 <_Z12digitalWriteib+0x98>
     a3e:	48 b1       	in	r20, 0x08	; 8
     a40:	21 e0       	ldi	r18, 0x01	; 1
     a42:	30 e0       	ldi	r19, 0x00	; 0
     a44:	b9 01       	movw	r22, r18
     a46:	02 c0       	rjmp	.+4      	; 0xa4c <_Z12digitalWriteib+0x8c>
     a48:	66 0f       	add	r22, r22
     a4a:	77 1f       	adc	r23, r23
     a4c:	8a 95       	dec	r24
     a4e:	e2 f7       	brpl	.-8      	; 0xa48 <_Z12digitalWriteib+0x88>
     a50:	cb 01       	movw	r24, r22
     a52:	84 2b       	or	r24, r20
     a54:	88 b9       	out	0x08, r24	; 8
     a56:	80 c0       	rjmp	.+256    	; 0xb58 <_Z12digitalWriteib+0x198>
		else PORTC &= ~(1<<pin);
     a58:	48 b1       	in	r20, 0x08	; 8
     a5a:	21 e0       	ldi	r18, 0x01	; 1
     a5c:	30 e0       	ldi	r19, 0x00	; 0
     a5e:	b9 01       	movw	r22, r18
     a60:	02 c0       	rjmp	.+4      	; 0xa66 <_Z12digitalWriteib+0xa6>
     a62:	66 0f       	add	r22, r22
     a64:	77 1f       	adc	r23, r23
     a66:	8a 95       	dec	r24
     a68:	e2 f7       	brpl	.-8      	; 0xa62 <_Z12digitalWriteib+0xa2>
     a6a:	cb 01       	movw	r24, r22
     a6c:	80 95       	com	r24
     a6e:	84 23       	and	r24, r20
     a70:	88 b9       	out	0x08, r24	; 8
     a72:	72 c0       	rjmp	.+228    	; 0xb58 <_Z12digitalWriteib+0x198>
	}
	else if(pin==38){
     a74:	86 32       	cpi	r24, 0x26	; 38
     a76:	91 05       	cpc	r25, r1
     a78:	31 f4       	brne	.+12     	; 0xa86 <_Z12digitalWriteib+0xc6>
		if(val) PORTD |= (1<<PIND7);
     a7a:	66 23       	and	r22, r22
     a7c:	11 f0       	breq	.+4      	; 0xa82 <_Z12digitalWriteib+0xc2>
     a7e:	5f 9a       	sbi	0x0b, 7	; 11
     a80:	6b c0       	rjmp	.+214    	; 0xb58 <_Z12digitalWriteib+0x198>
		else PORTD &= ~(1<<PIND7);
     a82:	5f 98       	cbi	0x0b, 7	; 11
     a84:	69 c0       	rjmp	.+210    	; 0xb58 <_Z12digitalWriteib+0x198>
	}
	else if(pin<42){
     a86:	8a 32       	cpi	r24, 0x2A	; 42
     a88:	91 05       	cpc	r25, r1
     a8a:	ec f4       	brge	.+58     	; 0xac6 <_Z12digitalWriteib+0x106>
		pin=(41-pin);
     a8c:	29 e2       	ldi	r18, 0x29	; 41
     a8e:	30 e0       	ldi	r19, 0x00	; 0
     a90:	28 1b       	sub	r18, r24
     a92:	39 0b       	sbc	r19, r25
		if(val) PORTG |= (1<<pin);
     a94:	66 23       	and	r22, r22
     a96:	59 f0       	breq	.+22     	; 0xaae <_Z12digitalWriteib+0xee>
     a98:	34 b3       	in	r19, 0x14	; 20
     a9a:	81 e0       	ldi	r24, 0x01	; 1
     a9c:	90 e0       	ldi	r25, 0x00	; 0
     a9e:	02 c0       	rjmp	.+4      	; 0xaa4 <_Z12digitalWriteib+0xe4>
     aa0:	88 0f       	add	r24, r24
     aa2:	99 1f       	adc	r25, r25
     aa4:	2a 95       	dec	r18
     aa6:	e2 f7       	brpl	.-8      	; 0xaa0 <_Z12digitalWriteib+0xe0>
     aa8:	83 2b       	or	r24, r19
     aaa:	84 bb       	out	0x14, r24	; 20
     aac:	55 c0       	rjmp	.+170    	; 0xb58 <_Z12digitalWriteib+0x198>
		else PORTG &= ~(1<<pin);
     aae:	34 b3       	in	r19, 0x14	; 20
     ab0:	81 e0       	ldi	r24, 0x01	; 1
     ab2:	90 e0       	ldi	r25, 0x00	; 0
     ab4:	02 c0       	rjmp	.+4      	; 0xaba <_Z12digitalWriteib+0xfa>
     ab6:	88 0f       	add	r24, r24
     ab8:	99 1f       	adc	r25, r25
     aba:	2a 95       	dec	r18
     abc:	e2 f7       	brpl	.-8      	; 0xab6 <_Z12digitalWriteib+0xf6>
     abe:	80 95       	com	r24
     ac0:	83 23       	and	r24, r19
     ac2:	84 bb       	out	0x14, r24	; 20
     ac4:	49 c0       	rjmp	.+146    	; 0xb58 <_Z12digitalWriteib+0x198>
	}
	else if(pin<50){
     ac6:	82 33       	cpi	r24, 0x32	; 50
     ac8:	91 05       	cpc	r25, r1
     aca:	0c f5       	brge	.+66     	; 0xb0e <_Z12digitalWriteib+0x14e>
		pin=(49-pin);
     acc:	21 e3       	ldi	r18, 0x31	; 49
     ace:	30 e0       	ldi	r19, 0x00	; 0
     ad0:	28 1b       	sub	r18, r24
     ad2:	39 0b       	sbc	r19, r25
		if(val) PORTL |= (1<<pin);
     ad4:	66 23       	and	r22, r22
     ad6:	69 f0       	breq	.+26     	; 0xaf2 <_Z12digitalWriteib+0x132>
     ad8:	eb e0       	ldi	r30, 0x0B	; 11
     ada:	f1 e0       	ldi	r31, 0x01	; 1
     adc:	30 81       	ld	r19, Z
     ade:	81 e0       	ldi	r24, 0x01	; 1
     ae0:	90 e0       	ldi	r25, 0x00	; 0
     ae2:	02 c0       	rjmp	.+4      	; 0xae8 <_Z12digitalWriteib+0x128>
     ae4:	88 0f       	add	r24, r24
     ae6:	99 1f       	adc	r25, r25
     ae8:	2a 95       	dec	r18
     aea:	e2 f7       	brpl	.-8      	; 0xae4 <_Z12digitalWriteib+0x124>
     aec:	83 2b       	or	r24, r19
     aee:	80 83       	st	Z, r24
     af0:	33 c0       	rjmp	.+102    	; 0xb58 <_Z12digitalWriteib+0x198>
		else PORTL &= ~(1<<pin);
     af2:	eb e0       	ldi	r30, 0x0B	; 11
     af4:	f1 e0       	ldi	r31, 0x01	; 1
     af6:	30 81       	ld	r19, Z
     af8:	81 e0       	ldi	r24, 0x01	; 1
     afa:	90 e0       	ldi	r25, 0x00	; 0
     afc:	02 c0       	rjmp	.+4      	; 0xb02 <_Z12digitalWriteib+0x142>
     afe:	88 0f       	add	r24, r24
     b00:	99 1f       	adc	r25, r25
     b02:	2a 95       	dec	r18
     b04:	e2 f7       	brpl	.-8      	; 0xafe <_Z12digitalWriteib+0x13e>
     b06:	80 95       	com	r24
     b08:	83 23       	and	r24, r19
     b0a:	80 83       	st	Z, r24
     b0c:	25 c0       	rjmp	.+74     	; 0xb58 <_Z12digitalWriteib+0x198>
	}
	else if(pin<54){
     b0e:	86 33       	cpi	r24, 0x36	; 54
     b10:	91 05       	cpc	r25, r1
     b12:	14 f5       	brge	.+68     	; 0xb58 <_Z12digitalWriteib+0x198>
		pin=(53-pin);
     b14:	25 e3       	ldi	r18, 0x35	; 53
     b16:	30 e0       	ldi	r19, 0x00	; 0
     b18:	a9 01       	movw	r20, r18
     b1a:	48 1b       	sub	r20, r24
     b1c:	59 0b       	sbc	r21, r25
     b1e:	ca 01       	movw	r24, r20
		if(val) PORTB |= (1<<pin);
     b20:	66 23       	and	r22, r22
     b22:	69 f0       	breq	.+26     	; 0xb3e <_Z12digitalWriteib+0x17e>
     b24:	45 b1       	in	r20, 0x05	; 5
     b26:	21 e0       	ldi	r18, 0x01	; 1
     b28:	30 e0       	ldi	r19, 0x00	; 0
     b2a:	b9 01       	movw	r22, r18
     b2c:	02 c0       	rjmp	.+4      	; 0xb32 <_Z12digitalWriteib+0x172>
     b2e:	66 0f       	add	r22, r22
     b30:	77 1f       	adc	r23, r23
     b32:	8a 95       	dec	r24
     b34:	e2 f7       	brpl	.-8      	; 0xb2e <_Z12digitalWriteib+0x16e>
     b36:	cb 01       	movw	r24, r22
     b38:	84 2b       	or	r24, r20
     b3a:	85 b9       	out	0x05, r24	; 5
     b3c:	0d c0       	rjmp	.+26     	; 0xb58 <_Z12digitalWriteib+0x198>
		else PORTB &= ~(1<<pin);
     b3e:	45 b1       	in	r20, 0x05	; 5
     b40:	21 e0       	ldi	r18, 0x01	; 1
     b42:	30 e0       	ldi	r19, 0x00	; 0
     b44:	b9 01       	movw	r22, r18
     b46:	02 c0       	rjmp	.+4      	; 0xb4c <_Z12digitalWriteib+0x18c>
     b48:	66 0f       	add	r22, r22
     b4a:	77 1f       	adc	r23, r23
     b4c:	8a 95       	dec	r24
     b4e:	e2 f7       	brpl	.-8      	; 0xb48 <_Z12digitalWriteib+0x188>
     b50:	cb 01       	movw	r24, r22
     b52:	80 95       	com	r24
     b54:	84 23       	and	r24, r20
     b56:	85 b9       	out	0x05, r24	; 5
	}
	return;
}
     b58:	df 91       	pop	r29
     b5a:	cf 91       	pop	r28
     b5c:	08 95       	ret

00000b5e <_Z11digitalReadi>:

bool digitalRead(int pin){
     b5e:	cf 93       	push	r28
     b60:	df 93       	push	r29
	if(pin==4){
     b62:	84 30       	cpi	r24, 0x04	; 4
     b64:	91 05       	cpc	r25, r1
     b66:	29 f4       	brne	.+10     	; 0xb72 <_Z11digitalReadi+0x14>
		if(PING&(1<<PING5))	return true;
     b68:	82 b3       	in	r24, 0x12	; 18
     b6a:	85 fb       	bst	r24, 5
     b6c:	88 27       	eor	r24, r24
     b6e:	80 f9       	bld	r24, 0
     b70:	6f c0       	rjmp	.+222    	; 0xc50 <_Z11digitalReadi+0xf2>
	}
	else if(pin<30){					//check if pin is in the A register
     b72:	8e 31       	cpi	r24, 0x1E	; 30
     b74:	91 05       	cpc	r25, r1
     b76:	64 f4       	brge	.+24     	; 0xb90 <_Z11digitalReadi+0x32>
		pin-=22;						//make pinrange 0-7
		if(PINA&(1<<pin))	return true;							//break function
     b78:	20 b1       	in	r18, 0x00	; 0
     b7a:	30 e0       	ldi	r19, 0x00	; 0
     b7c:	46 97       	sbiw	r24, 0x16	; 22
     b7e:	a9 01       	movw	r20, r18
     b80:	02 c0       	rjmp	.+4      	; 0xb86 <_Z11digitalReadi+0x28>
     b82:	55 95       	asr	r21
     b84:	47 95       	ror	r20
     b86:	8a 95       	dec	r24
     b88:	e2 f7       	brpl	.-8      	; 0xb82 <_Z11digitalReadi+0x24>
     b8a:	ca 01       	movw	r24, r20
     b8c:	81 70       	andi	r24, 0x01	; 1
     b8e:	60 c0       	rjmp	.+192    	; 0xc50 <_Z11digitalReadi+0xf2>
	}
	else if(pin<38){
     b90:	86 32       	cpi	r24, 0x26	; 38
     b92:	91 05       	cpc	r25, r1
     b94:	84 f4       	brge	.+32     	; 0xbb6 <_Z11digitalReadi+0x58>
		pin=37-pin;
		if(PINC&(1<<pin))	return true;							//break function
     b96:	26 b1       	in	r18, 0x06	; 6
     b98:	30 e0       	ldi	r19, 0x00	; 0
     b9a:	45 e2       	ldi	r20, 0x25	; 37
     b9c:	50 e0       	ldi	r21, 0x00	; 0
     b9e:	ba 01       	movw	r22, r20
     ba0:	68 1b       	sub	r22, r24
     ba2:	79 0b       	sbc	r23, r25
     ba4:	a9 01       	movw	r20, r18
     ba6:	02 c0       	rjmp	.+4      	; 0xbac <_Z11digitalReadi+0x4e>
     ba8:	55 95       	asr	r21
     baa:	47 95       	ror	r20
     bac:	6a 95       	dec	r22
     bae:	e2 f7       	brpl	.-8      	; 0xba8 <_Z11digitalReadi+0x4a>
     bb0:	ca 01       	movw	r24, r20
     bb2:	81 70       	andi	r24, 0x01	; 1
     bb4:	4d c0       	rjmp	.+154    	; 0xc50 <_Z11digitalReadi+0xf2>
	}
	else if(pin==38){
     bb6:	86 32       	cpi	r24, 0x26	; 38
     bb8:	91 05       	cpc	r25, r1
     bba:	29 f4       	brne	.+10     	; 0xbc6 <_Z11digitalReadi+0x68>
		if(PIND&(1<<PIND7))	return true;							//break function
     bbc:	89 b1       	in	r24, 0x09	; 9
     bbe:	88 1f       	adc	r24, r24
     bc0:	88 27       	eor	r24, r24
     bc2:	88 1f       	adc	r24, r24
     bc4:	45 c0       	rjmp	.+138    	; 0xc50 <_Z11digitalReadi+0xf2>
	}
	else if(pin<42){
     bc6:	8a 32       	cpi	r24, 0x2A	; 42
     bc8:	91 05       	cpc	r25, r1
     bca:	84 f4       	brge	.+32     	; 0xbec <_Z11digitalReadi+0x8e>
		pin=41-pin;
		if(PING&(1<<pin))	return true;							//break function
     bcc:	22 b3       	in	r18, 0x12	; 18
     bce:	30 e0       	ldi	r19, 0x00	; 0
     bd0:	49 e2       	ldi	r20, 0x29	; 41
     bd2:	50 e0       	ldi	r21, 0x00	; 0
     bd4:	ba 01       	movw	r22, r20
     bd6:	68 1b       	sub	r22, r24
     bd8:	79 0b       	sbc	r23, r25
     bda:	a9 01       	movw	r20, r18
     bdc:	02 c0       	rjmp	.+4      	; 0xbe2 <_Z11digitalReadi+0x84>
     bde:	55 95       	asr	r21
     be0:	47 95       	ror	r20
     be2:	6a 95       	dec	r22
     be4:	e2 f7       	brpl	.-8      	; 0xbde <_Z11digitalReadi+0x80>
     be6:	ca 01       	movw	r24, r20
     be8:	81 70       	andi	r24, 0x01	; 1
     bea:	32 c0       	rjmp	.+100    	; 0xc50 <_Z11digitalReadi+0xf2>
	}
	else if(pin<50){
     bec:	82 33       	cpi	r24, 0x32	; 50
     bee:	91 05       	cpc	r25, r1
     bf0:	8c f4       	brge	.+34     	; 0xc14 <_Z11digitalReadi+0xb6>
		pin=49-pin;
		if(PINL&(1<<pin))	return true;							//break function
     bf2:	20 91 09 01 	lds	r18, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
     bf6:	30 e0       	ldi	r19, 0x00	; 0
     bf8:	41 e3       	ldi	r20, 0x31	; 49
     bfa:	50 e0       	ldi	r21, 0x00	; 0
     bfc:	ba 01       	movw	r22, r20
     bfe:	68 1b       	sub	r22, r24
     c00:	79 0b       	sbc	r23, r25
     c02:	a9 01       	movw	r20, r18
     c04:	02 c0       	rjmp	.+4      	; 0xc0a <_Z11digitalReadi+0xac>
     c06:	55 95       	asr	r21
     c08:	47 95       	ror	r20
     c0a:	6a 95       	dec	r22
     c0c:	e2 f7       	brpl	.-8      	; 0xc06 <_Z11digitalReadi+0xa8>
     c0e:	ca 01       	movw	r24, r20
     c10:	81 70       	andi	r24, 0x01	; 1
     c12:	1e c0       	rjmp	.+60     	; 0xc50 <_Z11digitalReadi+0xf2>
	}
	else if(pin<54){
     c14:	86 33       	cpi	r24, 0x36	; 54
     c16:	91 05       	cpc	r25, r1
     c18:	84 f4       	brge	.+32     	; 0xc3a <_Z11digitalReadi+0xdc>
		pin=(53-pin);
		if(PINB&(1<<pin))	return true;							//break function
     c1a:	23 b1       	in	r18, 0x03	; 3
     c1c:	30 e0       	ldi	r19, 0x00	; 0
     c1e:	45 e3       	ldi	r20, 0x35	; 53
     c20:	50 e0       	ldi	r21, 0x00	; 0
     c22:	ba 01       	movw	r22, r20
     c24:	68 1b       	sub	r22, r24
     c26:	79 0b       	sbc	r23, r25
     c28:	a9 01       	movw	r20, r18
     c2a:	02 c0       	rjmp	.+4      	; 0xc30 <_Z11digitalReadi+0xd2>
     c2c:	55 95       	asr	r21
     c2e:	47 95       	ror	r20
     c30:	6a 95       	dec	r22
     c32:	e2 f7       	brpl	.-8      	; 0xc2c <_Z11digitalReadi+0xce>
     c34:	ca 01       	movw	r24, r20
     c36:	81 70       	andi	r24, 0x01	; 1
     c38:	0b c0       	rjmp	.+22     	; 0xc50 <_Z11digitalReadi+0xf2>
     c3a:	ec 01       	movw	r28, r24
	}
	else{					//pin unsupported
		Serial.print("ERROR: tried to read digital value from unsupported digital pin: ");
     c3c:	63 ea       	ldi	r22, 0xA3	; 163
     c3e:	72 e0       	ldi	r23, 0x02	; 2
     c40:	8e e2       	ldi	r24, 0x2E	; 46
     c42:	94 e0       	ldi	r25, 0x04	; 4
     c44:	55 d5       	rcall	.+2730   	; 0x16f0 <_ZN5USART5printEPKc>
		Serial.println(pin);
     c46:	be 01       	movw	r22, r28
     c48:	8e e2       	ldi	r24, 0x2E	; 46
     c4a:	94 e0       	ldi	r25, 0x04	; 4
     c4c:	98 d5       	rcall	.+2864   	; 0x177e <_ZN5USART7printlnEi>
		return false;
     c4e:	80 e0       	ldi	r24, 0x00	; 0
	}
	return false;	
}
     c50:	df 91       	pop	r29
     c52:	cf 91       	pop	r28
     c54:	08 95       	ret

00000c56 <_Z10analogReadi>:

int analogRead(int pin){
     c56:	cf 93       	push	r28
     c58:	df 93       	push	r29
	//set correct MUX registers, these determine on which pin the ADC should read it's value
	//first the MUXx bits are cleared, then filled to prevent old setting leaking though
	
	ADMUX &=(0b11100000);							//clear the bottom 4 bit
     c5a:	ec e7       	ldi	r30, 0x7C	; 124
     c5c:	f0 e0       	ldi	r31, 0x00	; 0
     c5e:	20 81       	ld	r18, Z
     c60:	20 7e       	andi	r18, 0xE0	; 224
     c62:	20 83       	st	Z, r18
	ADCSRB &=(0b11110111);							//clear the top one bit
     c64:	eb e7       	ldi	r30, 0x7B	; 123
     c66:	f0 e0       	ldi	r31, 0x00	; 0
     c68:	20 81       	ld	r18, Z
     c6a:	27 7f       	andi	r18, 0xF7	; 247
     c6c:	20 83       	st	Z, r18
	if(pin<8)										//if adc #0-7
     c6e:	88 30       	cpi	r24, 0x08	; 8
     c70:	91 05       	cpc	r25, r1
     c72:	34 f4       	brge	.+12     	; 0xc80 <_Z10analogReadi+0x2a>
	ADMUX |= pin;								//write the full pin to the ADMUX registry
     c74:	ec e7       	ldi	r30, 0x7C	; 124
     c76:	f0 e0       	ldi	r31, 0x00	; 0
     c78:	90 81       	ld	r25, Z
     c7a:	89 2b       	or	r24, r25
     c7c:	80 83       	st	Z, r24
     c7e:	1c c0       	rjmp	.+56     	; 0xcb8 <_Z10analogReadi+0x62>
	else if(pin<16){									//if adc #8-15
     c80:	80 31       	cpi	r24, 0x10	; 16
     c82:	91 05       	cpc	r25, r1
     c84:	64 f4       	brge	.+24     	; 0xc9e <_Z10analogReadi+0x48>
		ADCSRB |= (1<<3);							//write upper bit to ADCSRB register
     c86:	eb e7       	ldi	r30, 0x7B	; 123
     c88:	f0 e0       	ldi	r31, 0x00	; 0
     c8a:	90 81       	ld	r25, Z
     c8c:	98 60       	ori	r25, 0x08	; 8
     c8e:	90 83       	st	Z, r25
		ADMUX |= (pin-8);							//write lower bits to ADMUX registry
     c90:	ec e7       	ldi	r30, 0x7C	; 124
     c92:	f0 e0       	ldi	r31, 0x00	; 0
     c94:	90 81       	ld	r25, Z
     c96:	88 50       	subi	r24, 0x08	; 8
     c98:	89 2b       	or	r24, r25
     c9a:	80 83       	st	Z, r24
     c9c:	0d c0       	rjmp	.+26     	; 0xcb8 <_Z10analogReadi+0x62>
     c9e:	ec 01       	movw	r28, r24
	}
	else{
		Serial.print("ERROR: tried to read digital value from unsupported analog pin ");
     ca0:	65 ee       	ldi	r22, 0xE5	; 229
     ca2:	72 e0       	ldi	r23, 0x02	; 2
     ca4:	8e e2       	ldi	r24, 0x2E	; 46
     ca6:	94 e0       	ldi	r25, 0x04	; 4
     ca8:	23 d5       	rcall	.+2630   	; 0x16f0 <_ZN5USART5printEPKc>
		Serial.println(pin);
     caa:	be 01       	movw	r22, r28
     cac:	8e e2       	ldi	r24, 0x2E	; 46
     cae:	94 e0       	ldi	r25, 0x04	; 4
     cb0:	66 d5       	rcall	.+2764   	; 0x177e <_ZN5USART7printlnEi>
		return 0;
     cb2:	80 e0       	ldi	r24, 0x00	; 0
     cb4:	90 e0       	ldi	r25, 0x00	; 0
     cb6:	0c c0       	rjmp	.+24     	; 0xcd0 <_Z10analogReadi+0x7a>
	}
	ADCSRA |= (1<<ADSC);							//start ADC conversion
     cb8:	ea e7       	ldi	r30, 0x7A	; 122
     cba:	f0 e0       	ldi	r31, 0x00	; 0
     cbc:	80 81       	ld	r24, Z
     cbe:	80 64       	ori	r24, 0x40	; 64
     cc0:	80 83       	st	Z, r24
	while(ADCSRA & (1<<ADSC));						//wait until the ADSC is 0 again and the conversion is done
     cc2:	80 81       	ld	r24, Z
     cc4:	86 fd       	sbrc	r24, 6
     cc6:	fd cf       	rjmp	.-6      	; 0xcc2 <_Z10analogReadi+0x6c>
	return ADC;										//return the byte in ADLAR, the result of the ADC conversion
     cc8:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
     ccc:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
}
     cd0:	df 91       	pop	r29
     cd2:	cf 91       	pop	r28
     cd4:	08 95       	ret

00000cd6 <_Z9printinfov>:
*/


#ifdef DEBUG_MODE 
void printinfo(){
	Serial.print(analogRead(ai_hmi_steering));
     cd6:	8e e0       	ldi	r24, 0x0E	; 14
     cd8:	90 e0       	ldi	r25, 0x00	; 0
     cda:	bd df       	rcall	.-134    	; 0xc56 <_Z10analogReadi>
     cdc:	bc 01       	movw	r22, r24
     cde:	8e e2       	ldi	r24, 0x2E	; 46
     ce0:	94 e0       	ldi	r25, 0x04	; 4
     ce2:	2a d5       	rcall	.+2644   	; 0x1738 <_ZN5USART5printEi>
	Serial.print("DM: ");
     ce4:	65 e2       	ldi	r22, 0x25	; 37
     ce6:	73 e0       	ldi	r23, 0x03	; 3
     ce8:	8e e2       	ldi	r24, 0x2E	; 46
     cea:	94 e0       	ldi	r25, 0x04	; 4
     cec:	01 d5       	rcall	.+2562   	; 0x16f0 <_ZN5USART5printEPKc>
	Serial.print(drivemode);
     cee:	60 91 0d 04 	lds	r22, 0x040D	; 0x80040d <drivemode>
     cf2:	70 91 0e 04 	lds	r23, 0x040E	; 0x80040e <drivemode+0x1>
     cf6:	8e e2       	ldi	r24, 0x2E	; 46
     cf8:	94 e0       	ldi	r25, 0x04	; 4
     cfa:	1e d5       	rcall	.+2620   	; 0x1738 <_ZN5USART5printEi>
	Serial.print(" drive dir: ");
     cfc:	6a e2       	ldi	r22, 0x2A	; 42
     cfe:	73 e0       	ldi	r23, 0x03	; 3
     d00:	8e e2       	ldi	r24, 0x2E	; 46
     d02:	94 e0       	ldi	r25, 0x04	; 4
     d04:	f5 d4       	rcall	.+2538   	; 0x16f0 <_ZN5USART5printEPKc>
	Serial.print(driving_direction);
     d06:	60 91 00 02 	lds	r22, 0x0200	; 0x800200 <__data_start>
     d0a:	70 e0       	ldi	r23, 0x00	; 0
     d0c:	8e e2       	ldi	r24, 0x2E	; 46
     d0e:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" engine_dv = ");
     d10:	13 d5       	rcall	.+2598   	; 0x1738 <_ZN5USART5printEi>
     d12:	67 e3       	ldi	r22, 0x37	; 55
     d14:	73 e0       	ldi	r23, 0x03	; 3
     d16:	8e e2       	ldi	r24, 0x2E	; 46
     d18:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(engine_dv);
     d1a:	ea d4       	rcall	.+2516   	; 0x16f0 <_ZN5USART5printEPKc>
     d1c:	60 91 f6 03 	lds	r22, 0x03F6	; 0x8003f6 <engine_dv>
     d20:	70 91 f7 03 	lds	r23, 0x03F7	; 0x8003f7 <engine_dv+0x1>
     d24:	8e e2       	ldi	r24, 0x2E	; 46
     d26:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" brake_dv = ");
     d28:	07 d5       	rcall	.+2574   	; 0x1738 <_ZN5USART5printEi>
     d2a:	65 e4       	ldi	r22, 0x45	; 69
     d2c:	73 e0       	ldi	r23, 0x03	; 3
     d2e:	8e e2       	ldi	r24, 0x2E	; 46
     d30:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(braking_dv);
     d32:	de d4       	rcall	.+2492   	; 0x16f0 <_ZN5USART5printEPKc>
     d34:	60 91 f2 03 	lds	r22, 0x03F2	; 0x8003f2 <braking_dv>
     d38:	70 91 f3 03 	lds	r23, 0x03F3	; 0x8003f3 <braking_dv+0x1>
     d3c:	8e e2       	ldi	r24, 0x2E	; 46
     d3e:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" steering_dv = ");
     d40:	fb d4       	rcall	.+2550   	; 0x1738 <_ZN5USART5printEi>
     d42:	62 e5       	ldi	r22, 0x52	; 82
     d44:	73 e0       	ldi	r23, 0x03	; 3
     d46:	8e e2       	ldi	r24, 0x2E	; 46
     d48:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(steering_dv);
     d4a:	d2 d4       	rcall	.+2468   	; 0x16f0 <_ZN5USART5printEPKc>
     d4c:	60 91 05 04 	lds	r22, 0x0405	; 0x800405 <steering_dv>
     d50:	70 91 06 04 	lds	r23, 0x0406	; 0x800406 <steering_dv+0x1>
     d54:	8e e2       	ldi	r24, 0x2E	; 46
     d56:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" steering_cv = ");
     d58:	ef d4       	rcall	.+2526   	; 0x1738 <_ZN5USART5printEi>
     d5a:	62 e6       	ldi	r22, 0x62	; 98
     d5c:	73 e0       	ldi	r23, 0x03	; 3
     d5e:	8e e2       	ldi	r24, 0x2E	; 46
     d60:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(steering_cv);
     d62:	c6 d4       	rcall	.+2444   	; 0x16f0 <_ZN5USART5printEPKc>
     d64:	60 91 fb 03 	lds	r22, 0x03FB	; 0x8003fb <steering_cv>
     d68:	70 91 fc 03 	lds	r23, 0x03FC	; 0x8003fc <steering_cv+0x1>
     d6c:	8e e2       	ldi	r24, 0x2E	; 46
     d6e:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" steering_ov = ");
     d70:	e3 d4       	rcall	.+2502   	; 0x1738 <_ZN5USART5printEi>
     d72:	62 e7       	ldi	r22, 0x72	; 114
     d74:	73 e0       	ldi	r23, 0x03	; 3
     d76:	8e e2       	ldi	r24, 0x2E	; 46
     d78:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(steering_ov);
     d7a:	ba d4       	rcall	.+2420   	; 0x16f0 <_ZN5USART5printEPKc>
     d7c:	60 91 fa 03 	lds	r22, 0x03FA	; 0x8003fa <steering_ov>
     d80:	70 e0       	ldi	r23, 0x00	; 0
     d82:	8e e2       	ldi	r24, 0x2E	; 46
     d84:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" steering_delta = ");
     d86:	d8 d4       	rcall	.+2480   	; 0x1738 <_ZN5USART5printEi>
     d88:	62 e8       	ldi	r22, 0x82	; 130
     d8a:	73 e0       	ldi	r23, 0x03	; 3
     d8c:	8e e2       	ldi	r24, 0x2E	; 46
     d8e:	94 e0       	ldi	r25, 0x04	; 4
     d90:	af d4       	rcall	.+2398   	; 0x16f0 <_ZN5USART5printEPKc>
	Serial.println(steering_delta);
     d92:	60 91 03 04 	lds	r22, 0x0403	; 0x800403 <steering_delta>
     d96:	70 91 04 04 	lds	r23, 0x0404	; 0x800404 <steering_delta+0x1>
     d9a:	8e e2       	ldi	r24, 0x2E	; 46
     d9c:	94 e0       	ldi	r25, 0x04	; 4
     d9e:	ef c4       	rjmp	.+2526   	; 0x177e <_ZN5USART7printlnEi>
     da0:	08 95       	ret

00000da2 <_Z13updateCurtissv>:
     da2:	2f e0       	ldi	r18, 0x0F	; 15

/*
*read the Curtis CAN_BUS. because interrupt pin currently isn't working, we just update our variables with the latest message every tick, irregardless if it is new or old.
*/
void updateCurtiss(){
	CAN_Curt.readMsgBuf(&rxId_Curt, &len_Curt, rxBuf_Curt);	// Read data: len = data length, buf = data byte(s)
     da4:	34 e0       	ldi	r19, 0x04	; 4
     da6:	47 e1       	ldi	r20, 0x17	; 23
     da8:	54 e0       	ldi	r21, 0x04	; 4
     daa:	68 e1       	ldi	r22, 0x18	; 24
     dac:	74 e0       	ldi	r23, 0x04	; 4
     dae:	8c e1       	ldi	r24, 0x1C	; 28
     db0:	94 e0       	ldi	r25, 0x04	; 4
     db2:	11 d4       	rcall	.+2082   	; 0x15d6 <_ZN7MCP_CAN10readMsgBufEPmPhS1_>
	if((rxId_Curt & 0x40000000) == 0x40000000)					//Ignore remote requests
     db4:	80 91 18 04 	lds	r24, 0x0418	; 0x800418 <rxId_Curt>
     db8:	90 91 19 04 	lds	r25, 0x0419	; 0x800419 <rxId_Curt+0x1>
     dbc:	a0 91 1a 04 	lds	r26, 0x041A	; 0x80041a <rxId_Curt+0x2>
     dc0:	b0 91 1b 04 	lds	r27, 0x041B	; 0x80041b <rxId_Curt+0x3>
     dc4:	b6 fd       	sbrc	r27, 6
     dc6:	36 c0       	rjmp	.+108    	; 0xe34 <_Z13updateCurtissv+0x92>
		return;	
	//disassemble the message to the values and assign them to the corresponding variable
	low_voltage = rxBuf_Curt[0] + (rxBuf_Curt[1] * 256);
     dc8:	ef e0       	ldi	r30, 0x0F	; 15
     dca:	f4 e0       	ldi	r31, 0x04	; 4
     dcc:	81 81       	ldd	r24, Z+1	; 0x01
     dce:	90 e0       	ldi	r25, 0x00	; 0
     dd0:	98 2f       	mov	r25, r24
     dd2:	88 27       	eor	r24, r24
     dd4:	20 81       	ld	r18, Z
     dd6:	82 0f       	add	r24, r18
     dd8:	91 1d       	adc	r25, r1
     dda:	90 93 f1 03 	sts	0x03F1, r25	; 0x8003f1 <low_voltage+0x1>
     dde:	80 93 f0 03 	sts	0x03F0, r24	; 0x8003f0 <low_voltage>
	engine_rpm = rxBuf_Curt[2] + (rxBuf_Curt[3] * 256);
     de2:	83 81       	ldd	r24, Z+3	; 0x03
     de4:	90 e0       	ldi	r25, 0x00	; 0
     de6:	98 2f       	mov	r25, r24
     de8:	88 27       	eor	r24, r24
     dea:	22 81       	ldd	r18, Z+2	; 0x02
     dec:	82 0f       	add	r24, r18
     dee:	91 1d       	adc	r25, r1
     df0:	90 93 ef 03 	sts	0x03EF, r25	; 0x8003ef <engine_rpm+0x1>
     df4:	80 93 ee 03 	sts	0x03EE, r24	; 0x8003ee <engine_rpm>
	engine_temp = rxBuf_Curt[4] + (rxBuf_Curt[5] * 256);
     df8:	85 81       	ldd	r24, Z+5	; 0x05
     dfa:	90 e0       	ldi	r25, 0x00	; 0
     dfc:	98 2f       	mov	r25, r24
     dfe:	88 27       	eor	r24, r24
     e00:	24 81       	ldd	r18, Z+4	; 0x04
     e02:	82 0f       	add	r24, r18
     e04:	91 1d       	adc	r25, r1
     e06:	90 93 ed 03 	sts	0x03ED, r25	; 0x8003ed <engine_temp+0x1>
     e0a:	80 93 ec 03 	sts	0x03EC, r24	; 0x8003ec <engine_temp>
	control_temp = rxBuf_Curt[6] + (rxBuf_Curt[7] * 256);
     e0e:	87 81       	ldd	r24, Z+7	; 0x07
     e10:	90 e0       	ldi	r25, 0x00	; 0
     e12:	98 2f       	mov	r25, r24
     e14:	88 27       	eor	r24, r24
     e16:	26 81       	ldd	r18, Z+6	; 0x06
     e18:	ac 01       	movw	r20, r24
     e1a:	42 0f       	add	r20, r18
     e1c:	51 1d       	adc	r21, r1
     e1e:	50 93 eb 03 	sts	0x03EB, r21	; 0x8003eb <control_temp+0x1>
     e22:	40 93 ea 03 	sts	0x03EA, r20	; 0x8003ea <control_temp>
	high_voltage = rxBuf_Curt[8] + (rxBuf_Curt[7] * 256);	
     e26:	20 85       	ldd	r18, Z+8	; 0x08
     e28:	82 0f       	add	r24, r18
     e2a:	91 1d       	adc	r25, r1
     e2c:	90 93 e9 03 	sts	0x03E9, r25	; 0x8003e9 <__data_end+0x1>
     e30:	80 93 e8 03 	sts	0x03E8, r24	; 0x8003e8 <__data_end>
     e34:	08 95       	ret

00000e36 <main>:
unsigned char len_Curt;
unsigned char rxBuf_Curt[8];
char msgString_Curt[128]; 

int main(void){
	Serial.println("Alley Hoop V2.1");
     e36:	65 e9       	ldi	r22, 0x95	; 149
     e38:	73 e0       	ldi	r23, 0x03	; 3
     e3a:	8e e2       	ldi	r24, 0x2E	; 46
     e3c:	94 e0       	ldi	r25, 0x04	; 4
     e3e:	71 d4       	rcall	.+2274   	; 0x1722 <_ZN5USART7printlnEPKc>
	initIO();																									//initializes the IO pins
     e40:	b6 dc       	rcall	.-1684   	; 0x7ae <_Z6initIOv>
	initDrive();																								//detect steering modus
     e42:	d8 d9       	rcall	.-3152   	; 0x1f4 <_Z9initDrivev>
     e44:	60 e0       	ldi	r22, 0x00	; 0
	digitalWrite(34,LOW);																						//temporary for the old PCB, as the line isn't pulled down making it impossible to turn off the arduino
     e46:	82 e2       	ldi	r24, 0x22	; 34
     e48:	90 e0       	ldi	r25, 0x00	; 0
     e4a:	ba dd       	rcall	.-1164   	; 0x9c0 <_Z12digitalWriteib>
     e4c:	21 e0       	ldi	r18, 0x01	; 1
	if(CAN_Curt.begin(MCP_ANY, CAN_500KBPS, MCP_16MHZ) == CAN_OK)												//initialize the CAN BUS
     e4e:	4d e0       	ldi	r20, 0x0D	; 13
     e50:	63 e0       	ldi	r22, 0x03	; 3
     e52:	8c e1       	ldi	r24, 0x1C	; 28
     e54:	94 e0       	ldi	r25, 0x04	; 4
     e56:	85 d3       	rcall	.+1802   	; 0x1562 <_ZN7MCP_CAN5beginEhhh>
     e58:	81 11       	cpse	r24, r1
     e5a:	06 c0       	rjmp	.+12     	; 0xe68 <main+0x32>
     e5c:	65 ea       	ldi	r22, 0xA5	; 165
		Serial.println("MCP2515 Initialized Successfully!");
     e5e:	73 e0       	ldi	r23, 0x03	; 3
     e60:	8e e2       	ldi	r24, 0x2E	; 46
     e62:	94 e0       	ldi	r25, 0x04	; 4
     e64:	5e d4       	rcall	.+2236   	; 0x1722 <_ZN5USART7printlnEPKc>
     e66:	05 c0       	rjmp	.+10     	; 0xe72 <main+0x3c>
     e68:	67 ec       	ldi	r22, 0xC7	; 199
	else
		Serial.println("Error Initializing MCP2515...");
     e6a:	73 e0       	ldi	r23, 0x03	; 3
     e6c:	8e e2       	ldi	r24, 0x2E	; 46
     e6e:	94 e0       	ldi	r25, 0x04	; 4
     e70:	58 d4       	rcall	.+2224   	; 0x1722 <_ZN5USART7printlnEPKc>
	CAN_Curt.setMode(MCP_NORMAL);																				//Set operation mode to normal so the MCP2515 sends acknowledge packages to received data. (currently not operational because we can't use the interrupt
     e72:	60 e0       	ldi	r22, 0x00	; 0
     e74:	8c e1       	ldi	r24, 0x1C	; 28
     e76:	94 e0       	ldi	r25, 0x04	; 4
     e78:	d5 d1       	rcall	.+938    	; 0x1224 <_ZN7MCP_CAN7setModeEh>
     e7a:	93 df       	rcall	.-218    	; 0xda2 <_Z13updateCurtissv>

	while (1){																									//main program loop	
		updateCurtiss();																						//update the values retrieved from the Curtis
     e7c:	4f dc       	rcall	.-1890   	; 0x71c <_Z5drivev>
     e7e:	2b df       	rcall	.-426    	; 0xcd6 <_Z9printinfov>
		drive();																								//update the values send to various components
     e80:	fc cf       	rjmp	.-8      	; 0xe7a <main+0x44>

00000e82 <_GLOBAL__sub_I_Serial>:
     e82:	8e e2       	ldi	r24, 0x2E	; 46
		#ifdef DEBUG_MODE
			printinfo();																						//print info in the terminal, only when debug mode is enabled
     e84:	94 e0       	ldi	r25, 0x04	; 4
     e86:	29 d4       	rcall	.+2130   	; 0x16da <_ZN5USARTC1Ev>
     e88:	6f e2       	ldi	r22, 0x2F	; 47
#include "overhead.h"																							//defines and standard includes
#include "Drive.h"																								//takes care of driving the car

USART Serial;																									//initialize Serial communication 
MCP_CAN CAN_Curt(47);																							//create the CURTIS CAN BUS
     e8a:	8c e1       	ldi	r24, 0x1C	; 28
     e8c:	94 e0       	ldi	r25, 0x04	; 4
     e8e:	5c c3       	rjmp	.+1720   	; 0x1548 <_ZN7MCP_CANC1Eh>
     e90:	08 95       	ret

00000e92 <_ZN7MCP_CAN13mcp2515_resetEv>:
		tbufdata[MCP_EID0] = 0;
		tbufdata[MCP_EID8] = 0;
	}

	mcp2515_setRegisterS( mcp_addr, tbufdata, 4 );
}
     e92:	0f 93       	push	r16
     e94:	1f 93       	push	r17
     e96:	cf 93       	push	r28
     e98:	df 93       	push	r29
     e9a:	1f 92       	push	r1
     e9c:	1f 92       	push	r1
     e9e:	cd b7       	in	r28, 0x3d	; 61
     ea0:	de b7       	in	r29, 0x3e	; 62
     ea2:	00 e0       	ldi	r16, 0x00	; 0
     ea4:	21 e0       	ldi	r18, 0x01	; 1
     ea6:	40 e8       	ldi	r20, 0x80	; 128
     ea8:	56 e9       	ldi	r21, 0x96	; 150
     eaa:	68 e9       	ldi	r22, 0x98	; 152
     eac:	70 e0       	ldi	r23, 0x00	; 0
     eae:	ce 01       	movw	r24, r28
     eb0:	01 96       	adiw	r24, 0x01	; 1
     eb2:	e3 d3       	rcall	.+1990   	; 0x167a <_ZN11SPISettingsC1Emhh>
     eb4:	be 01       	movw	r22, r28
     eb6:	6f 5f       	subi	r22, 0xFF	; 255
     eb8:	7f 4f       	sbci	r23, 0xFF	; 255
     eba:	80 e3       	ldi	r24, 0x30	; 48
     ebc:	94 e0       	ldi	r25, 0x04	; 4
     ebe:	01 d4       	rcall	.+2050   	; 0x16c2 <_ZN8SPIClass16beginTransactionE11SPISettings>
     ec0:	0b e0       	ldi	r16, 0x0B	; 11
     ec2:	11 e0       	ldi	r17, 0x01	; 1
     ec4:	f8 01       	movw	r30, r16
     ec6:	80 81       	ld	r24, Z
     ec8:	8b 7f       	andi	r24, 0xFB	; 251
     eca:	80 83       	st	Z, r24
     ecc:	60 ec       	ldi	r22, 0xC0	; 192
     ece:	80 e3       	ldi	r24, 0x30	; 48
     ed0:	94 e0       	ldi	r25, 0x04	; 4
     ed2:	fd d3       	rcall	.+2042   	; 0x16ce <_ZN8SPIClass8transferEh>
     ed4:	f8 01       	movw	r30, r16
     ed6:	80 81       	ld	r24, Z
     ed8:	84 60       	ori	r24, 0x04	; 4
     eda:	80 83       	st	Z, r24
     edc:	8f e9       	ldi	r24, 0x9F	; 159
     ede:	9f e0       	ldi	r25, 0x0F	; 15
     ee0:	01 97       	sbiw	r24, 0x01	; 1
     ee2:	f1 f7       	brne	.-4      	; 0xee0 <_ZN7MCP_CAN13mcp2515_resetEv+0x4e>
     ee4:	00 c0       	rjmp	.+0      	; 0xee6 <_ZN7MCP_CAN13mcp2515_resetEv+0x54>
     ee6:	00 00       	nop
     ee8:	0f 90       	pop	r0
     eea:	0f 90       	pop	r0
     eec:	df 91       	pop	r29
     eee:	cf 91       	pop	r28
     ef0:	1f 91       	pop	r17
     ef2:	0f 91       	pop	r16
     ef4:	08 95       	ret

00000ef6 <_ZN7MCP_CAN20mcp2515_readRegisterEh>:
     ef6:	ff 92       	push	r15
     ef8:	0f 93       	push	r16
     efa:	1f 93       	push	r17
     efc:	cf 93       	push	r28
     efe:	df 93       	push	r29
     f00:	1f 92       	push	r1
     f02:	1f 92       	push	r1
     f04:	cd b7       	in	r28, 0x3d	; 61
     f06:	de b7       	in	r29, 0x3e	; 62
     f08:	f6 2e       	mov	r15, r22
     f0a:	00 e0       	ldi	r16, 0x00	; 0
     f0c:	21 e0       	ldi	r18, 0x01	; 1
     f0e:	40 e8       	ldi	r20, 0x80	; 128
     f10:	56 e9       	ldi	r21, 0x96	; 150
     f12:	68 e9       	ldi	r22, 0x98	; 152
     f14:	70 e0       	ldi	r23, 0x00	; 0
     f16:	ce 01       	movw	r24, r28
     f18:	01 96       	adiw	r24, 0x01	; 1
     f1a:	af d3       	rcall	.+1886   	; 0x167a <_ZN11SPISettingsC1Emhh>
     f1c:	be 01       	movw	r22, r28
     f1e:	6f 5f       	subi	r22, 0xFF	; 255
     f20:	7f 4f       	sbci	r23, 0xFF	; 255
     f22:	80 e3       	ldi	r24, 0x30	; 48
     f24:	94 e0       	ldi	r25, 0x04	; 4
     f26:	cd d3       	rcall	.+1946   	; 0x16c2 <_ZN8SPIClass16beginTransactionE11SPISettings>
     f28:	0b e0       	ldi	r16, 0x0B	; 11
     f2a:	11 e0       	ldi	r17, 0x01	; 1
     f2c:	f8 01       	movw	r30, r16
     f2e:	80 81       	ld	r24, Z
     f30:	8b 7f       	andi	r24, 0xFB	; 251
     f32:	80 83       	st	Z, r24
     f34:	63 e0       	ldi	r22, 0x03	; 3
     f36:	80 e3       	ldi	r24, 0x30	; 48
     f38:	94 e0       	ldi	r25, 0x04	; 4
     f3a:	c9 d3       	rcall	.+1938   	; 0x16ce <_ZN8SPIClass8transferEh>
     f3c:	6f 2d       	mov	r22, r15
     f3e:	80 e3       	ldi	r24, 0x30	; 48
     f40:	94 e0       	ldi	r25, 0x04	; 4
     f42:	c5 d3       	rcall	.+1930   	; 0x16ce <_ZN8SPIClass8transferEh>
     f44:	60 e0       	ldi	r22, 0x00	; 0
     f46:	80 e3       	ldi	r24, 0x30	; 48
     f48:	94 e0       	ldi	r25, 0x04	; 4
     f4a:	c1 d3       	rcall	.+1922   	; 0x16ce <_ZN8SPIClass8transferEh>
     f4c:	f8 01       	movw	r30, r16
     f4e:	90 81       	ld	r25, Z
     f50:	94 60       	ori	r25, 0x04	; 4
     f52:	90 83       	st	Z, r25
     f54:	0f 90       	pop	r0
     f56:	0f 90       	pop	r0
     f58:	df 91       	pop	r29
     f5a:	cf 91       	pop	r28
     f5c:	1f 91       	pop	r17
     f5e:	0f 91       	pop	r16
     f60:	ff 90       	pop	r15
     f62:	08 95       	ret

00000f64 <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh>:
     f64:	cf 92       	push	r12
     f66:	df 92       	push	r13
     f68:	ef 92       	push	r14
     f6a:	ff 92       	push	r15
     f6c:	0f 93       	push	r16
     f6e:	1f 93       	push	r17
     f70:	cf 93       	push	r28
     f72:	df 93       	push	r29
     f74:	1f 92       	push	r1
     f76:	1f 92       	push	r1
     f78:	cd b7       	in	r28, 0x3d	; 61
     f7a:	de b7       	in	r29, 0x3e	; 62
     f7c:	16 2f       	mov	r17, r22
     f7e:	6a 01       	movw	r12, r20
     f80:	f2 2e       	mov	r15, r18
     f82:	00 e0       	ldi	r16, 0x00	; 0
     f84:	21 e0       	ldi	r18, 0x01	; 1
     f86:	40 e8       	ldi	r20, 0x80	; 128
     f88:	56 e9       	ldi	r21, 0x96	; 150
     f8a:	68 e9       	ldi	r22, 0x98	; 152
     f8c:	70 e0       	ldi	r23, 0x00	; 0
     f8e:	ce 01       	movw	r24, r28
     f90:	01 96       	adiw	r24, 0x01	; 1
     f92:	73 d3       	rcall	.+1766   	; 0x167a <_ZN11SPISettingsC1Emhh>
     f94:	be 01       	movw	r22, r28
     f96:	6f 5f       	subi	r22, 0xFF	; 255
     f98:	7f 4f       	sbci	r23, 0xFF	; 255
     f9a:	80 e3       	ldi	r24, 0x30	; 48
     f9c:	94 e0       	ldi	r25, 0x04	; 4
     f9e:	91 d3       	rcall	.+1826   	; 0x16c2 <_ZN8SPIClass16beginTransactionE11SPISettings>
     fa0:	eb e0       	ldi	r30, 0x0B	; 11
     fa2:	f1 e0       	ldi	r31, 0x01	; 1
     fa4:	80 81       	ld	r24, Z
     fa6:	8b 7f       	andi	r24, 0xFB	; 251
     fa8:	80 83       	st	Z, r24
     faa:	63 e0       	ldi	r22, 0x03	; 3
     fac:	80 e3       	ldi	r24, 0x30	; 48
     fae:	94 e0       	ldi	r25, 0x04	; 4
     fb0:	8e d3       	rcall	.+1820   	; 0x16ce <_ZN8SPIClass8transferEh>
     fb2:	61 2f       	mov	r22, r17
     fb4:	80 e3       	ldi	r24, 0x30	; 48
     fb6:	94 e0       	ldi	r25, 0x04	; 4
     fb8:	8a d3       	rcall	.+1812   	; 0x16ce <_ZN8SPIClass8transferEh>
     fba:	ff 20       	and	r15, r15
     fbc:	99 f0       	breq	.+38     	; 0xfe4 <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh+0x80>
     fbe:	86 01       	movw	r16, r12
     fc0:	fa 94       	dec	r15
     fc2:	ef 2c       	mov	r14, r15
     fc4:	f1 2c       	mov	r15, r1
     fc6:	8f ef       	ldi	r24, 0xFF	; 255
     fc8:	e8 1a       	sub	r14, r24
     fca:	f8 0a       	sbc	r15, r24
     fcc:	ec 0c       	add	r14, r12
     fce:	fd 1c       	adc	r15, r13
     fd0:	60 e0       	ldi	r22, 0x00	; 0
     fd2:	80 e3       	ldi	r24, 0x30	; 48
     fd4:	94 e0       	ldi	r25, 0x04	; 4
     fd6:	7b d3       	rcall	.+1782   	; 0x16ce <_ZN8SPIClass8transferEh>
     fd8:	f8 01       	movw	r30, r16
     fda:	81 93       	st	Z+, r24
     fdc:	8f 01       	movw	r16, r30
     fde:	ee 15       	cp	r30, r14
     fe0:	ff 05       	cpc	r31, r15
     fe2:	b1 f7       	brne	.-20     	; 0xfd0 <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh+0x6c>
     fe4:	eb e0       	ldi	r30, 0x0B	; 11
     fe6:	f1 e0       	ldi	r31, 0x01	; 1
     fe8:	80 81       	ld	r24, Z
     fea:	84 60       	ori	r24, 0x04	; 4
     fec:	80 83       	st	Z, r24
     fee:	0f 90       	pop	r0
     ff0:	0f 90       	pop	r0
     ff2:	df 91       	pop	r29
     ff4:	cf 91       	pop	r28
     ff6:	1f 91       	pop	r17
     ff8:	0f 91       	pop	r16
     ffa:	ff 90       	pop	r15
     ffc:	ef 90       	pop	r14
     ffe:	df 90       	pop	r13
    1000:	cf 90       	pop	r12
    1002:	08 95       	ret

00001004 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>:
    1004:	ef 92       	push	r14
    1006:	ff 92       	push	r15
    1008:	0f 93       	push	r16
    100a:	1f 93       	push	r17
    100c:	cf 93       	push	r28
    100e:	df 93       	push	r29
    1010:	1f 92       	push	r1
    1012:	1f 92       	push	r1
    1014:	cd b7       	in	r28, 0x3d	; 61
    1016:	de b7       	in	r29, 0x3e	; 62
    1018:	e6 2e       	mov	r14, r22
    101a:	f4 2e       	mov	r15, r20
    101c:	00 e0       	ldi	r16, 0x00	; 0
    101e:	21 e0       	ldi	r18, 0x01	; 1
    1020:	40 e8       	ldi	r20, 0x80	; 128
    1022:	56 e9       	ldi	r21, 0x96	; 150
    1024:	68 e9       	ldi	r22, 0x98	; 152
    1026:	70 e0       	ldi	r23, 0x00	; 0
    1028:	ce 01       	movw	r24, r28
    102a:	01 96       	adiw	r24, 0x01	; 1
    102c:	26 d3       	rcall	.+1612   	; 0x167a <_ZN11SPISettingsC1Emhh>
    102e:	be 01       	movw	r22, r28
    1030:	6f 5f       	subi	r22, 0xFF	; 255
    1032:	7f 4f       	sbci	r23, 0xFF	; 255
    1034:	80 e3       	ldi	r24, 0x30	; 48
    1036:	94 e0       	ldi	r25, 0x04	; 4
    1038:	44 d3       	rcall	.+1672   	; 0x16c2 <_ZN8SPIClass16beginTransactionE11SPISettings>
    103a:	0b e0       	ldi	r16, 0x0B	; 11
    103c:	11 e0       	ldi	r17, 0x01	; 1
    103e:	f8 01       	movw	r30, r16
    1040:	80 81       	ld	r24, Z
    1042:	8b 7f       	andi	r24, 0xFB	; 251
    1044:	80 83       	st	Z, r24
    1046:	62 e0       	ldi	r22, 0x02	; 2
    1048:	80 e3       	ldi	r24, 0x30	; 48
    104a:	94 e0       	ldi	r25, 0x04	; 4
    104c:	40 d3       	rcall	.+1664   	; 0x16ce <_ZN8SPIClass8transferEh>
    104e:	6e 2d       	mov	r22, r14
    1050:	80 e3       	ldi	r24, 0x30	; 48
    1052:	94 e0       	ldi	r25, 0x04	; 4
    1054:	3c d3       	rcall	.+1656   	; 0x16ce <_ZN8SPIClass8transferEh>
    1056:	6f 2d       	mov	r22, r15
    1058:	80 e3       	ldi	r24, 0x30	; 48
    105a:	94 e0       	ldi	r25, 0x04	; 4
    105c:	38 d3       	rcall	.+1648   	; 0x16ce <_ZN8SPIClass8transferEh>
    105e:	f8 01       	movw	r30, r16
    1060:	80 81       	ld	r24, Z
    1062:	84 60       	ori	r24, 0x04	; 4
    1064:	80 83       	st	Z, r24
    1066:	0f 90       	pop	r0
    1068:	0f 90       	pop	r0
    106a:	df 91       	pop	r29
    106c:	cf 91       	pop	r28
    106e:	1f 91       	pop	r17
    1070:	0f 91       	pop	r16
    1072:	ff 90       	pop	r15
    1074:	ef 90       	pop	r14
    1076:	08 95       	ret

00001078 <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh>:
    1078:	cf 92       	push	r12
    107a:	df 92       	push	r13
    107c:	ef 92       	push	r14
    107e:	ff 92       	push	r15
    1080:	0f 93       	push	r16
    1082:	1f 93       	push	r17
    1084:	cf 93       	push	r28
    1086:	df 93       	push	r29
    1088:	1f 92       	push	r1
    108a:	1f 92       	push	r1
    108c:	cd b7       	in	r28, 0x3d	; 61
    108e:	de b7       	in	r29, 0x3e	; 62
    1090:	16 2f       	mov	r17, r22
    1092:	6a 01       	movw	r12, r20
    1094:	f2 2e       	mov	r15, r18
    1096:	00 e0       	ldi	r16, 0x00	; 0
    1098:	21 e0       	ldi	r18, 0x01	; 1
    109a:	40 e8       	ldi	r20, 0x80	; 128
    109c:	56 e9       	ldi	r21, 0x96	; 150
    109e:	68 e9       	ldi	r22, 0x98	; 152
    10a0:	70 e0       	ldi	r23, 0x00	; 0
    10a2:	ce 01       	movw	r24, r28
    10a4:	01 96       	adiw	r24, 0x01	; 1
    10a6:	e9 d2       	rcall	.+1490   	; 0x167a <_ZN11SPISettingsC1Emhh>
    10a8:	be 01       	movw	r22, r28
    10aa:	6f 5f       	subi	r22, 0xFF	; 255
    10ac:	7f 4f       	sbci	r23, 0xFF	; 255
    10ae:	80 e3       	ldi	r24, 0x30	; 48
    10b0:	94 e0       	ldi	r25, 0x04	; 4
    10b2:	07 d3       	rcall	.+1550   	; 0x16c2 <_ZN8SPIClass16beginTransactionE11SPISettings>
    10b4:	eb e0       	ldi	r30, 0x0B	; 11
    10b6:	f1 e0       	ldi	r31, 0x01	; 1
    10b8:	80 81       	ld	r24, Z
    10ba:	8b 7f       	andi	r24, 0xFB	; 251
    10bc:	80 83       	st	Z, r24
    10be:	62 e0       	ldi	r22, 0x02	; 2
    10c0:	80 e3       	ldi	r24, 0x30	; 48
    10c2:	94 e0       	ldi	r25, 0x04	; 4
    10c4:	04 d3       	rcall	.+1544   	; 0x16ce <_ZN8SPIClass8transferEh>
    10c6:	61 2f       	mov	r22, r17
    10c8:	80 e3       	ldi	r24, 0x30	; 48
    10ca:	94 e0       	ldi	r25, 0x04	; 4
    10cc:	00 d3       	rcall	.+1536   	; 0x16ce <_ZN8SPIClass8transferEh>
    10ce:	ff 20       	and	r15, r15
    10d0:	91 f0       	breq	.+36     	; 0x10f6 <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh+0x7e>
    10d2:	86 01       	movw	r16, r12
    10d4:	fa 94       	dec	r15
    10d6:	ef 2c       	mov	r14, r15
    10d8:	f1 2c       	mov	r15, r1
    10da:	8f ef       	ldi	r24, 0xFF	; 255
    10dc:	e8 1a       	sub	r14, r24
    10de:	f8 0a       	sbc	r15, r24
    10e0:	ec 0c       	add	r14, r12
    10e2:	fd 1c       	adc	r15, r13
    10e4:	f8 01       	movw	r30, r16
    10e6:	61 91       	ld	r22, Z+
    10e8:	8f 01       	movw	r16, r30
    10ea:	80 e3       	ldi	r24, 0x30	; 48
    10ec:	94 e0       	ldi	r25, 0x04	; 4
    10ee:	ef d2       	rcall	.+1502   	; 0x16ce <_ZN8SPIClass8transferEh>
    10f0:	0e 15       	cp	r16, r14
    10f2:	1f 05       	cpc	r17, r15
    10f4:	b9 f7       	brne	.-18     	; 0x10e4 <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh+0x6c>
    10f6:	eb e0       	ldi	r30, 0x0B	; 11
    10f8:	f1 e0       	ldi	r31, 0x01	; 1
    10fa:	80 81       	ld	r24, Z
    10fc:	84 60       	ori	r24, 0x04	; 4
    10fe:	80 83       	st	Z, r24
    1100:	0f 90       	pop	r0
    1102:	0f 90       	pop	r0
    1104:	df 91       	pop	r29
    1106:	cf 91       	pop	r28
    1108:	1f 91       	pop	r17
    110a:	0f 91       	pop	r16
    110c:	ff 90       	pop	r15
    110e:	ef 90       	pop	r14
    1110:	df 90       	pop	r13
    1112:	cf 90       	pop	r12
    1114:	08 95       	ret

00001116 <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>:
    1116:	df 92       	push	r13
    1118:	ef 92       	push	r14
    111a:	ff 92       	push	r15
    111c:	0f 93       	push	r16
    111e:	1f 93       	push	r17
    1120:	cf 93       	push	r28
    1122:	df 93       	push	r29
    1124:	1f 92       	push	r1
    1126:	1f 92       	push	r1
    1128:	cd b7       	in	r28, 0x3d	; 61
    112a:	de b7       	in	r29, 0x3e	; 62
    112c:	d6 2e       	mov	r13, r22
    112e:	e4 2e       	mov	r14, r20
    1130:	f2 2e       	mov	r15, r18
    1132:	00 e0       	ldi	r16, 0x00	; 0
    1134:	21 e0       	ldi	r18, 0x01	; 1
    1136:	40 e8       	ldi	r20, 0x80	; 128
    1138:	56 e9       	ldi	r21, 0x96	; 150
    113a:	68 e9       	ldi	r22, 0x98	; 152
    113c:	70 e0       	ldi	r23, 0x00	; 0
    113e:	ce 01       	movw	r24, r28
    1140:	01 96       	adiw	r24, 0x01	; 1
    1142:	9b d2       	rcall	.+1334   	; 0x167a <_ZN11SPISettingsC1Emhh>
    1144:	be 01       	movw	r22, r28
    1146:	6f 5f       	subi	r22, 0xFF	; 255
    1148:	7f 4f       	sbci	r23, 0xFF	; 255
    114a:	80 e3       	ldi	r24, 0x30	; 48
    114c:	94 e0       	ldi	r25, 0x04	; 4
    114e:	b9 d2       	rcall	.+1394   	; 0x16c2 <_ZN8SPIClass16beginTransactionE11SPISettings>
    1150:	0b e0       	ldi	r16, 0x0B	; 11
    1152:	11 e0       	ldi	r17, 0x01	; 1
    1154:	f8 01       	movw	r30, r16
    1156:	80 81       	ld	r24, Z
    1158:	8b 7f       	andi	r24, 0xFB	; 251
    115a:	80 83       	st	Z, r24
    115c:	65 e0       	ldi	r22, 0x05	; 5
    115e:	80 e3       	ldi	r24, 0x30	; 48
    1160:	94 e0       	ldi	r25, 0x04	; 4
    1162:	b5 d2       	rcall	.+1386   	; 0x16ce <_ZN8SPIClass8transferEh>
    1164:	6d 2d       	mov	r22, r13
    1166:	80 e3       	ldi	r24, 0x30	; 48
    1168:	94 e0       	ldi	r25, 0x04	; 4
    116a:	b1 d2       	rcall	.+1378   	; 0x16ce <_ZN8SPIClass8transferEh>
    116c:	6e 2d       	mov	r22, r14
    116e:	80 e3       	ldi	r24, 0x30	; 48
    1170:	94 e0       	ldi	r25, 0x04	; 4
    1172:	ad d2       	rcall	.+1370   	; 0x16ce <_ZN8SPIClass8transferEh>
    1174:	6f 2d       	mov	r22, r15
    1176:	80 e3       	ldi	r24, 0x30	; 48
    1178:	94 e0       	ldi	r25, 0x04	; 4
    117a:	a9 d2       	rcall	.+1362   	; 0x16ce <_ZN8SPIClass8transferEh>
    117c:	f8 01       	movw	r30, r16
    117e:	80 81       	ld	r24, Z
    1180:	84 60       	ori	r24, 0x04	; 4
    1182:	80 83       	st	Z, r24
    1184:	0f 90       	pop	r0
    1186:	0f 90       	pop	r0
    1188:	df 91       	pop	r29
    118a:	cf 91       	pop	r28
    118c:	1f 91       	pop	r17
    118e:	0f 91       	pop	r16
    1190:	ff 90       	pop	r15
    1192:	ef 90       	pop	r14
    1194:	df 90       	pop	r13
    1196:	08 95       	ret

00001198 <_ZN7MCP_CAN18mcp2515_readStatusEv>:
    1198:	0f 93       	push	r16
    119a:	1f 93       	push	r17
    119c:	cf 93       	push	r28
    119e:	df 93       	push	r29
    11a0:	1f 92       	push	r1
    11a2:	1f 92       	push	r1
    11a4:	cd b7       	in	r28, 0x3d	; 61
    11a6:	de b7       	in	r29, 0x3e	; 62
    11a8:	00 e0       	ldi	r16, 0x00	; 0
    11aa:	21 e0       	ldi	r18, 0x01	; 1
    11ac:	40 e8       	ldi	r20, 0x80	; 128
    11ae:	56 e9       	ldi	r21, 0x96	; 150
    11b0:	68 e9       	ldi	r22, 0x98	; 152
    11b2:	70 e0       	ldi	r23, 0x00	; 0
    11b4:	ce 01       	movw	r24, r28
    11b6:	01 96       	adiw	r24, 0x01	; 1
    11b8:	60 d2       	rcall	.+1216   	; 0x167a <_ZN11SPISettingsC1Emhh>
    11ba:	be 01       	movw	r22, r28
    11bc:	6f 5f       	subi	r22, 0xFF	; 255
    11be:	7f 4f       	sbci	r23, 0xFF	; 255
    11c0:	80 e3       	ldi	r24, 0x30	; 48
    11c2:	94 e0       	ldi	r25, 0x04	; 4
    11c4:	7e d2       	rcall	.+1276   	; 0x16c2 <_ZN8SPIClass16beginTransactionE11SPISettings>
    11c6:	0b e0       	ldi	r16, 0x0B	; 11
    11c8:	11 e0       	ldi	r17, 0x01	; 1
    11ca:	f8 01       	movw	r30, r16
    11cc:	80 81       	ld	r24, Z
    11ce:	8b 7f       	andi	r24, 0xFB	; 251
    11d0:	80 83       	st	Z, r24
    11d2:	60 ea       	ldi	r22, 0xA0	; 160
    11d4:	80 e3       	ldi	r24, 0x30	; 48
    11d6:	94 e0       	ldi	r25, 0x04	; 4
    11d8:	7a d2       	rcall	.+1268   	; 0x16ce <_ZN8SPIClass8transferEh>
    11da:	60 e0       	ldi	r22, 0x00	; 0
    11dc:	80 e3       	ldi	r24, 0x30	; 48
    11de:	94 e0       	ldi	r25, 0x04	; 4
    11e0:	76 d2       	rcall	.+1260   	; 0x16ce <_ZN8SPIClass8transferEh>
    11e2:	f8 01       	movw	r30, r16
    11e4:	90 81       	ld	r25, Z
    11e6:	94 60       	ori	r25, 0x04	; 4
    11e8:	90 83       	st	Z, r25
    11ea:	0f 90       	pop	r0
    11ec:	0f 90       	pop	r0
    11ee:	df 91       	pop	r29
    11f0:	cf 91       	pop	r28
    11f2:	1f 91       	pop	r17
    11f4:	0f 91       	pop	r16
    11f6:	08 95       	ret

000011f8 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>:
    11f8:	0f 93       	push	r16
    11fa:	1f 93       	push	r17
    11fc:	cf 93       	push	r28
    11fe:	8c 01       	movw	r16, r24
    1200:	c6 2f       	mov	r28, r22
    1202:	26 2f       	mov	r18, r22
    1204:	40 ee       	ldi	r20, 0xE0	; 224
    1206:	6f e0       	ldi	r22, 0x0F	; 15
    1208:	86 df       	rcall	.-244    	; 0x1116 <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    120a:	6f e0       	ldi	r22, 0x0F	; 15
    120c:	c8 01       	movw	r24, r16
    120e:	73 de       	rcall	.-794    	; 0xef6 <_ZN7MCP_CAN20mcp2515_readRegisterEh>
    1210:	98 2f       	mov	r25, r24
    1212:	90 7e       	andi	r25, 0xE0	; 224
    1214:	81 e0       	ldi	r24, 0x01	; 1
    1216:	9c 13       	cpse	r25, r28
    1218:	01 c0       	rjmp	.+2      	; 0x121c <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh+0x24>
    121a:	80 e0       	ldi	r24, 0x00	; 0
    121c:	cf 91       	pop	r28
    121e:	1f 91       	pop	r17
    1220:	0f 91       	pop	r16
    1222:	08 95       	ret

00001224 <_ZN7MCP_CAN7setModeEh>:
    1224:	fc 01       	movw	r30, r24
    1226:	61 8b       	std	Z+17, r22	; 0x11
    1228:	e7 cf       	rjmp	.-50     	; 0x11f8 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>
    122a:	08 95       	ret

0000122c <_ZN7MCP_CAN18mcp2515_configRateEhh>:
    122c:	cf 93       	push	r28
    122e:	df 93       	push	r29
    1230:	ec 01       	movw	r28, r24
    1232:	40 e4       	ldi	r20, 0x40	; 64
    1234:	6a e2       	ldi	r22, 0x2A	; 42
    1236:	e6 de       	rcall	.-564    	; 0x1004 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1238:	45 ee       	ldi	r20, 0xE5	; 229
    123a:	69 e2       	ldi	r22, 0x29	; 41
    123c:	ce 01       	movw	r24, r28
    123e:	e2 de       	rcall	.-572    	; 0x1004 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1240:	43 e8       	ldi	r20, 0x83	; 131
    1242:	68 e2       	ldi	r22, 0x28	; 40
    1244:	ce 01       	movw	r24, r28
    1246:	de de       	rcall	.-580    	; 0x1004 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1248:	80 e0       	ldi	r24, 0x00	; 0
    124a:	df 91       	pop	r29
    124c:	cf 91       	pop	r28
    124e:	08 95       	ret

00001250 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>:

/*********************************************************************************************************
** Function name:           mcp2515_write_mf
** Descriptions:            Write Masks and Filters
*********************************************************************************************************/
void MCP_CAN::mcp2515_write_mf( const uint8_t mcp_addr, const uint8_t ext, const uint32_t id ){
    1250:	0f 93       	push	r16
    1252:	1f 93       	push	r17
    1254:	cf 93       	push	r28
    1256:	df 93       	push	r29
    1258:	00 d0       	rcall	.+0      	; 0x125a <_ZN7MCP_CAN16mcp2515_write_mfEhhm+0xa>
    125a:	1f 92       	push	r1
    125c:	cd b7       	in	r28, 0x3d	; 61
    125e:	de b7       	in	r29, 0x3e	; 62
	uint16_t canid;
	uint8_t tbufdata[4];
	canid = (uint16_t)(id & 0x0FFFF);
	if ( ext == 1){
    1260:	41 30       	cpi	r20, 0x01	; 1
    1262:	c9 f4       	brne	.+50     	; 0x1296 <_ZN7MCP_CAN16mcp2515_write_mfEhhm+0x46>
		tbufdata[MCP_EID0] = (uint8_t) (canid & 0xFF);
    1264:	0c 83       	std	Y+4, r16	; 0x04
		tbufdata[MCP_EID8] = (uint8_t) (canid >> 8);
    1266:	1b 83       	std	Y+3, r17	; 0x03
		canid = (uint16_t)(id >> 16);
    1268:	89 01       	movw	r16, r18
    126a:	22 27       	eor	r18, r18
    126c:	33 27       	eor	r19, r19
		tbufdata[MCP_SIDL] = (uint8_t) (canid & 0x03);
		tbufdata[MCP_SIDL] += (uint8_t) ((canid & 0x1C) << 3);
		tbufdata[MCP_SIDL] |= MCP_TXB_EXIDE_M;
    126e:	40 2f       	mov	r20, r16
    1270:	4c 71       	andi	r20, 0x1C	; 28
    1272:	44 0f       	add	r20, r20
    1274:	44 0f       	add	r20, r20
    1276:	44 0f       	add	r20, r20
    1278:	50 2f       	mov	r21, r16
    127a:	53 70       	andi	r21, 0x03	; 3
    127c:	45 0f       	add	r20, r21
    127e:	48 60       	ori	r20, 0x08	; 8
    1280:	4a 83       	std	Y+2, r20	; 0x02
		tbufdata[MCP_SIDH] = (uint8_t) (canid >> 5 );
    1282:	16 95       	lsr	r17
    1284:	07 95       	ror	r16
    1286:	12 95       	swap	r17
    1288:	02 95       	swap	r16
    128a:	0f 70       	andi	r16, 0x0F	; 15
    128c:	01 27       	eor	r16, r17
    128e:	1f 70       	andi	r17, 0x0F	; 15
    1290:	01 27       	eor	r16, r17
    1292:	09 83       	std	Y+1, r16	; 0x01
    1294:	11 c0       	rjmp	.+34     	; 0x12b8 <_ZN7MCP_CAN16mcp2515_write_mfEhhm+0x68>
	} else {
		tbufdata[MCP_EID0] = (uint8_t) (canid & 0xFF);
    1296:	0c 83       	std	Y+4, r16	; 0x04
		tbufdata[MCP_EID8] = (uint8_t) (canid >> 8);
    1298:	1b 83       	std	Y+3, r17	; 0x03
		canid = (uint16_t)(id >> 16);
    129a:	89 01       	movw	r16, r18
    129c:	22 27       	eor	r18, r18
    129e:	33 27       	eor	r19, r19
		tbufdata[MCP_SIDL] = (uint8_t) ((canid & 0x07) << 5);
    12a0:	40 2f       	mov	r20, r16
    12a2:	42 95       	swap	r20
    12a4:	44 0f       	add	r20, r20
    12a6:	40 7e       	andi	r20, 0xE0	; 224
    12a8:	4a 83       	std	Y+2, r20	; 0x02
		tbufdata[MCP_SIDH] = (uint8_t) (canid >> 3 );
    12aa:	16 95       	lsr	r17
    12ac:	07 95       	ror	r16
    12ae:	16 95       	lsr	r17
    12b0:	07 95       	ror	r16
    12b2:	16 95       	lsr	r17
    12b4:	07 95       	ror	r16
    12b6:	09 83       	std	Y+1, r16	; 0x01
	}
	mcp2515_setRegisterS( mcp_addr, tbufdata, 4 );
    12b8:	24 e0       	ldi	r18, 0x04	; 4
    12ba:	ae 01       	movw	r20, r28
    12bc:	4f 5f       	subi	r20, 0xFF	; 255
    12be:	5f 4f       	sbci	r21, 0xFF	; 255
    12c0:	db de       	rcall	.-586    	; 0x1078 <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh>
}
    12c2:	0f 90       	pop	r0
    12c4:	0f 90       	pop	r0
    12c6:	0f 90       	pop	r0
    12c8:	0f 90       	pop	r0
    12ca:	df 91       	pop	r29
    12cc:	cf 91       	pop	r28
    12ce:	1f 91       	pop	r17
    12d0:	0f 91       	pop	r16
    12d2:	08 95       	ret

000012d4 <_ZN7MCP_CAN22mcp2515_initCANBuffersEv>:

/*********************************************************************************************************
** Function name:           mcp2515_initCANBuffers
** Descriptions:            Initialize Buffers, Masks, and Filters
*********************************************************************************************************/
void MCP_CAN::mcp2515_initCANBuffers(void){
    12d4:	ef 92       	push	r14
    12d6:	ff 92       	push	r15
    12d8:	0f 93       	push	r16
    12da:	1f 93       	push	r17
    12dc:	cf 93       	push	r28
    12de:	7c 01       	movw	r14, r24
	uint8_t std = 0;
	uint8_t ext = 1;
	uint32_t ulMask = 0x00, ulFilt = 0x00;


	mcp2515_write_mf(MCP_RXM0SIDH, ext, ulMask);			/*Set both masks to 0           */
    12e0:	00 e0       	ldi	r16, 0x00	; 0
    12e2:	10 e0       	ldi	r17, 0x00	; 0
    12e4:	98 01       	movw	r18, r16
    12e6:	41 e0       	ldi	r20, 0x01	; 1
    12e8:	60 e2       	ldi	r22, 0x20	; 32
    12ea:	b2 df       	rcall	.-156    	; 0x1250 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXM1SIDH, ext, ulMask);			/*Mask register ignores ext bit */
    12ec:	00 e0       	ldi	r16, 0x00	; 0
    12ee:	10 e0       	ldi	r17, 0x00	; 0
    12f0:	98 01       	movw	r18, r16
    12f2:	41 e0       	ldi	r20, 0x01	; 1
    12f4:	64 e2       	ldi	r22, 0x24	; 36
    12f6:	c7 01       	movw	r24, r14
    12f8:	ab df       	rcall	.-170    	; 0x1250 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	
	/* Set all filters to 0         */
	mcp2515_write_mf(MCP_RXF0SIDH, ext, ulFilt);			/* RXB0: extended               */
    12fa:	00 e0       	ldi	r16, 0x00	; 0
    12fc:	10 e0       	ldi	r17, 0x00	; 0
    12fe:	98 01       	movw	r18, r16
    1300:	41 e0       	ldi	r20, 0x01	; 1
    1302:	60 e0       	ldi	r22, 0x00	; 0
    1304:	c7 01       	movw	r24, r14
    1306:	a4 df       	rcall	.-184    	; 0x1250 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF1SIDH, std, ulFilt);			/* RXB1: standard               */
    1308:	00 e0       	ldi	r16, 0x00	; 0
    130a:	10 e0       	ldi	r17, 0x00	; 0
    130c:	98 01       	movw	r18, r16
    130e:	40 e0       	ldi	r20, 0x00	; 0
    1310:	64 e0       	ldi	r22, 0x04	; 4
    1312:	c7 01       	movw	r24, r14
    1314:	9d df       	rcall	.-198    	; 0x1250 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF2SIDH, ext, ulFilt);			/* RXB2: extended               */
    1316:	00 e0       	ldi	r16, 0x00	; 0
    1318:	10 e0       	ldi	r17, 0x00	; 0
    131a:	98 01       	movw	r18, r16
    131c:	41 e0       	ldi	r20, 0x01	; 1
    131e:	68 e0       	ldi	r22, 0x08	; 8
    1320:	c7 01       	movw	r24, r14
    1322:	96 df       	rcall	.-212    	; 0x1250 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF3SIDH, std, ulFilt);			/* RXB3: standard               */
    1324:	00 e0       	ldi	r16, 0x00	; 0
    1326:	10 e0       	ldi	r17, 0x00	; 0
    1328:	98 01       	movw	r18, r16
    132a:	40 e0       	ldi	r20, 0x00	; 0
    132c:	60 e1       	ldi	r22, 0x10	; 16
    132e:	c7 01       	movw	r24, r14
    1330:	8f df       	rcall	.-226    	; 0x1250 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF4SIDH, ext, ulFilt);
    1332:	00 e0       	ldi	r16, 0x00	; 0
    1334:	10 e0       	ldi	r17, 0x00	; 0
    1336:	98 01       	movw	r18, r16
    1338:	41 e0       	ldi	r20, 0x01	; 1
    133a:	64 e1       	ldi	r22, 0x14	; 20
    133c:	c7 01       	movw	r24, r14
    133e:	88 df       	rcall	.-240    	; 0x1250 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF5SIDH, std, ulFilt);
    1340:	00 e0       	ldi	r16, 0x00	; 0
    1342:	10 e0       	ldi	r17, 0x00	; 0
    1344:	98 01       	movw	r18, r16
    1346:	40 e0       	ldi	r20, 0x00	; 0
    1348:	68 e1       	ldi	r22, 0x18	; 24
    134a:	c7 01       	movw	r24, r14
    134c:	81 df       	rcall	.-254    	; 0x1250 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>

	/* Clear, deactivate the three  */
	/* transmit buffers             */
	/* TXBnCTRL -> TXBnD7           */
	a1 = MCP_TXB0CTRL;
    134e:	c0 e3       	ldi	r28, 0x30	; 48
	a2 = MCP_TXB1CTRL;
	a3 = MCP_TXB2CTRL;
	for (i = 0; i < 14; i++) {                                          /* in-buffer loop               */
		mcp2515_setRegister(a1, 0);
    1350:	40 e0       	ldi	r20, 0x00	; 0
    1352:	6c 2f       	mov	r22, r28
    1354:	c7 01       	movw	r24, r14
    1356:	56 de       	rcall	.-852    	; 0x1004 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		mcp2515_setRegister(a2, 0);
    1358:	60 e1       	ldi	r22, 0x10	; 16
    135a:	6c 0f       	add	r22, r28
    135c:	40 e0       	ldi	r20, 0x00	; 0
    135e:	c7 01       	movw	r24, r14
    1360:	51 de       	rcall	.-862    	; 0x1004 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		mcp2515_setRegister(a3, 0);
    1362:	60 e2       	ldi	r22, 0x20	; 32
    1364:	6c 0f       	add	r22, r28
    1366:	40 e0       	ldi	r20, 0x00	; 0
    1368:	c7 01       	movw	r24, r14
    136a:	4c de       	rcall	.-872    	; 0x1004 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		a1++;
    136c:	cf 5f       	subi	r28, 0xFF	; 255
	/* transmit buffers             */
	/* TXBnCTRL -> TXBnD7           */
	a1 = MCP_TXB0CTRL;
	a2 = MCP_TXB1CTRL;
	a3 = MCP_TXB2CTRL;
	for (i = 0; i < 14; i++) {                                          /* in-buffer loop               */
    136e:	ce 33       	cpi	r28, 0x3E	; 62
    1370:	79 f7       	brne	.-34     	; 0x1350 <_ZN7MCP_CAN22mcp2515_initCANBuffersEv+0x7c>
		mcp2515_setRegister(a3, 0);
		a1++;
		a2++;
		a3++;
	}
	mcp2515_setRegister(MCP_RXB0CTRL, 0);
    1372:	40 e0       	ldi	r20, 0x00	; 0
    1374:	60 e6       	ldi	r22, 0x60	; 96
    1376:	c7 01       	movw	r24, r14
    1378:	45 de       	rcall	.-886    	; 0x1004 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    137a:	40 e0       	ldi	r20, 0x00	; 0
	mcp2515_setRegister(MCP_RXB1CTRL, 0);
    137c:	60 e7       	ldi	r22, 0x70	; 112
    137e:	c7 01       	movw	r24, r14
    1380:	41 de       	rcall	.-894    	; 0x1004 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1382:	cf 91       	pop	r28
    1384:	1f 91       	pop	r17
}
    1386:	0f 91       	pop	r16
    1388:	ff 90       	pop	r15
    138a:	ef 90       	pop	r14
    138c:	08 95       	ret

0000138e <_ZN7MCP_CAN12mcp2515_initEhhh>:
    138e:	ff 92       	push	r15
    1390:	0f 93       	push	r16

/*********************************************************************************************************
** Function name:           mcp2515_init
** Descriptions:            Initialize the controller
*********************************************************************************************************/
uint8_t MCP_CAN::mcp2515_init(const uint8_t canIDMode, const uint8_t canSpeed, const uint8_t canClock){
    1392:	1f 93       	push	r17
    1394:	cf 93       	push	r28
    1396:	df 93       	push	r29
    1398:	ec 01       	movw	r28, r24
    139a:	f6 2e       	mov	r15, r22
    139c:	14 2f       	mov	r17, r20
    139e:	02 2f       	mov	r16, r18
	uint8_t res;
	mcp2515_reset();
    13a0:	78 dd       	rcall	.-1296   	; 0xe92 <_ZN7MCP_CAN13mcp2515_resetEv>
	mcpMode = MCP_LOOPBACK;
    13a2:	80 e4       	ldi	r24, 0x40	; 64
    13a4:	89 8b       	std	Y+17, r24	; 0x11
	res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
    13a6:	60 e8       	ldi	r22, 0x80	; 128
    13a8:	ce 01       	movw	r24, r28
    13aa:	26 df       	rcall	.-436    	; 0x11f8 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>
	if(res > 0)
    13ac:	81 11       	cpse	r24, r1
    13ae:	35 c0       	rjmp	.+106    	; 0x141a <_ZN7MCP_CAN12mcp2515_initEhhh+0x8c>
	return res;
	// Set Baudrate
	if(mcp2515_configRate(canSpeed, canClock))
    13b0:	40 2f       	mov	r20, r16
    13b2:	61 2f       	mov	r22, r17
    13b4:	ce 01       	movw	r24, r28
    13b6:	3a df       	rcall	.-396    	; 0x122c <_ZN7MCP_CAN18mcp2515_configRateEhh>
    13b8:	81 11       	cpse	r24, r1
	return res;
	if ( res == MCP2515_OK ) {
		mcp2515_initCANBuffers();											//init canbuffers
    13ba:	2c c0       	rjmp	.+88     	; 0x1414 <_ZN7MCP_CAN12mcp2515_initEhhh+0x86>
    13bc:	ce 01       	movw	r24, r28
		mcp2515_setRegister(MCP_CANINTE, MCP_RX0IF | MCP_RX1IF);			//interrupt mode
    13be:	8a df       	rcall	.-236    	; 0x12d4 <_ZN7MCP_CAN22mcp2515_initCANBuffersEv>
    13c0:	43 e0       	ldi	r20, 0x03	; 3
    13c2:	6b e2       	ldi	r22, 0x2B	; 43
    13c4:	ce 01       	movw	r24, r28
		mcp2515_setRegister(MCP_BFPCTRL,MCP_BxBFS_MASK | MCP_BxBFE_MASK);	//Sets BF pins as GPO
    13c6:	1e de       	rcall	.-964    	; 0x1004 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    13c8:	4c e3       	ldi	r20, 0x3C	; 60
    13ca:	6c e0       	ldi	r22, 0x0C	; 12
    13cc:	ce 01       	movw	r24, r28
		mcp2515_setRegister(MCP_TXRTSCTRL,0x00);							//Sets RTS pins as GPI
    13ce:	1a de       	rcall	.-972    	; 0x1004 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    13d0:	40 e0       	ldi	r20, 0x00	; 0
    13d2:	6d e0       	ldi	r22, 0x0D	; 13
    13d4:	ce 01       	movw	r24, r28
    13d6:	16 de       	rcall	.-980    	; 0x1004 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		switch(canIDMode){
    13d8:	ff 20       	and	r15, r15
    13da:	71 f0       	breq	.+28     	; 0x13f8 <_ZN7MCP_CAN12mcp2515_initEhhh+0x6a>
    13dc:	83 e0       	ldi	r24, 0x03	; 3
    13de:	f8 12       	cpse	r15, r24
			case (MCP_ANY):
			mcp2515_modifyRegister(MCP_RXB0CTRL,
			MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
			MCP_RXB_RX_ANY | MCP_RXB_BUKT_MASK);
    13e0:	1b c0       	rjmp	.+54     	; 0x1418 <_ZN7MCP_CAN12mcp2515_initEhhh+0x8a>
    13e2:	24 e6       	ldi	r18, 0x64	; 100
    13e4:	44 e6       	ldi	r20, 0x64	; 100
    13e6:	60 e6       	ldi	r22, 0x60	; 96
    13e8:	ce 01       	movw	r24, r28
			mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
			MCP_RXB_RX_ANY);
    13ea:	95 de       	rcall	.-726    	; 0x1116 <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    13ec:	20 e6       	ldi	r18, 0x60	; 96
    13ee:	40 e6       	ldi	r20, 0x60	; 96
    13f0:	60 e7       	ldi	r22, 0x70	; 112
    13f2:	ce 01       	movw	r24, r28
			break;
    13f4:	90 de       	rcall	.-736    	; 0x1116 <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
			case (MCP_STDEXT):
			mcp2515_modifyRegister(MCP_RXB0CTRL,
			MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
			MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK );
    13f6:	0a c0       	rjmp	.+20     	; 0x140c <_ZN7MCP_CAN12mcp2515_initEhhh+0x7e>
    13f8:	24 e0       	ldi	r18, 0x04	; 4
    13fa:	44 e6       	ldi	r20, 0x64	; 100
    13fc:	60 e6       	ldi	r22, 0x60	; 96
			mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
			MCP_RXB_RX_STDEXT);
    13fe:	ce 01       	movw	r24, r28
    1400:	8a de       	rcall	.-748    	; 0x1116 <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    1402:	20 e0       	ldi	r18, 0x00	; 0
    1404:	40 e6       	ldi	r20, 0x60	; 96
    1406:	60 e7       	ldi	r22, 0x70	; 112
    1408:	ce 01       	movw	r24, r28
			break;
			default:
			return MCP2515_FAIL;
			break;
		}
		res = mcp2515_setCANCTRL_Mode(mcpMode);
    140a:	85 de       	rcall	.-758    	; 0x1116 <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    140c:	69 89       	ldd	r22, Y+17	; 0x11
    140e:	ce 01       	movw	r24, r28
    1410:	f3 de       	rcall	.-538    	; 0x11f8 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>
    1412:	03 c0       	rjmp	.+6      	; 0x141a <_ZN7MCP_CAN12mcp2515_initEhhh+0x8c>
	res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
	if(res > 0)
	return res;
	// Set Baudrate
	if(mcp2515_configRate(canSpeed, canClock))
	return res;
    1414:	80 e0       	ldi	r24, 0x00	; 0
    1416:	01 c0       	rjmp	.+2      	; 0x141a <_ZN7MCP_CAN12mcp2515_initEhhh+0x8c>
			MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK );
			mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
			MCP_RXB_RX_STDEXT);
			break;
			default:
			return MCP2515_FAIL;
    1418:	81 e0       	ldi	r24, 0x01	; 1
		res = mcp2515_setCANCTRL_Mode(mcpMode);
		if(res)
		return res;
	}
	return res;
}
    141a:	df 91       	pop	r29
    141c:	cf 91       	pop	r28
    141e:	1f 91       	pop	r17
    1420:	0f 91       	pop	r16
    1422:	ff 90       	pop	r15
    1424:	08 95       	ret

00001426 <_ZN7MCP_CAN15mcp2515_read_idEhPhPm>:

/*********************************************************************************************************
** Function name:           mcp2515_read_id
** Descriptions:            Read CAN ID
*********************************************************************************************************/
void MCP_CAN::mcp2515_read_id( const uint8_t mcp_addr, uint8_t* ext, uint32_t* id ){
    1426:	ef 92       	push	r14
    1428:	ff 92       	push	r15
    142a:	0f 93       	push	r16
    142c:	1f 93       	push	r17
    142e:	cf 93       	push	r28
    1430:	df 93       	push	r29
    1432:	00 d0       	rcall	.+0      	; 0x1434 <_ZN7MCP_CAN15mcp2515_read_idEhPhPm+0xe>
    1434:	1f 92       	push	r1
    1436:	cd b7       	in	r28, 0x3d	; 61
    1438:	de b7       	in	r29, 0x3e	; 62
    143a:	7a 01       	movw	r14, r20
    143c:	89 01       	movw	r16, r18
	uint8_t tbufdata[4];
	*ext = 0;
    143e:	fa 01       	movw	r30, r20
    1440:	10 82       	st	Z, r1
	*id = 0;
    1442:	f9 01       	movw	r30, r18
    1444:	10 82       	st	Z, r1
    1446:	11 82       	std	Z+1, r1	; 0x01
    1448:	12 82       	std	Z+2, r1	; 0x02
    144a:	13 82       	std	Z+3, r1	; 0x03
	mcp2515_readRegisterS( mcp_addr, tbufdata, 4 );
    144c:	24 e0       	ldi	r18, 0x04	; 4
    144e:	ae 01       	movw	r20, r28
    1450:	4f 5f       	subi	r20, 0xFF	; 255
    1452:	5f 4f       	sbci	r21, 0xFF	; 255
    1454:	87 dd       	rcall	.-1266   	; 0xf64 <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh>
	*id = (tbufdata[MCP_SIDH]<<3) + (tbufdata[MCP_SIDL]>>5);
    1456:	2a 81       	ldd	r18, Y+2	; 0x02
    1458:	39 81       	ldd	r19, Y+1	; 0x01
    145a:	82 2f       	mov	r24, r18
    145c:	90 e0       	ldi	r25, 0x00	; 0
    145e:	95 95       	asr	r25
    1460:	87 95       	ror	r24
    1462:	95 95       	asr	r25
    1464:	87 95       	ror	r24
    1466:	95 95       	asr	r25
    1468:	87 95       	ror	r24
    146a:	95 95       	asr	r25
    146c:	87 95       	ror	r24
    146e:	95 95       	asr	r25
    1470:	87 95       	ror	r24
    1472:	f8 e0       	ldi	r31, 0x08	; 8
    1474:	3f 9f       	mul	r19, r31
    1476:	80 0d       	add	r24, r0
    1478:	91 1d       	adc	r25, r1
    147a:	11 24       	eor	r1, r1
    147c:	09 2e       	mov	r0, r25
    147e:	00 0c       	add	r0, r0
    1480:	aa 0b       	sbc	r26, r26
    1482:	bb 0b       	sbc	r27, r27
    1484:	f8 01       	movw	r30, r16
    1486:	80 83       	st	Z, r24
    1488:	91 83       	std	Z+1, r25	; 0x01
    148a:	a2 83       	std	Z+2, r26	; 0x02
    148c:	b3 83       	std	Z+3, r27	; 0x03
	if ( (tbufdata[MCP_SIDL] & MCP_TXB_EXIDE_M) ==  MCP_TXB_EXIDE_M ){
    148e:	23 ff       	sbrs	r18, 3
    1490:	26 c0       	rjmp	.+76     	; 0x14de <_ZN7MCP_CAN15mcp2515_read_idEhPhPm+0xb8>
		/* extended id                  */
		*id = (*id<<2) + (tbufdata[MCP_SIDL] & 0x03);
		*id = (*id<<8) + tbufdata[MCP_EID8];
		*id = (*id<<8) + tbufdata[MCP_EID0];
    1492:	88 0f       	add	r24, r24
    1494:	99 1f       	adc	r25, r25
    1496:	aa 1f       	adc	r26, r26
    1498:	bb 1f       	adc	r27, r27
    149a:	88 0f       	add	r24, r24
    149c:	99 1f       	adc	r25, r25
    149e:	aa 1f       	adc	r26, r26
    14a0:	bb 1f       	adc	r27, r27
    14a2:	23 70       	andi	r18, 0x03	; 3
    14a4:	82 0f       	add	r24, r18
    14a6:	91 1d       	adc	r25, r1
    14a8:	a1 1d       	adc	r26, r1
    14aa:	b1 1d       	adc	r27, r1
    14ac:	ba 2f       	mov	r27, r26
    14ae:	a9 2f       	mov	r26, r25
    14b0:	98 2f       	mov	r25, r24
    14b2:	88 27       	eor	r24, r24
    14b4:	2b 81       	ldd	r18, Y+3	; 0x03
    14b6:	82 0f       	add	r24, r18
    14b8:	91 1d       	adc	r25, r1
    14ba:	a1 1d       	adc	r26, r1
    14bc:	b1 1d       	adc	r27, r1
    14be:	ba 2f       	mov	r27, r26
    14c0:	a9 2f       	mov	r26, r25
    14c2:	98 2f       	mov	r25, r24
    14c4:	88 27       	eor	r24, r24
    14c6:	2c 81       	ldd	r18, Y+4	; 0x04
    14c8:	82 0f       	add	r24, r18
    14ca:	91 1d       	adc	r25, r1
    14cc:	a1 1d       	adc	r26, r1
    14ce:	b1 1d       	adc	r27, r1
    14d0:	80 83       	st	Z, r24
    14d2:	91 83       	std	Z+1, r25	; 0x01
    14d4:	a2 83       	std	Z+2, r26	; 0x02
    14d6:	b3 83       	std	Z+3, r27	; 0x03
		*ext = 1;
    14d8:	81 e0       	ldi	r24, 0x01	; 1
    14da:	f7 01       	movw	r30, r14
    14dc:	80 83       	st	Z, r24
	}
}
    14de:	0f 90       	pop	r0
    14e0:	0f 90       	pop	r0
    14e2:	0f 90       	pop	r0
    14e4:	0f 90       	pop	r0
    14e6:	df 91       	pop	r29
    14e8:	cf 91       	pop	r28
    14ea:	1f 91       	pop	r17
    14ec:	0f 91       	pop	r16
    14ee:	ff 90       	pop	r15
    14f0:	ef 90       	pop	r14
    14f2:	08 95       	ret

000014f4 <_ZN7MCP_CAN19mcp2515_read_canMsgEh>:

/*********************************************************************************************************
** Function name:           mcp2515_read_canMsg
** Descriptions:            Read message
*********************************************************************************************************/
void MCP_CAN::mcp2515_read_canMsg( const uint8_t buffer_sidh_addr){        /* read can msg                 */
    14f4:	0f 93       	push	r16
    14f6:	1f 93       	push	r17
    14f8:	cf 93       	push	r28
    14fa:	df 93       	push	r29
    14fc:	ec 01       	movw	r28, r24
    14fe:	16 2f       	mov	r17, r22
	uint8_t mcp_addr, ctrl;
	mcp_addr = buffer_sidh_addr;
	mcp2515_read_id( mcp_addr, &m_nExtFlg,&m_nID );
    1500:	9c 01       	movw	r18, r24
    1502:	2f 5f       	subi	r18, 0xFF	; 255
    1504:	3f 4f       	sbci	r19, 0xFF	; 255
    1506:	ac 01       	movw	r20, r24
    1508:	8e df       	rcall	.-228    	; 0x1426 <_ZN7MCP_CAN15mcp2515_read_idEhPhPm>
	ctrl = mcp2515_readRegister( mcp_addr-1 );
    150a:	6f ef       	ldi	r22, 0xFF	; 255
    150c:	61 0f       	add	r22, r17
    150e:	ce 01       	movw	r24, r28
    1510:	f2 dc       	rcall	.-1564   	; 0xef6 <_ZN7MCP_CAN20mcp2515_readRegisterEh>
    1512:	08 2f       	mov	r16, r24
	m_nDlc = mcp2515_readRegister( mcp_addr+4 );
    1514:	64 e0       	ldi	r22, 0x04	; 4
    1516:	61 0f       	add	r22, r17
    1518:	ce 01       	movw	r24, r28
    151a:	ed dc       	rcall	.-1574   	; 0xef6 <_ZN7MCP_CAN20mcp2515_readRegisterEh>
    151c:	8d 83       	std	Y+5, r24	; 0x05
	if (ctrl & 0x08)
    151e:	03 ff       	sbrs	r16, 3
    1520:	03 c0       	rjmp	.+6      	; 0x1528 <_ZN7MCP_CAN19mcp2515_read_canMsgEh+0x34>
		m_nRtr = 1;
    1522:	91 e0       	ldi	r25, 0x01	; 1
    1524:	9e 87       	std	Y+14, r25	; 0x0e
    1526:	01 c0       	rjmp	.+2      	; 0x152a <_ZN7MCP_CAN19mcp2515_read_canMsgEh+0x36>
	else
		m_nRtr = 0;
    1528:	1e 86       	std	Y+14, r1	; 0x0e
	m_nDlc &= MCP_DLC_MASK;
    152a:	28 2f       	mov	r18, r24
    152c:	2f 70       	andi	r18, 0x0F	; 15
    152e:	2d 83       	std	Y+5, r18	; 0x05
	mcp2515_readRegisterS( mcp_addr+5, &(m_nDta[0]), m_nDlc );
    1530:	ae 01       	movw	r20, r28
    1532:	4a 5f       	subi	r20, 0xFA	; 250
    1534:	5f 4f       	sbci	r21, 0xFF	; 255
    1536:	65 e0       	ldi	r22, 0x05	; 5
    1538:	61 0f       	add	r22, r17
    153a:	ce 01       	movw	r24, r28
    153c:	13 dd       	rcall	.-1498   	; 0xf64 <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh>
}
    153e:	df 91       	pop	r29
    1540:	cf 91       	pop	r28
    1542:	1f 91       	pop	r17
    1544:	0f 91       	pop	r16
    1546:	08 95       	ret

00001548 <_ZN7MCP_CANC1Eh>:
** Function name:           MCP_CAN
** Descriptions:            Public function to declare CAN class and the /CS pin.
*********************************************************************************************************/
MCP_CAN::MCP_CAN(uint8_t _CS)
{
	MCPCS = _CS;
    1548:	fc 01       	movw	r30, r24
    154a:	60 8b       	std	Z+16, r22	; 0x10
	MCP2515_UNSELECT();
    154c:	eb e0       	ldi	r30, 0x0B	; 11
    154e:	f1 e0       	ldi	r31, 0x01	; 1
    1550:	80 81       	ld	r24, Z
    1552:	84 60       	ori	r24, 0x04	; 4
    1554:	80 83       	st	Z, r24
	DDRL |= (1 << PL2);		//????
    1556:	ea e0       	ldi	r30, 0x0A	; 10
    1558:	f1 e0       	ldi	r31, 0x01	; 1
    155a:	80 81       	ld	r24, Z
    155c:	84 60       	ori	r24, 0x04	; 4
    155e:	80 83       	st	Z, r24
    1560:	08 95       	ret

00001562 <_ZN7MCP_CAN5beginEhhh>:
/*********************************************************************************************************
** Function name:           begin
** Descriptions:            Public function to declare controller initialization parameters.
*********************************************************************************************************/
uint8_t MCP_CAN::begin(uint8_t idmodeset, uint8_t speedset, uint8_t clockset)
{
    1562:	ff 92       	push	r15
    1564:	0f 93       	push	r16
    1566:	1f 93       	push	r17
    1568:	cf 93       	push	r28
    156a:	df 93       	push	r29
    156c:	ec 01       	movw	r28, r24
    156e:	16 2f       	mov	r17, r22
    1570:	04 2f       	mov	r16, r20
    1572:	f2 2e       	mov	r15, r18
	uint8_t res;

	SPI.begin();
    1574:	90 d0       	rcall	.+288    	; 0x1696 <_ZN8SPIClass5beginEv>
	res = mcp2515_init(idmodeset, speedset, clockset);
    1576:	2f 2d       	mov	r18, r15
    1578:	40 2f       	mov	r20, r16
    157a:	61 2f       	mov	r22, r17
    157c:	ce 01       	movw	r24, r28
    157e:	07 df       	rcall	.-498    	; 0x138e <_ZN7MCP_CAN12mcp2515_initEhhh>
    1580:	91 e0       	ldi	r25, 0x01	; 1
    1582:	81 11       	cpse	r24, r1
    1584:	01 c0       	rjmp	.+2      	; 0x1588 <_ZN7MCP_CAN5beginEhhh+0x26>
    1586:	90 e0       	ldi	r25, 0x00	; 0
	if (res == MCP2515_OK)
	return CAN_OK;
	
	return CAN_FAILINIT;
}
    1588:	89 2f       	mov	r24, r25
    158a:	df 91       	pop	r29
    158c:	cf 91       	pop	r28
    158e:	1f 91       	pop	r17
    1590:	0f 91       	pop	r16
    1592:	ff 90       	pop	r15
    1594:	08 95       	ret

00001596 <_ZN7MCP_CAN7readMsgEv>:

/*********************************************************************************************************
** Function name:           readMsg
** Descriptions:            Read message
*********************************************************************************************************/
uint8_t MCP_CAN::readMsg(){
    1596:	cf 93       	push	r28
    1598:	df 93       	push	r29
    159a:	ec 01       	movw	r28, r24
	uint8_t stat, res;
	stat = mcp2515_readStatus();
    159c:	fd dd       	rcall	.-1030   	; 0x1198 <_ZN7MCP_CAN18mcp2515_readStatusEv>

	if ( stat & MCP_STAT_RX0IF )                                        /* Msg in Buffer 0              */
    159e:	80 ff       	sbrs	r24, 0
    15a0:	0a c0       	rjmp	.+20     	; 0x15b6 <_ZN7MCP_CAN7readMsgEv+0x20>
	{
		mcp2515_read_canMsg( MCP_RXBUF_0);
    15a2:	61 e6       	ldi	r22, 0x61	; 97
    15a4:	ce 01       	movw	r24, r28
    15a6:	a6 df       	rcall	.-180    	; 0x14f4 <_ZN7MCP_CAN19mcp2515_read_canMsgEh>
		mcp2515_modifyRegister(MCP_CANINTF, MCP_RX0IF, 0);
    15a8:	20 e0       	ldi	r18, 0x00	; 0
    15aa:	41 e0       	ldi	r20, 0x01	; 1
    15ac:	6c e2       	ldi	r22, 0x2C	; 44
    15ae:	ce 01       	movw	r24, r28
    15b0:	b2 dd       	rcall	.-1180   	; 0x1116 <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
		res = CAN_OK;
    15b2:	80 e0       	ldi	r24, 0x00	; 0
    15b4:	0d c0       	rjmp	.+26     	; 0x15d0 <_ZN7MCP_CAN7readMsgEv+0x3a>
	}
	else if ( stat & MCP_STAT_RX1IF )                                   /* Msg in Buffer 1              */
    15b6:	81 ff       	sbrs	r24, 1
	{
		mcp2515_read_canMsg( MCP_RXBUF_1);
    15b8:	0a c0       	rjmp	.+20     	; 0x15ce <_ZN7MCP_CAN7readMsgEv+0x38>
    15ba:	61 e7       	ldi	r22, 0x71	; 113
    15bc:	ce 01       	movw	r24, r28
    15be:	9a df       	rcall	.-204    	; 0x14f4 <_ZN7MCP_CAN19mcp2515_read_canMsgEh>
		mcp2515_modifyRegister(MCP_CANINTF, MCP_RX1IF, 0);
    15c0:	20 e0       	ldi	r18, 0x00	; 0
    15c2:	42 e0       	ldi	r20, 0x02	; 2
    15c4:	6c e2       	ldi	r22, 0x2C	; 44
    15c6:	ce 01       	movw	r24, r28
    15c8:	a6 dd       	rcall	.-1204   	; 0x1116 <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
		res = CAN_OK;
    15ca:	80 e0       	ldi	r24, 0x00	; 0
    15cc:	01 c0       	rjmp	.+2      	; 0x15d0 <_ZN7MCP_CAN7readMsgEv+0x3a>
	}
	else
	res = CAN_NOMSG;
    15ce:	84 e0       	ldi	r24, 0x04	; 4
	
	return res;
}
    15d0:	df 91       	pop	r29
    15d2:	cf 91       	pop	r28
    15d4:	08 95       	ret

000015d6 <_ZN7MCP_CAN10readMsgBufEPmPhS1_>:

/*********************************************************************************************************
** Function name:           readMsgBuf
** Descriptions:            Public function, Reads message from receive buffer.
*********************************************************************************************************/
uint8_t MCP_CAN::readMsgBuf(uint32_t *id, uint8_t *len, uint8_t buf[]){
    15d6:	cf 92       	push	r12
    15d8:	df 92       	push	r13
    15da:	ef 92       	push	r14
    15dc:	ff 92       	push	r15
    15de:	0f 93       	push	r16
    15e0:	1f 93       	push	r17
    15e2:	cf 93       	push	r28
    15e4:	df 93       	push	r29
    15e6:	ec 01       	movw	r28, r24
    15e8:	7b 01       	movw	r14, r22
    15ea:	8a 01       	movw	r16, r20
    15ec:	c2 2e       	mov	r12, r18
    15ee:	d3 2e       	mov	r13, r19
	if(readMsg() == CAN_NOMSG)
    15f0:	d2 df       	rcall	.-92     	; 0x1596 <_ZN7MCP_CAN7readMsgEv>
    15f2:	84 30       	cpi	r24, 0x04	; 4
    15f4:	c9 f1       	breq	.+114    	; 0x1668 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x92>
	return CAN_NOMSG;

	if (m_nExtFlg)
    15f6:	88 81       	ld	r24, Y
    15f8:	88 23       	and	r24, r24
    15fa:	49 f0       	breq	.+18     	; 0x160e <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x38>
	m_nID |= 0x80000000;
    15fc:	89 81       	ldd	r24, Y+1	; 0x01
    15fe:	9a 81       	ldd	r25, Y+2	; 0x02
    1600:	ab 81       	ldd	r26, Y+3	; 0x03
    1602:	bc 81       	ldd	r27, Y+4	; 0x04
    1604:	b0 68       	ori	r27, 0x80	; 128
    1606:	89 83       	std	Y+1, r24	; 0x01
    1608:	9a 83       	std	Y+2, r25	; 0x02
    160a:	ab 83       	std	Y+3, r26	; 0x03
    160c:	bc 83       	std	Y+4, r27	; 0x04

	if (m_nRtr)
    160e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1610:	88 23       	and	r24, r24
    1612:	49 f0       	breq	.+18     	; 0x1626 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x50>
	m_nID |= 0x40000000;
    1614:	89 81       	ldd	r24, Y+1	; 0x01
    1616:	9a 81       	ldd	r25, Y+2	; 0x02
    1618:	ab 81       	ldd	r26, Y+3	; 0x03
    161a:	bc 81       	ldd	r27, Y+4	; 0x04
    161c:	b0 64       	ori	r27, 0x40	; 64
    161e:	89 83       	std	Y+1, r24	; 0x01
    1620:	9a 83       	std	Y+2, r25	; 0x02
    1622:	ab 83       	std	Y+3, r26	; 0x03
    1624:	bc 83       	std	Y+4, r27	; 0x04
	*id  = m_nID;
    1626:	89 81       	ldd	r24, Y+1	; 0x01
    1628:	9a 81       	ldd	r25, Y+2	; 0x02
    162a:	ab 81       	ldd	r26, Y+3	; 0x03
    162c:	bc 81       	ldd	r27, Y+4	; 0x04
    162e:	f7 01       	movw	r30, r14
    1630:	80 83       	st	Z, r24
    1632:	91 83       	std	Z+1, r25	; 0x01
    1634:	a2 83       	std	Z+2, r26	; 0x02
    1636:	b3 83       	std	Z+3, r27	; 0x03
	*len = m_nDlc;
    1638:	8d 81       	ldd	r24, Y+5	; 0x05
    163a:	f8 01       	movw	r30, r16
    163c:	80 83       	st	Z, r24
	for(int i = 0; i<m_nDlc; i++)
    163e:	8d 81       	ldd	r24, Y+5	; 0x05
    1640:	88 23       	and	r24, r24
    1642:	89 f0       	breq	.+34     	; 0x1666 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x90>
    1644:	de 01       	movw	r26, r28
    1646:	16 96       	adiw	r26, 0x06	; 6
    1648:	ec 2d       	mov	r30, r12
    164a:	fd 2d       	mov	r31, r13
    164c:	20 e0       	ldi	r18, 0x00	; 0
    164e:	30 e0       	ldi	r19, 0x00	; 0
	buf[i] = m_nDta[i];
    1650:	8d 91       	ld	r24, X+
    1652:	81 93       	st	Z+, r24

	if (m_nRtr)
	m_nID |= 0x40000000;
	*id  = m_nID;
	*len = m_nDlc;
	for(int i = 0; i<m_nDlc; i++)
    1654:	2f 5f       	subi	r18, 0xFF	; 255
    1656:	3f 4f       	sbci	r19, 0xFF	; 255
    1658:	8d 81       	ldd	r24, Y+5	; 0x05
    165a:	90 e0       	ldi	r25, 0x00	; 0
    165c:	28 17       	cp	r18, r24
    165e:	39 07       	cpc	r19, r25
    1660:	bc f3       	brlt	.-18     	; 0x1650 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x7a>
	buf[i] = m_nDta[i];
	return CAN_OK;
    1662:	80 e0       	ldi	r24, 0x00	; 0
    1664:	01 c0       	rjmp	.+2      	; 0x1668 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x92>
    1666:	80 e0       	ldi	r24, 0x00	; 0
}
    1668:	df 91       	pop	r29
    166a:	cf 91       	pop	r28
    166c:	1f 91       	pop	r17
    166e:	0f 91       	pop	r16
    1670:	ff 90       	pop	r15
    1672:	ef 90       	pop	r14
    1674:	df 90       	pop	r13
    1676:	cf 90       	pop	r12
    1678:	08 95       	ret

0000167a <_ZN11SPISettingsC1Emhh>:
void SPIClass::end() {
	cli();							// Protect from a scheduler and prevent transactionBegin
	if (initialized)					// Decrease the reference counter
		initialized--;
	if (!initialized)				
		SPCR &= ~(1 << SPE);
    167a:	0f 93       	push	r16
    167c:	fc 01       	movw	r30, r24
    167e:	22 23       	and	r18, r18
    1680:	11 f0       	breq	.+4      	; 0x1686 <_ZN11SPISettingsC1Emhh+0xc>
    1682:	90 e5       	ldi	r25, 0x50	; 80
    1684:	01 c0       	rjmp	.+2      	; 0x1688 <_ZN11SPISettingsC1Emhh+0xe>
    1686:	90 e7       	ldi	r25, 0x70	; 112
    1688:	0c 70       	andi	r16, 0x0C	; 12
    168a:	09 2b       	or	r16, r25
    168c:	00 83       	st	Z, r16
    168e:	81 e0       	ldi	r24, 0x01	; 1
    1690:	81 83       	std	Z+1, r24	; 0x01
    1692:	0f 91       	pop	r16
    1694:	08 95       	ret

00001696 <_ZN8SPIClass5beginEv>:
    1696:	f8 94       	cli
    1698:	80 91 2f 04 	lds	r24, 0x042F	; 0x80042f <_ZN8SPIClass11initializedE>
    169c:	81 11       	cpse	r24, r1
    169e:	0b c0       	rjmp	.+22     	; 0x16b6 <_ZN8SPIClass5beginEv+0x20>
    16a0:	58 9a       	sbi	0x0b, 0	; 11
    16a2:	20 9a       	sbi	0x04, 0	; 4
    16a4:	84 b1       	in	r24, 0x04	; 4
    16a6:	86 60       	ori	r24, 0x06	; 6
    16a8:	84 b9       	out	0x04, r24	; 4
    16aa:	8c b5       	in	r24, 0x2c	; 44
    16ac:	80 61       	ori	r24, 0x10	; 16
    16ae:	8c bd       	out	0x2c, r24	; 44
    16b0:	8c b5       	in	r24, 0x2c	; 44
    16b2:	80 64       	ori	r24, 0x40	; 64
    16b4:	8c bd       	out	0x2c, r24	; 44
    16b6:	80 91 2f 04 	lds	r24, 0x042F	; 0x80042f <_ZN8SPIClass11initializedE>
    16ba:	8f 5f       	subi	r24, 0xFF	; 255
    16bc:	80 93 2f 04 	sts	0x042F, r24	; 0x80042f <_ZN8SPIClass11initializedE>
    16c0:	08 95       	ret

000016c2 <_ZN8SPIClass16beginTransactionE11SPISettings>:
}

void SPIClass::beginTransaction(SPISettings settings) {
	SPCR = settings.spcr;
    16c2:	fb 01       	movw	r30, r22
    16c4:	80 81       	ld	r24, Z
    16c6:	8c bd       	out	0x2c, r24	; 44
	SPSR = settings.spsr;
    16c8:	81 81       	ldd	r24, Z+1	; 0x01
    16ca:	8d bd       	out	0x2d, r24	; 45
    16cc:	08 95       	ret

000016ce <_ZN8SPIClass8transferEh>:
}

uint8_t SPIClass::transfer(uint8_t data) {
SPDR = data;
    16ce:	6e bd       	out	0x2e, r22	; 46
while (!(SPSR & (1 << SPIF))) ; // wait
    16d0:	0d b4       	in	r0, 0x2d	; 45
    16d2:	07 fe       	sbrs	r0, 7
    16d4:	fd cf       	rjmp	.-6      	; 0x16d0 <_ZN8SPIClass8transferEh+0x2>
return SPDR;
    16d6:	8e b5       	in	r24, 0x2e	; 46
}
    16d8:	08 95       	ret

000016da <_ZN5USARTC1Ev>:
#include "USART.h"

//constructor with setup

USART::USART(){
	UCSR0B = (1 << TXEN0);						// Enable de USART Transmitter
    16da:	88 e0       	ldi	r24, 0x08	; 8
    16dc:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);		// 8 data bits, 1 stop bit
    16e0:	96 e0       	ldi	r25, 0x06	; 6
    16e2:	90 93 c2 00 	sts	0x00C2, r25	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
	UBRR0H=0;									//write the baudrate (76800)
    16e6:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
	UBRR0L=8;									// "
    16ea:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    16ee:	08 95       	ret

000016f0 <_ZN5USART5printEPKc>:
}



//write a string in the Serial
void USART::print(const char st[]) {
    16f0:	cf 93       	push	r28
    16f2:	df 93       	push	r29
	for(uint8_t i = 0 ; st[i] != 0 ; i++) {		//iterate over every char in the string
    16f4:	fb 01       	movw	r30, r22
    16f6:	90 81       	ld	r25, Z
    16f8:	99 23       	and	r25, r25
    16fa:	81 f0       	breq	.+32     	; 0x171c <_ZN5USART5printEPKc+0x2c>
    16fc:	20 e0       	ldi	r18, 0x00	; 0
		while(~UCSR0A & (1 << UDRE0));			//wait till the transmit buffer is empty
    16fe:	e0 ec       	ldi	r30, 0xC0	; 192
    1700:	f0 e0       	ldi	r31, 0x00	; 0
		UDR0 = (int)st[i];						//write the char in the transmit buffer
    1702:	c6 ec       	ldi	r28, 0xC6	; 198
    1704:	d0 e0       	ldi	r29, 0x00	; 0


//write a string in the Serial
void USART::print(const char st[]) {
	for(uint8_t i = 0 ; st[i] != 0 ; i++) {		//iterate over every char in the string
		while(~UCSR0A & (1 << UDRE0));			//wait till the transmit buffer is empty
    1706:	80 81       	ld	r24, Z
    1708:	85 ff       	sbrs	r24, 5
    170a:	fd cf       	rjmp	.-6      	; 0x1706 <_ZN5USART5printEPKc+0x16>
		UDR0 = (int)st[i];						//write the char in the transmit buffer
    170c:	98 83       	st	Y, r25



//write a string in the Serial
void USART::print(const char st[]) {
	for(uint8_t i = 0 ; st[i] != 0 ; i++) {		//iterate over every char in the string
    170e:	2f 5f       	subi	r18, 0xFF	; 255
    1710:	db 01       	movw	r26, r22
    1712:	a2 0f       	add	r26, r18
    1714:	b1 1d       	adc	r27, r1
    1716:	9c 91       	ld	r25, X
    1718:	91 11       	cpse	r25, r1
    171a:	f5 cf       	rjmp	.-22     	; 0x1706 <_ZN5USART5printEPKc+0x16>
		while(~UCSR0A & (1 << UDRE0));			//wait till the transmit buffer is empty
		UDR0 = (int)st[i];						//write the char in the transmit buffer
	}
}
    171c:	df 91       	pop	r29
    171e:	cf 91       	pop	r28
    1720:	08 95       	ret

00001722 <_ZN5USART7printlnEPKc>:

void USART::println(const char st[]){
    1722:	cf 93       	push	r28
    1724:	df 93       	push	r29
    1726:	ec 01       	movw	r28, r24
	this->print(st);
    1728:	e3 df       	rcall	.-58     	; 0x16f0 <_ZN5USART5printEPKc>
	this->print("\n\r");
    172a:	65 ee       	ldi	r22, 0xE5	; 229
    172c:	73 e0       	ldi	r23, 0x03	; 3
    172e:	ce 01       	movw	r24, r28
    1730:	df df       	rcall	.-66     	; 0x16f0 <_ZN5USART5printEPKc>
}
    1732:	df 91       	pop	r29
    1734:	cf 91       	pop	r28
    1736:	08 95       	ret

00001738 <_ZN5USART5printEi>:

//write an integer in the Serial
void USART::print(int i) {
    1738:	0f 93       	push	r16
    173a:	1f 93       	push	r17
    173c:	cf 93       	push	r28
    173e:	df 93       	push	r29
    1740:	cd b7       	in	r28, 0x3d	; 61
    1742:	de b7       	in	r29, 0x3e	; 62
    1744:	60 97       	sbiw	r28, 0x10	; 16
    1746:	0f b6       	in	r0, 0x3f	; 63
    1748:	f8 94       	cli
    174a:	de bf       	out	0x3e, r29	; 62
    174c:	0f be       	out	0x3f, r0	; 63
    174e:	cd bf       	out	0x3d, r28	; 61
    1750:	8c 01       	movw	r16, r24
    1752:	cb 01       	movw	r24, r22
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    1754:	4a e0       	ldi	r20, 0x0A	; 10
    1756:	be 01       	movw	r22, r28
    1758:	6f 5f       	subi	r22, 0xFF	; 255
    175a:	7f 4f       	sbci	r23, 0xFF	; 255
    175c:	71 d1       	rcall	.+738    	; 0x1a40 <__itoa_ncheck>
	char buffer[16];							//create a string
	itoa(i,buffer,10);							//parse the integer into the string
	print(buffer);						//print the string
    175e:	be 01       	movw	r22, r28
    1760:	6f 5f       	subi	r22, 0xFF	; 255
    1762:	7f 4f       	sbci	r23, 0xFF	; 255
    1764:	c8 01       	movw	r24, r16
    1766:	c4 df       	rcall	.-120    	; 0x16f0 <_ZN5USART5printEPKc>
}
    1768:	60 96       	adiw	r28, 0x10	; 16
    176a:	0f b6       	in	r0, 0x3f	; 63
    176c:	f8 94       	cli
    176e:	de bf       	out	0x3e, r29	; 62
    1770:	0f be       	out	0x3f, r0	; 63
    1772:	cd bf       	out	0x3d, r28	; 61
    1774:	df 91       	pop	r29
    1776:	cf 91       	pop	r28
    1778:	1f 91       	pop	r17
    177a:	0f 91       	pop	r16
    177c:	08 95       	ret

0000177e <_ZN5USART7printlnEi>:

void USART::println(int i){
    177e:	cf 93       	push	r28
    1780:	df 93       	push	r29
    1782:	ec 01       	movw	r28, r24
	this->print(i);
    1784:	d9 df       	rcall	.-78     	; 0x1738 <_ZN5USART5printEi>
	this->print("\n\r");
    1786:	65 ee       	ldi	r22, 0xE5	; 229
    1788:	73 e0       	ldi	r23, 0x03	; 3
    178a:	ce 01       	movw	r24, r28
    178c:	b1 df       	rcall	.-158    	; 0x16f0 <_ZN5USART5printEPKc>
}
    178e:	df 91       	pop	r29
    1790:	cf 91       	pop	r28
    1792:	08 95       	ret

00001794 <__divmodsi4>:
    1794:	05 2e       	mov	r0, r21
    1796:	97 fb       	bst	r25, 7
    1798:	16 f4       	brtc	.+4      	; 0x179e <__divmodsi4+0xa>
    179a:	00 94       	com	r0
    179c:	0f d0       	rcall	.+30     	; 0x17bc <__negsi2>
    179e:	57 fd       	sbrc	r21, 7
    17a0:	05 d0       	rcall	.+10     	; 0x17ac <__divmodsi4_neg2>
    17a2:	1d d1       	rcall	.+570    	; 0x19de <__udivmodsi4>
    17a4:	07 fc       	sbrc	r0, 7
    17a6:	02 d0       	rcall	.+4      	; 0x17ac <__divmodsi4_neg2>
    17a8:	46 f4       	brtc	.+16     	; 0x17ba <__divmodsi4_exit>
    17aa:	08 c0       	rjmp	.+16     	; 0x17bc <__negsi2>

000017ac <__divmodsi4_neg2>:
    17ac:	50 95       	com	r21
    17ae:	40 95       	com	r20
    17b0:	30 95       	com	r19
    17b2:	21 95       	neg	r18
    17b4:	3f 4f       	sbci	r19, 0xFF	; 255
    17b6:	4f 4f       	sbci	r20, 0xFF	; 255
    17b8:	5f 4f       	sbci	r21, 0xFF	; 255

000017ba <__divmodsi4_exit>:
    17ba:	08 95       	ret

000017bc <__negsi2>:
    17bc:	90 95       	com	r25
    17be:	80 95       	com	r24
    17c0:	70 95       	com	r23
    17c2:	61 95       	neg	r22
    17c4:	7f 4f       	sbci	r23, 0xFF	; 255
    17c6:	8f 4f       	sbci	r24, 0xFF	; 255
    17c8:	9f 4f       	sbci	r25, 0xFF	; 255
    17ca:	08 95       	ret

000017cc <__tablejump2__>:
    17cc:	ee 0f       	add	r30, r30
    17ce:	ff 1f       	adc	r31, r31
    17d0:	88 1f       	adc	r24, r24
    17d2:	8b bf       	out	0x3b, r24	; 59
    17d4:	07 90       	elpm	r0, Z+
    17d6:	f6 91       	elpm	r31, Z
    17d8:	e0 2d       	mov	r30, r0
    17da:	19 94       	eijmp

000017dc <__usmulhisi3>:
    17dc:	22 d1       	rcall	.+580    	; 0x1a22 <__umulhisi3>

000017de <__usmulhisi3_tail>:
    17de:	b7 ff       	sbrs	r27, 7
    17e0:	08 95       	ret
    17e2:	82 1b       	sub	r24, r18
    17e4:	93 0b       	sbc	r25, r19
    17e6:	08 95       	ret

000017e8 <__moddi3>:
    17e8:	68 94       	set
    17ea:	01 c0       	rjmp	.+2      	; 0x17ee <__divdi3_moddi3>

000017ec <__divdi3>:
    17ec:	e8 94       	clt

000017ee <__divdi3_moddi3>:
    17ee:	f9 2f       	mov	r31, r25
    17f0:	f1 2b       	or	r31, r17
    17f2:	0a f0       	brmi	.+2      	; 0x17f6 <__divdi3_moddi3+0x8>
    17f4:	27 c0       	rjmp	.+78     	; 0x1844 <__udivdi3_umoddi3>
    17f6:	a0 e0       	ldi	r26, 0x00	; 0
    17f8:	b0 e0       	ldi	r27, 0x00	; 0
    17fa:	e0 e0       	ldi	r30, 0x00	; 0
    17fc:	fc e0       	ldi	r31, 0x0C	; 12
    17fe:	93 c0       	rjmp	.+294    	; 0x1926 <__prologue_saves__+0xc>
    1800:	09 2e       	mov	r0, r25
    1802:	05 94       	asr	r0
    1804:	1a f4       	brpl	.+6      	; 0x180c <__divdi3_moddi3+0x1e>
    1806:	79 d0       	rcall	.+242    	; 0x18fa <__negdi2>
    1808:	11 23       	and	r17, r17
    180a:	92 f4       	brpl	.+36     	; 0x1830 <__divdi3_moddi3+0x42>
    180c:	f0 e8       	ldi	r31, 0x80	; 128
    180e:	0f 26       	eor	r0, r31
    1810:	ff ef       	ldi	r31, 0xFF	; 255
    1812:	e0 94       	com	r14
    1814:	f0 94       	com	r15
    1816:	00 95       	com	r16
    1818:	10 95       	com	r17
    181a:	b0 94       	com	r11
    181c:	c0 94       	com	r12
    181e:	d0 94       	com	r13
    1820:	a1 94       	neg	r10
    1822:	bf 0a       	sbc	r11, r31
    1824:	cf 0a       	sbc	r12, r31
    1826:	df 0a       	sbc	r13, r31
    1828:	ef 0a       	sbc	r14, r31
    182a:	ff 0a       	sbc	r15, r31
    182c:	0f 0b       	sbc	r16, r31
    182e:	1f 0b       	sbc	r17, r31
    1830:	13 d0       	rcall	.+38     	; 0x1858 <__udivmod64>
    1832:	07 fc       	sbrc	r0, 7
    1834:	62 d0       	rcall	.+196    	; 0x18fa <__negdi2>
    1836:	cd b7       	in	r28, 0x3d	; 61
    1838:	de b7       	in	r29, 0x3e	; 62
    183a:	ec e0       	ldi	r30, 0x0C	; 12
    183c:	90 c0       	rjmp	.+288    	; 0x195e <__epilogue_restores__+0xc>

0000183e <__umoddi3>:
    183e:	68 94       	set
    1840:	01 c0       	rjmp	.+2      	; 0x1844 <__udivdi3_umoddi3>

00001842 <__udivdi3>:
    1842:	e8 94       	clt

00001844 <__udivdi3_umoddi3>:
    1844:	8f 92       	push	r8
    1846:	9f 92       	push	r9
    1848:	cf 93       	push	r28
    184a:	df 93       	push	r29
    184c:	05 d0       	rcall	.+10     	; 0x1858 <__udivmod64>
    184e:	df 91       	pop	r29
    1850:	cf 91       	pop	r28
    1852:	9f 90       	pop	r9
    1854:	8f 90       	pop	r8
    1856:	08 95       	ret

00001858 <__udivmod64>:
    1858:	88 24       	eor	r8, r8
    185a:	99 24       	eor	r9, r9
    185c:	f4 01       	movw	r30, r8
    185e:	e4 01       	movw	r28, r8
    1860:	b0 e4       	ldi	r27, 0x40	; 64
    1862:	9f 93       	push	r25
    1864:	aa 27       	eor	r26, r26
    1866:	9a 15       	cp	r25, r10
    1868:	8b 04       	cpc	r8, r11
    186a:	9c 04       	cpc	r9, r12
    186c:	ed 05       	cpc	r30, r13
    186e:	fe 05       	cpc	r31, r14
    1870:	cf 05       	cpc	r28, r15
    1872:	d0 07       	cpc	r29, r16
    1874:	a1 07       	cpc	r26, r17
    1876:	98 f4       	brcc	.+38     	; 0x189e <__udivmod64+0x46>
    1878:	ad 2f       	mov	r26, r29
    187a:	dc 2f       	mov	r29, r28
    187c:	cf 2f       	mov	r28, r31
    187e:	fe 2f       	mov	r31, r30
    1880:	e9 2d       	mov	r30, r9
    1882:	98 2c       	mov	r9, r8
    1884:	89 2e       	mov	r8, r25
    1886:	98 2f       	mov	r25, r24
    1888:	87 2f       	mov	r24, r23
    188a:	76 2f       	mov	r23, r22
    188c:	65 2f       	mov	r22, r21
    188e:	54 2f       	mov	r21, r20
    1890:	43 2f       	mov	r20, r19
    1892:	32 2f       	mov	r19, r18
    1894:	22 27       	eor	r18, r18
    1896:	b8 50       	subi	r27, 0x08	; 8
    1898:	31 f7       	brne	.-52     	; 0x1866 <__udivmod64+0xe>
    189a:	bf 91       	pop	r27
    189c:	27 c0       	rjmp	.+78     	; 0x18ec <__udivmod64+0x94>
    189e:	1b 2e       	mov	r1, r27
    18a0:	bf 91       	pop	r27
    18a2:	bb 27       	eor	r27, r27
    18a4:	22 0f       	add	r18, r18
    18a6:	33 1f       	adc	r19, r19
    18a8:	44 1f       	adc	r20, r20
    18aa:	55 1f       	adc	r21, r21
    18ac:	66 1f       	adc	r22, r22
    18ae:	77 1f       	adc	r23, r23
    18b0:	88 1f       	adc	r24, r24
    18b2:	99 1f       	adc	r25, r25
    18b4:	88 1c       	adc	r8, r8
    18b6:	99 1c       	adc	r9, r9
    18b8:	ee 1f       	adc	r30, r30
    18ba:	ff 1f       	adc	r31, r31
    18bc:	cc 1f       	adc	r28, r28
    18be:	dd 1f       	adc	r29, r29
    18c0:	aa 1f       	adc	r26, r26
    18c2:	bb 1f       	adc	r27, r27
    18c4:	8a 14       	cp	r8, r10
    18c6:	9b 04       	cpc	r9, r11
    18c8:	ec 05       	cpc	r30, r12
    18ca:	fd 05       	cpc	r31, r13
    18cc:	ce 05       	cpc	r28, r14
    18ce:	df 05       	cpc	r29, r15
    18d0:	a0 07       	cpc	r26, r16
    18d2:	b1 07       	cpc	r27, r17
    18d4:	48 f0       	brcs	.+18     	; 0x18e8 <__udivmod64+0x90>
    18d6:	8a 18       	sub	r8, r10
    18d8:	9b 08       	sbc	r9, r11
    18da:	ec 09       	sbc	r30, r12
    18dc:	fd 09       	sbc	r31, r13
    18de:	ce 09       	sbc	r28, r14
    18e0:	df 09       	sbc	r29, r15
    18e2:	a0 0b       	sbc	r26, r16
    18e4:	b1 0b       	sbc	r27, r17
    18e6:	21 60       	ori	r18, 0x01	; 1
    18e8:	1a 94       	dec	r1
    18ea:	e1 f6       	brne	.-72     	; 0x18a4 <__udivmod64+0x4c>
    18ec:	2e f4       	brtc	.+10     	; 0x18f8 <__udivmod64+0xa0>
    18ee:	94 01       	movw	r18, r8
    18f0:	af 01       	movw	r20, r30
    18f2:	be 01       	movw	r22, r28
    18f4:	cd 01       	movw	r24, r26
    18f6:	00 0c       	add	r0, r0
    18f8:	08 95       	ret

000018fa <__negdi2>:
    18fa:	60 95       	com	r22
    18fc:	70 95       	com	r23
    18fe:	80 95       	com	r24
    1900:	90 95       	com	r25
    1902:	30 95       	com	r19
    1904:	40 95       	com	r20
    1906:	50 95       	com	r21
    1908:	21 95       	neg	r18
    190a:	3f 4f       	sbci	r19, 0xFF	; 255
    190c:	4f 4f       	sbci	r20, 0xFF	; 255
    190e:	5f 4f       	sbci	r21, 0xFF	; 255
    1910:	6f 4f       	sbci	r22, 0xFF	; 255
    1912:	7f 4f       	sbci	r23, 0xFF	; 255
    1914:	8f 4f       	sbci	r24, 0xFF	; 255
    1916:	9f 4f       	sbci	r25, 0xFF	; 255
    1918:	08 95       	ret

0000191a <__prologue_saves__>:
    191a:	2f 92       	push	r2
    191c:	3f 92       	push	r3
    191e:	4f 92       	push	r4
    1920:	5f 92       	push	r5
    1922:	6f 92       	push	r6
    1924:	7f 92       	push	r7
    1926:	8f 92       	push	r8
    1928:	9f 92       	push	r9
    192a:	af 92       	push	r10
    192c:	bf 92       	push	r11
    192e:	cf 92       	push	r12
    1930:	df 92       	push	r13
    1932:	ef 92       	push	r14
    1934:	ff 92       	push	r15
    1936:	0f 93       	push	r16
    1938:	1f 93       	push	r17
    193a:	cf 93       	push	r28
    193c:	df 93       	push	r29
    193e:	cd b7       	in	r28, 0x3d	; 61
    1940:	de b7       	in	r29, 0x3e	; 62
    1942:	ca 1b       	sub	r28, r26
    1944:	db 0b       	sbc	r29, r27
    1946:	0f b6       	in	r0, 0x3f	; 63
    1948:	f8 94       	cli
    194a:	de bf       	out	0x3e, r29	; 62
    194c:	0f be       	out	0x3f, r0	; 63
    194e:	cd bf       	out	0x3d, r28	; 61
    1950:	19 94       	eijmp

00001952 <__epilogue_restores__>:
    1952:	2a 88       	ldd	r2, Y+18	; 0x12
    1954:	39 88       	ldd	r3, Y+17	; 0x11
    1956:	48 88       	ldd	r4, Y+16	; 0x10
    1958:	5f 84       	ldd	r5, Y+15	; 0x0f
    195a:	6e 84       	ldd	r6, Y+14	; 0x0e
    195c:	7d 84       	ldd	r7, Y+13	; 0x0d
    195e:	8c 84       	ldd	r8, Y+12	; 0x0c
    1960:	9b 84       	ldd	r9, Y+11	; 0x0b
    1962:	aa 84       	ldd	r10, Y+10	; 0x0a
    1964:	b9 84       	ldd	r11, Y+9	; 0x09
    1966:	c8 84       	ldd	r12, Y+8	; 0x08
    1968:	df 80       	ldd	r13, Y+7	; 0x07
    196a:	ee 80       	ldd	r14, Y+6	; 0x06
    196c:	fd 80       	ldd	r15, Y+5	; 0x05
    196e:	0c 81       	ldd	r16, Y+4	; 0x04
    1970:	1b 81       	ldd	r17, Y+3	; 0x03
    1972:	aa 81       	ldd	r26, Y+2	; 0x02
    1974:	b9 81       	ldd	r27, Y+1	; 0x01
    1976:	ce 0f       	add	r28, r30
    1978:	d1 1d       	adc	r29, r1
    197a:	0f b6       	in	r0, 0x3f	; 63
    197c:	f8 94       	cli
    197e:	de bf       	out	0x3e, r29	; 62
    1980:	0f be       	out	0x3f, r0	; 63
    1982:	cd bf       	out	0x3d, r28	; 61
    1984:	ed 01       	movw	r28, r26
    1986:	08 95       	ret

00001988 <__ashldi3>:
    1988:	0f 93       	push	r16
    198a:	08 30       	cpi	r16, 0x08	; 8
    198c:	90 f0       	brcs	.+36     	; 0x19b2 <__ashldi3+0x2a>
    198e:	98 2f       	mov	r25, r24
    1990:	87 2f       	mov	r24, r23
    1992:	76 2f       	mov	r23, r22
    1994:	65 2f       	mov	r22, r21
    1996:	54 2f       	mov	r21, r20
    1998:	43 2f       	mov	r20, r19
    199a:	32 2f       	mov	r19, r18
    199c:	22 27       	eor	r18, r18
    199e:	08 50       	subi	r16, 0x08	; 8
    19a0:	f4 cf       	rjmp	.-24     	; 0x198a <__ashldi3+0x2>
    19a2:	22 0f       	add	r18, r18
    19a4:	33 1f       	adc	r19, r19
    19a6:	44 1f       	adc	r20, r20
    19a8:	55 1f       	adc	r21, r21
    19aa:	66 1f       	adc	r22, r22
    19ac:	77 1f       	adc	r23, r23
    19ae:	88 1f       	adc	r24, r24
    19b0:	99 1f       	adc	r25, r25
    19b2:	0a 95       	dec	r16
    19b4:	b2 f7       	brpl	.-20     	; 0x19a2 <__ashldi3+0x1a>
    19b6:	0f 91       	pop	r16
    19b8:	08 95       	ret

000019ba <__adddi3>:
    19ba:	2a 0d       	add	r18, r10
    19bc:	3b 1d       	adc	r19, r11
    19be:	4c 1d       	adc	r20, r12
    19c0:	5d 1d       	adc	r21, r13
    19c2:	6e 1d       	adc	r22, r14
    19c4:	7f 1d       	adc	r23, r15
    19c6:	80 1f       	adc	r24, r16
    19c8:	91 1f       	adc	r25, r17
    19ca:	08 95       	ret

000019cc <__subdi3>:
    19cc:	2a 19       	sub	r18, r10
    19ce:	3b 09       	sbc	r19, r11
    19d0:	4c 09       	sbc	r20, r12
    19d2:	5d 09       	sbc	r21, r13
    19d4:	6e 09       	sbc	r22, r14
    19d6:	7f 09       	sbc	r23, r15
    19d8:	80 0b       	sbc	r24, r16
    19da:	91 0b       	sbc	r25, r17
    19dc:	08 95       	ret

000019de <__udivmodsi4>:
    19de:	a1 e2       	ldi	r26, 0x21	; 33
    19e0:	1a 2e       	mov	r1, r26
    19e2:	aa 1b       	sub	r26, r26
    19e4:	bb 1b       	sub	r27, r27
    19e6:	fd 01       	movw	r30, r26
    19e8:	0d c0       	rjmp	.+26     	; 0x1a04 <__udivmodsi4_ep>

000019ea <__udivmodsi4_loop>:
    19ea:	aa 1f       	adc	r26, r26
    19ec:	bb 1f       	adc	r27, r27
    19ee:	ee 1f       	adc	r30, r30
    19f0:	ff 1f       	adc	r31, r31
    19f2:	a2 17       	cp	r26, r18
    19f4:	b3 07       	cpc	r27, r19
    19f6:	e4 07       	cpc	r30, r20
    19f8:	f5 07       	cpc	r31, r21
    19fa:	20 f0       	brcs	.+8      	; 0x1a04 <__udivmodsi4_ep>
    19fc:	a2 1b       	sub	r26, r18
    19fe:	b3 0b       	sbc	r27, r19
    1a00:	e4 0b       	sbc	r30, r20
    1a02:	f5 0b       	sbc	r31, r21

00001a04 <__udivmodsi4_ep>:
    1a04:	66 1f       	adc	r22, r22
    1a06:	77 1f       	adc	r23, r23
    1a08:	88 1f       	adc	r24, r24
    1a0a:	99 1f       	adc	r25, r25
    1a0c:	1a 94       	dec	r1
    1a0e:	69 f7       	brne	.-38     	; 0x19ea <__udivmodsi4_loop>
    1a10:	60 95       	com	r22
    1a12:	70 95       	com	r23
    1a14:	80 95       	com	r24
    1a16:	90 95       	com	r25
    1a18:	9b 01       	movw	r18, r22
    1a1a:	ac 01       	movw	r20, r24
    1a1c:	bd 01       	movw	r22, r26
    1a1e:	cf 01       	movw	r24, r30
    1a20:	08 95       	ret

00001a22 <__umulhisi3>:
    1a22:	a2 9f       	mul	r26, r18
    1a24:	b0 01       	movw	r22, r0
    1a26:	b3 9f       	mul	r27, r19
    1a28:	c0 01       	movw	r24, r0
    1a2a:	a3 9f       	mul	r26, r19
    1a2c:	70 0d       	add	r23, r0
    1a2e:	81 1d       	adc	r24, r1
    1a30:	11 24       	eor	r1, r1
    1a32:	91 1d       	adc	r25, r1
    1a34:	b2 9f       	mul	r27, r18
    1a36:	70 0d       	add	r23, r0
    1a38:	81 1d       	adc	r24, r1
    1a3a:	11 24       	eor	r1, r1
    1a3c:	91 1d       	adc	r25, r1
    1a3e:	08 95       	ret

00001a40 <__itoa_ncheck>:
    1a40:	bb 27       	eor	r27, r27
    1a42:	4a 30       	cpi	r20, 0x0A	; 10
    1a44:	31 f4       	brne	.+12     	; 0x1a52 <__itoa_ncheck+0x12>
    1a46:	99 23       	and	r25, r25
    1a48:	22 f4       	brpl	.+8      	; 0x1a52 <__itoa_ncheck+0x12>
    1a4a:	bd e2       	ldi	r27, 0x2D	; 45
    1a4c:	90 95       	com	r25
    1a4e:	81 95       	neg	r24
    1a50:	9f 4f       	sbci	r25, 0xFF	; 255
    1a52:	01 c0       	rjmp	.+2      	; 0x1a56 <__utoa_common>

00001a54 <__utoa_ncheck>:
    1a54:	bb 27       	eor	r27, r27

00001a56 <__utoa_common>:
    1a56:	fb 01       	movw	r30, r22
    1a58:	55 27       	eor	r21, r21
    1a5a:	aa 27       	eor	r26, r26
    1a5c:	88 0f       	add	r24, r24
    1a5e:	99 1f       	adc	r25, r25
    1a60:	aa 1f       	adc	r26, r26
    1a62:	a4 17       	cp	r26, r20
    1a64:	10 f0       	brcs	.+4      	; 0x1a6a <__utoa_common+0x14>
    1a66:	a4 1b       	sub	r26, r20
    1a68:	83 95       	inc	r24
    1a6a:	50 51       	subi	r21, 0x10	; 16
    1a6c:	b9 f7       	brne	.-18     	; 0x1a5c <__utoa_common+0x6>
    1a6e:	a0 5d       	subi	r26, 0xD0	; 208
    1a70:	aa 33       	cpi	r26, 0x3A	; 58
    1a72:	08 f0       	brcs	.+2      	; 0x1a76 <__utoa_common+0x20>
    1a74:	a9 5d       	subi	r26, 0xD9	; 217
    1a76:	a1 93       	st	Z+, r26
    1a78:	00 97       	sbiw	r24, 0x00	; 0
    1a7a:	79 f7       	brne	.-34     	; 0x1a5a <__utoa_common+0x4>
    1a7c:	b1 11       	cpse	r27, r1
    1a7e:	b1 93       	st	Z+, r27
    1a80:	11 92       	st	Z+, r1
    1a82:	cb 01       	movw	r24, r22
    1a84:	00 c0       	rjmp	.+0      	; 0x1a86 <strrev>

00001a86 <strrev>:
    1a86:	dc 01       	movw	r26, r24
    1a88:	fc 01       	movw	r30, r24
    1a8a:	67 2f       	mov	r22, r23
    1a8c:	71 91       	ld	r23, Z+
    1a8e:	77 23       	and	r23, r23
    1a90:	e1 f7       	brne	.-8      	; 0x1a8a <strrev+0x4>
    1a92:	32 97       	sbiw	r30, 0x02	; 2
    1a94:	04 c0       	rjmp	.+8      	; 0x1a9e <strrev+0x18>
    1a96:	7c 91       	ld	r23, X
    1a98:	6d 93       	st	X+, r22
    1a9a:	70 83       	st	Z, r23
    1a9c:	62 91       	ld	r22, -Z
    1a9e:	ae 17       	cp	r26, r30
    1aa0:	bf 07       	cpc	r27, r31
    1aa2:	c8 f3       	brcs	.-14     	; 0x1a96 <strrev+0x10>
    1aa4:	08 95       	ret

00001aa6 <_exit>:
    1aa6:	f8 94       	cli

00001aa8 <__stop_program>:
    1aa8:	ff cf       	rjmp	.-2      	; 0x1aa8 <__stop_program>
