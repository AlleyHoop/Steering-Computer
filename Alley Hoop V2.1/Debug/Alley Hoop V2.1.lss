
Alley Hoop V2.1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000234  00800200  00001a3c  00001ad0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001a3c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000059  00800434  00800434  00001d04  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001d04  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001d34  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000238  00000000  00000000  00001d74  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004627  00000000  00000000  00001fac  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000179d  00000000  00000000  000065d3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000173f  00000000  00000000  00007d70  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000670  00000000  00000000  000094b0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001148  00000000  00000000  00009b20  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001ef8  00000000  00000000  0000ac68  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001f0  00000000  00000000  0000cb60  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	7d c0       	rjmp	.+250    	; 0xfc <__ctors_end>
       2:	00 00       	nop
       4:	ab c0       	rjmp	.+342    	; 0x15c <__bad_interrupt>
       6:	00 00       	nop
       8:	a9 c0       	rjmp	.+338    	; 0x15c <__bad_interrupt>
       a:	00 00       	nop
       c:	a7 c0       	rjmp	.+334    	; 0x15c <__bad_interrupt>
       e:	00 00       	nop
      10:	a5 c0       	rjmp	.+330    	; 0x15c <__bad_interrupt>
      12:	00 00       	nop
      14:	a3 c0       	rjmp	.+326    	; 0x15c <__bad_interrupt>
      16:	00 00       	nop
      18:	a1 c0       	rjmp	.+322    	; 0x15c <__bad_interrupt>
      1a:	00 00       	nop
      1c:	9f c0       	rjmp	.+318    	; 0x15c <__bad_interrupt>
      1e:	00 00       	nop
      20:	9d c0       	rjmp	.+314    	; 0x15c <__bad_interrupt>
      22:	00 00       	nop
      24:	9b c0       	rjmp	.+310    	; 0x15c <__bad_interrupt>
      26:	00 00       	nop
      28:	99 c0       	rjmp	.+306    	; 0x15c <__bad_interrupt>
      2a:	00 00       	nop
      2c:	97 c0       	rjmp	.+302    	; 0x15c <__bad_interrupt>
      2e:	00 00       	nop
      30:	95 c0       	rjmp	.+298    	; 0x15c <__bad_interrupt>
      32:	00 00       	nop
      34:	93 c0       	rjmp	.+294    	; 0x15c <__bad_interrupt>
      36:	00 00       	nop
      38:	91 c0       	rjmp	.+290    	; 0x15c <__bad_interrupt>
      3a:	00 00       	nop
      3c:	8f c0       	rjmp	.+286    	; 0x15c <__bad_interrupt>
      3e:	00 00       	nop
      40:	8d c0       	rjmp	.+282    	; 0x15c <__bad_interrupt>
      42:	00 00       	nop
      44:	8b c0       	rjmp	.+278    	; 0x15c <__bad_interrupt>
      46:	00 00       	nop
      48:	89 c0       	rjmp	.+274    	; 0x15c <__bad_interrupt>
      4a:	00 00       	nop
      4c:	87 c0       	rjmp	.+270    	; 0x15c <__bad_interrupt>
      4e:	00 00       	nop
      50:	85 c0       	rjmp	.+266    	; 0x15c <__bad_interrupt>
      52:	00 00       	nop
      54:	83 c0       	rjmp	.+262    	; 0x15c <__bad_interrupt>
      56:	00 00       	nop
      58:	81 c0       	rjmp	.+258    	; 0x15c <__bad_interrupt>
      5a:	00 00       	nop
      5c:	7f c0       	rjmp	.+254    	; 0x15c <__bad_interrupt>
      5e:	00 00       	nop
      60:	7d c0       	rjmp	.+250    	; 0x15c <__bad_interrupt>
      62:	00 00       	nop
      64:	7b c0       	rjmp	.+246    	; 0x15c <__bad_interrupt>
      66:	00 00       	nop
      68:	79 c0       	rjmp	.+242    	; 0x15c <__bad_interrupt>
      6a:	00 00       	nop
      6c:	77 c0       	rjmp	.+238    	; 0x15c <__bad_interrupt>
      6e:	00 00       	nop
      70:	75 c0       	rjmp	.+234    	; 0x15c <__bad_interrupt>
      72:	00 00       	nop
      74:	73 c0       	rjmp	.+230    	; 0x15c <__bad_interrupt>
      76:	00 00       	nop
      78:	71 c0       	rjmp	.+226    	; 0x15c <__bad_interrupt>
      7a:	00 00       	nop
      7c:	6f c0       	rjmp	.+222    	; 0x15c <__bad_interrupt>
      7e:	00 00       	nop
      80:	6d c0       	rjmp	.+218    	; 0x15c <__bad_interrupt>
      82:	00 00       	nop
      84:	6b c0       	rjmp	.+214    	; 0x15c <__bad_interrupt>
      86:	00 00       	nop
      88:	69 c0       	rjmp	.+210    	; 0x15c <__bad_interrupt>
      8a:	00 00       	nop
      8c:	67 c0       	rjmp	.+206    	; 0x15c <__bad_interrupt>
      8e:	00 00       	nop
      90:	65 c0       	rjmp	.+202    	; 0x15c <__bad_interrupt>
      92:	00 00       	nop
      94:	63 c0       	rjmp	.+198    	; 0x15c <__bad_interrupt>
      96:	00 00       	nop
      98:	61 c0       	rjmp	.+194    	; 0x15c <__bad_interrupt>
      9a:	00 00       	nop
      9c:	5f c0       	rjmp	.+190    	; 0x15c <__bad_interrupt>
      9e:	00 00       	nop
      a0:	5d c0       	rjmp	.+186    	; 0x15c <__bad_interrupt>
      a2:	00 00       	nop
      a4:	5b c0       	rjmp	.+182    	; 0x15c <__bad_interrupt>
      a6:	00 00       	nop
      a8:	59 c0       	rjmp	.+178    	; 0x15c <__bad_interrupt>
      aa:	00 00       	nop
      ac:	57 c0       	rjmp	.+174    	; 0x15c <__bad_interrupt>
      ae:	00 00       	nop
      b0:	55 c0       	rjmp	.+170    	; 0x15c <__bad_interrupt>
      b2:	00 00       	nop
      b4:	53 c0       	rjmp	.+166    	; 0x15c <__bad_interrupt>
      b6:	00 00       	nop
      b8:	51 c0       	rjmp	.+162    	; 0x15c <__bad_interrupt>
      ba:	00 00       	nop
      bc:	4f c0       	rjmp	.+158    	; 0x15c <__bad_interrupt>
      be:	00 00       	nop
      c0:	4d c0       	rjmp	.+154    	; 0x15c <__bad_interrupt>
      c2:	00 00       	nop
      c4:	4b c0       	rjmp	.+150    	; 0x15c <__bad_interrupt>
      c6:	00 00       	nop
      c8:	49 c0       	rjmp	.+146    	; 0x15c <__bad_interrupt>
      ca:	00 00       	nop
      cc:	47 c0       	rjmp	.+142    	; 0x15c <__bad_interrupt>
      ce:	00 00       	nop
      d0:	45 c0       	rjmp	.+138    	; 0x15c <__bad_interrupt>
      d2:	00 00       	nop
      d4:	43 c0       	rjmp	.+134    	; 0x15c <__bad_interrupt>
      d6:	00 00       	nop
      d8:	41 c0       	rjmp	.+130    	; 0x15c <__bad_interrupt>
      da:	00 00       	nop
      dc:	3f c0       	rjmp	.+126    	; 0x15c <__bad_interrupt>
      de:	00 00       	nop
      e0:	3d c0       	rjmp	.+122    	; 0x15c <__bad_interrupt>
      e2:	00 00       	nop
      e4:	fb 03       	fmulsu	r23, r19
      e6:	00 04       	cpc	r0, r0
      e8:	05 04       	cpc	r0, r5
      ea:	07 04       	cpc	r0, r7
      ec:	0c 04       	cpc	r0, r12
      ee:	11 04       	cpc	r1, r1
      f0:	16 04       	cpc	r1, r6
      f2:	1b 04       	cpc	r1, r11
      f4:	1e 04       	cpc	r1, r14
      f6:	21 04       	cpc	r2, r1
      f8:	26 04       	cpc	r2, r6

000000fa <__ctors_start>:
      fa:	d9 06       	cpc	r13, r25

000000fc <__ctors_end>:
      fc:	11 24       	eor	r1, r1
      fe:	1f be       	out	0x3f, r1	; 63
     100:	cf ef       	ldi	r28, 0xFF	; 255
     102:	d1 e2       	ldi	r29, 0x21	; 33
     104:	de bf       	out	0x3e, r29	; 62
     106:	cd bf       	out	0x3d, r28	; 61
     108:	00 e0       	ldi	r16, 0x00	; 0
     10a:	0c bf       	out	0x3c, r16	; 60

0000010c <__do_copy_data>:
     10c:	14 e0       	ldi	r17, 0x04	; 4
     10e:	a0 e0       	ldi	r26, 0x00	; 0
     110:	b2 e0       	ldi	r27, 0x02	; 2
     112:	ec e3       	ldi	r30, 0x3C	; 60
     114:	fa e1       	ldi	r31, 0x1A	; 26
     116:	00 e0       	ldi	r16, 0x00	; 0
     118:	0b bf       	out	0x3b, r16	; 59
     11a:	02 c0       	rjmp	.+4      	; 0x120 <__do_copy_data+0x14>
     11c:	07 90       	elpm	r0, Z+
     11e:	0d 92       	st	X+, r0
     120:	a4 33       	cpi	r26, 0x34	; 52
     122:	b1 07       	cpc	r27, r17
     124:	d9 f7       	brne	.-10     	; 0x11c <__do_copy_data+0x10>

00000126 <__do_clear_bss>:
     126:	24 e0       	ldi	r18, 0x04	; 4
     128:	a4 e3       	ldi	r26, 0x34	; 52
     12a:	b4 e0       	ldi	r27, 0x04	; 4
     12c:	01 c0       	rjmp	.+2      	; 0x130 <.do_clear_bss_start>

0000012e <.do_clear_bss_loop>:
     12e:	1d 92       	st	X+, r1

00000130 <.do_clear_bss_start>:
     130:	ad 38       	cpi	r26, 0x8D	; 141
     132:	b2 07       	cpc	r27, r18
     134:	e1 f7       	brne	.-8      	; 0x12e <.do_clear_bss_loop>

00000136 <__do_global_ctors>:
     136:	10 e0       	ldi	r17, 0x00	; 0
     138:	ce e7       	ldi	r28, 0x7E	; 126
     13a:	d0 e0       	ldi	r29, 0x00	; 0
     13c:	00 e0       	ldi	r16, 0x00	; 0
     13e:	06 c0       	rjmp	.+12     	; 0x14c <__do_global_ctors+0x16>
     140:	21 97       	sbiw	r28, 0x01	; 1
     142:	01 09       	sbc	r16, r1
     144:	80 2f       	mov	r24, r16
     146:	fe 01       	movw	r30, r28
     148:	0e 94 a0 0c 	call	0x1940	; 0x1940 <__tablejump2__>
     14c:	cd 37       	cpi	r28, 0x7D	; 125
     14e:	d1 07       	cpc	r29, r17
     150:	80 e0       	ldi	r24, 0x00	; 0
     152:	08 07       	cpc	r16, r24
     154:	a9 f7       	brne	.-22     	; 0x140 <__do_global_ctors+0xa>
     156:	0b d6       	rcall	.+3094   	; 0xd6e <main>
     158:	0c 94 1c 0d 	jmp	0x1a38	; 0x1a38 <_exit>

0000015c <__bad_interrupt>:
     15c:	51 cf       	rjmp	.-350    	; 0x0 <__vectors>

0000015e <_Z11mode_selectv>:
		digitalWrite(do_hv_relais,LOW);			//disengage engine relay
		braking_dv=0;							//stop braking
	}
}

void mode_remote(){
     15e:	8b e2       	ldi	r24, 0x2B	; 43
     160:	90 e0       	ldi	r25, 0x00	; 0
     162:	4e d4       	rcall	.+2204   	; 0xa00 <_Z11digitalReadi>
     164:	88 23       	and	r24, r24
     166:	39 f0       	breq	.+14     	; 0x176 <_Z11mode_selectv+0x18>
     168:	81 e0       	ldi	r24, 0x01	; 1
     16a:	90 e0       	ldi	r25, 0x00	; 0
     16c:	90 93 6a 04 	sts	0x046A, r25	; 0x80046a <drivemode+0x1>
     170:	80 93 69 04 	sts	0x0469, r24	; 0x800469 <drivemode>
     174:	08 95       	ret
     176:	88 e2       	ldi	r24, 0x28	; 40
     178:	90 e0       	ldi	r25, 0x00	; 0
     17a:	42 d4       	rcall	.+2180   	; 0xa00 <_Z11digitalReadi>
     17c:	88 23       	and	r24, r24
     17e:	39 f0       	breq	.+14     	; 0x18e <_Z11mode_selectv+0x30>
     180:	82 e0       	ldi	r24, 0x02	; 2
     182:	90 e0       	ldi	r25, 0x00	; 0
     184:	90 93 6a 04 	sts	0x046A, r25	; 0x80046a <drivemode+0x1>
     188:	80 93 69 04 	sts	0x0469, r24	; 0x800469 <drivemode>
     18c:	08 95       	ret
     18e:	89 e2       	ldi	r24, 0x29	; 41
     190:	90 e0       	ldi	r25, 0x00	; 0
     192:	36 d4       	rcall	.+2156   	; 0xa00 <_Z11digitalReadi>
     194:	88 23       	and	r24, r24
     196:	39 f0       	breq	.+14     	; 0x1a6 <_Z11mode_selectv+0x48>
     198:	83 e0       	ldi	r24, 0x03	; 3
     19a:	90 e0       	ldi	r25, 0x00	; 0
     19c:	90 93 6a 04 	sts	0x046A, r25	; 0x80046a <drivemode+0x1>
     1a0:	80 93 69 04 	sts	0x0469, r24	; 0x800469 <drivemode>
     1a4:	08 95       	ret
     1a6:	10 92 6a 04 	sts	0x046A, r1	; 0x80046a <drivemode+0x1>
     1aa:	10 92 69 04 	sts	0x0469, r1	; 0x800469 <drivemode>
     1ae:	08 95       	ret

000001b0 <_Z9initDrivev>:
     1b0:	61 e0       	ldi	r22, 0x01	; 1
     1b2:	8a e1       	ldi	r24, 0x1A	; 26
     1b4:	90 e0       	ldi	r25, 0x00	; 0
     1b6:	55 d3       	rcall	.+1706   	; 0x862 <_Z12digitalWriteib>
     1b8:	61 e0       	ldi	r22, 0x01	; 1
     1ba:	88 e1       	ldi	r24, 0x18	; 24
     1bc:	90 e0       	ldi	r25, 0x00	; 0
     1be:	51 d3       	rcall	.+1698   	; 0x862 <_Z12digitalWriteib>
     1c0:	61 e0       	ldi	r22, 0x01	; 1
     1c2:	89 e1       	ldi	r24, 0x19	; 25
     1c4:	90 e0       	ldi	r25, 0x00	; 0
     1c6:	4d d3       	rcall	.+1690   	; 0x862 <_Z12digitalWriteib>
     1c8:	61 e0       	ldi	r22, 0x01	; 1
     1ca:	86 e1       	ldi	r24, 0x16	; 22
     1cc:	90 e0       	ldi	r25, 0x00	; 0
     1ce:	49 d3       	rcall	.+1682   	; 0x862 <_Z12digitalWriteib>
     1d0:	61 e0       	ldi	r22, 0x01	; 1
     1d2:	87 e1       	ldi	r24, 0x17	; 23
     1d4:	90 e0       	ldi	r25, 0x00	; 0
     1d6:	45 d3       	rcall	.+1674   	; 0x862 <_Z12digitalWriteib>
     1d8:	c2 cf       	rjmp	.-124    	; 0x15e <_Z11mode_selectv>
     1da:	08 95       	ret

000001dc <_Z13mode_joystickv>:
     1dc:	61 e0       	ldi	r22, 0x01	; 1
     1de:	81 e2       	ldi	r24, 0x21	; 33
     1e0:	90 e0       	ldi	r25, 0x00	; 0
     1e2:	3f d3       	rcall	.+1662   	; 0x862 <_Z12digitalWriteib>
     1e4:	80 91 3a 04 	lds	r24, 0x043A	; 0x80043a <engine_rpm>
     1e8:	90 91 3b 04 	lds	r25, 0x043B	; 0x80043b <engine_rpm+0x1>
     1ec:	89 2b       	or	r24, r25
     1ee:	29 f4       	brne	.+10     	; 0x1fa <_Z13mode_joystickv+0x1e>
     1f0:	8a e2       	ldi	r24, 0x2A	; 42
     1f2:	90 e0       	ldi	r25, 0x00	; 0
     1f4:	05 d4       	rcall	.+2058   	; 0xa00 <_Z11digitalReadi>
     1f6:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
     1fa:	84 e0       	ldi	r24, 0x04	; 4
     1fc:	90 e0       	ldi	r25, 0x00	; 0
     1fe:	7c d4       	rcall	.+2296   	; 0xaf8 <_Z10analogReadi>
     200:	dc 01       	movw	r26, r24
     202:	ab 5f       	subi	r26, 0xFB	; 251
     204:	b1 40       	sbci	r27, 0x01	; 1
     206:	2e e5       	ldi	r18, 0x5E	; 94
     208:	31 e0       	ldi	r19, 0x01	; 1
     20a:	0e 94 a8 0c 	call	0x1950	; 0x1950 <__usmulhisi3>
     20e:	29 e8       	ldi	r18, 0x89	; 137
     210:	30 e0       	ldi	r19, 0x00	; 0
     212:	40 e0       	ldi	r20, 0x00	; 0
     214:	50 e0       	ldi	r21, 0x00	; 0
     216:	0e 94 84 0c 	call	0x1908	; 0x1908 <__divmodsi4>
     21a:	20 93 61 04 	sts	0x0461, r18	; 0x800461 <steering_dv>
     21e:	30 93 62 04 	sts	0x0462, r19	; 0x800462 <steering_dv+0x1>
     222:	40 93 63 04 	sts	0x0463, r20	; 0x800463 <steering_dv+0x2>
     226:	50 93 64 04 	sts	0x0464, r21	; 0x800464 <steering_dv+0x3>
     22a:	82 e0       	ldi	r24, 0x02	; 2
     22c:	90 e0       	ldi	r25, 0x00	; 0
     22e:	64 d4       	rcall	.+2248   	; 0xaf8 <_Z10analogReadi>
     230:	8e 5f       	subi	r24, 0xFE	; 254
     232:	91 40       	sbci	r25, 0x01	; 1
     234:	9c 01       	movw	r18, r24
     236:	2c 5f       	subi	r18, 0xFC	; 252
     238:	3f 4f       	sbci	r19, 0xFF	; 255
     23a:	29 30       	cpi	r18, 0x09	; 9
     23c:	31 05       	cpc	r19, r1
     23e:	68 f0       	brcs	.+26     	; 0x25a <_Z13mode_joystickv+0x7e>
     240:	09 2e       	mov	r0, r25
     242:	00 0c       	add	r0, r0
     244:	aa 0b       	sbc	r26, r26
     246:	bb 0b       	sbc	r27, r27
     248:	80 93 65 04 	sts	0x0465, r24	; 0x800465 <driving_dv>
     24c:	90 93 66 04 	sts	0x0466, r25	; 0x800466 <driving_dv+0x1>
     250:	a0 93 67 04 	sts	0x0467, r26	; 0x800467 <driving_dv+0x2>
     254:	b0 93 68 04 	sts	0x0468, r27	; 0x800468 <driving_dv+0x3>
     258:	08 c0       	rjmp	.+16     	; 0x26a <_Z13mode_joystickv+0x8e>
     25a:	10 92 65 04 	sts	0x0465, r1	; 0x800465 <driving_dv>
     25e:	10 92 66 04 	sts	0x0466, r1	; 0x800466 <driving_dv+0x1>
     262:	10 92 67 04 	sts	0x0467, r1	; 0x800467 <driving_dv+0x2>
     266:	10 92 68 04 	sts	0x0468, r1	; 0x800468 <driving_dv+0x3>
     26a:	10 92 54 04 	sts	0x0454, r1	; 0x800454 <engine_dv>
     26e:	10 92 55 04 	sts	0x0455, r1	; 0x800455 <engine_dv+0x1>
     272:	10 92 56 04 	sts	0x0456, r1	; 0x800456 <engine_dv+0x2>
     276:	10 92 57 04 	sts	0x0457, r1	; 0x800457 <engine_dv+0x3>
     27a:	10 92 47 04 	sts	0x0447, r1	; 0x800447 <braking_dv>
     27e:	10 92 48 04 	sts	0x0448, r1	; 0x800448 <braking_dv+0x1>
     282:	10 92 49 04 	sts	0x0449, r1	; 0x800449 <braking_dv+0x2>
     286:	10 92 4a 04 	sts	0x044A, r1	; 0x80044a <braking_dv+0x3>
     28a:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__data_start>
     28e:	88 23       	and	r24, r24
     290:	51 f1       	breq	.+84     	; 0x2e6 <_Z13mode_joystickv+0x10a>
     292:	80 91 65 04 	lds	r24, 0x0465	; 0x800465 <driving_dv>
     296:	90 91 66 04 	lds	r25, 0x0466	; 0x800466 <driving_dv+0x1>
     29a:	a0 91 67 04 	lds	r26, 0x0467	; 0x800467 <driving_dv+0x2>
     29e:	b0 91 68 04 	lds	r27, 0x0468	; 0x800468 <driving_dv+0x3>
     2a2:	18 16       	cp	r1, r24
     2a4:	19 06       	cpc	r1, r25
     2a6:	1a 06       	cpc	r1, r26
     2a8:	1b 06       	cpc	r1, r27
     2aa:	4c f4       	brge	.+18     	; 0x2be <_Z13mode_joystickv+0xe2>
     2ac:	80 93 54 04 	sts	0x0454, r24	; 0x800454 <engine_dv>
     2b0:	90 93 55 04 	sts	0x0455, r25	; 0x800455 <engine_dv+0x1>
     2b4:	a0 93 56 04 	sts	0x0456, r26	; 0x800456 <engine_dv+0x2>
     2b8:	b0 93 57 04 	sts	0x0457, r27	; 0x800457 <engine_dv+0x3>
     2bc:	08 95       	ret
     2be:	9c 01       	movw	r18, r24
     2c0:	99 23       	and	r25, r25
     2c2:	24 f4       	brge	.+8      	; 0x2cc <_Z13mode_joystickv+0xf0>
     2c4:	22 27       	eor	r18, r18
     2c6:	33 27       	eor	r19, r19
     2c8:	28 1b       	sub	r18, r24
     2ca:	39 0b       	sbc	r19, r25
     2cc:	c9 01       	movw	r24, r18
     2ce:	33 0f       	add	r19, r19
     2d0:	aa 0b       	sbc	r26, r26
     2d2:	bb 0b       	sbc	r27, r27
     2d4:	80 93 47 04 	sts	0x0447, r24	; 0x800447 <braking_dv>
     2d8:	90 93 48 04 	sts	0x0448, r25	; 0x800448 <braking_dv+0x1>
     2dc:	a0 93 49 04 	sts	0x0449, r26	; 0x800449 <braking_dv+0x2>
     2e0:	b0 93 4a 04 	sts	0x044A, r27	; 0x80044a <braking_dv+0x3>
     2e4:	08 95       	ret
     2e6:	80 91 65 04 	lds	r24, 0x0465	; 0x800465 <driving_dv>
     2ea:	90 91 66 04 	lds	r25, 0x0466	; 0x800466 <driving_dv+0x1>
     2ee:	a0 91 67 04 	lds	r26, 0x0467	; 0x800467 <driving_dv+0x2>
     2f2:	b0 91 68 04 	lds	r27, 0x0468	; 0x800468 <driving_dv+0x3>
     2f6:	18 16       	cp	r1, r24
     2f8:	19 06       	cpc	r1, r25
     2fa:	1a 06       	cpc	r1, r26
     2fc:	1b 06       	cpc	r1, r27
     2fe:	4c f4       	brge	.+18     	; 0x312 <_Z13mode_joystickv+0x136>
     300:	80 93 47 04 	sts	0x0447, r24	; 0x800447 <braking_dv>
     304:	90 93 48 04 	sts	0x0448, r25	; 0x800448 <braking_dv+0x1>
     308:	a0 93 49 04 	sts	0x0449, r26	; 0x800449 <braking_dv+0x2>
     30c:	b0 93 4a 04 	sts	0x044A, r27	; 0x80044a <braking_dv+0x3>
     310:	08 95       	ret
     312:	9c 01       	movw	r18, r24
     314:	99 23       	and	r25, r25
     316:	24 f4       	brge	.+8      	; 0x320 <_Z13mode_joystickv+0x144>
     318:	22 27       	eor	r18, r18
     31a:	33 27       	eor	r19, r19
     31c:	28 1b       	sub	r18, r24
     31e:	39 0b       	sbc	r19, r25
     320:	c9 01       	movw	r24, r18
     322:	33 0f       	add	r19, r19
     324:	aa 0b       	sbc	r26, r26
     326:	bb 0b       	sbc	r27, r27
     328:	80 93 54 04 	sts	0x0454, r24	; 0x800454 <engine_dv>
     32c:	90 93 55 04 	sts	0x0455, r25	; 0x800455 <engine_dv+0x1>
     330:	a0 93 56 04 	sts	0x0456, r26	; 0x800456 <engine_dv+0x2>
     334:	b0 93 57 04 	sts	0x0457, r27	; 0x800457 <engine_dv+0x3>
     338:	08 95       	ret

0000033a <_Z9mode_idlev>:
     33a:	10 92 54 04 	sts	0x0454, r1	; 0x800454 <engine_dv>
     33e:	10 92 55 04 	sts	0x0455, r1	; 0x800455 <engine_dv+0x1>
     342:	10 92 56 04 	sts	0x0456, r1	; 0x800456 <engine_dv+0x2>
     346:	10 92 57 04 	sts	0x0457, r1	; 0x800457 <engine_dv+0x3>
     34a:	8b ef       	ldi	r24, 0xFB	; 251
     34c:	91 e0       	ldi	r25, 0x01	; 1
     34e:	a0 e0       	ldi	r26, 0x00	; 0
     350:	b0 e0       	ldi	r27, 0x00	; 0
     352:	80 93 61 04 	sts	0x0461, r24	; 0x800461 <steering_dv>
     356:	90 93 62 04 	sts	0x0462, r25	; 0x800462 <steering_dv+0x1>
     35a:	a0 93 63 04 	sts	0x0463, r26	; 0x800463 <steering_dv+0x2>
     35e:	b0 93 64 04 	sts	0x0464, r27	; 0x800464 <steering_dv+0x3>
     362:	84 e6       	ldi	r24, 0x64	; 100
     364:	90 e0       	ldi	r25, 0x00	; 0
     366:	a0 e0       	ldi	r26, 0x00	; 0
     368:	b0 e0       	ldi	r27, 0x00	; 0
     36a:	80 93 47 04 	sts	0x0447, r24	; 0x800447 <braking_dv>
     36e:	90 93 48 04 	sts	0x0448, r25	; 0x800448 <braking_dv+0x1>
     372:	a0 93 49 04 	sts	0x0449, r26	; 0x800449 <braking_dv+0x2>
     376:	b0 93 4a 04 	sts	0x044A, r27	; 0x80044a <braking_dv+0x3>
     37a:	80 91 3a 04 	lds	r24, 0x043A	; 0x80043a <engine_rpm>
     37e:	90 91 3b 04 	lds	r25, 0x043B	; 0x80043b <engine_rpm+0x1>
     382:	89 2b       	or	r24, r25
     384:	61 f4       	brne	.+24     	; 0x39e <_Z9mode_idlev+0x64>
     386:	60 e0       	ldi	r22, 0x00	; 0
     388:	81 e2       	ldi	r24, 0x21	; 33
     38a:	90 e0       	ldi	r25, 0x00	; 0
     38c:	6a d2       	rcall	.+1236   	; 0x862 <_Z12digitalWriteib>
     38e:	10 92 47 04 	sts	0x0447, r1	; 0x800447 <braking_dv>
     392:	10 92 48 04 	sts	0x0448, r1	; 0x800448 <braking_dv+0x1>
     396:	10 92 49 04 	sts	0x0449, r1	; 0x800449 <braking_dv+0x2>
     39a:	10 92 4a 04 	sts	0x044A, r1	; 0x80044a <braking_dv+0x3>
     39e:	08 95       	ret

000003a0 <_Z9run_brakev>:
	//digitalWrite(do_hv_relais,HIGH);
	//not (yet) implemented
}

void run_brake(){
	braking_cv = (long(analogRead(ai_brake_pressure) - braking_sensor_offset) * (250 / 1023));				//retrieve the current value of the brake pressure sensor
     3a0:	81 e0       	ldi	r24, 0x01	; 1
     3a2:	90 e0       	ldi	r25, 0x00	; 0
     3a4:	a9 d3       	rcall	.+1874   	; 0xaf8 <_Z10analogReadi>
     3a6:	10 92 3f 04 	sts	0x043F, r1	; 0x80043f <braking_cv>
     3aa:	10 92 40 04 	sts	0x0440, r1	; 0x800440 <braking_cv+0x1>
     3ae:	10 92 41 04 	sts	0x0441, r1	; 0x800441 <braking_cv+0x2>
     3b2:	10 92 42 04 	sts	0x0442, r1	; 0x800442 <braking_cv+0x3>
	braking_delta = braking_dv - braking_cv;
     3b6:	40 91 47 04 	lds	r20, 0x0447	; 0x800447 <braking_dv>
     3ba:	50 91 48 04 	lds	r21, 0x0448	; 0x800448 <braking_dv+0x1>
     3be:	60 91 49 04 	lds	r22, 0x0449	; 0x800449 <braking_dv+0x2>
     3c2:	70 91 4a 04 	lds	r23, 0x044A	; 0x80044a <braking_dv+0x3>
	if(abs(braking_delta)<10)
     3c6:	ca 01       	movw	r24, r20
     3c8:	09 96       	adiw	r24, 0x09	; 9
     3ca:	43 97       	sbiw	r24, 0x13	; 19
     3cc:	48 f0       	brcs	.+18     	; 0x3e0 <_Z9run_brakev+0x40>
	//not (yet) implemented
}

void run_brake(){
	braking_cv = (long(analogRead(ai_brake_pressure) - braking_sensor_offset) * (250 / 1023));				//retrieve the current value of the brake pressure sensor
	braking_delta = braking_dv - braking_cv;
     3ce:	40 93 43 04 	sts	0x0443, r20	; 0x800443 <braking_delta>
     3d2:	50 93 44 04 	sts	0x0444, r21	; 0x800444 <braking_delta+0x1>
     3d6:	60 93 45 04 	sts	0x0445, r22	; 0x800445 <braking_delta+0x2>
     3da:	70 93 46 04 	sts	0x0446, r23	; 0x800446 <braking_delta+0x3>
     3de:	08 c0       	rjmp	.+16     	; 0x3f0 <_Z9run_brakev+0x50>
	if(abs(braking_delta)<10)
		braking_delta = 0;
     3e0:	10 92 43 04 	sts	0x0443, r1	; 0x800443 <braking_delta>
     3e4:	10 92 44 04 	sts	0x0444, r1	; 0x800444 <braking_delta+0x1>
     3e8:	10 92 45 04 	sts	0x0445, r1	; 0x800445 <braking_delta+0x2>
     3ec:	10 92 46 04 	sts	0x0446, r1	; 0x800446 <braking_delta+0x3>
	braking_ov = constrain(braking_dv * braking_kp, 0, 255);
     3f0:	db 01       	movw	r26, r22
     3f2:	ca 01       	movw	r24, r20
     3f4:	88 0f       	add	r24, r24
     3f6:	99 1f       	adc	r25, r25
     3f8:	aa 1f       	adc	r26, r26
     3fa:	bb 1f       	adc	r27, r27
     3fc:	84 0f       	add	r24, r20
     3fe:	95 1f       	adc	r25, r21
     400:	a6 1f       	adc	r26, r22
     402:	b7 1f       	adc	r27, r23
     404:	bb 23       	and	r27, r27
     406:	5c f0       	brlt	.+22     	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
     408:	8f 3f       	cpi	r24, 0xFF	; 255
     40a:	91 05       	cpc	r25, r1
     40c:	a1 05       	cpc	r26, r1
     40e:	b1 05       	cpc	r27, r1
     410:	39 f0       	breq	.+14     	; 0x420 <__LOCK_REGION_LENGTH__+0x20>
     412:	34 f0       	brlt	.+12     	; 0x420 <__LOCK_REGION_LENGTH__+0x20>
     414:	8f ef       	ldi	r24, 0xFF	; 255
     416:	90 e0       	ldi	r25, 0x00	; 0
     418:	a0 e0       	ldi	r26, 0x00	; 0
     41a:	b0 e0       	ldi	r27, 0x00	; 0
     41c:	01 c0       	rjmp	.+2      	; 0x420 <__LOCK_REGION_LENGTH__+0x20>
     41e:	80 e0       	ldi	r24, 0x00	; 0
     420:	80 93 3e 04 	sts	0x043E, r24	; 0x80043e <braking_ov>
	analogWrite(pwm_brake_pump, braking_dv);															//Write op to brake pump
     424:	ba 01       	movw	r22, r20
     426:	87 e0       	ldi	r24, 0x07	; 7
     428:	90 e0       	ldi	r25, 0x00	; 0
     42a:	d4 c1       	rjmp	.+936    	; 0x7d4 <_Z11analogWriteii>
     42c:	08 95       	ret

0000042e <_Z9run_steerv>:
}

void run_steer(){
     42e:	0f 93       	push	r16
     430:	1f 93       	push	r17
	steering_cv = -(long(analogRead(ai_steer_pot)- steering_sensor_offset) * 1000/1023);				//retrieve the current value of the steering potentiometer and convert it to 10th of degrees
     432:	80 e0       	ldi	r24, 0x00	; 0
     434:	90 e0       	ldi	r25, 0x00	; 0
     436:	60 d3       	rcall	.+1728   	; 0xaf8 <_Z10analogReadi>
     438:	dc 01       	movw	r26, r24
     43a:	b2 50       	subi	r27, 0x02	; 2
     43c:	28 ee       	ldi	r18, 0xE8	; 232
     43e:	33 e0       	ldi	r19, 0x03	; 3
     440:	0e 94 a8 0c 	call	0x1950	; 0x1950 <__usmulhisi3>
     444:	2f ef       	ldi	r18, 0xFF	; 255
     446:	33 e0       	ldi	r19, 0x03	; 3
     448:	40 e0       	ldi	r20, 0x00	; 0
     44a:	50 e0       	ldi	r21, 0x00	; 0
     44c:	0e 94 84 0c 	call	0x1908	; 0x1908 <__divmodsi4>
     450:	88 27       	eor	r24, r24
     452:	99 27       	eor	r25, r25
     454:	dc 01       	movw	r26, r24
     456:	82 1b       	sub	r24, r18
     458:	93 0b       	sbc	r25, r19
     45a:	a4 0b       	sbc	r26, r20
     45c:	b5 0b       	sbc	r27, r21
     45e:	80 93 59 04 	sts	0x0459, r24	; 0x800459 <steering_cv>
     462:	90 93 5a 04 	sts	0x045A, r25	; 0x80045a <steering_cv+0x1>
     466:	a0 93 5b 04 	sts	0x045B, r26	; 0x80045b <steering_cv+0x2>
     46a:	b0 93 5c 04 	sts	0x045C, r27	; 0x80045c <steering_cv+0x3>
	if(abs(steering_dv)<steering_deadzone)																//create a dead zone around default joystick position, desired value must at least be bigger then dead zone value (makes going straight easier
     46e:	80 91 61 04 	lds	r24, 0x0461	; 0x800461 <steering_dv>
     472:	90 91 62 04 	lds	r25, 0x0462	; 0x800462 <steering_dv+0x1>
     476:	c1 96       	adiw	r24, 0x31	; 49
     478:	83 36       	cpi	r24, 0x63	; 99
     47a:	91 05       	cpc	r25, r1
     47c:	40 f4       	brcc	.+16     	; 0x48e <_Z9run_steerv+0x60>
		steering_dv = 0;
     47e:	10 92 61 04 	sts	0x0461, r1	; 0x800461 <steering_dv>
     482:	10 92 62 04 	sts	0x0462, r1	; 0x800462 <steering_dv+0x1>
     486:	10 92 63 04 	sts	0x0463, r1	; 0x800463 <steering_dv+0x2>
     48a:	10 92 64 04 	sts	0x0464, r1	; 0x800464 <steering_dv+0x3>
	steering_delta = steering_dv - steering_cv;															//difference between desired value and current value
     48e:	80 91 61 04 	lds	r24, 0x0461	; 0x800461 <steering_dv>
     492:	90 91 62 04 	lds	r25, 0x0462	; 0x800462 <steering_dv+0x1>
     496:	a0 91 63 04 	lds	r26, 0x0463	; 0x800463 <steering_dv+0x2>
     49a:	b0 91 64 04 	lds	r27, 0x0464	; 0x800464 <steering_dv+0x3>
     49e:	89 01       	movw	r16, r18
     4a0:	9a 01       	movw	r18, r20
     4a2:	08 0f       	add	r16, r24
     4a4:	19 1f       	adc	r17, r25
     4a6:	2a 1f       	adc	r18, r26
     4a8:	3b 1f       	adc	r19, r27
     4aa:	00 93 5d 04 	sts	0x045D, r16	; 0x80045d <steering_delta>
     4ae:	10 93 5e 04 	sts	0x045E, r17	; 0x80045e <steering_delta+0x1>
     4b2:	20 93 5f 04 	sts	0x045F, r18	; 0x80045f <steering_delta+0x2>
     4b6:	30 93 60 04 	sts	0x0460, r19	; 0x800460 <steering_delta+0x3>
	if(abs(steering_delta)<10)																			//if the two are too close together, don't steer, this to prevent the motor from constantly trying to make small movements which it is not capable of, so it starts skreeching
     4ba:	c8 01       	movw	r24, r16
     4bc:	09 96       	adiw	r24, 0x09	; 9
     4be:	43 97       	sbiw	r24, 0x13	; 19
     4c0:	70 f4       	brcc	.+28     	; 0x4de <_Z9run_steerv+0xb0>
		steering_delta=0;
     4c2:	10 92 5d 04 	sts	0x045D, r1	; 0x80045d <steering_delta>
     4c6:	10 92 5e 04 	sts	0x045E, r1	; 0x80045e <steering_delta+0x1>
     4ca:	10 92 5f 04 	sts	0x045F, r1	; 0x80045f <steering_delta+0x2>
     4ce:	10 92 60 04 	sts	0x0460, r1	; 0x800460 <steering_delta+0x3>
	steering_ov = constrain((abs(steering_delta) * steering_kp), 0, 255);								//determine the output PMW value in such a way that the smaller the delta, the slower it goes to smooth out steering
     4d2:	60 e0       	ldi	r22, 0x00	; 0
     4d4:	70 e0       	ldi	r23, 0x00	; 0
     4d6:	00 e0       	ldi	r16, 0x00	; 0
     4d8:	10 e0       	ldi	r17, 0x00	; 0
     4da:	98 01       	movw	r18, r16
     4dc:	11 c0       	rjmp	.+34     	; 0x500 <_Z9run_steerv+0xd2>
     4de:	c8 01       	movw	r24, r16
     4e0:	99 23       	and	r25, r25
     4e2:	24 f4       	brge	.+8      	; 0x4ec <_Z9run_steerv+0xbe>
     4e4:	88 27       	eor	r24, r24
     4e6:	99 27       	eor	r25, r25
     4e8:	80 1b       	sub	r24, r16
     4ea:	91 0b       	sbc	r25, r17
     4ec:	bc 01       	movw	r22, r24
     4ee:	66 0f       	add	r22, r22
     4f0:	77 1f       	adc	r23, r23
     4f2:	66 0f       	add	r22, r22
     4f4:	77 1f       	adc	r23, r23
     4f6:	66 0f       	add	r22, r22
     4f8:	77 1f       	adc	r23, r23
     4fa:	68 1b       	sub	r22, r24
     4fc:	79 0b       	sbc	r23, r25
     4fe:	3a f0       	brmi	.+14     	; 0x50e <_Z9run_steerv+0xe0>
     500:	6f 3f       	cpi	r22, 0xFF	; 255
     502:	71 05       	cpc	r23, r1
     504:	29 f0       	breq	.+10     	; 0x510 <_Z9run_steerv+0xe2>
     506:	24 f0       	brlt	.+8      	; 0x510 <_Z9run_steerv+0xe2>
     508:	6f ef       	ldi	r22, 0xFF	; 255
     50a:	70 e0       	ldi	r23, 0x00	; 0
     50c:	01 c0       	rjmp	.+2      	; 0x510 <_Z9run_steerv+0xe2>
     50e:	60 e0       	ldi	r22, 0x00	; 0
     510:	60 93 58 04 	sts	0x0458, r22	; 0x800458 <steering_ov>
	if (steering_delta < 0) {																			//H bridge settings, let the engine turn the correct way
     514:	33 23       	and	r19, r19
     516:	54 f4       	brge	.+20     	; 0x52c <_Z9run_steerv+0xfe>
		analogWrite(pwm_steer_rpwm, steering_ov);														
     518:	70 e0       	ldi	r23, 0x00	; 0
     51a:	83 e0       	ldi	r24, 0x03	; 3
     51c:	90 e0       	ldi	r25, 0x00	; 0
     51e:	5a d1       	rcall	.+692    	; 0x7d4 <_Z11analogWriteii>
		analogWrite(pwm_steer_lpwm, 0);
     520:	60 e0       	ldi	r22, 0x00	; 0
     522:	70 e0       	ldi	r23, 0x00	; 0
     524:	82 e0       	ldi	r24, 0x02	; 2
     526:	90 e0       	ldi	r25, 0x00	; 0
     528:	55 d1       	rcall	.+682    	; 0x7d4 <_Z11analogWriteii>
     52a:	1b c0       	rjmp	.+54     	; 0x562 <_Z9run_steerv+0x134>
	}
	else if (steering_delta > 0) {
     52c:	10 16       	cp	r1, r16
     52e:	11 06       	cpc	r1, r17
     530:	12 06       	cpc	r1, r18
     532:	13 06       	cpc	r1, r19
     534:	64 f4       	brge	.+24     	; 0x54e <_Z9run_steerv+0x120>
		analogWrite(pwm_steer_rpwm, 0);
     536:	60 e0       	ldi	r22, 0x00	; 0
     538:	70 e0       	ldi	r23, 0x00	; 0
     53a:	83 e0       	ldi	r24, 0x03	; 3
     53c:	90 e0       	ldi	r25, 0x00	; 0
     53e:	4a d1       	rcall	.+660    	; 0x7d4 <_Z11analogWriteii>
		analogWrite(pwm_steer_lpwm, steering_ov);
     540:	60 91 58 04 	lds	r22, 0x0458	; 0x800458 <steering_ov>
     544:	70 e0       	ldi	r23, 0x00	; 0
     546:	82 e0       	ldi	r24, 0x02	; 2
     548:	90 e0       	ldi	r25, 0x00	; 0
     54a:	44 d1       	rcall	.+648    	; 0x7d4 <_Z11analogWriteii>
     54c:	0a c0       	rjmp	.+20     	; 0x562 <_Z9run_steerv+0x134>
	}
	else {
		analogWrite(pwm_steer_rpwm, 0);
     54e:	60 e0       	ldi	r22, 0x00	; 0
     550:	70 e0       	ldi	r23, 0x00	; 0
     552:	83 e0       	ldi	r24, 0x03	; 3
     554:	90 e0       	ldi	r25, 0x00	; 0
     556:	3e d1       	rcall	.+636    	; 0x7d4 <_Z11analogWriteii>
		analogWrite(pwm_steer_lpwm, 0);
     558:	60 e0       	ldi	r22, 0x00	; 0
     55a:	70 e0       	ldi	r23, 0x00	; 0
     55c:	82 e0       	ldi	r24, 0x02	; 2
     55e:	90 e0       	ldi	r25, 0x00	; 0
     560:	39 d1       	rcall	.+626    	; 0x7d4 <_Z11analogWriteii>
     562:	1f 91       	pop	r17
	}	
}
     564:	0f 91       	pop	r16
     566:	08 95       	ret

00000568 <_Z10run_curtisv>:
     568:	60 91 3a 04 	lds	r22, 0x043A	; 0x80043a <engine_rpm>

void run_curtis(){
	engine_cv = (engine_rpm * float(100 / 1023));												//the proces value of the engine system is the rpm which we read from the CAN-bus of the curtis
     56c:	70 91 3b 04 	lds	r23, 0x043B	; 0x80043b <engine_rpm+0x1>
     570:	80 e0       	ldi	r24, 0x00	; 0
     572:	90 e0       	ldi	r25, 0x00	; 0
     574:	0e 94 93 0b 	call	0x1726	; 0x1726 <__floatunsisf>
     578:	20 e0       	ldi	r18, 0x00	; 0
     57a:	30 e0       	ldi	r19, 0x00	; 0
     57c:	a9 01       	movw	r20, r18
     57e:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <__mulsf3>
     582:	0e 94 62 0b 	call	0x16c4	; 0x16c4 <__fixsfsi>
     586:	60 93 4c 04 	sts	0x044C, r22	; 0x80044c <engine_cv>
     58a:	70 93 4d 04 	sts	0x044D, r23	; 0x80044d <engine_cv+0x1>
     58e:	80 93 4e 04 	sts	0x044E, r24	; 0x80044e <engine_cv+0x2>
     592:	90 93 4f 04 	sts	0x044F, r25	; 0x80044f <engine_cv+0x3>
	digitalWrite(do_drive_forward, driving_direction);											//give the curtiss the correct driving direction
     596:	60 91 00 02 	lds	r22, 0x0200	; 0x800200 <__data_start>
     59a:	8b e1       	ldi	r24, 0x1B	; 27
     59c:	90 e0       	ldi	r25, 0x00	; 0
     59e:	61 d1       	rcall	.+706    	; 0x862 <_Z12digitalWriteib>
	digitalWrite(do_drive_reverse, !driving_direction);
     5a0:	60 91 00 02 	lds	r22, 0x0200	; 0x800200 <__data_start>
     5a4:	81 e0       	ldi	r24, 0x01	; 1
     5a6:	68 27       	eor	r22, r24
     5a8:	8c e1       	ldi	r24, 0x1C	; 28
     5aa:	90 e0       	ldi	r25, 0x00	; 0
     5ac:	5a d1       	rcall	.+692    	; 0x862 <_Z12digitalWriteib>
	
	//Set the curtis in the right mode for braking, driving or neutral																		//if we want to brake
		digitalWrite(do_drive_throttleswitch, engine_dv);				//if there is an engine signal, enable listening to the throttle
     5ae:	61 e0       	ldi	r22, 0x01	; 1
     5b0:	80 91 54 04 	lds	r24, 0x0454	; 0x800454 <engine_dv>
     5b4:	90 91 55 04 	lds	r25, 0x0455	; 0x800455 <engine_dv+0x1>
     5b8:	a0 91 56 04 	lds	r26, 0x0456	; 0x800456 <engine_dv+0x2>
     5bc:	b0 91 57 04 	lds	r27, 0x0457	; 0x800457 <engine_dv+0x3>
     5c0:	89 2b       	or	r24, r25
     5c2:	8a 2b       	or	r24, r26
     5c4:	8b 2b       	or	r24, r27
     5c6:	09 f4       	brne	.+2      	; 0x5ca <_Z10run_curtisv+0x62>
     5c8:	60 e0       	ldi	r22, 0x00	; 0
     5ca:	8e e1       	ldi	r24, 0x1E	; 30
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	49 d1       	rcall	.+658    	; 0x862 <_Z12digitalWriteib>
		digitalWrite(do_drive_brake, braking_dv);						//if there is an braking signal, turn on the braking 
     5d0:	61 e0       	ldi	r22, 0x01	; 1
     5d2:	80 91 47 04 	lds	r24, 0x0447	; 0x800447 <braking_dv>
     5d6:	90 91 48 04 	lds	r25, 0x0448	; 0x800448 <braking_dv+0x1>
     5da:	a0 91 49 04 	lds	r26, 0x0449	; 0x800449 <braking_dv+0x2>
     5de:	b0 91 4a 04 	lds	r27, 0x044A	; 0x80044a <braking_dv+0x3>
     5e2:	89 2b       	or	r24, r25
     5e4:	8a 2b       	or	r24, r26
     5e6:	8b 2b       	or	r24, r27
     5e8:	09 f4       	brne	.+2      	; 0x5ec <_Z10run_curtisv+0x84>
     5ea:	60 e0       	ldi	r22, 0x00	; 0
     5ec:	8d e1       	ldi	r24, 0x1D	; 29
     5ee:	90 e0       	ldi	r25, 0x00	; 0
     5f0:	38 d1       	rcall	.+624    	; 0x862 <_Z12digitalWriteib>

	engine_delta = engine_dv - engine_cv;									//calculate delta
     5f2:	40 91 54 04 	lds	r20, 0x0454	; 0x800454 <engine_dv>
     5f6:	50 91 55 04 	lds	r21, 0x0455	; 0x800455 <engine_dv+0x1>
     5fa:	60 91 56 04 	lds	r22, 0x0456	; 0x800456 <engine_dv+0x2>
     5fe:	70 91 57 04 	lds	r23, 0x0457	; 0x800457 <engine_dv+0x3>
     602:	80 91 4c 04 	lds	r24, 0x044C	; 0x80044c <engine_cv>
     606:	90 91 4d 04 	lds	r25, 0x044D	; 0x80044d <engine_cv+0x1>
     60a:	a0 91 4e 04 	lds	r26, 0x044E	; 0x80044e <engine_cv+0x2>
     60e:	b0 91 4f 04 	lds	r27, 0x044F	; 0x80044f <engine_cv+0x3>
     612:	9a 01       	movw	r18, r20
     614:	ab 01       	movw	r20, r22
     616:	28 1b       	sub	r18, r24
     618:	39 0b       	sbc	r19, r25
     61a:	4a 0b       	sbc	r20, r26
     61c:	5b 0b       	sbc	r21, r27
     61e:	20 93 50 04 	sts	0x0450, r18	; 0x800450 <engine_delta>
     622:	30 93 51 04 	sts	0x0451, r19	; 0x800451 <engine_delta+0x1>
     626:	40 93 52 04 	sts	0x0452, r20	; 0x800452 <engine_delta+0x2>
     62a:	50 93 53 04 	sts	0x0453, r21	; 0x800453 <engine_delta+0x3>
	engine_ov = constrain(engine_delta * engine_kp * 255 / 100, 0, 255);	//calculate output value
     62e:	ad ef       	ldi	r26, 0xFD	; 253
     630:	b2 e0       	ldi	r27, 0x02	; 2
     632:	0e 94 ae 0c 	call	0x195c	; 0x195c <__muluhisi3>
     636:	6d 39       	cpi	r22, 0x9D	; 157
     638:	2f ef       	ldi	r18, 0xFF	; 255
     63a:	72 07       	cpc	r23, r18
     63c:	82 07       	cpc	r24, r18
     63e:	92 07       	cpc	r25, r18
     640:	6c f0       	brlt	.+26     	; 0x65c <_Z10run_curtisv+0xf4>
     642:	61 15       	cp	r22, r1
     644:	24 e6       	ldi	r18, 0x64	; 100
     646:	72 07       	cpc	r23, r18
     648:	81 05       	cpc	r24, r1
     64a:	91 05       	cpc	r25, r1
     64c:	4c f4       	brge	.+18     	; 0x660 <_Z10run_curtisv+0xf8>
     64e:	24 e6       	ldi	r18, 0x64	; 100
     650:	30 e0       	ldi	r19, 0x00	; 0
     652:	40 e0       	ldi	r20, 0x00	; 0
     654:	50 e0       	ldi	r21, 0x00	; 0
     656:	0e 94 84 0c 	call	0x1908	; 0x1908 <__divmodsi4>
     65a:	03 c0       	rjmp	.+6      	; 0x662 <_Z10run_curtisv+0xfa>
     65c:	20 e0       	ldi	r18, 0x00	; 0
     65e:	01 c0       	rjmp	.+2      	; 0x662 <_Z10run_curtisv+0xfa>
     660:	2f ef       	ldi	r18, 0xFF	; 255
     662:	20 93 4b 04 	sts	0x044B, r18	; 0x80044b <engine_ov>
	analogWrite(pwm_drive_throttle, engine_ov);								//Write op to throttle signal of curtis
     666:	62 2f       	mov	r22, r18
     668:	70 e0       	ldi	r23, 0x00	; 0
     66a:	88 e0       	ldi	r24, 0x08	; 8
     66c:	90 e0       	ldi	r25, 0x00	; 0
     66e:	b2 c0       	rjmp	.+356    	; 0x7d4 <_Z11analogWriteii>
     670:	08 95       	ret

00000672 <_Z5drivev>:
	}
}

void drive(){
	//get correct driving input parameters from selected source (remote and auto not implemented, thus being interpreted as idle)
	mode_select();
     672:	75 dd       	rcall	.-1302   	; 0x15e <_Z11mode_selectv>
	switch(drivemode){
     674:	80 91 69 04 	lds	r24, 0x0469	; 0x800469 <drivemode>
     678:	90 91 6a 04 	lds	r25, 0x046A	; 0x80046a <drivemode+0x1>
     67c:	81 30       	cpi	r24, 0x01	; 1
     67e:	91 05       	cpc	r25, r1
     680:	51 f0       	breq	.+20     	; 0x696 <_Z5drivev+0x24>
     682:	1c f4       	brge	.+6      	; 0x68a <_Z5drivev+0x18>
     684:	89 2b       	or	r24, r25
     686:	49 f0       	breq	.+18     	; 0x69a <_Z5drivev+0x28>
     688:	0d c0       	rjmp	.+26     	; 0x6a4 <_Z5drivev+0x32>
     68a:	82 30       	cpi	r24, 0x02	; 2
     68c:	91 05       	cpc	r25, r1
     68e:	49 f0       	breq	.+18     	; 0x6a2 <_Z5drivev+0x30>
     690:	03 97       	sbiw	r24, 0x03	; 3
     692:	29 f0       	breq	.+10     	; 0x69e <_Z5drivev+0x2c>
		case drivemode_joystick:
			mode_joystick();
     694:	07 c0       	rjmp	.+14     	; 0x6a4 <_Z5drivev+0x32>
			break;
     696:	a2 dd       	rcall	.-1212   	; 0x1dc <_Z13mode_joystickv>
		case drivemode_idle:
			mode_idle();		
     698:	05 c0       	rjmp	.+10     	; 0x6a4 <_Z5drivev+0x32>
			break;
		case drivemode_auto:
			mode_idle();		//not yet implemented
     69a:	4f de       	rcall	.-866    	; 0x33a <_Z9mode_idlev>
			break;
		case drivemode_remote:
			mode_idle();		//not yet implemented
     69c:	03 c0       	rjmp	.+6      	; 0x6a4 <_Z5drivev+0x32>
     69e:	4d de       	rcall	.-870    	; 0x33a <_Z9mode_idlev>
			break;	
	}
	run_steer();				//update the steering system
     6a0:	01 c0       	rjmp	.+2      	; 0x6a4 <_Z5drivev+0x32>
     6a2:	4b de       	rcall	.-874    	; 0x33a <_Z9mode_idlev>
	run_brake();				//update the braking system
     6a4:	c4 de       	rcall	.-632    	; 0x42e <_Z9run_steerv>
     6a6:	7c de       	rcall	.-776    	; 0x3a0 <_Z9run_brakev>
	run_curtis();				//update the Curtis
     6a8:	5f cf       	rjmp	.-322    	; 0x568 <_Z10run_curtisv>
     6aa:	08 95       	ret

000006ac <_Z6initIOv>:
     6ac:	cf 93       	push	r28
#include "IOPins.h"

//this funcion should be called when initializng the program. It writes the correct settings to the registry, allowing the use of analog and digital reading and writing of pins.
void initIO(){
     6ae:	df 93       	push	r29
	Serial.println("Applying IO settings...");
     6b0:	61 e0       	ldi	r22, 0x01	; 1
     6b2:	72 e0       	ldi	r23, 0x02	; 2
     6b4:	8a e8       	ldi	r24, 0x8A	; 138
     6b6:	94 e0       	ldi	r25, 0x04	; 4
     6b8:	cc d7       	rcall	.+3992   	; 0x1652 <_ZN5USART7printlnEPKc>
	//Read/Write pins
	//////////////////////////////////////
	//Disable the pullup resistor in these pins, making them output by writing a 1 to their respective registry entries. Pins not written to default to input pins.
	//when adding/altering pins, alter them in the respective switch case as well.
	//digitalwrite
	DDRA |= 0b11111111;
     6ba:	81 b1       	in	r24, 0x01	; 1
     6bc:	8f ef       	ldi	r24, 0xFF	; 255
     6be:	81 b9       	out	0x01, r24	; 1
	//B pins are reserved for SPI, don't touch those
	DDRC |= 0b11111111;
     6c0:	97 b1       	in	r25, 0x07	; 7
     6c2:	87 b9       	out	0x07, r24	; 7
	DDRD |= 0b10000000;
     6c4:	57 9a       	sbi	0x0a, 7	; 10
	DDRG |= 0b00000111;
     6c6:	83 b3       	in	r24, 0x13	; 19
     6c8:	87 60       	ori	r24, 0x07	; 7
     6ca:	83 bb       	out	0x13, r24	; 19
	//DDRL |= 0b11111111;
	
	//analogwrite, Not all pins support PWM signals, please consult datasheets before altering.
	DDRB |= 0b11110000;
     6cc:	84 b1       	in	r24, 0x04	; 4
     6ce:	80 6f       	ori	r24, 0xF0	; 240
     6d0:	84 b9       	out	0x04, r24	; 4
	DDRE |= 0b00111000;
     6d2:	8d b1       	in	r24, 0x0d	; 13
     6d4:	88 63       	ori	r24, 0x38	; 56
     6d6:	8d b9       	out	0x0d, r24	; 13
	DDRG |= 0b00100000;
     6d8:	9d 9a       	sbi	0x13, 5	; 19
	DDRH |= 0b01111000;
     6da:	e1 e0       	ldi	r30, 0x01	; 1
     6dc:	f1 e0       	ldi	r31, 0x01	; 1
     6de:	80 81       	ld	r24, Z
     6e0:	88 67       	ori	r24, 0x78	; 120
     6e2:	80 83       	st	Z, r24
	DDRL |= 0b00111000;
     6e4:	ea e0       	ldi	r30, 0x0A	; 10
     6e6:	f1 e0       	ldi	r31, 0x01	; 1
     6e8:	80 81       	ld	r24, Z
     6ea:	88 63       	ori	r24, 0x38	; 56
     6ec:	80 83       	st	Z, r24
	//when something is unclear or you want to change some setting, please consult the datasheet first.
	
	//Compare output mode
	//determines how the PWN behaves, now it Clears OCxx on compare match. This makes it so that low value OCRxx will result in short pulses, while higher result in longer ones
	//COM0xx0 will make OCxx toggle on compare match, both will set om compare match. Neither will disable the pmw by disconnecting OCxx.
	TCCR0A |= (( 1 << COM0A1) | (1 << COM0B1));
     6ee:	84 b5       	in	r24, 0x24	; 36
     6f0:	80 6a       	ori	r24, 0xA0	; 160
     6f2:	84 bd       	out	0x24, r24	; 36
	TCCR1A |= (( 1 << COM1A1) | (1 << COM1B1));
     6f4:	c0 e8       	ldi	r28, 0x80	; 128
     6f6:	d0 e0       	ldi	r29, 0x00	; 0
     6f8:	88 81       	ld	r24, Y
     6fa:	80 6a       	ori	r24, 0xA0	; 160
     6fc:	88 83       	st	Y, r24
	TCCR2A |= (( 1 << COM2A1) | (1 << COM2B1));
     6fe:	a0 eb       	ldi	r26, 0xB0	; 176
     700:	b0 e0       	ldi	r27, 0x00	; 0
     702:	8c 91       	ld	r24, X
     704:	80 6a       	ori	r24, 0xA0	; 160
     706:	8c 93       	st	X, r24
	TCCR3A |= (( 1 << COM3A1) | (1 << COM3B1));
     708:	e0 e9       	ldi	r30, 0x90	; 144
     70a:	f0 e0       	ldi	r31, 0x00	; 0
     70c:	80 81       	ld	r24, Z
     70e:	80 6a       	ori	r24, 0xA0	; 160
     710:	80 83       	st	Z, r24
	//TCCR4A |= (( 1 << COM4A1) | (1 << COM4B1));
	
	//Waveform Generation
	//note that here OCRxA and OCRxB use the same registry and thus also use the same waveform.
	//the current PWM is Fast PMW, but in this case the PWM mode isn't really important.
	TCCR0A |= ((1 << WGM01) | (1 << WGM00));
     712:	84 b5       	in	r24, 0x24	; 36
     714:	83 60       	ori	r24, 0x03	; 3
     716:	84 bd       	out	0x24, r24	; 36
	TCCR1A |= ((1 << WGM12) | (1 << WGM10));		//16 bit timer, scaled back to 8 bit. (TCCR0x and TCCR2x are 8 bit already)
     718:	88 81       	ld	r24, Y
     71a:	89 60       	ori	r24, 0x09	; 9
     71c:	88 83       	st	Y, r24
	TCCR2A |= ((1 << WGM21) | (1 << WGM20));
     71e:	8c 91       	ld	r24, X
     720:	83 60       	ori	r24, 0x03	; 3
     722:	8c 93       	st	X, r24
	TCCR3A |= ((1 << WGM32) | (1 << WGM30));		//16 bit
     724:	80 81       	ld	r24, Z
     726:	89 60       	ori	r24, 0x09	; 9
     728:	80 83       	st	Z, r24
	
	//clock Select
	//currently selected, Internal clock, /8 prescaler. this starts the PWM as well
	//F_CPU=16000000 / 256 / 8 ~= 7812Hz wave
	//again as with the OCRxx, these use the same registry as well and are thus linked
	TCCR0B |= (1 << CS01);
     72a:	85 b5       	in	r24, 0x25	; 37
     72c:	82 60       	ori	r24, 0x02	; 2
     72e:	85 bd       	out	0x25, r24	; 37
	TCCR1B |= (1 << CS11);
     730:	e1 e8       	ldi	r30, 0x81	; 129
     732:	f0 e0       	ldi	r31, 0x00	; 0
     734:	80 81       	ld	r24, Z
     736:	82 60       	ori	r24, 0x02	; 2
     738:	80 83       	st	Z, r24
	TCCR2B |= (1 << CS21);
     73a:	e1 eb       	ldi	r30, 0xB1	; 177
     73c:	f0 e0       	ldi	r31, 0x00	; 0
     73e:	80 81       	ld	r24, Z
     740:	82 60       	ori	r24, 0x02	; 2
     742:	80 83       	st	Z, r24
	TCCR3B |= (1 << CS31);
     744:	e1 e9       	ldi	r30, 0x91	; 145
     746:	f0 e0       	ldi	r31, 0x00	; 0
     748:	80 81       	ld	r24, Z
     74a:	82 60       	ori	r24, 0x02	; 2
     74c:	80 83       	st	Z, r24
	TCCR4B |= (1 << CS41);
     74e:	e1 ea       	ldi	r30, 0xA1	; 161
     750:	f0 e0       	ldi	r31, 0x00	; 0
     752:	80 81       	ld	r24, Z
     754:	82 60       	ori	r24, 0x02	; 2
     756:	80 83       	st	Z, r24
	
	//initialize each pwm as 0
	OCR3B=0;	//pin 2
     758:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <__TEXT_REGION_LENGTH__+0x70009b>
     75c:	10 92 9a 00 	sts	0x009A, r1	; 0x80009a <__TEXT_REGION_LENGTH__+0x70009a>
	OCR3C=0;	//pin 3
     760:	10 92 9d 00 	sts	0x009D, r1	; 0x80009d <__TEXT_REGION_LENGTH__+0x70009d>
     764:	10 92 9c 00 	sts	0x009C, r1	; 0x80009c <__TEXT_REGION_LENGTH__+0x70009c>
	OCR0B=0;	//pin 4
     768:	18 bc       	out	0x28, r1	; 40
	OCR3A=0;	//pin 5
     76a:	10 92 99 00 	sts	0x0099, r1	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
     76e:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
	OCR4A=0;	//pin 6
     772:	10 92 a9 00 	sts	0x00A9, r1	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
     776:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
	OCR4B=0;	//pin 7
     77a:	10 92 ab 00 	sts	0x00AB, r1	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
     77e:	10 92 aa 00 	sts	0x00AA, r1	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
	OCR4C=0;	//pin 8
     782:	10 92 ad 00 	sts	0x00AD, r1	; 0x8000ad <__TEXT_REGION_LENGTH__+0x7000ad>
     786:	10 92 ac 00 	sts	0x00AC, r1	; 0x8000ac <__TEXT_REGION_LENGTH__+0x7000ac>
	OCR2B=0;	//pin 9
     78a:	10 92 b4 00 	sts	0x00B4, r1	; 0x8000b4 <__TEXT_REGION_LENGTH__+0x7000b4>
	OCR2A=0;	//pin 10
     78e:	10 92 b3 00 	sts	0x00B3, r1	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
	OCR1A=0;	//pin 11
     792:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     796:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
	OCR1B=0;	//pin 12
     79a:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     79e:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
	OCR1C=0;	//pin 13
     7a2:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
     7a6:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
	//Analog Digital Converter, analogread
	//////////////////////////////////////
	
	//Analog Digital Multiplexer Selection Register, voltage reference selection
	//Current setting: AVcc with external capacitor at AREF pin (internal 5v)
	ADMUX |= (1 << REFS0);
     7aa:	ec e7       	ldi	r30, 0x7C	; 124
     7ac:	f0 e0       	ldi	r31, 0x00	; 0
     7ae:	80 81       	ld	r24, Z
     7b0:	80 64       	ori	r24, 0x40	; 64
     7b2:	80 83       	st	Z, r24
	
	// 1/128 prescaler
	ADCSRA |= (1 << ADPS0) | (1 << ADPS1) | (1 << ADPS2);
     7b4:	ea e7       	ldi	r30, 0x7A	; 122
     7b6:	f0 e0       	ldi	r31, 0x00	; 0
     7b8:	80 81       	ld	r24, Z
     7ba:	87 60       	ori	r24, 0x07	; 7
     7bc:	80 83       	st	Z, r24
	
	//enable the ADC convector, and disable GPIO functionality on the ADC pins
	ADCSRA |= (1 << ADEN);
     7be:	80 81       	ld	r24, Z
     7c0:	80 68       	ori	r24, 0x80	; 128
     7c2:	80 83       	st	Z, r24
	Serial.println("IO setting generated");
     7c4:	69 e1       	ldi	r22, 0x19	; 25
     7c6:	72 e0       	ldi	r23, 0x02	; 2
     7c8:	8a e8       	ldi	r24, 0x8A	; 138
     7ca:	94 e0       	ldi	r25, 0x04	; 4
     7cc:	42 d7       	rcall	.+3716   	; 0x1652 <_ZN5USART7printlnEPKc>
	return;
}
     7ce:	df 91       	pop	r29
     7d0:	cf 91       	pop	r28
     7d2:	08 95       	ret

000007d4 <_Z11analogWriteii>:


//writes a value between 0 and 255 to the correct output compare register
//analogWrite(pin numer, value it should receive).
void analogWrite(int pin,int val){
     7d4:	6f 3f       	cpi	r22, 0xFF	; 255
     7d6:	71 05       	cpc	r23, r1
     7d8:	19 f0       	breq	.+6      	; 0x7e0 <_Z11analogWriteii+0xc>
     7da:	14 f0       	brlt	.+4      	; 0x7e0 <_Z11analogWriteii+0xc>
     7dc:	6f ef       	ldi	r22, 0xFF	; 255
     7de:	70 e0       	ldi	r23, 0x00	; 0
	if(val>255)			//if the given value exeeds 255, make it 255
	val=255;
	switch(pin){
     7e0:	fc 01       	movw	r30, r24
     7e2:	32 97       	sbiw	r30, 0x02	; 2
     7e4:	eb 30       	cpi	r30, 0x0B	; 11
     7e6:	f1 05       	cpc	r31, r1
     7e8:	b0 f5       	brcc	.+108    	; 0x856 <_Z11analogWriteii+0x82>
     7ea:	88 27       	eor	r24, r24
     7ec:	ee 58       	subi	r30, 0x8E	; 142
     7ee:	ff 4f       	sbci	r31, 0xFF	; 255
     7f0:	8f 4f       	sbci	r24, 0xFF	; 255
     7f2:	0c 94 a0 0c 	jmp	0x1940	; 0x1940 <__tablejump2__>
		case 2:
		OCR3B=val;
     7f6:	70 93 9b 00 	sts	0x009B, r23	; 0x80009b <__TEXT_REGION_LENGTH__+0x70009b>
     7fa:	60 93 9a 00 	sts	0x009A, r22	; 0x80009a <__TEXT_REGION_LENGTH__+0x70009a>
		return;
     7fe:	08 95       	ret
		case 3:
		OCR3C=val;
     800:	70 93 9d 00 	sts	0x009D, r23	; 0x80009d <__TEXT_REGION_LENGTH__+0x70009d>
     804:	60 93 9c 00 	sts	0x009C, r22	; 0x80009c <__TEXT_REGION_LENGTH__+0x70009c>
		return;
     808:	08 95       	ret
		case 4:
		OCR0B=val;
     80a:	68 bd       	out	0x28, r22	; 40
		return;
     80c:	08 95       	ret
		case 5:
		OCR3A=val;
     80e:	70 93 99 00 	sts	0x0099, r23	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
     812:	60 93 98 00 	sts	0x0098, r22	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
		return;
     816:	08 95       	ret
		case 6:
		OCR4A=val;
     818:	70 93 a9 00 	sts	0x00A9, r23	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
     81c:	60 93 a8 00 	sts	0x00A8, r22	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
		return;
     820:	08 95       	ret
		case 7:
		OCR4B=val;
     822:	70 93 ab 00 	sts	0x00AB, r23	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
     826:	60 93 aa 00 	sts	0x00AA, r22	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
		return;
     82a:	08 95       	ret
		case 8:
		OCR4C=val;
     82c:	70 93 ad 00 	sts	0x00AD, r23	; 0x8000ad <__TEXT_REGION_LENGTH__+0x7000ad>
     830:	60 93 ac 00 	sts	0x00AC, r22	; 0x8000ac <__TEXT_REGION_LENGTH__+0x7000ac>
		return;
     834:	08 95       	ret
		case 9:
		OCR2B=val;
     836:	60 93 b4 00 	sts	0x00B4, r22	; 0x8000b4 <__TEXT_REGION_LENGTH__+0x7000b4>
		return;
     83a:	08 95       	ret
		case 10:
		OCR2A=val;
     83c:	60 93 b3 00 	sts	0x00B3, r22	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
		return;
     840:	08 95       	ret
		case 11:
		OCR1A=val;
     842:	70 93 89 00 	sts	0x0089, r23	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     846:	60 93 88 00 	sts	0x0088, r22	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
		return;
     84a:	08 95       	ret
		case 12:
		OCR1B=val;
     84c:	70 93 8b 00 	sts	0x008B, r23	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     850:	60 93 8a 00 	sts	0x008A, r22	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
		return;
     854:	08 95       	ret
		}
	Serial.println("ERROR: tried to write analog value to unsupported pin");
     856:	6e e2       	ldi	r22, 0x2E	; 46
     858:	72 e0       	ldi	r23, 0x02	; 2
     85a:	8a e8       	ldi	r24, 0x8A	; 138
     85c:	94 e0       	ldi	r25, 0x04	; 4
     85e:	f9 c6       	rjmp	.+3570   	; 0x1652 <_ZN5USART7printlnEPKc>
     860:	08 95       	ret

00000862 <_Z12digitalWriteib>:
	return;
}

//writes a digital value to a pin.
void digitalWrite(int pin,bool val){
     862:	cf 93       	push	r28
     864:	df 93       	push	r29
	if(pin<22||pin>53){					//check if the pin is a digital IO pin
     866:	9c 01       	movw	r18, r24
     868:	26 51       	subi	r18, 0x16	; 22
     86a:	31 09       	sbc	r19, r1
     86c:	20 32       	cpi	r18, 0x20	; 32
     86e:	31 05       	cpc	r19, r1
     870:	58 f0       	brcs	.+22     	; 0x888 <_Z12digitalWriteib+0x26>
     872:	ec 01       	movw	r28, r24
		Serial.print("ERROR: tried to write digital value to unsupported digital pin");
     874:	64 e6       	ldi	r22, 0x64	; 100
     876:	72 e0       	ldi	r23, 0x02	; 2
     878:	8a e8       	ldi	r24, 0x8A	; 138
     87a:	94 e0       	ldi	r25, 0x04	; 4
     87c:	d1 d6       	rcall	.+3490   	; 0x1620 <_ZN5USART5printEPKc>
		Serial.println(pin);
     87e:	be 01       	movw	r22, r28
     880:	8a e8       	ldi	r24, 0x8A	; 138
     882:	94 e0       	ldi	r25, 0x04	; 4
     884:	14 d7       	rcall	.+3624   	; 0x16ae <_ZN5USART7printlnEi>
     886:	b9 c0       	rjmp	.+370    	; 0x9fa <_Z12digitalWriteib+0x198>
	}
	else if(pin<30){					//check if pin is in the A register
     888:	8e 31       	cpi	r24, 0x1E	; 30
     88a:	91 05       	cpc	r25, r1
     88c:	f4 f4       	brge	.+60     	; 0x8ca <_Z12digitalWriteib+0x68>
		pin-=22;						//make pinrange 0-7
     88e:	46 97       	sbiw	r24, 0x16	; 22
		if(val) PORTA |= (1<<pin);		//set correct bit in A register is val==true
     890:	66 23       	and	r22, r22
     892:	69 f0       	breq	.+26     	; 0x8ae <_Z12digitalWriteib+0x4c>
     894:	42 b1       	in	r20, 0x02	; 2
     896:	21 e0       	ldi	r18, 0x01	; 1
     898:	30 e0       	ldi	r19, 0x00	; 0
     89a:	b9 01       	movw	r22, r18
     89c:	02 c0       	rjmp	.+4      	; 0x8a2 <_Z12digitalWriteib+0x40>
     89e:	66 0f       	add	r22, r22
     8a0:	77 1f       	adc	r23, r23
     8a2:	8a 95       	dec	r24
     8a4:	e2 f7       	brpl	.-8      	; 0x89e <_Z12digitalWriteib+0x3c>
     8a6:	cb 01       	movw	r24, r22
     8a8:	84 2b       	or	r24, r20
     8aa:	82 b9       	out	0x02, r24	; 2
     8ac:	a6 c0       	rjmp	.+332    	; 0x9fa <_Z12digitalWriteib+0x198>
		else PORTA &= ~(1<<pin);		//unset bit if false
     8ae:	42 b1       	in	r20, 0x02	; 2
     8b0:	21 e0       	ldi	r18, 0x01	; 1
     8b2:	30 e0       	ldi	r19, 0x00	; 0
     8b4:	b9 01       	movw	r22, r18
     8b6:	02 c0       	rjmp	.+4      	; 0x8bc <_Z12digitalWriteib+0x5a>
     8b8:	66 0f       	add	r22, r22
     8ba:	77 1f       	adc	r23, r23
     8bc:	8a 95       	dec	r24
     8be:	e2 f7       	brpl	.-8      	; 0x8b8 <_Z12digitalWriteib+0x56>
     8c0:	cb 01       	movw	r24, r22
     8c2:	80 95       	com	r24
     8c4:	84 23       	and	r24, r20
     8c6:	82 b9       	out	0x02, r24	; 2
     8c8:	98 c0       	rjmp	.+304    	; 0x9fa <_Z12digitalWriteib+0x198>
	}
	else if(pin<38){
     8ca:	86 32       	cpi	r24, 0x26	; 38
     8cc:	91 05       	cpc	r25, r1
     8ce:	1c f5       	brge	.+70     	; 0x916 <_Z12digitalWriteib+0xb4>
		pin=(37-pin);
     8d0:	25 e2       	ldi	r18, 0x25	; 37
     8d2:	30 e0       	ldi	r19, 0x00	; 0
     8d4:	a9 01       	movw	r20, r18
     8d6:	48 1b       	sub	r20, r24
     8d8:	59 0b       	sbc	r21, r25
     8da:	ca 01       	movw	r24, r20
		if(val) PORTC |= (1<<pin);
     8dc:	66 23       	and	r22, r22
     8de:	69 f0       	breq	.+26     	; 0x8fa <_Z12digitalWriteib+0x98>
     8e0:	48 b1       	in	r20, 0x08	; 8
     8e2:	21 e0       	ldi	r18, 0x01	; 1
     8e4:	30 e0       	ldi	r19, 0x00	; 0
     8e6:	b9 01       	movw	r22, r18
     8e8:	02 c0       	rjmp	.+4      	; 0x8ee <_Z12digitalWriteib+0x8c>
     8ea:	66 0f       	add	r22, r22
     8ec:	77 1f       	adc	r23, r23
     8ee:	8a 95       	dec	r24
     8f0:	e2 f7       	brpl	.-8      	; 0x8ea <_Z12digitalWriteib+0x88>
     8f2:	cb 01       	movw	r24, r22
     8f4:	84 2b       	or	r24, r20
     8f6:	88 b9       	out	0x08, r24	; 8
     8f8:	80 c0       	rjmp	.+256    	; 0x9fa <_Z12digitalWriteib+0x198>
		else PORTC &= ~(1<<pin);
     8fa:	48 b1       	in	r20, 0x08	; 8
     8fc:	21 e0       	ldi	r18, 0x01	; 1
     8fe:	30 e0       	ldi	r19, 0x00	; 0
     900:	b9 01       	movw	r22, r18
     902:	02 c0       	rjmp	.+4      	; 0x908 <_Z12digitalWriteib+0xa6>
     904:	66 0f       	add	r22, r22
     906:	77 1f       	adc	r23, r23
     908:	8a 95       	dec	r24
     90a:	e2 f7       	brpl	.-8      	; 0x904 <_Z12digitalWriteib+0xa2>
     90c:	cb 01       	movw	r24, r22
     90e:	80 95       	com	r24
     910:	84 23       	and	r24, r20
     912:	88 b9       	out	0x08, r24	; 8
     914:	72 c0       	rjmp	.+228    	; 0x9fa <_Z12digitalWriteib+0x198>
	}
	else if(pin==38){
     916:	86 32       	cpi	r24, 0x26	; 38
     918:	91 05       	cpc	r25, r1
     91a:	31 f4       	brne	.+12     	; 0x928 <_Z12digitalWriteib+0xc6>
		if(val) PORTD |= (1<<PIND7);
     91c:	66 23       	and	r22, r22
     91e:	11 f0       	breq	.+4      	; 0x924 <_Z12digitalWriteib+0xc2>
     920:	5f 9a       	sbi	0x0b, 7	; 11
     922:	6b c0       	rjmp	.+214    	; 0x9fa <_Z12digitalWriteib+0x198>
		else PORTD &= ~(1<<PIND7);
     924:	5f 98       	cbi	0x0b, 7	; 11
     926:	69 c0       	rjmp	.+210    	; 0x9fa <_Z12digitalWriteib+0x198>
	}
	else if(pin<42){
     928:	8a 32       	cpi	r24, 0x2A	; 42
     92a:	91 05       	cpc	r25, r1
     92c:	ec f4       	brge	.+58     	; 0x968 <_Z12digitalWriteib+0x106>
		pin=(41-pin);
     92e:	29 e2       	ldi	r18, 0x29	; 41
     930:	30 e0       	ldi	r19, 0x00	; 0
     932:	28 1b       	sub	r18, r24
     934:	39 0b       	sbc	r19, r25
		if(val) PORTG |= (1<<pin);
     936:	66 23       	and	r22, r22
     938:	59 f0       	breq	.+22     	; 0x950 <_Z12digitalWriteib+0xee>
     93a:	34 b3       	in	r19, 0x14	; 20
     93c:	81 e0       	ldi	r24, 0x01	; 1
     93e:	90 e0       	ldi	r25, 0x00	; 0
     940:	02 c0       	rjmp	.+4      	; 0x946 <_Z12digitalWriteib+0xe4>
     942:	88 0f       	add	r24, r24
     944:	99 1f       	adc	r25, r25
     946:	2a 95       	dec	r18
     948:	e2 f7       	brpl	.-8      	; 0x942 <_Z12digitalWriteib+0xe0>
     94a:	83 2b       	or	r24, r19
     94c:	84 bb       	out	0x14, r24	; 20
     94e:	55 c0       	rjmp	.+170    	; 0x9fa <_Z12digitalWriteib+0x198>
		else PORTG &= ~(1<<pin);
     950:	34 b3       	in	r19, 0x14	; 20
     952:	81 e0       	ldi	r24, 0x01	; 1
     954:	90 e0       	ldi	r25, 0x00	; 0
     956:	02 c0       	rjmp	.+4      	; 0x95c <_Z12digitalWriteib+0xfa>
     958:	88 0f       	add	r24, r24
     95a:	99 1f       	adc	r25, r25
     95c:	2a 95       	dec	r18
     95e:	e2 f7       	brpl	.-8      	; 0x958 <_Z12digitalWriteib+0xf6>
     960:	80 95       	com	r24
     962:	83 23       	and	r24, r19
     964:	84 bb       	out	0x14, r24	; 20
     966:	49 c0       	rjmp	.+146    	; 0x9fa <_Z12digitalWriteib+0x198>
	}
	else if(pin<50){
     968:	82 33       	cpi	r24, 0x32	; 50
     96a:	91 05       	cpc	r25, r1
     96c:	0c f5       	brge	.+66     	; 0x9b0 <_Z12digitalWriteib+0x14e>
		pin=(49-pin);
     96e:	21 e3       	ldi	r18, 0x31	; 49
     970:	30 e0       	ldi	r19, 0x00	; 0
     972:	28 1b       	sub	r18, r24
     974:	39 0b       	sbc	r19, r25
		if(val) PORTL |= (1<<pin);
     976:	66 23       	and	r22, r22
     978:	69 f0       	breq	.+26     	; 0x994 <_Z12digitalWriteib+0x132>
     97a:	eb e0       	ldi	r30, 0x0B	; 11
     97c:	f1 e0       	ldi	r31, 0x01	; 1
     97e:	30 81       	ld	r19, Z
     980:	81 e0       	ldi	r24, 0x01	; 1
     982:	90 e0       	ldi	r25, 0x00	; 0
     984:	02 c0       	rjmp	.+4      	; 0x98a <_Z12digitalWriteib+0x128>
     986:	88 0f       	add	r24, r24
     988:	99 1f       	adc	r25, r25
     98a:	2a 95       	dec	r18
     98c:	e2 f7       	brpl	.-8      	; 0x986 <_Z12digitalWriteib+0x124>
     98e:	83 2b       	or	r24, r19
     990:	80 83       	st	Z, r24
     992:	33 c0       	rjmp	.+102    	; 0x9fa <_Z12digitalWriteib+0x198>
		else PORTL &= ~(1<<pin);
     994:	eb e0       	ldi	r30, 0x0B	; 11
     996:	f1 e0       	ldi	r31, 0x01	; 1
     998:	30 81       	ld	r19, Z
     99a:	81 e0       	ldi	r24, 0x01	; 1
     99c:	90 e0       	ldi	r25, 0x00	; 0
     99e:	02 c0       	rjmp	.+4      	; 0x9a4 <_Z12digitalWriteib+0x142>
     9a0:	88 0f       	add	r24, r24
     9a2:	99 1f       	adc	r25, r25
     9a4:	2a 95       	dec	r18
     9a6:	e2 f7       	brpl	.-8      	; 0x9a0 <_Z12digitalWriteib+0x13e>
     9a8:	80 95       	com	r24
     9aa:	83 23       	and	r24, r19
     9ac:	80 83       	st	Z, r24
     9ae:	25 c0       	rjmp	.+74     	; 0x9fa <_Z12digitalWriteib+0x198>
	}
	else if(pin<54){
     9b0:	86 33       	cpi	r24, 0x36	; 54
     9b2:	91 05       	cpc	r25, r1
     9b4:	14 f5       	brge	.+68     	; 0x9fa <_Z12digitalWriteib+0x198>
		pin=(53-pin);
     9b6:	25 e3       	ldi	r18, 0x35	; 53
     9b8:	30 e0       	ldi	r19, 0x00	; 0
     9ba:	a9 01       	movw	r20, r18
     9bc:	48 1b       	sub	r20, r24
     9be:	59 0b       	sbc	r21, r25
     9c0:	ca 01       	movw	r24, r20
		if(val) PORTB |= (1<<pin);
     9c2:	66 23       	and	r22, r22
     9c4:	69 f0       	breq	.+26     	; 0x9e0 <_Z12digitalWriteib+0x17e>
     9c6:	45 b1       	in	r20, 0x05	; 5
     9c8:	21 e0       	ldi	r18, 0x01	; 1
     9ca:	30 e0       	ldi	r19, 0x00	; 0
     9cc:	b9 01       	movw	r22, r18
     9ce:	02 c0       	rjmp	.+4      	; 0x9d4 <_Z12digitalWriteib+0x172>
     9d0:	66 0f       	add	r22, r22
     9d2:	77 1f       	adc	r23, r23
     9d4:	8a 95       	dec	r24
     9d6:	e2 f7       	brpl	.-8      	; 0x9d0 <_Z12digitalWriteib+0x16e>
     9d8:	cb 01       	movw	r24, r22
     9da:	84 2b       	or	r24, r20
     9dc:	85 b9       	out	0x05, r24	; 5
     9de:	0d c0       	rjmp	.+26     	; 0x9fa <_Z12digitalWriteib+0x198>
		else PORTB &= ~(1<<pin);
     9e0:	45 b1       	in	r20, 0x05	; 5
     9e2:	21 e0       	ldi	r18, 0x01	; 1
     9e4:	30 e0       	ldi	r19, 0x00	; 0
     9e6:	b9 01       	movw	r22, r18
     9e8:	02 c0       	rjmp	.+4      	; 0x9ee <_Z12digitalWriteib+0x18c>
     9ea:	66 0f       	add	r22, r22
     9ec:	77 1f       	adc	r23, r23
     9ee:	8a 95       	dec	r24
     9f0:	e2 f7       	brpl	.-8      	; 0x9ea <_Z12digitalWriteib+0x188>
     9f2:	cb 01       	movw	r24, r22
     9f4:	80 95       	com	r24
     9f6:	84 23       	and	r24, r20
     9f8:	85 b9       	out	0x05, r24	; 5
	}
	return;
}
     9fa:	df 91       	pop	r29
     9fc:	cf 91       	pop	r28
     9fe:	08 95       	ret

00000a00 <_Z11digitalReadi>:

bool digitalRead(int pin){
     a00:	cf 93       	push	r28
     a02:	df 93       	push	r29
	if(pin==4){
     a04:	84 30       	cpi	r24, 0x04	; 4
     a06:	91 05       	cpc	r25, r1
     a08:	29 f4       	brne	.+10     	; 0xa14 <_Z11digitalReadi+0x14>
		if(PING&(1<<PING5))	return true;
     a0a:	82 b3       	in	r24, 0x12	; 18
     a0c:	85 fb       	bst	r24, 5
     a0e:	88 27       	eor	r24, r24
     a10:	80 f9       	bld	r24, 0
     a12:	6f c0       	rjmp	.+222    	; 0xaf2 <_Z11digitalReadi+0xf2>
	}
	else if(pin<30){					//check if pin is in the A register
     a14:	8e 31       	cpi	r24, 0x1E	; 30
     a16:	91 05       	cpc	r25, r1
     a18:	64 f4       	brge	.+24     	; 0xa32 <_Z11digitalReadi+0x32>
		pin-=22;						//make pinrange 0-7
		if(PINA&(1<<pin))	return true;							//break function
     a1a:	20 b1       	in	r18, 0x00	; 0
     a1c:	30 e0       	ldi	r19, 0x00	; 0
     a1e:	46 97       	sbiw	r24, 0x16	; 22
     a20:	a9 01       	movw	r20, r18
     a22:	02 c0       	rjmp	.+4      	; 0xa28 <_Z11digitalReadi+0x28>
     a24:	55 95       	asr	r21
     a26:	47 95       	ror	r20
     a28:	8a 95       	dec	r24
     a2a:	e2 f7       	brpl	.-8      	; 0xa24 <_Z11digitalReadi+0x24>
     a2c:	ca 01       	movw	r24, r20
     a2e:	81 70       	andi	r24, 0x01	; 1
     a30:	60 c0       	rjmp	.+192    	; 0xaf2 <_Z11digitalReadi+0xf2>
	}
	else if(pin<38){
     a32:	86 32       	cpi	r24, 0x26	; 38
     a34:	91 05       	cpc	r25, r1
     a36:	84 f4       	brge	.+32     	; 0xa58 <_Z11digitalReadi+0x58>
		pin=37-pin;
		if(PINC&(1<<pin))	return true;							//break function
     a38:	26 b1       	in	r18, 0x06	; 6
     a3a:	30 e0       	ldi	r19, 0x00	; 0
     a3c:	45 e2       	ldi	r20, 0x25	; 37
     a3e:	50 e0       	ldi	r21, 0x00	; 0
     a40:	ba 01       	movw	r22, r20
     a42:	68 1b       	sub	r22, r24
     a44:	79 0b       	sbc	r23, r25
     a46:	a9 01       	movw	r20, r18
     a48:	02 c0       	rjmp	.+4      	; 0xa4e <_Z11digitalReadi+0x4e>
     a4a:	55 95       	asr	r21
     a4c:	47 95       	ror	r20
     a4e:	6a 95       	dec	r22
     a50:	e2 f7       	brpl	.-8      	; 0xa4a <_Z11digitalReadi+0x4a>
     a52:	ca 01       	movw	r24, r20
     a54:	81 70       	andi	r24, 0x01	; 1
     a56:	4d c0       	rjmp	.+154    	; 0xaf2 <_Z11digitalReadi+0xf2>
	}
	else if(pin==38){
     a58:	86 32       	cpi	r24, 0x26	; 38
     a5a:	91 05       	cpc	r25, r1
     a5c:	29 f4       	brne	.+10     	; 0xa68 <_Z11digitalReadi+0x68>
		if(PIND&(1<<PIND7))	return true;							//break function
     a5e:	89 b1       	in	r24, 0x09	; 9
     a60:	88 1f       	adc	r24, r24
     a62:	88 27       	eor	r24, r24
     a64:	88 1f       	adc	r24, r24
     a66:	45 c0       	rjmp	.+138    	; 0xaf2 <_Z11digitalReadi+0xf2>
	}
	else if(pin<42){
     a68:	8a 32       	cpi	r24, 0x2A	; 42
     a6a:	91 05       	cpc	r25, r1
     a6c:	84 f4       	brge	.+32     	; 0xa8e <_Z11digitalReadi+0x8e>
		pin=41-pin;
		if(PING&(1<<pin))	return true;							//break function
     a6e:	22 b3       	in	r18, 0x12	; 18
     a70:	30 e0       	ldi	r19, 0x00	; 0
     a72:	49 e2       	ldi	r20, 0x29	; 41
     a74:	50 e0       	ldi	r21, 0x00	; 0
     a76:	ba 01       	movw	r22, r20
     a78:	68 1b       	sub	r22, r24
     a7a:	79 0b       	sbc	r23, r25
     a7c:	a9 01       	movw	r20, r18
     a7e:	02 c0       	rjmp	.+4      	; 0xa84 <_Z11digitalReadi+0x84>
     a80:	55 95       	asr	r21
     a82:	47 95       	ror	r20
     a84:	6a 95       	dec	r22
     a86:	e2 f7       	brpl	.-8      	; 0xa80 <_Z11digitalReadi+0x80>
     a88:	ca 01       	movw	r24, r20
     a8a:	81 70       	andi	r24, 0x01	; 1
     a8c:	32 c0       	rjmp	.+100    	; 0xaf2 <_Z11digitalReadi+0xf2>
	}
	else if(pin<50){
     a8e:	82 33       	cpi	r24, 0x32	; 50
     a90:	91 05       	cpc	r25, r1
     a92:	8c f4       	brge	.+34     	; 0xab6 <_Z11digitalReadi+0xb6>
		pin=49-pin;
		if(PINL&(1<<pin))	return true;							//break function
     a94:	20 91 09 01 	lds	r18, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
     a98:	30 e0       	ldi	r19, 0x00	; 0
     a9a:	41 e3       	ldi	r20, 0x31	; 49
     a9c:	50 e0       	ldi	r21, 0x00	; 0
     a9e:	ba 01       	movw	r22, r20
     aa0:	68 1b       	sub	r22, r24
     aa2:	79 0b       	sbc	r23, r25
     aa4:	a9 01       	movw	r20, r18
     aa6:	02 c0       	rjmp	.+4      	; 0xaac <_Z11digitalReadi+0xac>
     aa8:	55 95       	asr	r21
     aaa:	47 95       	ror	r20
     aac:	6a 95       	dec	r22
     aae:	e2 f7       	brpl	.-8      	; 0xaa8 <_Z11digitalReadi+0xa8>
     ab0:	ca 01       	movw	r24, r20
     ab2:	81 70       	andi	r24, 0x01	; 1
     ab4:	1e c0       	rjmp	.+60     	; 0xaf2 <_Z11digitalReadi+0xf2>
	}
	else if(pin<54){
     ab6:	86 33       	cpi	r24, 0x36	; 54
     ab8:	91 05       	cpc	r25, r1
     aba:	84 f4       	brge	.+32     	; 0xadc <_Z11digitalReadi+0xdc>
		pin=(53-pin);
		if(PINB&(1<<pin))	return true;							//break function
     abc:	23 b1       	in	r18, 0x03	; 3
     abe:	30 e0       	ldi	r19, 0x00	; 0
     ac0:	45 e3       	ldi	r20, 0x35	; 53
     ac2:	50 e0       	ldi	r21, 0x00	; 0
     ac4:	ba 01       	movw	r22, r20
     ac6:	68 1b       	sub	r22, r24
     ac8:	79 0b       	sbc	r23, r25
     aca:	a9 01       	movw	r20, r18
     acc:	02 c0       	rjmp	.+4      	; 0xad2 <_Z11digitalReadi+0xd2>
     ace:	55 95       	asr	r21
     ad0:	47 95       	ror	r20
     ad2:	6a 95       	dec	r22
     ad4:	e2 f7       	brpl	.-8      	; 0xace <_Z11digitalReadi+0xce>
     ad6:	ca 01       	movw	r24, r20
     ad8:	81 70       	andi	r24, 0x01	; 1
     ada:	0b c0       	rjmp	.+22     	; 0xaf2 <_Z11digitalReadi+0xf2>
     adc:	ec 01       	movw	r28, r24
	}
	else{					//pin unsupported
		Serial.print("ERROR: tried to read digital value from unsupported digital pin: ");
     ade:	63 ea       	ldi	r22, 0xA3	; 163
     ae0:	72 e0       	ldi	r23, 0x02	; 2
     ae2:	8a e8       	ldi	r24, 0x8A	; 138
     ae4:	94 e0       	ldi	r25, 0x04	; 4
     ae6:	9c d5       	rcall	.+2872   	; 0x1620 <_ZN5USART5printEPKc>
		Serial.println(pin);
     ae8:	be 01       	movw	r22, r28
     aea:	8a e8       	ldi	r24, 0x8A	; 138
     aec:	94 e0       	ldi	r25, 0x04	; 4
     aee:	df d5       	rcall	.+3006   	; 0x16ae <_ZN5USART7printlnEi>
		return false;
     af0:	80 e0       	ldi	r24, 0x00	; 0
	}
	return false;	
}
     af2:	df 91       	pop	r29
     af4:	cf 91       	pop	r28
     af6:	08 95       	ret

00000af8 <_Z10analogReadi>:

int analogRead(int pin){
     af8:	cf 93       	push	r28
     afa:	df 93       	push	r29
	//set correct MUX registers, these determine on which pin the ADC should read it's value
	//first the MUXx bits are cleared, then filled to prevent old setting leaking though
	
	ADMUX &=(0b11100000);							//clear the bottom 4 bit
     afc:	ec e7       	ldi	r30, 0x7C	; 124
     afe:	f0 e0       	ldi	r31, 0x00	; 0
     b00:	20 81       	ld	r18, Z
     b02:	20 7e       	andi	r18, 0xE0	; 224
     b04:	20 83       	st	Z, r18
	ADCSRB &=(0b11110111);							//clear the top one bit
     b06:	eb e7       	ldi	r30, 0x7B	; 123
     b08:	f0 e0       	ldi	r31, 0x00	; 0
     b0a:	20 81       	ld	r18, Z
     b0c:	27 7f       	andi	r18, 0xF7	; 247
     b0e:	20 83       	st	Z, r18
	if(pin<8)										//if adc #0-7
     b10:	88 30       	cpi	r24, 0x08	; 8
     b12:	91 05       	cpc	r25, r1
     b14:	34 f4       	brge	.+12     	; 0xb22 <_Z10analogReadi+0x2a>
	ADMUX |= pin;								//write the full pin to the ADMUX registry
     b16:	ec e7       	ldi	r30, 0x7C	; 124
     b18:	f0 e0       	ldi	r31, 0x00	; 0
     b1a:	90 81       	ld	r25, Z
     b1c:	89 2b       	or	r24, r25
     b1e:	80 83       	st	Z, r24
     b20:	1c c0       	rjmp	.+56     	; 0xb5a <_Z10analogReadi+0x62>
	else if(pin<16){									//if adc #8-15
     b22:	80 31       	cpi	r24, 0x10	; 16
     b24:	91 05       	cpc	r25, r1
     b26:	64 f4       	brge	.+24     	; 0xb40 <_Z10analogReadi+0x48>
		ADCSRB |= (1<<3);							//write upper bit to ADCSRB register
     b28:	eb e7       	ldi	r30, 0x7B	; 123
     b2a:	f0 e0       	ldi	r31, 0x00	; 0
     b2c:	90 81       	ld	r25, Z
     b2e:	98 60       	ori	r25, 0x08	; 8
     b30:	90 83       	st	Z, r25
		ADMUX |= (pin-8);							//write lower bits to ADMUX registry
     b32:	ec e7       	ldi	r30, 0x7C	; 124
     b34:	f0 e0       	ldi	r31, 0x00	; 0
     b36:	90 81       	ld	r25, Z
     b38:	88 50       	subi	r24, 0x08	; 8
     b3a:	89 2b       	or	r24, r25
     b3c:	80 83       	st	Z, r24
     b3e:	0d c0       	rjmp	.+26     	; 0xb5a <_Z10analogReadi+0x62>
     b40:	ec 01       	movw	r28, r24
	}
	else{
		Serial.print("ERROR: tried to read digital value from unsupported analog pin ");
     b42:	65 ee       	ldi	r22, 0xE5	; 229
     b44:	72 e0       	ldi	r23, 0x02	; 2
     b46:	8a e8       	ldi	r24, 0x8A	; 138
     b48:	94 e0       	ldi	r25, 0x04	; 4
     b4a:	6a d5       	rcall	.+2772   	; 0x1620 <_ZN5USART5printEPKc>
		Serial.println(pin);
     b4c:	be 01       	movw	r22, r28
     b4e:	8a e8       	ldi	r24, 0x8A	; 138
     b50:	94 e0       	ldi	r25, 0x04	; 4
     b52:	ad d5       	rcall	.+2906   	; 0x16ae <_ZN5USART7printlnEi>
		return 0;
     b54:	80 e0       	ldi	r24, 0x00	; 0
     b56:	90 e0       	ldi	r25, 0x00	; 0
     b58:	0c c0       	rjmp	.+24     	; 0xb72 <_Z10analogReadi+0x7a>
	}
	ADCSRA |= (1<<ADSC);							//start ADC conversion
     b5a:	ea e7       	ldi	r30, 0x7A	; 122
     b5c:	f0 e0       	ldi	r31, 0x00	; 0
     b5e:	80 81       	ld	r24, Z
     b60:	80 64       	ori	r24, 0x40	; 64
     b62:	80 83       	st	Z, r24
	while(ADCSRA & (1<<ADSC));						//wait until the ADSC is 0 again and the conversion is done
     b64:	80 81       	ld	r24, Z
     b66:	86 fd       	sbrc	r24, 6
     b68:	fd cf       	rjmp	.-6      	; 0xb64 <_Z10analogReadi+0x6c>
	return ADC;										//return the byte in ADLAR, the result of the ADC conversion
     b6a:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
     b6e:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
}
     b72:	df 91       	pop	r29
     b74:	cf 91       	pop	r28
     b76:	08 95       	ret

00000b78 <_Z9printinfov>:
}

#ifdef DEBUG_MODE									//only spam terminal when in debug mode
void printinfo(){

	Serial.print("DM: ");
     b78:	65 e2       	ldi	r22, 0x25	; 37
     b7a:	73 e0       	ldi	r23, 0x03	; 3
     b7c:	8a e8       	ldi	r24, 0x8A	; 138
     b7e:	94 e0       	ldi	r25, 0x04	; 4
     b80:	4f d5       	rcall	.+2718   	; 0x1620 <_ZN5USART5printEPKc>
	Serial.print(drivemode);
     b82:	60 91 69 04 	lds	r22, 0x0469	; 0x800469 <drivemode>
     b86:	70 91 6a 04 	lds	r23, 0x046A	; 0x80046a <drivemode+0x1>
     b8a:	8a e8       	ldi	r24, 0x8A	; 138
     b8c:	94 e0       	ldi	r25, 0x04	; 4
     b8e:	6c d5       	rcall	.+2776   	; 0x1668 <_ZN5USART5printEi>
	Serial.print(" drive dir: ");
     b90:	6a e2       	ldi	r22, 0x2A	; 42
     b92:	73 e0       	ldi	r23, 0x03	; 3
     b94:	8a e8       	ldi	r24, 0x8A	; 138
     b96:	94 e0       	ldi	r25, 0x04	; 4
     b98:	43 d5       	rcall	.+2694   	; 0x1620 <_ZN5USART5printEPKc>
	Serial.print(driving_direction);
     b9a:	60 91 00 02 	lds	r22, 0x0200	; 0x800200 <__data_start>
     b9e:	70 e0       	ldi	r23, 0x00	; 0
     ba0:	8a e8       	ldi	r24, 0x8A	; 138
     ba2:	94 e0       	ldi	r25, 0x04	; 4
     ba4:	61 d5       	rcall	.+2754   	; 0x1668 <_ZN5USART5printEi>
	Serial.print(" engine_dv = ");
     ba6:	67 e3       	ldi	r22, 0x37	; 55
     ba8:	73 e0       	ldi	r23, 0x03	; 3
     baa:	8a e8       	ldi	r24, 0x8A	; 138
     bac:	94 e0       	ldi	r25, 0x04	; 4
     bae:	38 d5       	rcall	.+2672   	; 0x1620 <_ZN5USART5printEPKc>
	Serial.print(engine_dv);
     bb0:	60 91 54 04 	lds	r22, 0x0454	; 0x800454 <engine_dv>
     bb4:	70 91 55 04 	lds	r23, 0x0455	; 0x800455 <engine_dv+0x1>
     bb8:	8a e8       	ldi	r24, 0x8A	; 138
     bba:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" speed. = ");
     bbc:	55 d5       	rcall	.+2730   	; 0x1668 <_ZN5USART5printEi>
     bbe:	65 e4       	ldi	r22, 0x45	; 69
     bc0:	73 e0       	ldi	r23, 0x03	; 3
     bc2:	8a e8       	ldi	r24, 0x8A	; 138
     bc4:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(engine_cv);
     bc6:	2c d5       	rcall	.+2648   	; 0x1620 <_ZN5USART5printEPKc>
     bc8:	60 91 4c 04 	lds	r22, 0x044C	; 0x80044c <engine_cv>
     bcc:	70 91 4d 04 	lds	r23, 0x044D	; 0x80044d <engine_cv+0x1>
     bd0:	8a e8       	ldi	r24, 0x8A	; 138
     bd2:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" engine_ov = ");
     bd4:	49 d5       	rcall	.+2706   	; 0x1668 <_ZN5USART5printEi>
     bd6:	60 e5       	ldi	r22, 0x50	; 80
     bd8:	73 e0       	ldi	r23, 0x03	; 3
     bda:	8a e8       	ldi	r24, 0x8A	; 138
     bdc:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(engine_ov);
     bde:	20 d5       	rcall	.+2624   	; 0x1620 <_ZN5USART5printEPKc>
     be0:	60 91 4b 04 	lds	r22, 0x044B	; 0x80044b <engine_ov>
     be4:	70 e0       	ldi	r23, 0x00	; 0
     be6:	8a e8       	ldi	r24, 0x8A	; 138
     be8:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" brake_dv = ");
     bea:	3e d5       	rcall	.+2684   	; 0x1668 <_ZN5USART5printEi>
     bec:	6e e5       	ldi	r22, 0x5E	; 94
     bee:	73 e0       	ldi	r23, 0x03	; 3
     bf0:	8a e8       	ldi	r24, 0x8A	; 138
     bf2:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(braking_dv);
     bf4:	15 d5       	rcall	.+2602   	; 0x1620 <_ZN5USART5printEPKc>
     bf6:	60 91 47 04 	lds	r22, 0x0447	; 0x800447 <braking_dv>
     bfa:	70 91 48 04 	lds	r23, 0x0448	; 0x800448 <braking_dv+0x1>
     bfe:	8a e8       	ldi	r24, 0x8A	; 138
	Serial.print(" braking_ov = ");
     c00:	94 e0       	ldi	r25, 0x04	; 4
     c02:	32 d5       	rcall	.+2660   	; 0x1668 <_ZN5USART5printEi>
     c04:	6b e6       	ldi	r22, 0x6B	; 107
     c06:	73 e0       	ldi	r23, 0x03	; 3
     c08:	8a e8       	ldi	r24, 0x8A	; 138
	Serial.print(braking_ov);
     c0a:	94 e0       	ldi	r25, 0x04	; 4
     c0c:	09 d5       	rcall	.+2578   	; 0x1620 <_ZN5USART5printEPKc>
     c0e:	60 91 3e 04 	lds	r22, 0x043E	; 0x80043e <braking_ov>
     c12:	70 e0       	ldi	r23, 0x00	; 0
     c14:	8a e8       	ldi	r24, 0x8A	; 138

	Serial.print(" steering_dv = ");
     c16:	94 e0       	ldi	r25, 0x04	; 4
     c18:	27 d5       	rcall	.+2638   	; 0x1668 <_ZN5USART5printEi>
     c1a:	6a e7       	ldi	r22, 0x7A	; 122
     c1c:	73 e0       	ldi	r23, 0x03	; 3
     c1e:	8a e8       	ldi	r24, 0x8A	; 138
	Serial.print(steering_dv);
     c20:	94 e0       	ldi	r25, 0x04	; 4
     c22:	fe d4       	rcall	.+2556   	; 0x1620 <_ZN5USART5printEPKc>
     c24:	60 91 61 04 	lds	r22, 0x0461	; 0x800461 <steering_dv>
     c28:	70 91 62 04 	lds	r23, 0x0462	; 0x800462 <steering_dv+0x1>
     c2c:	8a e8       	ldi	r24, 0x8A	; 138
	Serial.print(" steering_cv = ");
     c2e:	94 e0       	ldi	r25, 0x04	; 4
     c30:	1b d5       	rcall	.+2614   	; 0x1668 <_ZN5USART5printEi>
     c32:	6a e8       	ldi	r22, 0x8A	; 138
     c34:	73 e0       	ldi	r23, 0x03	; 3
     c36:	8a e8       	ldi	r24, 0x8A	; 138
	Serial.print(steering_cv);
     c38:	94 e0       	ldi	r25, 0x04	; 4
     c3a:	f2 d4       	rcall	.+2532   	; 0x1620 <_ZN5USART5printEPKc>
     c3c:	60 91 59 04 	lds	r22, 0x0459	; 0x800459 <steering_cv>
     c40:	70 91 5a 04 	lds	r23, 0x045A	; 0x80045a <steering_cv+0x1>
	Serial.print(" steering_ov = ");
     c44:	8a e8       	ldi	r24, 0x8A	; 138
     c46:	94 e0       	ldi	r25, 0x04	; 4
     c48:	0f d5       	rcall	.+2590   	; 0x1668 <_ZN5USART5printEi>
     c4a:	6a e9       	ldi	r22, 0x9A	; 154
     c4c:	73 e0       	ldi	r23, 0x03	; 3
	Serial.print(steering_ov);
     c4e:	8a e8       	ldi	r24, 0x8A	; 138
     c50:	94 e0       	ldi	r25, 0x04	; 4
     c52:	e6 d4       	rcall	.+2508   	; 0x1620 <_ZN5USART5printEPKc>
     c54:	60 91 58 04 	lds	r22, 0x0458	; 0x800458 <steering_ov>
     c58:	70 e0       	ldi	r23, 0x00	; 0
	Serial.print(" delta = ");
     c5a:	8a e8       	ldi	r24, 0x8A	; 138
     c5c:	94 e0       	ldi	r25, 0x04	; 4
     c5e:	04 d5       	rcall	.+2568   	; 0x1668 <_ZN5USART5printEi>
     c60:	6a ea       	ldi	r22, 0xAA	; 170
     c62:	73 e0       	ldi	r23, 0x03	; 3
	Serial.print(steering_delta);
     c64:	8a e8       	ldi	r24, 0x8A	; 138
     c66:	94 e0       	ldi	r25, 0x04	; 4
     c68:	db d4       	rcall	.+2486   	; 0x1620 <_ZN5USART5printEPKc>
     c6a:	60 91 5d 04 	lds	r22, 0x045D	; 0x80045d <steering_delta>
     c6e:	70 91 5e 04 	lds	r23, 0x045E	; 0x80045e <steering_delta+0x1>
	Serial.print(" low volt = ");
     c72:	8a e8       	ldi	r24, 0x8A	; 138
     c74:	94 e0       	ldi	r25, 0x04	; 4
     c76:	f8 d4       	rcall	.+2544   	; 0x1668 <_ZN5USART5printEi>
     c78:	64 eb       	ldi	r22, 0xB4	; 180
     c7a:	73 e0       	ldi	r23, 0x03	; 3
	Serial.print(low_voltage);
     c7c:	8a e8       	ldi	r24, 0x8A	; 138
     c7e:	94 e0       	ldi	r25, 0x04	; 4
     c80:	cf d4       	rcall	.+2462   	; 0x1620 <_ZN5USART5printEPKc>
     c82:	60 91 3c 04 	lds	r22, 0x043C	; 0x80043c <low_voltage>
     c86:	70 91 3d 04 	lds	r23, 0x043D	; 0x80043d <low_voltage+0x1>
	Serial.print(" high volt = ");
     c8a:	8a e8       	ldi	r24, 0x8A	; 138
     c8c:	94 e0       	ldi	r25, 0x04	; 4
     c8e:	ec d4       	rcall	.+2520   	; 0x1668 <_ZN5USART5printEi>
     c90:	61 ec       	ldi	r22, 0xC1	; 193
     c92:	73 e0       	ldi	r23, 0x03	; 3
	Serial.print(high_voltage);
     c94:	8a e8       	ldi	r24, 0x8A	; 138
     c96:	94 e0       	ldi	r25, 0x04	; 4
     c98:	c3 d4       	rcall	.+2438   	; 0x1620 <_ZN5USART5printEPKc>
     c9a:	60 91 34 04 	lds	r22, 0x0434	; 0x800434 <__data_end>
     c9e:	70 91 35 04 	lds	r23, 0x0435	; 0x800435 <__data_end+0x1>
	Serial.print(" rpm = ");
     ca2:	8a e8       	ldi	r24, 0x8A	; 138
     ca4:	94 e0       	ldi	r25, 0x04	; 4
     ca6:	e0 d4       	rcall	.+2496   	; 0x1668 <_ZN5USART5printEi>
     ca8:	6f ec       	ldi	r22, 0xCF	; 207
     caa:	73 e0       	ldi	r23, 0x03	; 3
     cac:	8a e8       	ldi	r24, 0x8A	; 138
	Serial.print(engine_rpm);
     cae:	94 e0       	ldi	r25, 0x04	; 4
     cb0:	b7 d4       	rcall	.+2414   	; 0x1620 <_ZN5USART5printEPKc>
     cb2:	60 91 3a 04 	lds	r22, 0x043A	; 0x80043a <engine_rpm>
     cb6:	70 91 3b 04 	lds	r23, 0x043B	; 0x80043b <engine_rpm+0x1>
     cba:	8a e8       	ldi	r24, 0x8A	; 138
     cbc:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" temp = ");
     cbe:	d4 d4       	rcall	.+2472   	; 0x1668 <_ZN5USART5printEi>
     cc0:	67 ed       	ldi	r22, 0xD7	; 215
     cc2:	73 e0       	ldi	r23, 0x03	; 3
     cc4:	8a e8       	ldi	r24, 0x8A	; 138
     cc6:	94 e0       	ldi	r25, 0x04	; 4
     cc8:	ab d4       	rcall	.+2390   	; 0x1620 <_ZN5USART5printEPKc>
	Serial.println(engine_temp);
     cca:	60 91 38 04 	lds	r22, 0x0438	; 0x800438 <engine_temp>
     cce:	70 91 39 04 	lds	r23, 0x0439	; 0x800439 <engine_temp+0x1>
     cd2:	8a e8       	ldi	r24, 0x8A	; 138
     cd4:	94 e0       	ldi	r25, 0x04	; 4
     cd6:	eb c4       	rjmp	.+2518   	; 0x16ae <_ZN5USART7printlnEi>
     cd8:	08 95       	ret

00000cda <_Z13updateCurtissv>:
     cda:	2b e6       	ldi	r18, 0x6B	; 107
}
#endif

void updateCurtiss(){
	CAN_Curt.readMsgBuf(&rxId_Curt, &len_Curt, rxBuf_Curt);	// Read data: len = data length, buf = data byte(s)
     cdc:	34 e0       	ldi	r19, 0x04	; 4
     cde:	43 e7       	ldi	r20, 0x73	; 115
     ce0:	54 e0       	ldi	r21, 0x04	; 4
     ce2:	64 e7       	ldi	r22, 0x74	; 116
     ce4:	74 e0       	ldi	r23, 0x04	; 4
     ce6:	88 e7       	ldi	r24, 0x78	; 120
     ce8:	94 e0       	ldi	r25, 0x04	; 4
     cea:	0d d4       	rcall	.+2074   	; 0x1506 <_ZN7MCP_CAN10readMsgBufEPmPhS1_>
	if((rxId_Curt & 0x40000000) == 0x40000000)					//Ignore remote requests
     cec:	80 91 74 04 	lds	r24, 0x0474	; 0x800474 <rxId_Curt>
     cf0:	90 91 75 04 	lds	r25, 0x0475	; 0x800475 <rxId_Curt+0x1>
     cf4:	a0 91 76 04 	lds	r26, 0x0476	; 0x800476 <rxId_Curt+0x2>
     cf8:	b0 91 77 04 	lds	r27, 0x0477	; 0x800477 <rxId_Curt+0x3>
     cfc:	b6 fd       	sbrc	r27, 6
     cfe:	36 c0       	rjmp	.+108    	; 0xd6c <_Z13updateCurtissv+0x92>
		return;	
	low_voltage = rxBuf_Curt[0] + (rxBuf_Curt[1] * 256);
     d00:	eb e6       	ldi	r30, 0x6B	; 107
     d02:	f4 e0       	ldi	r31, 0x04	; 4
     d04:	81 81       	ldd	r24, Z+1	; 0x01
     d06:	90 e0       	ldi	r25, 0x00	; 0
     d08:	98 2f       	mov	r25, r24
     d0a:	88 27       	eor	r24, r24
     d0c:	20 81       	ld	r18, Z
     d0e:	82 0f       	add	r24, r18
     d10:	91 1d       	adc	r25, r1
     d12:	90 93 3d 04 	sts	0x043D, r25	; 0x80043d <low_voltage+0x1>
     d16:	80 93 3c 04 	sts	0x043C, r24	; 0x80043c <low_voltage>
	engine_rpm = rxBuf_Curt[2] + (rxBuf_Curt[3] * 256);
     d1a:	83 81       	ldd	r24, Z+3	; 0x03
     d1c:	90 e0       	ldi	r25, 0x00	; 0
     d1e:	98 2f       	mov	r25, r24
     d20:	88 27       	eor	r24, r24
     d22:	22 81       	ldd	r18, Z+2	; 0x02
     d24:	82 0f       	add	r24, r18
     d26:	91 1d       	adc	r25, r1
     d28:	90 93 3b 04 	sts	0x043B, r25	; 0x80043b <engine_rpm+0x1>
     d2c:	80 93 3a 04 	sts	0x043A, r24	; 0x80043a <engine_rpm>
	engine_temp = rxBuf_Curt[4] + (rxBuf_Curt[5] * 256);
     d30:	85 81       	ldd	r24, Z+5	; 0x05
     d32:	90 e0       	ldi	r25, 0x00	; 0
     d34:	98 2f       	mov	r25, r24
     d36:	88 27       	eor	r24, r24
     d38:	24 81       	ldd	r18, Z+4	; 0x04
     d3a:	82 0f       	add	r24, r18
     d3c:	91 1d       	adc	r25, r1
     d3e:	90 93 39 04 	sts	0x0439, r25	; 0x800439 <engine_temp+0x1>
     d42:	80 93 38 04 	sts	0x0438, r24	; 0x800438 <engine_temp>
	control_temp = rxBuf_Curt[6] + (rxBuf_Curt[7] * 256);
     d46:	87 81       	ldd	r24, Z+7	; 0x07
     d48:	90 e0       	ldi	r25, 0x00	; 0
     d4a:	98 2f       	mov	r25, r24
     d4c:	88 27       	eor	r24, r24
     d4e:	26 81       	ldd	r18, Z+6	; 0x06
     d50:	ac 01       	movw	r20, r24
     d52:	42 0f       	add	r20, r18
     d54:	51 1d       	adc	r21, r1
     d56:	50 93 37 04 	sts	0x0437, r21	; 0x800437 <control_temp+0x1>
     d5a:	40 93 36 04 	sts	0x0436, r20	; 0x800436 <control_temp>
	high_voltage = rxBuf_Curt[8] + (rxBuf_Curt[7] * 256);	
     d5e:	20 85       	ldd	r18, Z+8	; 0x08
     d60:	82 0f       	add	r24, r18
     d62:	91 1d       	adc	r25, r1
     d64:	90 93 35 04 	sts	0x0435, r25	; 0x800435 <__data_end+0x1>
     d68:	80 93 34 04 	sts	0x0434, r24	; 0x800434 <__data_end>
     d6c:	08 95       	ret

00000d6e <main>:
unsigned char len_Curt;
unsigned char rxBuf_Curt[8];
char msgString_Curt[128]; 

int main(void){
	Serial.println("Alley Hoop V2.1");
     d6e:	60 ee       	ldi	r22, 0xE0	; 224
     d70:	73 e0       	ldi	r23, 0x03	; 3
     d72:	8a e8       	ldi	r24, 0x8A	; 138
     d74:	94 e0       	ldi	r25, 0x04	; 4
     d76:	6d d4       	rcall	.+2266   	; 0x1652 <_ZN5USART7printlnEPKc>
	initIO();															//initializes the IO pins
     d78:	99 dc       	rcall	.-1742   	; 0x6ac <_Z6initIOv>
	initDrive();														//detect steering modus
     d7a:	1a da       	rcall	.-3020   	; 0x1b0 <_Z9initDrivev>
     d7c:	21 e0       	ldi	r18, 0x01	; 1

	if(CAN_Curt.begin(MCP_ANY, CAN_500KBPS, MCP_16MHZ) == CAN_OK)		//initialize the CAN BUS
     d7e:	4d e0       	ldi	r20, 0x0D	; 13
     d80:	63 e0       	ldi	r22, 0x03	; 3
     d82:	88 e7       	ldi	r24, 0x78	; 120
     d84:	94 e0       	ldi	r25, 0x04	; 4
     d86:	85 d3       	rcall	.+1802   	; 0x1492 <_ZN7MCP_CAN5beginEhhh>
     d88:	81 11       	cpse	r24, r1
     d8a:	06 c0       	rjmp	.+12     	; 0xd98 <main+0x2a>
     d8c:	60 ef       	ldi	r22, 0xF0	; 240
		Serial.println("MCP2515 Initialized Successfully!");
     d8e:	73 e0       	ldi	r23, 0x03	; 3
     d90:	8a e8       	ldi	r24, 0x8A	; 138
     d92:	94 e0       	ldi	r25, 0x04	; 4
     d94:	5e d4       	rcall	.+2236   	; 0x1652 <_ZN5USART7printlnEPKc>
     d96:	05 c0       	rjmp	.+10     	; 0xda2 <main+0x34>
     d98:	62 e1       	ldi	r22, 0x12	; 18
	else
		Serial.println("Error Initializing MCP2515...");
     d9a:	74 e0       	ldi	r23, 0x04	; 4
     d9c:	8a e8       	ldi	r24, 0x8A	; 138
     d9e:	94 e0       	ldi	r25, 0x04	; 4
     da0:	58 d4       	rcall	.+2224   	; 0x1652 <_ZN5USART7printlnEPKc>
	CAN_Curt.setMode(MCP_NORMAL);										// Set operation mode to normal so the MCP2515 sends acks to received data.
     da2:	60 e0       	ldi	r22, 0x00	; 0
     da4:	88 e7       	ldi	r24, 0x78	; 120
     da6:	94 e0       	ldi	r25, 0x04	; 4
     da8:	d5 d1       	rcall	.+938    	; 0x1154 <_ZN7MCP_CAN7setModeEh>

	while (1){				//main program loop	
		updateCurtiss();		//update the values retrieved from the Curtis
     daa:	97 df       	rcall	.-210    	; 0xcda <_Z13updateCurtissv>
     dac:	62 dc       	rcall	.-1852   	; 0x672 <_Z5drivev>
		drive();				//update the values send to various components
     dae:	e4 de       	rcall	.-568    	; 0xb78 <_Z9printinfov>
     db0:	fc cf       	rjmp	.-8      	; 0xdaa <main+0x3c>

00000db2 <_GLOBAL__sub_I_Serial>:
		#ifdef DEBUG_MODE
			printinfo();			//print info in the terminal, only when debug mode is enabled
     db2:	8a e8       	ldi	r24, 0x8A	; 138
     db4:	94 e0       	ldi	r25, 0x04	; 4
     db6:	29 d4       	rcall	.+2130   	; 0x160a <_ZN5USARTC1Ev>
#include <util/delay.h>		//allows usage of _delay_ms()
#include "overhead.h"		//defines and standard includes
#include "Drive.h"			//takes care of driving the car

USART Serial;				//global Serial
MCP_CAN CAN_Curt(47);		//the Curtiss CAN BUS
     db8:	6f e2       	ldi	r22, 0x2F	; 47
     dba:	88 e7       	ldi	r24, 0x78	; 120
     dbc:	94 e0       	ldi	r25, 0x04	; 4
     dbe:	5c c3       	rjmp	.+1720   	; 0x1478 <_ZN7MCP_CANC1Eh>
     dc0:	08 95       	ret

00000dc2 <_ZN7MCP_CAN13mcp2515_resetEv>:
		tbufdata[MCP_EID0] = 0;
		tbufdata[MCP_EID8] = 0;
	}

	mcp2515_setRegisterS( mcp_addr, tbufdata, 4 );
}
     dc2:	0f 93       	push	r16
     dc4:	1f 93       	push	r17
     dc6:	cf 93       	push	r28
     dc8:	df 93       	push	r29
     dca:	1f 92       	push	r1
     dcc:	1f 92       	push	r1
     dce:	cd b7       	in	r28, 0x3d	; 61
     dd0:	de b7       	in	r29, 0x3e	; 62
     dd2:	00 e0       	ldi	r16, 0x00	; 0
     dd4:	21 e0       	ldi	r18, 0x01	; 1
     dd6:	40 e8       	ldi	r20, 0x80	; 128
     dd8:	56 e9       	ldi	r21, 0x96	; 150
     dda:	68 e9       	ldi	r22, 0x98	; 152
     ddc:	70 e0       	ldi	r23, 0x00	; 0
     dde:	ce 01       	movw	r24, r28
     de0:	01 96       	adiw	r24, 0x01	; 1
     de2:	e3 d3       	rcall	.+1990   	; 0x15aa <_ZN11SPISettingsC1Emhh>
     de4:	be 01       	movw	r22, r28
     de6:	6f 5f       	subi	r22, 0xFF	; 255
     de8:	7f 4f       	sbci	r23, 0xFF	; 255
     dea:	8c e8       	ldi	r24, 0x8C	; 140
     dec:	94 e0       	ldi	r25, 0x04	; 4
     dee:	01 d4       	rcall	.+2050   	; 0x15f2 <_ZN8SPIClass16beginTransactionE11SPISettings>
     df0:	0b e0       	ldi	r16, 0x0B	; 11
     df2:	11 e0       	ldi	r17, 0x01	; 1
     df4:	f8 01       	movw	r30, r16
     df6:	80 81       	ld	r24, Z
     df8:	8b 7f       	andi	r24, 0xFB	; 251
     dfa:	80 83       	st	Z, r24
     dfc:	60 ec       	ldi	r22, 0xC0	; 192
     dfe:	8c e8       	ldi	r24, 0x8C	; 140
     e00:	94 e0       	ldi	r25, 0x04	; 4
     e02:	fd d3       	rcall	.+2042   	; 0x15fe <_ZN8SPIClass8transferEh>
     e04:	f8 01       	movw	r30, r16
     e06:	80 81       	ld	r24, Z
     e08:	84 60       	ori	r24, 0x04	; 4
     e0a:	80 83       	st	Z, r24
     e0c:	83 ec       	ldi	r24, 0xC3	; 195
     e0e:	99 e0       	ldi	r25, 0x09	; 9
     e10:	01 97       	sbiw	r24, 0x01	; 1
     e12:	f1 f7       	brne	.-4      	; 0xe10 <_ZN7MCP_CAN13mcp2515_resetEv+0x4e>
     e14:	00 c0       	rjmp	.+0      	; 0xe16 <_ZN7MCP_CAN13mcp2515_resetEv+0x54>
     e16:	00 00       	nop
     e18:	0f 90       	pop	r0
     e1a:	0f 90       	pop	r0
     e1c:	df 91       	pop	r29
     e1e:	cf 91       	pop	r28
     e20:	1f 91       	pop	r17
     e22:	0f 91       	pop	r16
     e24:	08 95       	ret

00000e26 <_ZN7MCP_CAN20mcp2515_readRegisterEh>:
     e26:	ff 92       	push	r15
     e28:	0f 93       	push	r16
     e2a:	1f 93       	push	r17
     e2c:	cf 93       	push	r28
     e2e:	df 93       	push	r29
     e30:	1f 92       	push	r1
     e32:	1f 92       	push	r1
     e34:	cd b7       	in	r28, 0x3d	; 61
     e36:	de b7       	in	r29, 0x3e	; 62
     e38:	f6 2e       	mov	r15, r22
     e3a:	00 e0       	ldi	r16, 0x00	; 0
     e3c:	21 e0       	ldi	r18, 0x01	; 1
     e3e:	40 e8       	ldi	r20, 0x80	; 128
     e40:	56 e9       	ldi	r21, 0x96	; 150
     e42:	68 e9       	ldi	r22, 0x98	; 152
     e44:	70 e0       	ldi	r23, 0x00	; 0
     e46:	ce 01       	movw	r24, r28
     e48:	01 96       	adiw	r24, 0x01	; 1
     e4a:	af d3       	rcall	.+1886   	; 0x15aa <_ZN11SPISettingsC1Emhh>
     e4c:	be 01       	movw	r22, r28
     e4e:	6f 5f       	subi	r22, 0xFF	; 255
     e50:	7f 4f       	sbci	r23, 0xFF	; 255
     e52:	8c e8       	ldi	r24, 0x8C	; 140
     e54:	94 e0       	ldi	r25, 0x04	; 4
     e56:	cd d3       	rcall	.+1946   	; 0x15f2 <_ZN8SPIClass16beginTransactionE11SPISettings>
     e58:	0b e0       	ldi	r16, 0x0B	; 11
     e5a:	11 e0       	ldi	r17, 0x01	; 1
     e5c:	f8 01       	movw	r30, r16
     e5e:	80 81       	ld	r24, Z
     e60:	8b 7f       	andi	r24, 0xFB	; 251
     e62:	80 83       	st	Z, r24
     e64:	63 e0       	ldi	r22, 0x03	; 3
     e66:	8c e8       	ldi	r24, 0x8C	; 140
     e68:	94 e0       	ldi	r25, 0x04	; 4
     e6a:	c9 d3       	rcall	.+1938   	; 0x15fe <_ZN8SPIClass8transferEh>
     e6c:	6f 2d       	mov	r22, r15
     e6e:	8c e8       	ldi	r24, 0x8C	; 140
     e70:	94 e0       	ldi	r25, 0x04	; 4
     e72:	c5 d3       	rcall	.+1930   	; 0x15fe <_ZN8SPIClass8transferEh>
     e74:	60 e0       	ldi	r22, 0x00	; 0
     e76:	8c e8       	ldi	r24, 0x8C	; 140
     e78:	94 e0       	ldi	r25, 0x04	; 4
     e7a:	c1 d3       	rcall	.+1922   	; 0x15fe <_ZN8SPIClass8transferEh>
     e7c:	f8 01       	movw	r30, r16
     e7e:	90 81       	ld	r25, Z
     e80:	94 60       	ori	r25, 0x04	; 4
     e82:	90 83       	st	Z, r25
     e84:	0f 90       	pop	r0
     e86:	0f 90       	pop	r0
     e88:	df 91       	pop	r29
     e8a:	cf 91       	pop	r28
     e8c:	1f 91       	pop	r17
     e8e:	0f 91       	pop	r16
     e90:	ff 90       	pop	r15
     e92:	08 95       	ret

00000e94 <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh>:
     e94:	cf 92       	push	r12
     e96:	df 92       	push	r13
     e98:	ef 92       	push	r14
     e9a:	ff 92       	push	r15
     e9c:	0f 93       	push	r16
     e9e:	1f 93       	push	r17
     ea0:	cf 93       	push	r28
     ea2:	df 93       	push	r29
     ea4:	1f 92       	push	r1
     ea6:	1f 92       	push	r1
     ea8:	cd b7       	in	r28, 0x3d	; 61
     eaa:	de b7       	in	r29, 0x3e	; 62
     eac:	16 2f       	mov	r17, r22
     eae:	6a 01       	movw	r12, r20
     eb0:	f2 2e       	mov	r15, r18
     eb2:	00 e0       	ldi	r16, 0x00	; 0
     eb4:	21 e0       	ldi	r18, 0x01	; 1
     eb6:	40 e8       	ldi	r20, 0x80	; 128
     eb8:	56 e9       	ldi	r21, 0x96	; 150
     eba:	68 e9       	ldi	r22, 0x98	; 152
     ebc:	70 e0       	ldi	r23, 0x00	; 0
     ebe:	ce 01       	movw	r24, r28
     ec0:	01 96       	adiw	r24, 0x01	; 1
     ec2:	73 d3       	rcall	.+1766   	; 0x15aa <_ZN11SPISettingsC1Emhh>
     ec4:	be 01       	movw	r22, r28
     ec6:	6f 5f       	subi	r22, 0xFF	; 255
     ec8:	7f 4f       	sbci	r23, 0xFF	; 255
     eca:	8c e8       	ldi	r24, 0x8C	; 140
     ecc:	94 e0       	ldi	r25, 0x04	; 4
     ece:	91 d3       	rcall	.+1826   	; 0x15f2 <_ZN8SPIClass16beginTransactionE11SPISettings>
     ed0:	eb e0       	ldi	r30, 0x0B	; 11
     ed2:	f1 e0       	ldi	r31, 0x01	; 1
     ed4:	80 81       	ld	r24, Z
     ed6:	8b 7f       	andi	r24, 0xFB	; 251
     ed8:	80 83       	st	Z, r24
     eda:	63 e0       	ldi	r22, 0x03	; 3
     edc:	8c e8       	ldi	r24, 0x8C	; 140
     ede:	94 e0       	ldi	r25, 0x04	; 4
     ee0:	8e d3       	rcall	.+1820   	; 0x15fe <_ZN8SPIClass8transferEh>
     ee2:	61 2f       	mov	r22, r17
     ee4:	8c e8       	ldi	r24, 0x8C	; 140
     ee6:	94 e0       	ldi	r25, 0x04	; 4
     ee8:	8a d3       	rcall	.+1812   	; 0x15fe <_ZN8SPIClass8transferEh>
     eea:	ff 20       	and	r15, r15
     eec:	99 f0       	breq	.+38     	; 0xf14 <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh+0x80>
     eee:	86 01       	movw	r16, r12
     ef0:	fa 94       	dec	r15
     ef2:	ef 2c       	mov	r14, r15
     ef4:	f1 2c       	mov	r15, r1
     ef6:	8f ef       	ldi	r24, 0xFF	; 255
     ef8:	e8 1a       	sub	r14, r24
     efa:	f8 0a       	sbc	r15, r24
     efc:	ec 0c       	add	r14, r12
     efe:	fd 1c       	adc	r15, r13
     f00:	60 e0       	ldi	r22, 0x00	; 0
     f02:	8c e8       	ldi	r24, 0x8C	; 140
     f04:	94 e0       	ldi	r25, 0x04	; 4
     f06:	7b d3       	rcall	.+1782   	; 0x15fe <_ZN8SPIClass8transferEh>
     f08:	f8 01       	movw	r30, r16
     f0a:	81 93       	st	Z+, r24
     f0c:	8f 01       	movw	r16, r30
     f0e:	ee 15       	cp	r30, r14
     f10:	ff 05       	cpc	r31, r15
     f12:	b1 f7       	brne	.-20     	; 0xf00 <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh+0x6c>
     f14:	eb e0       	ldi	r30, 0x0B	; 11
     f16:	f1 e0       	ldi	r31, 0x01	; 1
     f18:	80 81       	ld	r24, Z
     f1a:	84 60       	ori	r24, 0x04	; 4
     f1c:	80 83       	st	Z, r24
     f1e:	0f 90       	pop	r0
     f20:	0f 90       	pop	r0
     f22:	df 91       	pop	r29
     f24:	cf 91       	pop	r28
     f26:	1f 91       	pop	r17
     f28:	0f 91       	pop	r16
     f2a:	ff 90       	pop	r15
     f2c:	ef 90       	pop	r14
     f2e:	df 90       	pop	r13
     f30:	cf 90       	pop	r12
     f32:	08 95       	ret

00000f34 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>:
     f34:	ef 92       	push	r14
     f36:	ff 92       	push	r15
     f38:	0f 93       	push	r16
     f3a:	1f 93       	push	r17
     f3c:	cf 93       	push	r28
     f3e:	df 93       	push	r29
     f40:	1f 92       	push	r1
     f42:	1f 92       	push	r1
     f44:	cd b7       	in	r28, 0x3d	; 61
     f46:	de b7       	in	r29, 0x3e	; 62
     f48:	e6 2e       	mov	r14, r22
     f4a:	f4 2e       	mov	r15, r20
     f4c:	00 e0       	ldi	r16, 0x00	; 0
     f4e:	21 e0       	ldi	r18, 0x01	; 1
     f50:	40 e8       	ldi	r20, 0x80	; 128
     f52:	56 e9       	ldi	r21, 0x96	; 150
     f54:	68 e9       	ldi	r22, 0x98	; 152
     f56:	70 e0       	ldi	r23, 0x00	; 0
     f58:	ce 01       	movw	r24, r28
     f5a:	01 96       	adiw	r24, 0x01	; 1
     f5c:	26 d3       	rcall	.+1612   	; 0x15aa <_ZN11SPISettingsC1Emhh>
     f5e:	be 01       	movw	r22, r28
     f60:	6f 5f       	subi	r22, 0xFF	; 255
     f62:	7f 4f       	sbci	r23, 0xFF	; 255
     f64:	8c e8       	ldi	r24, 0x8C	; 140
     f66:	94 e0       	ldi	r25, 0x04	; 4
     f68:	44 d3       	rcall	.+1672   	; 0x15f2 <_ZN8SPIClass16beginTransactionE11SPISettings>
     f6a:	0b e0       	ldi	r16, 0x0B	; 11
     f6c:	11 e0       	ldi	r17, 0x01	; 1
     f6e:	f8 01       	movw	r30, r16
     f70:	80 81       	ld	r24, Z
     f72:	8b 7f       	andi	r24, 0xFB	; 251
     f74:	80 83       	st	Z, r24
     f76:	62 e0       	ldi	r22, 0x02	; 2
     f78:	8c e8       	ldi	r24, 0x8C	; 140
     f7a:	94 e0       	ldi	r25, 0x04	; 4
     f7c:	40 d3       	rcall	.+1664   	; 0x15fe <_ZN8SPIClass8transferEh>
     f7e:	6e 2d       	mov	r22, r14
     f80:	8c e8       	ldi	r24, 0x8C	; 140
     f82:	94 e0       	ldi	r25, 0x04	; 4
     f84:	3c d3       	rcall	.+1656   	; 0x15fe <_ZN8SPIClass8transferEh>
     f86:	6f 2d       	mov	r22, r15
     f88:	8c e8       	ldi	r24, 0x8C	; 140
     f8a:	94 e0       	ldi	r25, 0x04	; 4
     f8c:	38 d3       	rcall	.+1648   	; 0x15fe <_ZN8SPIClass8transferEh>
     f8e:	f8 01       	movw	r30, r16
     f90:	80 81       	ld	r24, Z
     f92:	84 60       	ori	r24, 0x04	; 4
     f94:	80 83       	st	Z, r24
     f96:	0f 90       	pop	r0
     f98:	0f 90       	pop	r0
     f9a:	df 91       	pop	r29
     f9c:	cf 91       	pop	r28
     f9e:	1f 91       	pop	r17
     fa0:	0f 91       	pop	r16
     fa2:	ff 90       	pop	r15
     fa4:	ef 90       	pop	r14
     fa6:	08 95       	ret

00000fa8 <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh>:
     fa8:	cf 92       	push	r12
     faa:	df 92       	push	r13
     fac:	ef 92       	push	r14
     fae:	ff 92       	push	r15
     fb0:	0f 93       	push	r16
     fb2:	1f 93       	push	r17
     fb4:	cf 93       	push	r28
     fb6:	df 93       	push	r29
     fb8:	1f 92       	push	r1
     fba:	1f 92       	push	r1
     fbc:	cd b7       	in	r28, 0x3d	; 61
     fbe:	de b7       	in	r29, 0x3e	; 62
     fc0:	16 2f       	mov	r17, r22
     fc2:	6a 01       	movw	r12, r20
     fc4:	f2 2e       	mov	r15, r18
     fc6:	00 e0       	ldi	r16, 0x00	; 0
     fc8:	21 e0       	ldi	r18, 0x01	; 1
     fca:	40 e8       	ldi	r20, 0x80	; 128
     fcc:	56 e9       	ldi	r21, 0x96	; 150
     fce:	68 e9       	ldi	r22, 0x98	; 152
     fd0:	70 e0       	ldi	r23, 0x00	; 0
     fd2:	ce 01       	movw	r24, r28
     fd4:	01 96       	adiw	r24, 0x01	; 1
     fd6:	e9 d2       	rcall	.+1490   	; 0x15aa <_ZN11SPISettingsC1Emhh>
     fd8:	be 01       	movw	r22, r28
     fda:	6f 5f       	subi	r22, 0xFF	; 255
     fdc:	7f 4f       	sbci	r23, 0xFF	; 255
     fde:	8c e8       	ldi	r24, 0x8C	; 140
     fe0:	94 e0       	ldi	r25, 0x04	; 4
     fe2:	07 d3       	rcall	.+1550   	; 0x15f2 <_ZN8SPIClass16beginTransactionE11SPISettings>
     fe4:	eb e0       	ldi	r30, 0x0B	; 11
     fe6:	f1 e0       	ldi	r31, 0x01	; 1
     fe8:	80 81       	ld	r24, Z
     fea:	8b 7f       	andi	r24, 0xFB	; 251
     fec:	80 83       	st	Z, r24
     fee:	62 e0       	ldi	r22, 0x02	; 2
     ff0:	8c e8       	ldi	r24, 0x8C	; 140
     ff2:	94 e0       	ldi	r25, 0x04	; 4
     ff4:	04 d3       	rcall	.+1544   	; 0x15fe <_ZN8SPIClass8transferEh>
     ff6:	61 2f       	mov	r22, r17
     ff8:	8c e8       	ldi	r24, 0x8C	; 140
     ffa:	94 e0       	ldi	r25, 0x04	; 4
     ffc:	00 d3       	rcall	.+1536   	; 0x15fe <_ZN8SPIClass8transferEh>
     ffe:	ff 20       	and	r15, r15
    1000:	91 f0       	breq	.+36     	; 0x1026 <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh+0x7e>
    1002:	86 01       	movw	r16, r12
    1004:	fa 94       	dec	r15
    1006:	ef 2c       	mov	r14, r15
    1008:	f1 2c       	mov	r15, r1
    100a:	8f ef       	ldi	r24, 0xFF	; 255
    100c:	e8 1a       	sub	r14, r24
    100e:	f8 0a       	sbc	r15, r24
    1010:	ec 0c       	add	r14, r12
    1012:	fd 1c       	adc	r15, r13
    1014:	f8 01       	movw	r30, r16
    1016:	61 91       	ld	r22, Z+
    1018:	8f 01       	movw	r16, r30
    101a:	8c e8       	ldi	r24, 0x8C	; 140
    101c:	94 e0       	ldi	r25, 0x04	; 4
    101e:	ef d2       	rcall	.+1502   	; 0x15fe <_ZN8SPIClass8transferEh>
    1020:	0e 15       	cp	r16, r14
    1022:	1f 05       	cpc	r17, r15
    1024:	b9 f7       	brne	.-18     	; 0x1014 <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh+0x6c>
    1026:	eb e0       	ldi	r30, 0x0B	; 11
    1028:	f1 e0       	ldi	r31, 0x01	; 1
    102a:	80 81       	ld	r24, Z
    102c:	84 60       	ori	r24, 0x04	; 4
    102e:	80 83       	st	Z, r24
    1030:	0f 90       	pop	r0
    1032:	0f 90       	pop	r0
    1034:	df 91       	pop	r29
    1036:	cf 91       	pop	r28
    1038:	1f 91       	pop	r17
    103a:	0f 91       	pop	r16
    103c:	ff 90       	pop	r15
    103e:	ef 90       	pop	r14
    1040:	df 90       	pop	r13
    1042:	cf 90       	pop	r12
    1044:	08 95       	ret

00001046 <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>:
    1046:	df 92       	push	r13
    1048:	ef 92       	push	r14
    104a:	ff 92       	push	r15
    104c:	0f 93       	push	r16
    104e:	1f 93       	push	r17
    1050:	cf 93       	push	r28
    1052:	df 93       	push	r29
    1054:	1f 92       	push	r1
    1056:	1f 92       	push	r1
    1058:	cd b7       	in	r28, 0x3d	; 61
    105a:	de b7       	in	r29, 0x3e	; 62
    105c:	d6 2e       	mov	r13, r22
    105e:	e4 2e       	mov	r14, r20
    1060:	f2 2e       	mov	r15, r18
    1062:	00 e0       	ldi	r16, 0x00	; 0
    1064:	21 e0       	ldi	r18, 0x01	; 1
    1066:	40 e8       	ldi	r20, 0x80	; 128
    1068:	56 e9       	ldi	r21, 0x96	; 150
    106a:	68 e9       	ldi	r22, 0x98	; 152
    106c:	70 e0       	ldi	r23, 0x00	; 0
    106e:	ce 01       	movw	r24, r28
    1070:	01 96       	adiw	r24, 0x01	; 1
    1072:	9b d2       	rcall	.+1334   	; 0x15aa <_ZN11SPISettingsC1Emhh>
    1074:	be 01       	movw	r22, r28
    1076:	6f 5f       	subi	r22, 0xFF	; 255
    1078:	7f 4f       	sbci	r23, 0xFF	; 255
    107a:	8c e8       	ldi	r24, 0x8C	; 140
    107c:	94 e0       	ldi	r25, 0x04	; 4
    107e:	b9 d2       	rcall	.+1394   	; 0x15f2 <_ZN8SPIClass16beginTransactionE11SPISettings>
    1080:	0b e0       	ldi	r16, 0x0B	; 11
    1082:	11 e0       	ldi	r17, 0x01	; 1
    1084:	f8 01       	movw	r30, r16
    1086:	80 81       	ld	r24, Z
    1088:	8b 7f       	andi	r24, 0xFB	; 251
    108a:	80 83       	st	Z, r24
    108c:	65 e0       	ldi	r22, 0x05	; 5
    108e:	8c e8       	ldi	r24, 0x8C	; 140
    1090:	94 e0       	ldi	r25, 0x04	; 4
    1092:	b5 d2       	rcall	.+1386   	; 0x15fe <_ZN8SPIClass8transferEh>
    1094:	6d 2d       	mov	r22, r13
    1096:	8c e8       	ldi	r24, 0x8C	; 140
    1098:	94 e0       	ldi	r25, 0x04	; 4
    109a:	b1 d2       	rcall	.+1378   	; 0x15fe <_ZN8SPIClass8transferEh>
    109c:	6e 2d       	mov	r22, r14
    109e:	8c e8       	ldi	r24, 0x8C	; 140
    10a0:	94 e0       	ldi	r25, 0x04	; 4
    10a2:	ad d2       	rcall	.+1370   	; 0x15fe <_ZN8SPIClass8transferEh>
    10a4:	6f 2d       	mov	r22, r15
    10a6:	8c e8       	ldi	r24, 0x8C	; 140
    10a8:	94 e0       	ldi	r25, 0x04	; 4
    10aa:	a9 d2       	rcall	.+1362   	; 0x15fe <_ZN8SPIClass8transferEh>
    10ac:	f8 01       	movw	r30, r16
    10ae:	80 81       	ld	r24, Z
    10b0:	84 60       	ori	r24, 0x04	; 4
    10b2:	80 83       	st	Z, r24
    10b4:	0f 90       	pop	r0
    10b6:	0f 90       	pop	r0
    10b8:	df 91       	pop	r29
    10ba:	cf 91       	pop	r28
    10bc:	1f 91       	pop	r17
    10be:	0f 91       	pop	r16
    10c0:	ff 90       	pop	r15
    10c2:	ef 90       	pop	r14
    10c4:	df 90       	pop	r13
    10c6:	08 95       	ret

000010c8 <_ZN7MCP_CAN18mcp2515_readStatusEv>:
    10c8:	0f 93       	push	r16
    10ca:	1f 93       	push	r17
    10cc:	cf 93       	push	r28
    10ce:	df 93       	push	r29
    10d0:	1f 92       	push	r1
    10d2:	1f 92       	push	r1
    10d4:	cd b7       	in	r28, 0x3d	; 61
    10d6:	de b7       	in	r29, 0x3e	; 62
    10d8:	00 e0       	ldi	r16, 0x00	; 0
    10da:	21 e0       	ldi	r18, 0x01	; 1
    10dc:	40 e8       	ldi	r20, 0x80	; 128
    10de:	56 e9       	ldi	r21, 0x96	; 150
    10e0:	68 e9       	ldi	r22, 0x98	; 152
    10e2:	70 e0       	ldi	r23, 0x00	; 0
    10e4:	ce 01       	movw	r24, r28
    10e6:	01 96       	adiw	r24, 0x01	; 1
    10e8:	60 d2       	rcall	.+1216   	; 0x15aa <_ZN11SPISettingsC1Emhh>
    10ea:	be 01       	movw	r22, r28
    10ec:	6f 5f       	subi	r22, 0xFF	; 255
    10ee:	7f 4f       	sbci	r23, 0xFF	; 255
    10f0:	8c e8       	ldi	r24, 0x8C	; 140
    10f2:	94 e0       	ldi	r25, 0x04	; 4
    10f4:	7e d2       	rcall	.+1276   	; 0x15f2 <_ZN8SPIClass16beginTransactionE11SPISettings>
    10f6:	0b e0       	ldi	r16, 0x0B	; 11
    10f8:	11 e0       	ldi	r17, 0x01	; 1
    10fa:	f8 01       	movw	r30, r16
    10fc:	80 81       	ld	r24, Z
    10fe:	8b 7f       	andi	r24, 0xFB	; 251
    1100:	80 83       	st	Z, r24
    1102:	60 ea       	ldi	r22, 0xA0	; 160
    1104:	8c e8       	ldi	r24, 0x8C	; 140
    1106:	94 e0       	ldi	r25, 0x04	; 4
    1108:	7a d2       	rcall	.+1268   	; 0x15fe <_ZN8SPIClass8transferEh>
    110a:	60 e0       	ldi	r22, 0x00	; 0
    110c:	8c e8       	ldi	r24, 0x8C	; 140
    110e:	94 e0       	ldi	r25, 0x04	; 4
    1110:	76 d2       	rcall	.+1260   	; 0x15fe <_ZN8SPIClass8transferEh>
    1112:	f8 01       	movw	r30, r16
    1114:	90 81       	ld	r25, Z
    1116:	94 60       	ori	r25, 0x04	; 4
    1118:	90 83       	st	Z, r25
    111a:	0f 90       	pop	r0
    111c:	0f 90       	pop	r0
    111e:	df 91       	pop	r29
    1120:	cf 91       	pop	r28
    1122:	1f 91       	pop	r17
    1124:	0f 91       	pop	r16
    1126:	08 95       	ret

00001128 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>:
    1128:	0f 93       	push	r16
    112a:	1f 93       	push	r17
    112c:	cf 93       	push	r28
    112e:	8c 01       	movw	r16, r24
    1130:	c6 2f       	mov	r28, r22
    1132:	26 2f       	mov	r18, r22
    1134:	40 ee       	ldi	r20, 0xE0	; 224
    1136:	6f e0       	ldi	r22, 0x0F	; 15
    1138:	86 df       	rcall	.-244    	; 0x1046 <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    113a:	6f e0       	ldi	r22, 0x0F	; 15
    113c:	c8 01       	movw	r24, r16
    113e:	73 de       	rcall	.-794    	; 0xe26 <_ZN7MCP_CAN20mcp2515_readRegisterEh>
    1140:	98 2f       	mov	r25, r24
    1142:	90 7e       	andi	r25, 0xE0	; 224
    1144:	81 e0       	ldi	r24, 0x01	; 1
    1146:	9c 13       	cpse	r25, r28
    1148:	01 c0       	rjmp	.+2      	; 0x114c <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh+0x24>
    114a:	80 e0       	ldi	r24, 0x00	; 0
    114c:	cf 91       	pop	r28
    114e:	1f 91       	pop	r17
    1150:	0f 91       	pop	r16
    1152:	08 95       	ret

00001154 <_ZN7MCP_CAN7setModeEh>:
    1154:	fc 01       	movw	r30, r24
    1156:	61 8b       	std	Z+17, r22	; 0x11
    1158:	e7 cf       	rjmp	.-50     	; 0x1128 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>
    115a:	08 95       	ret

0000115c <_ZN7MCP_CAN18mcp2515_configRateEhh>:
    115c:	cf 93       	push	r28
    115e:	df 93       	push	r29
    1160:	ec 01       	movw	r28, r24
    1162:	40 e4       	ldi	r20, 0x40	; 64
    1164:	6a e2       	ldi	r22, 0x2A	; 42
    1166:	e6 de       	rcall	.-564    	; 0xf34 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1168:	45 ee       	ldi	r20, 0xE5	; 229
    116a:	69 e2       	ldi	r22, 0x29	; 41
    116c:	ce 01       	movw	r24, r28
    116e:	e2 de       	rcall	.-572    	; 0xf34 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1170:	43 e8       	ldi	r20, 0x83	; 131
    1172:	68 e2       	ldi	r22, 0x28	; 40
    1174:	ce 01       	movw	r24, r28
    1176:	de de       	rcall	.-580    	; 0xf34 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1178:	80 e0       	ldi	r24, 0x00	; 0
    117a:	df 91       	pop	r29
    117c:	cf 91       	pop	r28
    117e:	08 95       	ret

00001180 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>:

/*********************************************************************************************************
** Function name:           mcp2515_write_mf
** Descriptions:            Write Masks and Filters
*********************************************************************************************************/
void MCP_CAN::mcp2515_write_mf( const uint8_t mcp_addr, const uint8_t ext, const uint32_t id ){
    1180:	0f 93       	push	r16
    1182:	1f 93       	push	r17
    1184:	cf 93       	push	r28
    1186:	df 93       	push	r29
    1188:	00 d0       	rcall	.+0      	; 0x118a <_ZN7MCP_CAN16mcp2515_write_mfEhhm+0xa>
    118a:	1f 92       	push	r1
    118c:	cd b7       	in	r28, 0x3d	; 61
    118e:	de b7       	in	r29, 0x3e	; 62
	uint16_t canid;
	uint8_t tbufdata[4];
	canid = (uint16_t)(id & 0x0FFFF);
	if ( ext == 1){
    1190:	41 30       	cpi	r20, 0x01	; 1
    1192:	c9 f4       	brne	.+50     	; 0x11c6 <_ZN7MCP_CAN16mcp2515_write_mfEhhm+0x46>
		tbufdata[MCP_EID0] = (uint8_t) (canid & 0xFF);
    1194:	0c 83       	std	Y+4, r16	; 0x04
		tbufdata[MCP_EID8] = (uint8_t) (canid >> 8);
    1196:	1b 83       	std	Y+3, r17	; 0x03
		canid = (uint16_t)(id >> 16);
    1198:	89 01       	movw	r16, r18
    119a:	22 27       	eor	r18, r18
    119c:	33 27       	eor	r19, r19
		tbufdata[MCP_SIDL] = (uint8_t) (canid & 0x03);
		tbufdata[MCP_SIDL] += (uint8_t) ((canid & 0x1C) << 3);
		tbufdata[MCP_SIDL] |= MCP_TXB_EXIDE_M;
    119e:	40 2f       	mov	r20, r16
    11a0:	4c 71       	andi	r20, 0x1C	; 28
    11a2:	44 0f       	add	r20, r20
    11a4:	44 0f       	add	r20, r20
    11a6:	44 0f       	add	r20, r20
    11a8:	50 2f       	mov	r21, r16
    11aa:	53 70       	andi	r21, 0x03	; 3
    11ac:	45 0f       	add	r20, r21
    11ae:	48 60       	ori	r20, 0x08	; 8
    11b0:	4a 83       	std	Y+2, r20	; 0x02
		tbufdata[MCP_SIDH] = (uint8_t) (canid >> 5 );
    11b2:	16 95       	lsr	r17
    11b4:	07 95       	ror	r16
    11b6:	12 95       	swap	r17
    11b8:	02 95       	swap	r16
    11ba:	0f 70       	andi	r16, 0x0F	; 15
    11bc:	01 27       	eor	r16, r17
    11be:	1f 70       	andi	r17, 0x0F	; 15
    11c0:	01 27       	eor	r16, r17
    11c2:	09 83       	std	Y+1, r16	; 0x01
    11c4:	11 c0       	rjmp	.+34     	; 0x11e8 <_ZN7MCP_CAN16mcp2515_write_mfEhhm+0x68>
	} else {
		tbufdata[MCP_EID0] = (uint8_t) (canid & 0xFF);
    11c6:	0c 83       	std	Y+4, r16	; 0x04
		tbufdata[MCP_EID8] = (uint8_t) (canid >> 8);
    11c8:	1b 83       	std	Y+3, r17	; 0x03
		canid = (uint16_t)(id >> 16);
    11ca:	89 01       	movw	r16, r18
    11cc:	22 27       	eor	r18, r18
    11ce:	33 27       	eor	r19, r19
		tbufdata[MCP_SIDL] = (uint8_t) ((canid & 0x07) << 5);
    11d0:	40 2f       	mov	r20, r16
    11d2:	42 95       	swap	r20
    11d4:	44 0f       	add	r20, r20
    11d6:	40 7e       	andi	r20, 0xE0	; 224
    11d8:	4a 83       	std	Y+2, r20	; 0x02
		tbufdata[MCP_SIDH] = (uint8_t) (canid >> 3 );
    11da:	16 95       	lsr	r17
    11dc:	07 95       	ror	r16
    11de:	16 95       	lsr	r17
    11e0:	07 95       	ror	r16
    11e2:	16 95       	lsr	r17
    11e4:	07 95       	ror	r16
    11e6:	09 83       	std	Y+1, r16	; 0x01
	}
	mcp2515_setRegisterS( mcp_addr, tbufdata, 4 );
    11e8:	24 e0       	ldi	r18, 0x04	; 4
    11ea:	ae 01       	movw	r20, r28
    11ec:	4f 5f       	subi	r20, 0xFF	; 255
    11ee:	5f 4f       	sbci	r21, 0xFF	; 255
    11f0:	db de       	rcall	.-586    	; 0xfa8 <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh>
}
    11f2:	0f 90       	pop	r0
    11f4:	0f 90       	pop	r0
    11f6:	0f 90       	pop	r0
    11f8:	0f 90       	pop	r0
    11fa:	df 91       	pop	r29
    11fc:	cf 91       	pop	r28
    11fe:	1f 91       	pop	r17
    1200:	0f 91       	pop	r16
    1202:	08 95       	ret

00001204 <_ZN7MCP_CAN22mcp2515_initCANBuffersEv>:

/*********************************************************************************************************
** Function name:           mcp2515_initCANBuffers
** Descriptions:            Initialize Buffers, Masks, and Filters
*********************************************************************************************************/
void MCP_CAN::mcp2515_initCANBuffers(void){
    1204:	ef 92       	push	r14
    1206:	ff 92       	push	r15
    1208:	0f 93       	push	r16
    120a:	1f 93       	push	r17
    120c:	cf 93       	push	r28
    120e:	7c 01       	movw	r14, r24
	uint8_t std = 0;
	uint8_t ext = 1;
	uint32_t ulMask = 0x00, ulFilt = 0x00;


	mcp2515_write_mf(MCP_RXM0SIDH, ext, ulMask);			/*Set both masks to 0           */
    1210:	00 e0       	ldi	r16, 0x00	; 0
    1212:	10 e0       	ldi	r17, 0x00	; 0
    1214:	98 01       	movw	r18, r16
    1216:	41 e0       	ldi	r20, 0x01	; 1
    1218:	60 e2       	ldi	r22, 0x20	; 32
    121a:	b2 df       	rcall	.-156    	; 0x1180 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXM1SIDH, ext, ulMask);			/*Mask register ignores ext bit */
    121c:	00 e0       	ldi	r16, 0x00	; 0
    121e:	10 e0       	ldi	r17, 0x00	; 0
    1220:	98 01       	movw	r18, r16
    1222:	41 e0       	ldi	r20, 0x01	; 1
    1224:	64 e2       	ldi	r22, 0x24	; 36
    1226:	c7 01       	movw	r24, r14
    1228:	ab df       	rcall	.-170    	; 0x1180 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	
	/* Set all filters to 0         */
	mcp2515_write_mf(MCP_RXF0SIDH, ext, ulFilt);			/* RXB0: extended               */
    122a:	00 e0       	ldi	r16, 0x00	; 0
    122c:	10 e0       	ldi	r17, 0x00	; 0
    122e:	98 01       	movw	r18, r16
    1230:	41 e0       	ldi	r20, 0x01	; 1
    1232:	60 e0       	ldi	r22, 0x00	; 0
    1234:	c7 01       	movw	r24, r14
    1236:	a4 df       	rcall	.-184    	; 0x1180 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF1SIDH, std, ulFilt);			/* RXB1: standard               */
    1238:	00 e0       	ldi	r16, 0x00	; 0
    123a:	10 e0       	ldi	r17, 0x00	; 0
    123c:	98 01       	movw	r18, r16
    123e:	40 e0       	ldi	r20, 0x00	; 0
    1240:	64 e0       	ldi	r22, 0x04	; 4
    1242:	c7 01       	movw	r24, r14
    1244:	9d df       	rcall	.-198    	; 0x1180 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF2SIDH, ext, ulFilt);			/* RXB2: extended               */
    1246:	00 e0       	ldi	r16, 0x00	; 0
    1248:	10 e0       	ldi	r17, 0x00	; 0
    124a:	98 01       	movw	r18, r16
    124c:	41 e0       	ldi	r20, 0x01	; 1
    124e:	68 e0       	ldi	r22, 0x08	; 8
    1250:	c7 01       	movw	r24, r14
    1252:	96 df       	rcall	.-212    	; 0x1180 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF3SIDH, std, ulFilt);			/* RXB3: standard               */
    1254:	00 e0       	ldi	r16, 0x00	; 0
    1256:	10 e0       	ldi	r17, 0x00	; 0
    1258:	98 01       	movw	r18, r16
    125a:	40 e0       	ldi	r20, 0x00	; 0
    125c:	60 e1       	ldi	r22, 0x10	; 16
    125e:	c7 01       	movw	r24, r14
    1260:	8f df       	rcall	.-226    	; 0x1180 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF4SIDH, ext, ulFilt);
    1262:	00 e0       	ldi	r16, 0x00	; 0
    1264:	10 e0       	ldi	r17, 0x00	; 0
    1266:	98 01       	movw	r18, r16
    1268:	41 e0       	ldi	r20, 0x01	; 1
    126a:	64 e1       	ldi	r22, 0x14	; 20
    126c:	c7 01       	movw	r24, r14
    126e:	88 df       	rcall	.-240    	; 0x1180 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF5SIDH, std, ulFilt);
    1270:	00 e0       	ldi	r16, 0x00	; 0
    1272:	10 e0       	ldi	r17, 0x00	; 0
    1274:	98 01       	movw	r18, r16
    1276:	40 e0       	ldi	r20, 0x00	; 0
    1278:	68 e1       	ldi	r22, 0x18	; 24
    127a:	c7 01       	movw	r24, r14
    127c:	81 df       	rcall	.-254    	; 0x1180 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>

	/* Clear, deactivate the three  */
	/* transmit buffers             */
	/* TXBnCTRL -> TXBnD7           */
	a1 = MCP_TXB0CTRL;
    127e:	c0 e3       	ldi	r28, 0x30	; 48
	a2 = MCP_TXB1CTRL;
	a3 = MCP_TXB2CTRL;
	for (i = 0; i < 14; i++) {                                          /* in-buffer loop               */
		mcp2515_setRegister(a1, 0);
    1280:	40 e0       	ldi	r20, 0x00	; 0
    1282:	6c 2f       	mov	r22, r28
    1284:	c7 01       	movw	r24, r14
    1286:	56 de       	rcall	.-852    	; 0xf34 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		mcp2515_setRegister(a2, 0);
    1288:	60 e1       	ldi	r22, 0x10	; 16
    128a:	6c 0f       	add	r22, r28
    128c:	40 e0       	ldi	r20, 0x00	; 0
    128e:	c7 01       	movw	r24, r14
    1290:	51 de       	rcall	.-862    	; 0xf34 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		mcp2515_setRegister(a3, 0);
    1292:	60 e2       	ldi	r22, 0x20	; 32
    1294:	6c 0f       	add	r22, r28
    1296:	40 e0       	ldi	r20, 0x00	; 0
    1298:	c7 01       	movw	r24, r14
    129a:	4c de       	rcall	.-872    	; 0xf34 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		a1++;
    129c:	cf 5f       	subi	r28, 0xFF	; 255
	/* transmit buffers             */
	/* TXBnCTRL -> TXBnD7           */
	a1 = MCP_TXB0CTRL;
	a2 = MCP_TXB1CTRL;
	a3 = MCP_TXB2CTRL;
	for (i = 0; i < 14; i++) {                                          /* in-buffer loop               */
    129e:	ce 33       	cpi	r28, 0x3E	; 62
    12a0:	79 f7       	brne	.-34     	; 0x1280 <_ZN7MCP_CAN22mcp2515_initCANBuffersEv+0x7c>
		mcp2515_setRegister(a3, 0);
		a1++;
		a2++;
		a3++;
	}
	mcp2515_setRegister(MCP_RXB0CTRL, 0);
    12a2:	40 e0       	ldi	r20, 0x00	; 0
    12a4:	60 e6       	ldi	r22, 0x60	; 96
    12a6:	c7 01       	movw	r24, r14
    12a8:	45 de       	rcall	.-886    	; 0xf34 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    12aa:	40 e0       	ldi	r20, 0x00	; 0
	mcp2515_setRegister(MCP_RXB1CTRL, 0);
    12ac:	60 e7       	ldi	r22, 0x70	; 112
    12ae:	c7 01       	movw	r24, r14
    12b0:	41 de       	rcall	.-894    	; 0xf34 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    12b2:	cf 91       	pop	r28
    12b4:	1f 91       	pop	r17
}
    12b6:	0f 91       	pop	r16
    12b8:	ff 90       	pop	r15
    12ba:	ef 90       	pop	r14
    12bc:	08 95       	ret

000012be <_ZN7MCP_CAN12mcp2515_initEhhh>:
    12be:	ff 92       	push	r15
    12c0:	0f 93       	push	r16

/*********************************************************************************************************
** Function name:           mcp2515_init
** Descriptions:            Initialize the controller
*********************************************************************************************************/
uint8_t MCP_CAN::mcp2515_init(const uint8_t canIDMode, const uint8_t canSpeed, const uint8_t canClock){
    12c2:	1f 93       	push	r17
    12c4:	cf 93       	push	r28
    12c6:	df 93       	push	r29
    12c8:	ec 01       	movw	r28, r24
    12ca:	f6 2e       	mov	r15, r22
    12cc:	14 2f       	mov	r17, r20
    12ce:	02 2f       	mov	r16, r18
	uint8_t res;
	mcp2515_reset();
    12d0:	78 dd       	rcall	.-1296   	; 0xdc2 <_ZN7MCP_CAN13mcp2515_resetEv>
	mcpMode = MCP_LOOPBACK;
    12d2:	80 e4       	ldi	r24, 0x40	; 64
    12d4:	89 8b       	std	Y+17, r24	; 0x11
	res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
    12d6:	60 e8       	ldi	r22, 0x80	; 128
    12d8:	ce 01       	movw	r24, r28
    12da:	26 df       	rcall	.-436    	; 0x1128 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>
	if(res > 0)
    12dc:	81 11       	cpse	r24, r1
    12de:	35 c0       	rjmp	.+106    	; 0x134a <_ZN7MCP_CAN12mcp2515_initEhhh+0x8c>
	return res;
	// Set Baudrate
	if(mcp2515_configRate(canSpeed, canClock))
    12e0:	40 2f       	mov	r20, r16
    12e2:	61 2f       	mov	r22, r17
    12e4:	ce 01       	movw	r24, r28
    12e6:	3a df       	rcall	.-396    	; 0x115c <_ZN7MCP_CAN18mcp2515_configRateEhh>
    12e8:	81 11       	cpse	r24, r1
	return res;
	if ( res == MCP2515_OK ) {
		mcp2515_initCANBuffers();											//init canbuffers
    12ea:	2c c0       	rjmp	.+88     	; 0x1344 <_ZN7MCP_CAN12mcp2515_initEhhh+0x86>
    12ec:	ce 01       	movw	r24, r28
		mcp2515_setRegister(MCP_CANINTE, MCP_RX0IF | MCP_RX1IF);			//interrupt mode
    12ee:	8a df       	rcall	.-236    	; 0x1204 <_ZN7MCP_CAN22mcp2515_initCANBuffersEv>
    12f0:	43 e0       	ldi	r20, 0x03	; 3
    12f2:	6b e2       	ldi	r22, 0x2B	; 43
    12f4:	ce 01       	movw	r24, r28
		mcp2515_setRegister(MCP_BFPCTRL,MCP_BxBFS_MASK | MCP_BxBFE_MASK);	//Sets BF pins as GPO
    12f6:	1e de       	rcall	.-964    	; 0xf34 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    12f8:	4c e3       	ldi	r20, 0x3C	; 60
    12fa:	6c e0       	ldi	r22, 0x0C	; 12
    12fc:	ce 01       	movw	r24, r28
		mcp2515_setRegister(MCP_TXRTSCTRL,0x00);							//Sets RTS pins as GPI
    12fe:	1a de       	rcall	.-972    	; 0xf34 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1300:	40 e0       	ldi	r20, 0x00	; 0
    1302:	6d e0       	ldi	r22, 0x0D	; 13
    1304:	ce 01       	movw	r24, r28
    1306:	16 de       	rcall	.-980    	; 0xf34 <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		switch(canIDMode){
    1308:	ff 20       	and	r15, r15
    130a:	71 f0       	breq	.+28     	; 0x1328 <_ZN7MCP_CAN12mcp2515_initEhhh+0x6a>
    130c:	83 e0       	ldi	r24, 0x03	; 3
    130e:	f8 12       	cpse	r15, r24
			case (MCP_ANY):
			mcp2515_modifyRegister(MCP_RXB0CTRL,
			MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
			MCP_RXB_RX_ANY | MCP_RXB_BUKT_MASK);
    1310:	1b c0       	rjmp	.+54     	; 0x1348 <_ZN7MCP_CAN12mcp2515_initEhhh+0x8a>
    1312:	24 e6       	ldi	r18, 0x64	; 100
    1314:	44 e6       	ldi	r20, 0x64	; 100
    1316:	60 e6       	ldi	r22, 0x60	; 96
    1318:	ce 01       	movw	r24, r28
			mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
			MCP_RXB_RX_ANY);
    131a:	95 de       	rcall	.-726    	; 0x1046 <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    131c:	20 e6       	ldi	r18, 0x60	; 96
    131e:	40 e6       	ldi	r20, 0x60	; 96
    1320:	60 e7       	ldi	r22, 0x70	; 112
    1322:	ce 01       	movw	r24, r28
			break;
    1324:	90 de       	rcall	.-736    	; 0x1046 <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
			case (MCP_STDEXT):
			mcp2515_modifyRegister(MCP_RXB0CTRL,
			MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
			MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK );
    1326:	0a c0       	rjmp	.+20     	; 0x133c <_ZN7MCP_CAN12mcp2515_initEhhh+0x7e>
    1328:	24 e0       	ldi	r18, 0x04	; 4
    132a:	44 e6       	ldi	r20, 0x64	; 100
    132c:	60 e6       	ldi	r22, 0x60	; 96
			mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
			MCP_RXB_RX_STDEXT);
    132e:	ce 01       	movw	r24, r28
    1330:	8a de       	rcall	.-748    	; 0x1046 <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    1332:	20 e0       	ldi	r18, 0x00	; 0
    1334:	40 e6       	ldi	r20, 0x60	; 96
    1336:	60 e7       	ldi	r22, 0x70	; 112
    1338:	ce 01       	movw	r24, r28
			break;
			default:
			return MCP2515_FAIL;
			break;
		}
		res = mcp2515_setCANCTRL_Mode(mcpMode);
    133a:	85 de       	rcall	.-758    	; 0x1046 <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    133c:	69 89       	ldd	r22, Y+17	; 0x11
    133e:	ce 01       	movw	r24, r28
    1340:	f3 de       	rcall	.-538    	; 0x1128 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>
    1342:	03 c0       	rjmp	.+6      	; 0x134a <_ZN7MCP_CAN12mcp2515_initEhhh+0x8c>
	res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
	if(res > 0)
	return res;
	// Set Baudrate
	if(mcp2515_configRate(canSpeed, canClock))
	return res;
    1344:	80 e0       	ldi	r24, 0x00	; 0
    1346:	01 c0       	rjmp	.+2      	; 0x134a <_ZN7MCP_CAN12mcp2515_initEhhh+0x8c>
			MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK );
			mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
			MCP_RXB_RX_STDEXT);
			break;
			default:
			return MCP2515_FAIL;
    1348:	81 e0       	ldi	r24, 0x01	; 1
		res = mcp2515_setCANCTRL_Mode(mcpMode);
		if(res)
		return res;
	}
	return res;
}
    134a:	df 91       	pop	r29
    134c:	cf 91       	pop	r28
    134e:	1f 91       	pop	r17
    1350:	0f 91       	pop	r16
    1352:	ff 90       	pop	r15
    1354:	08 95       	ret

00001356 <_ZN7MCP_CAN15mcp2515_read_idEhPhPm>:

/*********************************************************************************************************
** Function name:           mcp2515_read_id
** Descriptions:            Read CAN ID
*********************************************************************************************************/
void MCP_CAN::mcp2515_read_id( const uint8_t mcp_addr, uint8_t* ext, uint32_t* id ){
    1356:	ef 92       	push	r14
    1358:	ff 92       	push	r15
    135a:	0f 93       	push	r16
    135c:	1f 93       	push	r17
    135e:	cf 93       	push	r28
    1360:	df 93       	push	r29
    1362:	00 d0       	rcall	.+0      	; 0x1364 <_ZN7MCP_CAN15mcp2515_read_idEhPhPm+0xe>
    1364:	1f 92       	push	r1
    1366:	cd b7       	in	r28, 0x3d	; 61
    1368:	de b7       	in	r29, 0x3e	; 62
    136a:	7a 01       	movw	r14, r20
    136c:	89 01       	movw	r16, r18
	uint8_t tbufdata[4];
	*ext = 0;
    136e:	fa 01       	movw	r30, r20
    1370:	10 82       	st	Z, r1
	*id = 0;
    1372:	f9 01       	movw	r30, r18
    1374:	10 82       	st	Z, r1
    1376:	11 82       	std	Z+1, r1	; 0x01
    1378:	12 82       	std	Z+2, r1	; 0x02
    137a:	13 82       	std	Z+3, r1	; 0x03
	mcp2515_readRegisterS( mcp_addr, tbufdata, 4 );
    137c:	24 e0       	ldi	r18, 0x04	; 4
    137e:	ae 01       	movw	r20, r28
    1380:	4f 5f       	subi	r20, 0xFF	; 255
    1382:	5f 4f       	sbci	r21, 0xFF	; 255
    1384:	87 dd       	rcall	.-1266   	; 0xe94 <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh>
	*id = (tbufdata[MCP_SIDH]<<3) + (tbufdata[MCP_SIDL]>>5);
    1386:	2a 81       	ldd	r18, Y+2	; 0x02
    1388:	39 81       	ldd	r19, Y+1	; 0x01
    138a:	82 2f       	mov	r24, r18
    138c:	90 e0       	ldi	r25, 0x00	; 0
    138e:	95 95       	asr	r25
    1390:	87 95       	ror	r24
    1392:	95 95       	asr	r25
    1394:	87 95       	ror	r24
    1396:	95 95       	asr	r25
    1398:	87 95       	ror	r24
    139a:	95 95       	asr	r25
    139c:	87 95       	ror	r24
    139e:	95 95       	asr	r25
    13a0:	87 95       	ror	r24
    13a2:	f8 e0       	ldi	r31, 0x08	; 8
    13a4:	3f 9f       	mul	r19, r31
    13a6:	80 0d       	add	r24, r0
    13a8:	91 1d       	adc	r25, r1
    13aa:	11 24       	eor	r1, r1
    13ac:	09 2e       	mov	r0, r25
    13ae:	00 0c       	add	r0, r0
    13b0:	aa 0b       	sbc	r26, r26
    13b2:	bb 0b       	sbc	r27, r27
    13b4:	f8 01       	movw	r30, r16
    13b6:	80 83       	st	Z, r24
    13b8:	91 83       	std	Z+1, r25	; 0x01
    13ba:	a2 83       	std	Z+2, r26	; 0x02
    13bc:	b3 83       	std	Z+3, r27	; 0x03
	if ( (tbufdata[MCP_SIDL] & MCP_TXB_EXIDE_M) ==  MCP_TXB_EXIDE_M ){
    13be:	23 ff       	sbrs	r18, 3
    13c0:	26 c0       	rjmp	.+76     	; 0x140e <_ZN7MCP_CAN15mcp2515_read_idEhPhPm+0xb8>
		/* extended id                  */
		*id = (*id<<2) + (tbufdata[MCP_SIDL] & 0x03);
		*id = (*id<<8) + tbufdata[MCP_EID8];
		*id = (*id<<8) + tbufdata[MCP_EID0];
    13c2:	88 0f       	add	r24, r24
    13c4:	99 1f       	adc	r25, r25
    13c6:	aa 1f       	adc	r26, r26
    13c8:	bb 1f       	adc	r27, r27
    13ca:	88 0f       	add	r24, r24
    13cc:	99 1f       	adc	r25, r25
    13ce:	aa 1f       	adc	r26, r26
    13d0:	bb 1f       	adc	r27, r27
    13d2:	23 70       	andi	r18, 0x03	; 3
    13d4:	82 0f       	add	r24, r18
    13d6:	91 1d       	adc	r25, r1
    13d8:	a1 1d       	adc	r26, r1
    13da:	b1 1d       	adc	r27, r1
    13dc:	ba 2f       	mov	r27, r26
    13de:	a9 2f       	mov	r26, r25
    13e0:	98 2f       	mov	r25, r24
    13e2:	88 27       	eor	r24, r24
    13e4:	2b 81       	ldd	r18, Y+3	; 0x03
    13e6:	82 0f       	add	r24, r18
    13e8:	91 1d       	adc	r25, r1
    13ea:	a1 1d       	adc	r26, r1
    13ec:	b1 1d       	adc	r27, r1
    13ee:	ba 2f       	mov	r27, r26
    13f0:	a9 2f       	mov	r26, r25
    13f2:	98 2f       	mov	r25, r24
    13f4:	88 27       	eor	r24, r24
    13f6:	2c 81       	ldd	r18, Y+4	; 0x04
    13f8:	82 0f       	add	r24, r18
    13fa:	91 1d       	adc	r25, r1
    13fc:	a1 1d       	adc	r26, r1
    13fe:	b1 1d       	adc	r27, r1
    1400:	80 83       	st	Z, r24
    1402:	91 83       	std	Z+1, r25	; 0x01
    1404:	a2 83       	std	Z+2, r26	; 0x02
    1406:	b3 83       	std	Z+3, r27	; 0x03
		*ext = 1;
    1408:	81 e0       	ldi	r24, 0x01	; 1
    140a:	f7 01       	movw	r30, r14
    140c:	80 83       	st	Z, r24
	}
}
    140e:	0f 90       	pop	r0
    1410:	0f 90       	pop	r0
    1412:	0f 90       	pop	r0
    1414:	0f 90       	pop	r0
    1416:	df 91       	pop	r29
    1418:	cf 91       	pop	r28
    141a:	1f 91       	pop	r17
    141c:	0f 91       	pop	r16
    141e:	ff 90       	pop	r15
    1420:	ef 90       	pop	r14
    1422:	08 95       	ret

00001424 <_ZN7MCP_CAN19mcp2515_read_canMsgEh>:

/*********************************************************************************************************
** Function name:           mcp2515_read_canMsg
** Descriptions:            Read message
*********************************************************************************************************/
void MCP_CAN::mcp2515_read_canMsg( const uint8_t buffer_sidh_addr){        /* read can msg                 */
    1424:	0f 93       	push	r16
    1426:	1f 93       	push	r17
    1428:	cf 93       	push	r28
    142a:	df 93       	push	r29
    142c:	ec 01       	movw	r28, r24
    142e:	16 2f       	mov	r17, r22
	uint8_t mcp_addr, ctrl;
	mcp_addr = buffer_sidh_addr;
	mcp2515_read_id( mcp_addr, &m_nExtFlg,&m_nID );
    1430:	9c 01       	movw	r18, r24
    1432:	2f 5f       	subi	r18, 0xFF	; 255
    1434:	3f 4f       	sbci	r19, 0xFF	; 255
    1436:	ac 01       	movw	r20, r24
    1438:	8e df       	rcall	.-228    	; 0x1356 <_ZN7MCP_CAN15mcp2515_read_idEhPhPm>
	ctrl = mcp2515_readRegister( mcp_addr-1 );
    143a:	6f ef       	ldi	r22, 0xFF	; 255
    143c:	61 0f       	add	r22, r17
    143e:	ce 01       	movw	r24, r28
    1440:	f2 dc       	rcall	.-1564   	; 0xe26 <_ZN7MCP_CAN20mcp2515_readRegisterEh>
    1442:	08 2f       	mov	r16, r24
	m_nDlc = mcp2515_readRegister( mcp_addr+4 );
    1444:	64 e0       	ldi	r22, 0x04	; 4
    1446:	61 0f       	add	r22, r17
    1448:	ce 01       	movw	r24, r28
    144a:	ed dc       	rcall	.-1574   	; 0xe26 <_ZN7MCP_CAN20mcp2515_readRegisterEh>
    144c:	8d 83       	std	Y+5, r24	; 0x05
	if (ctrl & 0x08)
    144e:	03 ff       	sbrs	r16, 3
    1450:	03 c0       	rjmp	.+6      	; 0x1458 <_ZN7MCP_CAN19mcp2515_read_canMsgEh+0x34>
		m_nRtr = 1;
    1452:	91 e0       	ldi	r25, 0x01	; 1
    1454:	9e 87       	std	Y+14, r25	; 0x0e
    1456:	01 c0       	rjmp	.+2      	; 0x145a <_ZN7MCP_CAN19mcp2515_read_canMsgEh+0x36>
	else
		m_nRtr = 0;
    1458:	1e 86       	std	Y+14, r1	; 0x0e
	m_nDlc &= MCP_DLC_MASK;
    145a:	28 2f       	mov	r18, r24
    145c:	2f 70       	andi	r18, 0x0F	; 15
    145e:	2d 83       	std	Y+5, r18	; 0x05
	mcp2515_readRegisterS( mcp_addr+5, &(m_nDta[0]), m_nDlc );
    1460:	ae 01       	movw	r20, r28
    1462:	4a 5f       	subi	r20, 0xFA	; 250
    1464:	5f 4f       	sbci	r21, 0xFF	; 255
    1466:	65 e0       	ldi	r22, 0x05	; 5
    1468:	61 0f       	add	r22, r17
    146a:	ce 01       	movw	r24, r28
    146c:	13 dd       	rcall	.-1498   	; 0xe94 <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh>
}
    146e:	df 91       	pop	r29
    1470:	cf 91       	pop	r28
    1472:	1f 91       	pop	r17
    1474:	0f 91       	pop	r16
    1476:	08 95       	ret

00001478 <_ZN7MCP_CANC1Eh>:
** Function name:           MCP_CAN
** Descriptions:            Public function to declare CAN class and the /CS pin.
*********************************************************************************************************/
MCP_CAN::MCP_CAN(uint8_t _CS)
{
	MCPCS = _CS;
    1478:	fc 01       	movw	r30, r24
    147a:	60 8b       	std	Z+16, r22	; 0x10
	MCP2515_UNSELECT();
    147c:	eb e0       	ldi	r30, 0x0B	; 11
    147e:	f1 e0       	ldi	r31, 0x01	; 1
    1480:	80 81       	ld	r24, Z
    1482:	84 60       	ori	r24, 0x04	; 4
    1484:	80 83       	st	Z, r24
	DDRL |= (1 << PL2);		//????
    1486:	ea e0       	ldi	r30, 0x0A	; 10
    1488:	f1 e0       	ldi	r31, 0x01	; 1
    148a:	80 81       	ld	r24, Z
    148c:	84 60       	ori	r24, 0x04	; 4
    148e:	80 83       	st	Z, r24
    1490:	08 95       	ret

00001492 <_ZN7MCP_CAN5beginEhhh>:
/*********************************************************************************************************
** Function name:           begin
** Descriptions:            Public function to declare controller initialization parameters.
*********************************************************************************************************/
uint8_t MCP_CAN::begin(uint8_t idmodeset, uint8_t speedset, uint8_t clockset)
{
    1492:	ff 92       	push	r15
    1494:	0f 93       	push	r16
    1496:	1f 93       	push	r17
    1498:	cf 93       	push	r28
    149a:	df 93       	push	r29
    149c:	ec 01       	movw	r28, r24
    149e:	16 2f       	mov	r17, r22
    14a0:	04 2f       	mov	r16, r20
    14a2:	f2 2e       	mov	r15, r18
	uint8_t res;

	SPI.begin();
    14a4:	90 d0       	rcall	.+288    	; 0x15c6 <_ZN8SPIClass5beginEv>
	res = mcp2515_init(idmodeset, speedset, clockset);
    14a6:	2f 2d       	mov	r18, r15
    14a8:	40 2f       	mov	r20, r16
    14aa:	61 2f       	mov	r22, r17
    14ac:	ce 01       	movw	r24, r28
    14ae:	07 df       	rcall	.-498    	; 0x12be <_ZN7MCP_CAN12mcp2515_initEhhh>
    14b0:	91 e0       	ldi	r25, 0x01	; 1
    14b2:	81 11       	cpse	r24, r1
    14b4:	01 c0       	rjmp	.+2      	; 0x14b8 <_ZN7MCP_CAN5beginEhhh+0x26>
    14b6:	90 e0       	ldi	r25, 0x00	; 0
	if (res == MCP2515_OK)
	return CAN_OK;
	
	return CAN_FAILINIT;
}
    14b8:	89 2f       	mov	r24, r25
    14ba:	df 91       	pop	r29
    14bc:	cf 91       	pop	r28
    14be:	1f 91       	pop	r17
    14c0:	0f 91       	pop	r16
    14c2:	ff 90       	pop	r15
    14c4:	08 95       	ret

000014c6 <_ZN7MCP_CAN7readMsgEv>:

/*********************************************************************************************************
** Function name:           readMsg
** Descriptions:            Read message
*********************************************************************************************************/
uint8_t MCP_CAN::readMsg(){
    14c6:	cf 93       	push	r28
    14c8:	df 93       	push	r29
    14ca:	ec 01       	movw	r28, r24
	uint8_t stat, res;
	stat = mcp2515_readStatus();
    14cc:	fd dd       	rcall	.-1030   	; 0x10c8 <_ZN7MCP_CAN18mcp2515_readStatusEv>

	if ( stat & MCP_STAT_RX0IF )                                        /* Msg in Buffer 0              */
    14ce:	80 ff       	sbrs	r24, 0
    14d0:	0a c0       	rjmp	.+20     	; 0x14e6 <_ZN7MCP_CAN7readMsgEv+0x20>
	{
		mcp2515_read_canMsg( MCP_RXBUF_0);
    14d2:	61 e6       	ldi	r22, 0x61	; 97
    14d4:	ce 01       	movw	r24, r28
    14d6:	a6 df       	rcall	.-180    	; 0x1424 <_ZN7MCP_CAN19mcp2515_read_canMsgEh>
		mcp2515_modifyRegister(MCP_CANINTF, MCP_RX0IF, 0);
    14d8:	20 e0       	ldi	r18, 0x00	; 0
    14da:	41 e0       	ldi	r20, 0x01	; 1
    14dc:	6c e2       	ldi	r22, 0x2C	; 44
    14de:	ce 01       	movw	r24, r28
    14e0:	b2 dd       	rcall	.-1180   	; 0x1046 <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
		res = CAN_OK;
    14e2:	80 e0       	ldi	r24, 0x00	; 0
    14e4:	0d c0       	rjmp	.+26     	; 0x1500 <_ZN7MCP_CAN7readMsgEv+0x3a>
	}
	else if ( stat & MCP_STAT_RX1IF )                                   /* Msg in Buffer 1              */
    14e6:	81 ff       	sbrs	r24, 1
	{
		mcp2515_read_canMsg( MCP_RXBUF_1);
    14e8:	0a c0       	rjmp	.+20     	; 0x14fe <_ZN7MCP_CAN7readMsgEv+0x38>
    14ea:	61 e7       	ldi	r22, 0x71	; 113
    14ec:	ce 01       	movw	r24, r28
    14ee:	9a df       	rcall	.-204    	; 0x1424 <_ZN7MCP_CAN19mcp2515_read_canMsgEh>
		mcp2515_modifyRegister(MCP_CANINTF, MCP_RX1IF, 0);
    14f0:	20 e0       	ldi	r18, 0x00	; 0
    14f2:	42 e0       	ldi	r20, 0x02	; 2
    14f4:	6c e2       	ldi	r22, 0x2C	; 44
    14f6:	ce 01       	movw	r24, r28
    14f8:	a6 dd       	rcall	.-1204   	; 0x1046 <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
		res = CAN_OK;
    14fa:	80 e0       	ldi	r24, 0x00	; 0
    14fc:	01 c0       	rjmp	.+2      	; 0x1500 <_ZN7MCP_CAN7readMsgEv+0x3a>
	}
	else
	res = CAN_NOMSG;
    14fe:	84 e0       	ldi	r24, 0x04	; 4
	
	return res;
}
    1500:	df 91       	pop	r29
    1502:	cf 91       	pop	r28
    1504:	08 95       	ret

00001506 <_ZN7MCP_CAN10readMsgBufEPmPhS1_>:

/*********************************************************************************************************
** Function name:           readMsgBuf
** Descriptions:            Public function, Reads message from receive buffer.
*********************************************************************************************************/
uint8_t MCP_CAN::readMsgBuf(uint32_t *id, uint8_t *len, uint8_t buf[]){
    1506:	cf 92       	push	r12
    1508:	df 92       	push	r13
    150a:	ef 92       	push	r14
    150c:	ff 92       	push	r15
    150e:	0f 93       	push	r16
    1510:	1f 93       	push	r17
    1512:	cf 93       	push	r28
    1514:	df 93       	push	r29
    1516:	ec 01       	movw	r28, r24
    1518:	7b 01       	movw	r14, r22
    151a:	8a 01       	movw	r16, r20
    151c:	c2 2e       	mov	r12, r18
    151e:	d3 2e       	mov	r13, r19
	if(readMsg() == CAN_NOMSG)
    1520:	d2 df       	rcall	.-92     	; 0x14c6 <_ZN7MCP_CAN7readMsgEv>
    1522:	84 30       	cpi	r24, 0x04	; 4
    1524:	c9 f1       	breq	.+114    	; 0x1598 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x92>
	return CAN_NOMSG;

	if (m_nExtFlg)
    1526:	88 81       	ld	r24, Y
    1528:	88 23       	and	r24, r24
    152a:	49 f0       	breq	.+18     	; 0x153e <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x38>
	m_nID |= 0x80000000;
    152c:	89 81       	ldd	r24, Y+1	; 0x01
    152e:	9a 81       	ldd	r25, Y+2	; 0x02
    1530:	ab 81       	ldd	r26, Y+3	; 0x03
    1532:	bc 81       	ldd	r27, Y+4	; 0x04
    1534:	b0 68       	ori	r27, 0x80	; 128
    1536:	89 83       	std	Y+1, r24	; 0x01
    1538:	9a 83       	std	Y+2, r25	; 0x02
    153a:	ab 83       	std	Y+3, r26	; 0x03
    153c:	bc 83       	std	Y+4, r27	; 0x04

	if (m_nRtr)
    153e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1540:	88 23       	and	r24, r24
    1542:	49 f0       	breq	.+18     	; 0x1556 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x50>
	m_nID |= 0x40000000;
    1544:	89 81       	ldd	r24, Y+1	; 0x01
    1546:	9a 81       	ldd	r25, Y+2	; 0x02
    1548:	ab 81       	ldd	r26, Y+3	; 0x03
    154a:	bc 81       	ldd	r27, Y+4	; 0x04
    154c:	b0 64       	ori	r27, 0x40	; 64
    154e:	89 83       	std	Y+1, r24	; 0x01
    1550:	9a 83       	std	Y+2, r25	; 0x02
    1552:	ab 83       	std	Y+3, r26	; 0x03
    1554:	bc 83       	std	Y+4, r27	; 0x04
	*id  = m_nID;
    1556:	89 81       	ldd	r24, Y+1	; 0x01
    1558:	9a 81       	ldd	r25, Y+2	; 0x02
    155a:	ab 81       	ldd	r26, Y+3	; 0x03
    155c:	bc 81       	ldd	r27, Y+4	; 0x04
    155e:	f7 01       	movw	r30, r14
    1560:	80 83       	st	Z, r24
    1562:	91 83       	std	Z+1, r25	; 0x01
    1564:	a2 83       	std	Z+2, r26	; 0x02
    1566:	b3 83       	std	Z+3, r27	; 0x03
	*len = m_nDlc;
    1568:	8d 81       	ldd	r24, Y+5	; 0x05
    156a:	f8 01       	movw	r30, r16
    156c:	80 83       	st	Z, r24
	for(int i = 0; i<m_nDlc; i++)
    156e:	8d 81       	ldd	r24, Y+5	; 0x05
    1570:	88 23       	and	r24, r24
    1572:	89 f0       	breq	.+34     	; 0x1596 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x90>
    1574:	de 01       	movw	r26, r28
    1576:	16 96       	adiw	r26, 0x06	; 6
    1578:	ec 2d       	mov	r30, r12
    157a:	fd 2d       	mov	r31, r13
    157c:	20 e0       	ldi	r18, 0x00	; 0
    157e:	30 e0       	ldi	r19, 0x00	; 0
	buf[i] = m_nDta[i];
    1580:	8d 91       	ld	r24, X+
    1582:	81 93       	st	Z+, r24

	if (m_nRtr)
	m_nID |= 0x40000000;
	*id  = m_nID;
	*len = m_nDlc;
	for(int i = 0; i<m_nDlc; i++)
    1584:	2f 5f       	subi	r18, 0xFF	; 255
    1586:	3f 4f       	sbci	r19, 0xFF	; 255
    1588:	8d 81       	ldd	r24, Y+5	; 0x05
    158a:	90 e0       	ldi	r25, 0x00	; 0
    158c:	28 17       	cp	r18, r24
    158e:	39 07       	cpc	r19, r25
    1590:	bc f3       	brlt	.-18     	; 0x1580 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x7a>
	buf[i] = m_nDta[i];
	return CAN_OK;
    1592:	80 e0       	ldi	r24, 0x00	; 0
    1594:	01 c0       	rjmp	.+2      	; 0x1598 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x92>
    1596:	80 e0       	ldi	r24, 0x00	; 0
}
    1598:	df 91       	pop	r29
    159a:	cf 91       	pop	r28
    159c:	1f 91       	pop	r17
    159e:	0f 91       	pop	r16
    15a0:	ff 90       	pop	r15
    15a2:	ef 90       	pop	r14
    15a4:	df 90       	pop	r13
    15a6:	cf 90       	pop	r12
    15a8:	08 95       	ret

000015aa <_ZN11SPISettingsC1Emhh>:
void SPIClass::end() {
	cli();							// Protect from a scheduler and prevent transactionBegin
	if (initialized)					// Decrease the reference counter
		initialized--;
	if (!initialized)				
		SPCR &= ~(1 << SPE);
    15aa:	0f 93       	push	r16
    15ac:	fc 01       	movw	r30, r24
    15ae:	22 23       	and	r18, r18
    15b0:	11 f0       	breq	.+4      	; 0x15b6 <_ZN11SPISettingsC1Emhh+0xc>
    15b2:	90 e5       	ldi	r25, 0x50	; 80
    15b4:	01 c0       	rjmp	.+2      	; 0x15b8 <_ZN11SPISettingsC1Emhh+0xe>
    15b6:	90 e7       	ldi	r25, 0x70	; 112
    15b8:	0c 70       	andi	r16, 0x0C	; 12
    15ba:	09 2b       	or	r16, r25
    15bc:	00 83       	st	Z, r16
    15be:	81 e0       	ldi	r24, 0x01	; 1
    15c0:	81 83       	std	Z+1, r24	; 0x01
    15c2:	0f 91       	pop	r16
    15c4:	08 95       	ret

000015c6 <_ZN8SPIClass5beginEv>:
    15c6:	f8 94       	cli
    15c8:	80 91 8b 04 	lds	r24, 0x048B	; 0x80048b <_ZN8SPIClass11initializedE>
    15cc:	81 11       	cpse	r24, r1
    15ce:	0b c0       	rjmp	.+22     	; 0x15e6 <_ZN8SPIClass5beginEv+0x20>
    15d0:	58 9a       	sbi	0x0b, 0	; 11
    15d2:	20 9a       	sbi	0x04, 0	; 4
    15d4:	84 b1       	in	r24, 0x04	; 4
    15d6:	86 60       	ori	r24, 0x06	; 6
    15d8:	84 b9       	out	0x04, r24	; 4
    15da:	8c b5       	in	r24, 0x2c	; 44
    15dc:	80 61       	ori	r24, 0x10	; 16
    15de:	8c bd       	out	0x2c, r24	; 44
    15e0:	8c b5       	in	r24, 0x2c	; 44
    15e2:	80 64       	ori	r24, 0x40	; 64
    15e4:	8c bd       	out	0x2c, r24	; 44
    15e6:	80 91 8b 04 	lds	r24, 0x048B	; 0x80048b <_ZN8SPIClass11initializedE>
    15ea:	8f 5f       	subi	r24, 0xFF	; 255
    15ec:	80 93 8b 04 	sts	0x048B, r24	; 0x80048b <_ZN8SPIClass11initializedE>
    15f0:	08 95       	ret

000015f2 <_ZN8SPIClass16beginTransactionE11SPISettings>:
}

void SPIClass::beginTransaction(SPISettings settings) {
	SPCR = settings.spcr;
    15f2:	fb 01       	movw	r30, r22
    15f4:	80 81       	ld	r24, Z
    15f6:	8c bd       	out	0x2c, r24	; 44
	SPSR = settings.spsr;
    15f8:	81 81       	ldd	r24, Z+1	; 0x01
    15fa:	8d bd       	out	0x2d, r24	; 45
    15fc:	08 95       	ret

000015fe <_ZN8SPIClass8transferEh>:
}

uint8_t SPIClass::transfer(uint8_t data) {
SPDR = data;
    15fe:	6e bd       	out	0x2e, r22	; 46
while (!(SPSR & (1 << SPIF))) ; // wait
    1600:	0d b4       	in	r0, 0x2d	; 45
    1602:	07 fe       	sbrs	r0, 7
    1604:	fd cf       	rjmp	.-6      	; 0x1600 <_ZN8SPIClass8transferEh+0x2>
return SPDR;
    1606:	8e b5       	in	r24, 0x2e	; 46
}
    1608:	08 95       	ret

0000160a <_ZN5USARTC1Ev>:
#include "USART.h"

//constructor with setup

USART::USART(){
	UCSR0B = (1 << TXEN0);						// Enable de USART Transmitter
    160a:	88 e0       	ldi	r24, 0x08	; 8
    160c:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);		// 8 data bits, 1 stop bit
    1610:	96 e0       	ldi	r25, 0x06	; 6
    1612:	90 93 c2 00 	sts	0x00C2, r25	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
	UBRR0H=0;									//write the baudrate (76800)
    1616:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
	UBRR0L=8;									// "
    161a:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    161e:	08 95       	ret

00001620 <_ZN5USART5printEPKc>:
}



//write a string in the Serial
void USART::print(const char st[]) {
    1620:	cf 93       	push	r28
    1622:	df 93       	push	r29
	for(uint8_t i = 0 ; st[i] != 0 ; i++) {		//iterate over every char in the string
    1624:	fb 01       	movw	r30, r22
    1626:	90 81       	ld	r25, Z
    1628:	99 23       	and	r25, r25
    162a:	81 f0       	breq	.+32     	; 0x164c <_ZN5USART5printEPKc+0x2c>
    162c:	20 e0       	ldi	r18, 0x00	; 0
		while(~UCSR0A & (1 << UDRE0));			//wait till the transmit buffer is empty
    162e:	e0 ec       	ldi	r30, 0xC0	; 192
    1630:	f0 e0       	ldi	r31, 0x00	; 0
		UDR0 = (int)st[i];						//write the char in the transmit buffer
    1632:	c6 ec       	ldi	r28, 0xC6	; 198
    1634:	d0 e0       	ldi	r29, 0x00	; 0


//write a string in the Serial
void USART::print(const char st[]) {
	for(uint8_t i = 0 ; st[i] != 0 ; i++) {		//iterate over every char in the string
		while(~UCSR0A & (1 << UDRE0));			//wait till the transmit buffer is empty
    1636:	80 81       	ld	r24, Z
    1638:	85 ff       	sbrs	r24, 5
    163a:	fd cf       	rjmp	.-6      	; 0x1636 <_ZN5USART5printEPKc+0x16>
		UDR0 = (int)st[i];						//write the char in the transmit buffer
    163c:	98 83       	st	Y, r25



//write a string in the Serial
void USART::print(const char st[]) {
	for(uint8_t i = 0 ; st[i] != 0 ; i++) {		//iterate over every char in the string
    163e:	2f 5f       	subi	r18, 0xFF	; 255
    1640:	db 01       	movw	r26, r22
    1642:	a2 0f       	add	r26, r18
    1644:	b1 1d       	adc	r27, r1
    1646:	9c 91       	ld	r25, X
    1648:	91 11       	cpse	r25, r1
    164a:	f5 cf       	rjmp	.-22     	; 0x1636 <_ZN5USART5printEPKc+0x16>
		while(~UCSR0A & (1 << UDRE0));			//wait till the transmit buffer is empty
		UDR0 = (int)st[i];						//write the char in the transmit buffer
	}
}
    164c:	df 91       	pop	r29
    164e:	cf 91       	pop	r28
    1650:	08 95       	ret

00001652 <_ZN5USART7printlnEPKc>:

void USART::println(const char st[]){
    1652:	cf 93       	push	r28
    1654:	df 93       	push	r29
    1656:	ec 01       	movw	r28, r24
	this->print(st);
    1658:	e3 df       	rcall	.-58     	; 0x1620 <_ZN5USART5printEPKc>
	this->print("\n\r");
    165a:	60 e3       	ldi	r22, 0x30	; 48
    165c:	74 e0       	ldi	r23, 0x04	; 4
    165e:	ce 01       	movw	r24, r28
    1660:	df df       	rcall	.-66     	; 0x1620 <_ZN5USART5printEPKc>
}
    1662:	df 91       	pop	r29
    1664:	cf 91       	pop	r28
    1666:	08 95       	ret

00001668 <_ZN5USART5printEi>:

//write an integer in the Serial
void USART::print(int i) {
    1668:	0f 93       	push	r16
    166a:	1f 93       	push	r17
    166c:	cf 93       	push	r28
    166e:	df 93       	push	r29
    1670:	cd b7       	in	r28, 0x3d	; 61
    1672:	de b7       	in	r29, 0x3e	; 62
    1674:	60 97       	sbiw	r28, 0x10	; 16
    1676:	0f b6       	in	r0, 0x3f	; 63
    1678:	f8 94       	cli
    167a:	de bf       	out	0x3e, r29	; 62
    167c:	0f be       	out	0x3f, r0	; 63
    167e:	cd bf       	out	0x3d, r28	; 61
    1680:	8c 01       	movw	r16, r24
    1682:	cb 01       	movw	r24, r22
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    1684:	4a e0       	ldi	r20, 0x0A	; 10
    1686:	be 01       	movw	r22, r28
    1688:	6f 5f       	subi	r22, 0xFF	; 255
    168a:	7f 4f       	sbci	r23, 0xFF	; 255
    168c:	a2 d1       	rcall	.+836    	; 0x19d2 <__itoa_ncheck>
	char buffer[16];							//create a string
	itoa(i,buffer,10);							//parse the integer into the string
	print(buffer);						//print the string
    168e:	be 01       	movw	r22, r28
    1690:	6f 5f       	subi	r22, 0xFF	; 255
    1692:	7f 4f       	sbci	r23, 0xFF	; 255
    1694:	c8 01       	movw	r24, r16
    1696:	c4 df       	rcall	.-120    	; 0x1620 <_ZN5USART5printEPKc>
}
    1698:	60 96       	adiw	r28, 0x10	; 16
    169a:	0f b6       	in	r0, 0x3f	; 63
    169c:	f8 94       	cli
    169e:	de bf       	out	0x3e, r29	; 62
    16a0:	0f be       	out	0x3f, r0	; 63
    16a2:	cd bf       	out	0x3d, r28	; 61
    16a4:	df 91       	pop	r29
    16a6:	cf 91       	pop	r28
    16a8:	1f 91       	pop	r17
    16aa:	0f 91       	pop	r16
    16ac:	08 95       	ret

000016ae <_ZN5USART7printlnEi>:

void USART::println(int i){
    16ae:	cf 93       	push	r28
    16b0:	df 93       	push	r29
    16b2:	ec 01       	movw	r28, r24
	this->print(i);
    16b4:	d9 df       	rcall	.-78     	; 0x1668 <_ZN5USART5printEi>
	this->print("\n\r");
    16b6:	60 e3       	ldi	r22, 0x30	; 48
    16b8:	74 e0       	ldi	r23, 0x04	; 4
    16ba:	ce 01       	movw	r24, r28
    16bc:	b1 df       	rcall	.-158    	; 0x1620 <_ZN5USART5printEPKc>
}
    16be:	df 91       	pop	r29
    16c0:	cf 91       	pop	r28
    16c2:	08 95       	ret

000016c4 <__fixsfsi>:
    16c4:	04 d0       	rcall	.+8      	; 0x16ce <__fixunssfsi>
    16c6:	68 94       	set
    16c8:	b1 11       	cpse	r27, r1
    16ca:	8d c0       	rjmp	.+282    	; 0x17e6 <__fp_szero>
    16cc:	08 95       	ret

000016ce <__fixunssfsi>:
    16ce:	70 d0       	rcall	.+224    	; 0x17b0 <__fp_splitA>
    16d0:	88 f0       	brcs	.+34     	; 0x16f4 <__fixunssfsi+0x26>
    16d2:	9f 57       	subi	r25, 0x7F	; 127
    16d4:	90 f0       	brcs	.+36     	; 0x16fa <__fixunssfsi+0x2c>
    16d6:	b9 2f       	mov	r27, r25
    16d8:	99 27       	eor	r25, r25
    16da:	b7 51       	subi	r27, 0x17	; 23
    16dc:	a0 f0       	brcs	.+40     	; 0x1706 <__fixunssfsi+0x38>
    16de:	d1 f0       	breq	.+52     	; 0x1714 <__fixunssfsi+0x46>
    16e0:	66 0f       	add	r22, r22
    16e2:	77 1f       	adc	r23, r23
    16e4:	88 1f       	adc	r24, r24
    16e6:	99 1f       	adc	r25, r25
    16e8:	1a f0       	brmi	.+6      	; 0x16f0 <__fixunssfsi+0x22>
    16ea:	ba 95       	dec	r27
    16ec:	c9 f7       	brne	.-14     	; 0x16e0 <__fixunssfsi+0x12>
    16ee:	12 c0       	rjmp	.+36     	; 0x1714 <__fixunssfsi+0x46>
    16f0:	b1 30       	cpi	r27, 0x01	; 1
    16f2:	81 f0       	breq	.+32     	; 0x1714 <__fixunssfsi+0x46>
    16f4:	77 d0       	rcall	.+238    	; 0x17e4 <__fp_zero>
    16f6:	b1 e0       	ldi	r27, 0x01	; 1
    16f8:	08 95       	ret
    16fa:	74 c0       	rjmp	.+232    	; 0x17e4 <__fp_zero>
    16fc:	67 2f       	mov	r22, r23
    16fe:	78 2f       	mov	r23, r24
    1700:	88 27       	eor	r24, r24
    1702:	b8 5f       	subi	r27, 0xF8	; 248
    1704:	39 f0       	breq	.+14     	; 0x1714 <__fixunssfsi+0x46>
    1706:	b9 3f       	cpi	r27, 0xF9	; 249
    1708:	cc f3       	brlt	.-14     	; 0x16fc <__fixunssfsi+0x2e>
    170a:	86 95       	lsr	r24
    170c:	77 95       	ror	r23
    170e:	67 95       	ror	r22
    1710:	b3 95       	inc	r27
    1712:	d9 f7       	brne	.-10     	; 0x170a <__fixunssfsi+0x3c>
    1714:	3e f4       	brtc	.+14     	; 0x1724 <__fixunssfsi+0x56>
    1716:	90 95       	com	r25
    1718:	80 95       	com	r24
    171a:	70 95       	com	r23
    171c:	61 95       	neg	r22
    171e:	7f 4f       	sbci	r23, 0xFF	; 255
    1720:	8f 4f       	sbci	r24, 0xFF	; 255
    1722:	9f 4f       	sbci	r25, 0xFF	; 255
    1724:	08 95       	ret

00001726 <__floatunsisf>:
    1726:	e8 94       	clt
    1728:	09 c0       	rjmp	.+18     	; 0x173c <__floatsisf+0x12>

0000172a <__floatsisf>:
    172a:	97 fb       	bst	r25, 7
    172c:	3e f4       	brtc	.+14     	; 0x173c <__floatsisf+0x12>
    172e:	90 95       	com	r25
    1730:	80 95       	com	r24
    1732:	70 95       	com	r23
    1734:	61 95       	neg	r22
    1736:	7f 4f       	sbci	r23, 0xFF	; 255
    1738:	8f 4f       	sbci	r24, 0xFF	; 255
    173a:	9f 4f       	sbci	r25, 0xFF	; 255
    173c:	99 23       	and	r25, r25
    173e:	a9 f0       	breq	.+42     	; 0x176a <__floatsisf+0x40>
    1740:	f9 2f       	mov	r31, r25
    1742:	96 e9       	ldi	r25, 0x96	; 150
    1744:	bb 27       	eor	r27, r27
    1746:	93 95       	inc	r25
    1748:	f6 95       	lsr	r31
    174a:	87 95       	ror	r24
    174c:	77 95       	ror	r23
    174e:	67 95       	ror	r22
    1750:	b7 95       	ror	r27
    1752:	f1 11       	cpse	r31, r1
    1754:	f8 cf       	rjmp	.-16     	; 0x1746 <__floatsisf+0x1c>
    1756:	fa f4       	brpl	.+62     	; 0x1796 <__floatsisf+0x6c>
    1758:	bb 0f       	add	r27, r27
    175a:	11 f4       	brne	.+4      	; 0x1760 <__floatsisf+0x36>
    175c:	60 ff       	sbrs	r22, 0
    175e:	1b c0       	rjmp	.+54     	; 0x1796 <__floatsisf+0x6c>
    1760:	6f 5f       	subi	r22, 0xFF	; 255
    1762:	7f 4f       	sbci	r23, 0xFF	; 255
    1764:	8f 4f       	sbci	r24, 0xFF	; 255
    1766:	9f 4f       	sbci	r25, 0xFF	; 255
    1768:	16 c0       	rjmp	.+44     	; 0x1796 <__floatsisf+0x6c>
    176a:	88 23       	and	r24, r24
    176c:	11 f0       	breq	.+4      	; 0x1772 <__floatsisf+0x48>
    176e:	96 e9       	ldi	r25, 0x96	; 150
    1770:	11 c0       	rjmp	.+34     	; 0x1794 <__floatsisf+0x6a>
    1772:	77 23       	and	r23, r23
    1774:	21 f0       	breq	.+8      	; 0x177e <__floatsisf+0x54>
    1776:	9e e8       	ldi	r25, 0x8E	; 142
    1778:	87 2f       	mov	r24, r23
    177a:	76 2f       	mov	r23, r22
    177c:	05 c0       	rjmp	.+10     	; 0x1788 <__floatsisf+0x5e>
    177e:	66 23       	and	r22, r22
    1780:	71 f0       	breq	.+28     	; 0x179e <__floatsisf+0x74>
    1782:	96 e8       	ldi	r25, 0x86	; 134
    1784:	86 2f       	mov	r24, r22
    1786:	70 e0       	ldi	r23, 0x00	; 0
    1788:	60 e0       	ldi	r22, 0x00	; 0
    178a:	2a f0       	brmi	.+10     	; 0x1796 <__floatsisf+0x6c>
    178c:	9a 95       	dec	r25
    178e:	66 0f       	add	r22, r22
    1790:	77 1f       	adc	r23, r23
    1792:	88 1f       	adc	r24, r24
    1794:	da f7       	brpl	.-10     	; 0x178c <__floatsisf+0x62>
    1796:	88 0f       	add	r24, r24
    1798:	96 95       	lsr	r25
    179a:	87 95       	ror	r24
    179c:	97 f9       	bld	r25, 7
    179e:	08 95       	ret

000017a0 <__fp_split3>:
    17a0:	57 fd       	sbrc	r21, 7
    17a2:	90 58       	subi	r25, 0x80	; 128
    17a4:	44 0f       	add	r20, r20
    17a6:	55 1f       	adc	r21, r21
    17a8:	59 f0       	breq	.+22     	; 0x17c0 <__fp_splitA+0x10>
    17aa:	5f 3f       	cpi	r21, 0xFF	; 255
    17ac:	71 f0       	breq	.+28     	; 0x17ca <__fp_splitA+0x1a>
    17ae:	47 95       	ror	r20

000017b0 <__fp_splitA>:
    17b0:	88 0f       	add	r24, r24
    17b2:	97 fb       	bst	r25, 7
    17b4:	99 1f       	adc	r25, r25
    17b6:	61 f0       	breq	.+24     	; 0x17d0 <__fp_splitA+0x20>
    17b8:	9f 3f       	cpi	r25, 0xFF	; 255
    17ba:	79 f0       	breq	.+30     	; 0x17da <__fp_splitA+0x2a>
    17bc:	87 95       	ror	r24
    17be:	08 95       	ret
    17c0:	12 16       	cp	r1, r18
    17c2:	13 06       	cpc	r1, r19
    17c4:	14 06       	cpc	r1, r20
    17c6:	55 1f       	adc	r21, r21
    17c8:	f2 cf       	rjmp	.-28     	; 0x17ae <__fp_split3+0xe>
    17ca:	46 95       	lsr	r20
    17cc:	f1 df       	rcall	.-30     	; 0x17b0 <__fp_splitA>
    17ce:	08 c0       	rjmp	.+16     	; 0x17e0 <__fp_splitA+0x30>
    17d0:	16 16       	cp	r1, r22
    17d2:	17 06       	cpc	r1, r23
    17d4:	18 06       	cpc	r1, r24
    17d6:	99 1f       	adc	r25, r25
    17d8:	f1 cf       	rjmp	.-30     	; 0x17bc <__fp_splitA+0xc>
    17da:	86 95       	lsr	r24
    17dc:	71 05       	cpc	r23, r1
    17de:	61 05       	cpc	r22, r1
    17e0:	08 94       	sec
    17e2:	08 95       	ret

000017e4 <__fp_zero>:
    17e4:	e8 94       	clt

000017e6 <__fp_szero>:
    17e6:	bb 27       	eor	r27, r27
    17e8:	66 27       	eor	r22, r22
    17ea:	77 27       	eor	r23, r23
    17ec:	cb 01       	movw	r24, r22
    17ee:	97 f9       	bld	r25, 7
    17f0:	08 95       	ret

000017f2 <__mulsf3>:
    17f2:	0b d0       	rcall	.+22     	; 0x180a <__mulsf3x>
    17f4:	78 c0       	rjmp	.+240    	; 0x18e6 <__fp_round>
    17f6:	69 d0       	rcall	.+210    	; 0x18ca <__fp_pscA>
    17f8:	28 f0       	brcs	.+10     	; 0x1804 <__mulsf3+0x12>
    17fa:	6e d0       	rcall	.+220    	; 0x18d8 <__fp_pscB>
    17fc:	18 f0       	brcs	.+6      	; 0x1804 <__mulsf3+0x12>
    17fe:	95 23       	and	r25, r21
    1800:	09 f0       	breq	.+2      	; 0x1804 <__mulsf3+0x12>
    1802:	5a c0       	rjmp	.+180    	; 0x18b8 <__fp_inf>
    1804:	5f c0       	rjmp	.+190    	; 0x18c4 <__fp_nan>
    1806:	11 24       	eor	r1, r1
    1808:	ee cf       	rjmp	.-36     	; 0x17e6 <__fp_szero>

0000180a <__mulsf3x>:
    180a:	ca df       	rcall	.-108    	; 0x17a0 <__fp_split3>
    180c:	a0 f3       	brcs	.-24     	; 0x17f6 <__mulsf3+0x4>

0000180e <__mulsf3_pse>:
    180e:	95 9f       	mul	r25, r21
    1810:	d1 f3       	breq	.-12     	; 0x1806 <__mulsf3+0x14>
    1812:	95 0f       	add	r25, r21
    1814:	50 e0       	ldi	r21, 0x00	; 0
    1816:	55 1f       	adc	r21, r21
    1818:	62 9f       	mul	r22, r18
    181a:	f0 01       	movw	r30, r0
    181c:	72 9f       	mul	r23, r18
    181e:	bb 27       	eor	r27, r27
    1820:	f0 0d       	add	r31, r0
    1822:	b1 1d       	adc	r27, r1
    1824:	63 9f       	mul	r22, r19
    1826:	aa 27       	eor	r26, r26
    1828:	f0 0d       	add	r31, r0
    182a:	b1 1d       	adc	r27, r1
    182c:	aa 1f       	adc	r26, r26
    182e:	64 9f       	mul	r22, r20
    1830:	66 27       	eor	r22, r22
    1832:	b0 0d       	add	r27, r0
    1834:	a1 1d       	adc	r26, r1
    1836:	66 1f       	adc	r22, r22
    1838:	82 9f       	mul	r24, r18
    183a:	22 27       	eor	r18, r18
    183c:	b0 0d       	add	r27, r0
    183e:	a1 1d       	adc	r26, r1
    1840:	62 1f       	adc	r22, r18
    1842:	73 9f       	mul	r23, r19
    1844:	b0 0d       	add	r27, r0
    1846:	a1 1d       	adc	r26, r1
    1848:	62 1f       	adc	r22, r18
    184a:	83 9f       	mul	r24, r19
    184c:	a0 0d       	add	r26, r0
    184e:	61 1d       	adc	r22, r1
    1850:	22 1f       	adc	r18, r18
    1852:	74 9f       	mul	r23, r20
    1854:	33 27       	eor	r19, r19
    1856:	a0 0d       	add	r26, r0
    1858:	61 1d       	adc	r22, r1
    185a:	23 1f       	adc	r18, r19
    185c:	84 9f       	mul	r24, r20
    185e:	60 0d       	add	r22, r0
    1860:	21 1d       	adc	r18, r1
    1862:	82 2f       	mov	r24, r18
    1864:	76 2f       	mov	r23, r22
    1866:	6a 2f       	mov	r22, r26
    1868:	11 24       	eor	r1, r1
    186a:	9f 57       	subi	r25, 0x7F	; 127
    186c:	50 40       	sbci	r21, 0x00	; 0
    186e:	8a f0       	brmi	.+34     	; 0x1892 <__mulsf3_pse+0x84>
    1870:	e1 f0       	breq	.+56     	; 0x18aa <__mulsf3_pse+0x9c>
    1872:	88 23       	and	r24, r24
    1874:	4a f0       	brmi	.+18     	; 0x1888 <__mulsf3_pse+0x7a>
    1876:	ee 0f       	add	r30, r30
    1878:	ff 1f       	adc	r31, r31
    187a:	bb 1f       	adc	r27, r27
    187c:	66 1f       	adc	r22, r22
    187e:	77 1f       	adc	r23, r23
    1880:	88 1f       	adc	r24, r24
    1882:	91 50       	subi	r25, 0x01	; 1
    1884:	50 40       	sbci	r21, 0x00	; 0
    1886:	a9 f7       	brne	.-22     	; 0x1872 <__mulsf3_pse+0x64>
    1888:	9e 3f       	cpi	r25, 0xFE	; 254
    188a:	51 05       	cpc	r21, r1
    188c:	70 f0       	brcs	.+28     	; 0x18aa <__mulsf3_pse+0x9c>
    188e:	14 c0       	rjmp	.+40     	; 0x18b8 <__fp_inf>
    1890:	aa cf       	rjmp	.-172    	; 0x17e6 <__fp_szero>
    1892:	5f 3f       	cpi	r21, 0xFF	; 255
    1894:	ec f3       	brlt	.-6      	; 0x1890 <__mulsf3_pse+0x82>
    1896:	98 3e       	cpi	r25, 0xE8	; 232
    1898:	dc f3       	brlt	.-10     	; 0x1890 <__mulsf3_pse+0x82>
    189a:	86 95       	lsr	r24
    189c:	77 95       	ror	r23
    189e:	67 95       	ror	r22
    18a0:	b7 95       	ror	r27
    18a2:	f7 95       	ror	r31
    18a4:	e7 95       	ror	r30
    18a6:	9f 5f       	subi	r25, 0xFF	; 255
    18a8:	c1 f7       	brne	.-16     	; 0x189a <__mulsf3_pse+0x8c>
    18aa:	fe 2b       	or	r31, r30
    18ac:	88 0f       	add	r24, r24
    18ae:	91 1d       	adc	r25, r1
    18b0:	96 95       	lsr	r25
    18b2:	87 95       	ror	r24
    18b4:	97 f9       	bld	r25, 7
    18b6:	08 95       	ret

000018b8 <__fp_inf>:
    18b8:	97 f9       	bld	r25, 7
    18ba:	9f 67       	ori	r25, 0x7F	; 127
    18bc:	80 e8       	ldi	r24, 0x80	; 128
    18be:	70 e0       	ldi	r23, 0x00	; 0
    18c0:	60 e0       	ldi	r22, 0x00	; 0
    18c2:	08 95       	ret

000018c4 <__fp_nan>:
    18c4:	9f ef       	ldi	r25, 0xFF	; 255
    18c6:	80 ec       	ldi	r24, 0xC0	; 192
    18c8:	08 95       	ret

000018ca <__fp_pscA>:
    18ca:	00 24       	eor	r0, r0
    18cc:	0a 94       	dec	r0
    18ce:	16 16       	cp	r1, r22
    18d0:	17 06       	cpc	r1, r23
    18d2:	18 06       	cpc	r1, r24
    18d4:	09 06       	cpc	r0, r25
    18d6:	08 95       	ret

000018d8 <__fp_pscB>:
    18d8:	00 24       	eor	r0, r0
    18da:	0a 94       	dec	r0
    18dc:	12 16       	cp	r1, r18
    18de:	13 06       	cpc	r1, r19
    18e0:	14 06       	cpc	r1, r20
    18e2:	05 06       	cpc	r0, r21
    18e4:	08 95       	ret

000018e6 <__fp_round>:
    18e6:	09 2e       	mov	r0, r25
    18e8:	03 94       	inc	r0
    18ea:	00 0c       	add	r0, r0
    18ec:	11 f4       	brne	.+4      	; 0x18f2 <__fp_round+0xc>
    18ee:	88 23       	and	r24, r24
    18f0:	52 f0       	brmi	.+20     	; 0x1906 <__fp_round+0x20>
    18f2:	bb 0f       	add	r27, r27
    18f4:	40 f4       	brcc	.+16     	; 0x1906 <__fp_round+0x20>
    18f6:	bf 2b       	or	r27, r31
    18f8:	11 f4       	brne	.+4      	; 0x18fe <__fp_round+0x18>
    18fa:	60 ff       	sbrs	r22, 0
    18fc:	04 c0       	rjmp	.+8      	; 0x1906 <__fp_round+0x20>
    18fe:	6f 5f       	subi	r22, 0xFF	; 255
    1900:	7f 4f       	sbci	r23, 0xFF	; 255
    1902:	8f 4f       	sbci	r24, 0xFF	; 255
    1904:	9f 4f       	sbci	r25, 0xFF	; 255
    1906:	08 95       	ret

00001908 <__divmodsi4>:
    1908:	05 2e       	mov	r0, r21
    190a:	97 fb       	bst	r25, 7
    190c:	16 f4       	brtc	.+4      	; 0x1912 <__divmodsi4+0xa>
    190e:	00 94       	com	r0
    1910:	0f d0       	rcall	.+30     	; 0x1930 <__negsi2>
    1912:	57 fd       	sbrc	r21, 7
    1914:	05 d0       	rcall	.+10     	; 0x1920 <__divmodsi4_neg2>
    1916:	2c d0       	rcall	.+88     	; 0x1970 <__udivmodsi4>
    1918:	07 fc       	sbrc	r0, 7
    191a:	02 d0       	rcall	.+4      	; 0x1920 <__divmodsi4_neg2>
    191c:	46 f4       	brtc	.+16     	; 0x192e <__divmodsi4_exit>
    191e:	08 c0       	rjmp	.+16     	; 0x1930 <__negsi2>

00001920 <__divmodsi4_neg2>:
    1920:	50 95       	com	r21
    1922:	40 95       	com	r20
    1924:	30 95       	com	r19
    1926:	21 95       	neg	r18
    1928:	3f 4f       	sbci	r19, 0xFF	; 255
    192a:	4f 4f       	sbci	r20, 0xFF	; 255
    192c:	5f 4f       	sbci	r21, 0xFF	; 255

0000192e <__divmodsi4_exit>:
    192e:	08 95       	ret

00001930 <__negsi2>:
    1930:	90 95       	com	r25
    1932:	80 95       	com	r24
    1934:	70 95       	com	r23
    1936:	61 95       	neg	r22
    1938:	7f 4f       	sbci	r23, 0xFF	; 255
    193a:	8f 4f       	sbci	r24, 0xFF	; 255
    193c:	9f 4f       	sbci	r25, 0xFF	; 255
    193e:	08 95       	ret

00001940 <__tablejump2__>:
    1940:	ee 0f       	add	r30, r30
    1942:	ff 1f       	adc	r31, r31
    1944:	88 1f       	adc	r24, r24
    1946:	8b bf       	out	0x3b, r24	; 59
    1948:	07 90       	elpm	r0, Z+
    194a:	f6 91       	elpm	r31, Z
    194c:	e0 2d       	mov	r30, r0
    194e:	19 94       	eijmp

00001950 <__usmulhisi3>:
    1950:	31 d0       	rcall	.+98     	; 0x19b4 <__umulhisi3>

00001952 <__usmulhisi3_tail>:
    1952:	b7 ff       	sbrs	r27, 7
    1954:	08 95       	ret
    1956:	82 1b       	sub	r24, r18
    1958:	93 0b       	sbc	r25, r19
    195a:	08 95       	ret

0000195c <__muluhisi3>:
    195c:	2b d0       	rcall	.+86     	; 0x19b4 <__umulhisi3>
    195e:	a5 9f       	mul	r26, r21
    1960:	90 0d       	add	r25, r0
    1962:	b4 9f       	mul	r27, r20
    1964:	90 0d       	add	r25, r0
    1966:	a4 9f       	mul	r26, r20
    1968:	80 0d       	add	r24, r0
    196a:	91 1d       	adc	r25, r1
    196c:	11 24       	eor	r1, r1
    196e:	08 95       	ret

00001970 <__udivmodsi4>:
    1970:	a1 e2       	ldi	r26, 0x21	; 33
    1972:	1a 2e       	mov	r1, r26
    1974:	aa 1b       	sub	r26, r26
    1976:	bb 1b       	sub	r27, r27
    1978:	fd 01       	movw	r30, r26
    197a:	0d c0       	rjmp	.+26     	; 0x1996 <__udivmodsi4_ep>

0000197c <__udivmodsi4_loop>:
    197c:	aa 1f       	adc	r26, r26
    197e:	bb 1f       	adc	r27, r27
    1980:	ee 1f       	adc	r30, r30
    1982:	ff 1f       	adc	r31, r31
    1984:	a2 17       	cp	r26, r18
    1986:	b3 07       	cpc	r27, r19
    1988:	e4 07       	cpc	r30, r20
    198a:	f5 07       	cpc	r31, r21
    198c:	20 f0       	brcs	.+8      	; 0x1996 <__udivmodsi4_ep>
    198e:	a2 1b       	sub	r26, r18
    1990:	b3 0b       	sbc	r27, r19
    1992:	e4 0b       	sbc	r30, r20
    1994:	f5 0b       	sbc	r31, r21

00001996 <__udivmodsi4_ep>:
    1996:	66 1f       	adc	r22, r22
    1998:	77 1f       	adc	r23, r23
    199a:	88 1f       	adc	r24, r24
    199c:	99 1f       	adc	r25, r25
    199e:	1a 94       	dec	r1
    19a0:	69 f7       	brne	.-38     	; 0x197c <__udivmodsi4_loop>
    19a2:	60 95       	com	r22
    19a4:	70 95       	com	r23
    19a6:	80 95       	com	r24
    19a8:	90 95       	com	r25
    19aa:	9b 01       	movw	r18, r22
    19ac:	ac 01       	movw	r20, r24
    19ae:	bd 01       	movw	r22, r26
    19b0:	cf 01       	movw	r24, r30
    19b2:	08 95       	ret

000019b4 <__umulhisi3>:
    19b4:	a2 9f       	mul	r26, r18
    19b6:	b0 01       	movw	r22, r0
    19b8:	b3 9f       	mul	r27, r19
    19ba:	c0 01       	movw	r24, r0
    19bc:	a3 9f       	mul	r26, r19
    19be:	70 0d       	add	r23, r0
    19c0:	81 1d       	adc	r24, r1
    19c2:	11 24       	eor	r1, r1
    19c4:	91 1d       	adc	r25, r1
    19c6:	b2 9f       	mul	r27, r18
    19c8:	70 0d       	add	r23, r0
    19ca:	81 1d       	adc	r24, r1
    19cc:	11 24       	eor	r1, r1
    19ce:	91 1d       	adc	r25, r1
    19d0:	08 95       	ret

000019d2 <__itoa_ncheck>:
    19d2:	bb 27       	eor	r27, r27
    19d4:	4a 30       	cpi	r20, 0x0A	; 10
    19d6:	31 f4       	brne	.+12     	; 0x19e4 <__itoa_ncheck+0x12>
    19d8:	99 23       	and	r25, r25
    19da:	22 f4       	brpl	.+8      	; 0x19e4 <__itoa_ncheck+0x12>
    19dc:	bd e2       	ldi	r27, 0x2D	; 45
    19de:	90 95       	com	r25
    19e0:	81 95       	neg	r24
    19e2:	9f 4f       	sbci	r25, 0xFF	; 255
    19e4:	01 c0       	rjmp	.+2      	; 0x19e8 <__utoa_common>

000019e6 <__utoa_ncheck>:
    19e6:	bb 27       	eor	r27, r27

000019e8 <__utoa_common>:
    19e8:	fb 01       	movw	r30, r22
    19ea:	55 27       	eor	r21, r21
    19ec:	aa 27       	eor	r26, r26
    19ee:	88 0f       	add	r24, r24
    19f0:	99 1f       	adc	r25, r25
    19f2:	aa 1f       	adc	r26, r26
    19f4:	a4 17       	cp	r26, r20
    19f6:	10 f0       	brcs	.+4      	; 0x19fc <__utoa_common+0x14>
    19f8:	a4 1b       	sub	r26, r20
    19fa:	83 95       	inc	r24
    19fc:	50 51       	subi	r21, 0x10	; 16
    19fe:	b9 f7       	brne	.-18     	; 0x19ee <__utoa_common+0x6>
    1a00:	a0 5d       	subi	r26, 0xD0	; 208
    1a02:	aa 33       	cpi	r26, 0x3A	; 58
    1a04:	08 f0       	brcs	.+2      	; 0x1a08 <__utoa_common+0x20>
    1a06:	a9 5d       	subi	r26, 0xD9	; 217
    1a08:	a1 93       	st	Z+, r26
    1a0a:	00 97       	sbiw	r24, 0x00	; 0
    1a0c:	79 f7       	brne	.-34     	; 0x19ec <__utoa_common+0x4>
    1a0e:	b1 11       	cpse	r27, r1
    1a10:	b1 93       	st	Z+, r27
    1a12:	11 92       	st	Z+, r1
    1a14:	cb 01       	movw	r24, r22
    1a16:	00 c0       	rjmp	.+0      	; 0x1a18 <strrev>

00001a18 <strrev>:
    1a18:	dc 01       	movw	r26, r24
    1a1a:	fc 01       	movw	r30, r24
    1a1c:	67 2f       	mov	r22, r23
    1a1e:	71 91       	ld	r23, Z+
    1a20:	77 23       	and	r23, r23
    1a22:	e1 f7       	brne	.-8      	; 0x1a1c <strrev+0x4>
    1a24:	32 97       	sbiw	r30, 0x02	; 2
    1a26:	04 c0       	rjmp	.+8      	; 0x1a30 <strrev+0x18>
    1a28:	7c 91       	ld	r23, X
    1a2a:	6d 93       	st	X+, r22
    1a2c:	70 83       	st	Z, r23
    1a2e:	62 91       	ld	r22, -Z
    1a30:	ae 17       	cp	r26, r30
    1a32:	bf 07       	cpc	r27, r31
    1a34:	c8 f3       	brcs	.-14     	; 0x1a28 <strrev+0x10>
    1a36:	08 95       	ret

00001a38 <_exit>:
    1a38:	f8 94       	cli

00001a3a <__stop_program>:
    1a3a:	ff cf       	rjmp	.-2      	; 0x1a3a <__stop_program>
