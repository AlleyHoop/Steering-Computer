
Alley Hoop V2.1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000234  00800200  00001a44  00001ad8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001a44  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000059  00800434  00800434  00001d0c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001d0c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001d3c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000238  00000000  00000000  00001d7c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004645  00000000  00000000  00001fb4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000179d  00000000  00000000  000065f9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001745  00000000  00000000  00007d96  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000670  00000000  00000000  000094dc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001148  00000000  00000000  00009b4c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001ef8  00000000  00000000  0000ac94  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001f0  00000000  00000000  0000cb8c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	7d c0       	rjmp	.+250    	; 0xfc <__ctors_end>
       2:	00 00       	nop
       4:	ab c0       	rjmp	.+342    	; 0x15c <__bad_interrupt>
       6:	00 00       	nop
       8:	a9 c0       	rjmp	.+338    	; 0x15c <__bad_interrupt>
       a:	00 00       	nop
       c:	a7 c0       	rjmp	.+334    	; 0x15c <__bad_interrupt>
       e:	00 00       	nop
      10:	a5 c0       	rjmp	.+330    	; 0x15c <__bad_interrupt>
      12:	00 00       	nop
      14:	a3 c0       	rjmp	.+326    	; 0x15c <__bad_interrupt>
      16:	00 00       	nop
      18:	a1 c0       	rjmp	.+322    	; 0x15c <__bad_interrupt>
      1a:	00 00       	nop
      1c:	9f c0       	rjmp	.+318    	; 0x15c <__bad_interrupt>
      1e:	00 00       	nop
      20:	9d c0       	rjmp	.+314    	; 0x15c <__bad_interrupt>
      22:	00 00       	nop
      24:	9b c0       	rjmp	.+310    	; 0x15c <__bad_interrupt>
      26:	00 00       	nop
      28:	99 c0       	rjmp	.+306    	; 0x15c <__bad_interrupt>
      2a:	00 00       	nop
      2c:	97 c0       	rjmp	.+302    	; 0x15c <__bad_interrupt>
      2e:	00 00       	nop
      30:	95 c0       	rjmp	.+298    	; 0x15c <__bad_interrupt>
      32:	00 00       	nop
      34:	93 c0       	rjmp	.+294    	; 0x15c <__bad_interrupt>
      36:	00 00       	nop
      38:	91 c0       	rjmp	.+290    	; 0x15c <__bad_interrupt>
      3a:	00 00       	nop
      3c:	8f c0       	rjmp	.+286    	; 0x15c <__bad_interrupt>
      3e:	00 00       	nop
      40:	8d c0       	rjmp	.+282    	; 0x15c <__bad_interrupt>
      42:	00 00       	nop
      44:	8b c0       	rjmp	.+278    	; 0x15c <__bad_interrupt>
      46:	00 00       	nop
      48:	89 c0       	rjmp	.+274    	; 0x15c <__bad_interrupt>
      4a:	00 00       	nop
      4c:	87 c0       	rjmp	.+270    	; 0x15c <__bad_interrupt>
      4e:	00 00       	nop
      50:	85 c0       	rjmp	.+266    	; 0x15c <__bad_interrupt>
      52:	00 00       	nop
      54:	83 c0       	rjmp	.+262    	; 0x15c <__bad_interrupt>
      56:	00 00       	nop
      58:	81 c0       	rjmp	.+258    	; 0x15c <__bad_interrupt>
      5a:	00 00       	nop
      5c:	7f c0       	rjmp	.+254    	; 0x15c <__bad_interrupt>
      5e:	00 00       	nop
      60:	7d c0       	rjmp	.+250    	; 0x15c <__bad_interrupt>
      62:	00 00       	nop
      64:	7b c0       	rjmp	.+246    	; 0x15c <__bad_interrupt>
      66:	00 00       	nop
      68:	79 c0       	rjmp	.+242    	; 0x15c <__bad_interrupt>
      6a:	00 00       	nop
      6c:	77 c0       	rjmp	.+238    	; 0x15c <__bad_interrupt>
      6e:	00 00       	nop
      70:	75 c0       	rjmp	.+234    	; 0x15c <__bad_interrupt>
      72:	00 00       	nop
      74:	73 c0       	rjmp	.+230    	; 0x15c <__bad_interrupt>
      76:	00 00       	nop
      78:	71 c0       	rjmp	.+226    	; 0x15c <__bad_interrupt>
      7a:	00 00       	nop
      7c:	6f c0       	rjmp	.+222    	; 0x15c <__bad_interrupt>
      7e:	00 00       	nop
      80:	6d c0       	rjmp	.+218    	; 0x15c <__bad_interrupt>
      82:	00 00       	nop
      84:	6b c0       	rjmp	.+214    	; 0x15c <__bad_interrupt>
      86:	00 00       	nop
      88:	69 c0       	rjmp	.+210    	; 0x15c <__bad_interrupt>
      8a:	00 00       	nop
      8c:	67 c0       	rjmp	.+206    	; 0x15c <__bad_interrupt>
      8e:	00 00       	nop
      90:	65 c0       	rjmp	.+202    	; 0x15c <__bad_interrupt>
      92:	00 00       	nop
      94:	63 c0       	rjmp	.+198    	; 0x15c <__bad_interrupt>
      96:	00 00       	nop
      98:	61 c0       	rjmp	.+194    	; 0x15c <__bad_interrupt>
      9a:	00 00       	nop
      9c:	5f c0       	rjmp	.+190    	; 0x15c <__bad_interrupt>
      9e:	00 00       	nop
      a0:	5d c0       	rjmp	.+186    	; 0x15c <__bad_interrupt>
      a2:	00 00       	nop
      a4:	5b c0       	rjmp	.+182    	; 0x15c <__bad_interrupt>
      a6:	00 00       	nop
      a8:	59 c0       	rjmp	.+178    	; 0x15c <__bad_interrupt>
      aa:	00 00       	nop
      ac:	57 c0       	rjmp	.+174    	; 0x15c <__bad_interrupt>
      ae:	00 00       	nop
      b0:	55 c0       	rjmp	.+170    	; 0x15c <__bad_interrupt>
      b2:	00 00       	nop
      b4:	53 c0       	rjmp	.+166    	; 0x15c <__bad_interrupt>
      b6:	00 00       	nop
      b8:	51 c0       	rjmp	.+162    	; 0x15c <__bad_interrupt>
      ba:	00 00       	nop
      bc:	4f c0       	rjmp	.+158    	; 0x15c <__bad_interrupt>
      be:	00 00       	nop
      c0:	4d c0       	rjmp	.+154    	; 0x15c <__bad_interrupt>
      c2:	00 00       	nop
      c4:	4b c0       	rjmp	.+150    	; 0x15c <__bad_interrupt>
      c6:	00 00       	nop
      c8:	49 c0       	rjmp	.+146    	; 0x15c <__bad_interrupt>
      ca:	00 00       	nop
      cc:	47 c0       	rjmp	.+142    	; 0x15c <__bad_interrupt>
      ce:	00 00       	nop
      d0:	45 c0       	rjmp	.+138    	; 0x15c <__bad_interrupt>
      d2:	00 00       	nop
      d4:	43 c0       	rjmp	.+134    	; 0x15c <__bad_interrupt>
      d6:	00 00       	nop
      d8:	41 c0       	rjmp	.+130    	; 0x15c <__bad_interrupt>
      da:	00 00       	nop
      dc:	3f c0       	rjmp	.+126    	; 0x15c <__bad_interrupt>
      de:	00 00       	nop
      e0:	3d c0       	rjmp	.+122    	; 0x15c <__bad_interrupt>
      e2:	00 00       	nop
      e4:	ff 03       	fmulsu	r23, r23
      e6:	04 04       	cpc	r0, r4
      e8:	09 04       	cpc	r0, r9
      ea:	0b 04       	cpc	r0, r11
      ec:	10 04       	cpc	r1, r0
      ee:	15 04       	cpc	r1, r5
      f0:	1a 04       	cpc	r1, r10
      f2:	1f 04       	cpc	r1, r15
      f4:	22 04       	cpc	r2, r2
      f6:	25 04       	cpc	r2, r5
      f8:	2a 04       	cpc	r2, r10

000000fa <__ctors_start>:
      fa:	dd 06       	cpc	r13, r29

000000fc <__ctors_end>:
      fc:	11 24       	eor	r1, r1
      fe:	1f be       	out	0x3f, r1	; 63
     100:	cf ef       	ldi	r28, 0xFF	; 255
     102:	d1 e2       	ldi	r29, 0x21	; 33
     104:	de bf       	out	0x3e, r29	; 62
     106:	cd bf       	out	0x3d, r28	; 61
     108:	00 e0       	ldi	r16, 0x00	; 0
     10a:	0c bf       	out	0x3c, r16	; 60

0000010c <__do_copy_data>:
     10c:	14 e0       	ldi	r17, 0x04	; 4
     10e:	a0 e0       	ldi	r26, 0x00	; 0
     110:	b2 e0       	ldi	r27, 0x02	; 2
     112:	e4 e4       	ldi	r30, 0x44	; 68
     114:	fa e1       	ldi	r31, 0x1A	; 26
     116:	00 e0       	ldi	r16, 0x00	; 0
     118:	0b bf       	out	0x3b, r16	; 59
     11a:	02 c0       	rjmp	.+4      	; 0x120 <__do_copy_data+0x14>
     11c:	07 90       	elpm	r0, Z+
     11e:	0d 92       	st	X+, r0
     120:	a4 33       	cpi	r26, 0x34	; 52
     122:	b1 07       	cpc	r27, r17
     124:	d9 f7       	brne	.-10     	; 0x11c <__do_copy_data+0x10>

00000126 <__do_clear_bss>:
     126:	24 e0       	ldi	r18, 0x04	; 4
     128:	a4 e3       	ldi	r26, 0x34	; 52
     12a:	b4 e0       	ldi	r27, 0x04	; 4
     12c:	01 c0       	rjmp	.+2      	; 0x130 <.do_clear_bss_start>

0000012e <.do_clear_bss_loop>:
     12e:	1d 92       	st	X+, r1

00000130 <.do_clear_bss_start>:
     130:	ad 38       	cpi	r26, 0x8D	; 141
     132:	b2 07       	cpc	r27, r18
     134:	e1 f7       	brne	.-8      	; 0x12e <.do_clear_bss_loop>

00000136 <__do_global_ctors>:
     136:	10 e0       	ldi	r17, 0x00	; 0
     138:	ce e7       	ldi	r28, 0x7E	; 126
     13a:	d0 e0       	ldi	r29, 0x00	; 0
     13c:	00 e0       	ldi	r16, 0x00	; 0
     13e:	06 c0       	rjmp	.+12     	; 0x14c <__do_global_ctors+0x16>
     140:	21 97       	sbiw	r28, 0x01	; 1
     142:	01 09       	sbc	r16, r1
     144:	80 2f       	mov	r24, r16
     146:	fe 01       	movw	r30, r28
     148:	0e 94 a4 0c 	call	0x1948	; 0x1948 <__tablejump2__>
     14c:	cd 37       	cpi	r28, 0x7D	; 125
     14e:	d1 07       	cpc	r29, r17
     150:	80 e0       	ldi	r24, 0x00	; 0
     152:	08 07       	cpc	r16, r24
     154:	a9 f7       	brne	.-22     	; 0x140 <__do_global_ctors+0xa>
     156:	0f d6       	rcall	.+3102   	; 0xd76 <main>
     158:	0c 94 20 0d 	jmp	0x1a40	; 0x1a40 <_exit>

0000015c <__bad_interrupt>:
     15c:	51 cf       	rjmp	.-350    	; 0x0 <__vectors>

0000015e <_Z11mode_selectv>:
		digitalWrite(do_hv_relais,LOW);			//disengage engine relay
		braking_dv=0;							//stop braking
	}
}

void mode_remote(){
     15e:	8b e2       	ldi	r24, 0x2B	; 43
     160:	90 e0       	ldi	r25, 0x00	; 0
     162:	52 d4       	rcall	.+2212   	; 0xa08 <_Z11digitalReadi>
     164:	88 23       	and	r24, r24
     166:	39 f0       	breq	.+14     	; 0x176 <_Z11mode_selectv+0x18>
     168:	81 e0       	ldi	r24, 0x01	; 1
     16a:	90 e0       	ldi	r25, 0x00	; 0
     16c:	90 93 6a 04 	sts	0x046A, r25	; 0x80046a <drivemode+0x1>
     170:	80 93 69 04 	sts	0x0469, r24	; 0x800469 <drivemode>
     174:	08 95       	ret
     176:	88 e2       	ldi	r24, 0x28	; 40
     178:	90 e0       	ldi	r25, 0x00	; 0
     17a:	46 d4       	rcall	.+2188   	; 0xa08 <_Z11digitalReadi>
     17c:	88 23       	and	r24, r24
     17e:	39 f0       	breq	.+14     	; 0x18e <_Z11mode_selectv+0x30>
     180:	82 e0       	ldi	r24, 0x02	; 2
     182:	90 e0       	ldi	r25, 0x00	; 0
     184:	90 93 6a 04 	sts	0x046A, r25	; 0x80046a <drivemode+0x1>
     188:	80 93 69 04 	sts	0x0469, r24	; 0x800469 <drivemode>
     18c:	08 95       	ret
     18e:	89 e2       	ldi	r24, 0x29	; 41
     190:	90 e0       	ldi	r25, 0x00	; 0
     192:	3a d4       	rcall	.+2164   	; 0xa08 <_Z11digitalReadi>
     194:	88 23       	and	r24, r24
     196:	39 f0       	breq	.+14     	; 0x1a6 <_Z11mode_selectv+0x48>
     198:	83 e0       	ldi	r24, 0x03	; 3
     19a:	90 e0       	ldi	r25, 0x00	; 0
     19c:	90 93 6a 04 	sts	0x046A, r25	; 0x80046a <drivemode+0x1>
     1a0:	80 93 69 04 	sts	0x0469, r24	; 0x800469 <drivemode>
     1a4:	08 95       	ret
     1a6:	10 92 6a 04 	sts	0x046A, r1	; 0x80046a <drivemode+0x1>
     1aa:	10 92 69 04 	sts	0x0469, r1	; 0x800469 <drivemode>
     1ae:	08 95       	ret

000001b0 <_Z9initDrivev>:
     1b0:	61 e0       	ldi	r22, 0x01	; 1
     1b2:	8a e1       	ldi	r24, 0x1A	; 26
     1b4:	90 e0       	ldi	r25, 0x00	; 0
     1b6:	59 d3       	rcall	.+1714   	; 0x86a <_Z12digitalWriteib>
     1b8:	61 e0       	ldi	r22, 0x01	; 1
     1ba:	88 e1       	ldi	r24, 0x18	; 24
     1bc:	90 e0       	ldi	r25, 0x00	; 0
     1be:	55 d3       	rcall	.+1706   	; 0x86a <_Z12digitalWriteib>
     1c0:	61 e0       	ldi	r22, 0x01	; 1
     1c2:	89 e1       	ldi	r24, 0x19	; 25
     1c4:	90 e0       	ldi	r25, 0x00	; 0
     1c6:	51 d3       	rcall	.+1698   	; 0x86a <_Z12digitalWriteib>
     1c8:	61 e0       	ldi	r22, 0x01	; 1
     1ca:	86 e1       	ldi	r24, 0x16	; 22
     1cc:	90 e0       	ldi	r25, 0x00	; 0
     1ce:	4d d3       	rcall	.+1690   	; 0x86a <_Z12digitalWriteib>
     1d0:	61 e0       	ldi	r22, 0x01	; 1
     1d2:	87 e1       	ldi	r24, 0x17	; 23
     1d4:	90 e0       	ldi	r25, 0x00	; 0
     1d6:	49 d3       	rcall	.+1682   	; 0x86a <_Z12digitalWriteib>
     1d8:	61 e0       	ldi	r22, 0x01	; 1
     1da:	82 e2       	ldi	r24, 0x22	; 34
     1dc:	90 e0       	ldi	r25, 0x00	; 0
     1de:	45 d3       	rcall	.+1674   	; 0x86a <_Z12digitalWriteib>
     1e0:	be cf       	rjmp	.-132    	; 0x15e <_Z11mode_selectv>
     1e2:	08 95       	ret

000001e4 <_Z13mode_joystickv>:
     1e4:	61 e0       	ldi	r22, 0x01	; 1
     1e6:	81 e2       	ldi	r24, 0x21	; 33
     1e8:	90 e0       	ldi	r25, 0x00	; 0
     1ea:	3f d3       	rcall	.+1662   	; 0x86a <_Z12digitalWriteib>
     1ec:	80 91 3a 04 	lds	r24, 0x043A	; 0x80043a <engine_rpm>
     1f0:	90 91 3b 04 	lds	r25, 0x043B	; 0x80043b <engine_rpm+0x1>
     1f4:	89 2b       	or	r24, r25
     1f6:	29 f4       	brne	.+10     	; 0x202 <_Z13mode_joystickv+0x1e>
     1f8:	8a e2       	ldi	r24, 0x2A	; 42
     1fa:	90 e0       	ldi	r25, 0x00	; 0
     1fc:	05 d4       	rcall	.+2058   	; 0xa08 <_Z11digitalReadi>
     1fe:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
     202:	84 e0       	ldi	r24, 0x04	; 4
     204:	90 e0       	ldi	r25, 0x00	; 0
     206:	7c d4       	rcall	.+2296   	; 0xb00 <_Z10analogReadi>
     208:	dc 01       	movw	r26, r24
     20a:	ab 5f       	subi	r26, 0xFB	; 251
     20c:	b1 40       	sbci	r27, 0x01	; 1
     20e:	2e e5       	ldi	r18, 0x5E	; 94
     210:	31 e0       	ldi	r19, 0x01	; 1
     212:	0e 94 ac 0c 	call	0x1958	; 0x1958 <__usmulhisi3>
     216:	29 e8       	ldi	r18, 0x89	; 137
     218:	30 e0       	ldi	r19, 0x00	; 0
     21a:	40 e0       	ldi	r20, 0x00	; 0
     21c:	50 e0       	ldi	r21, 0x00	; 0
     21e:	0e 94 88 0c 	call	0x1910	; 0x1910 <__divmodsi4>
     222:	20 93 61 04 	sts	0x0461, r18	; 0x800461 <steering_dv>
     226:	30 93 62 04 	sts	0x0462, r19	; 0x800462 <steering_dv+0x1>
     22a:	40 93 63 04 	sts	0x0463, r20	; 0x800463 <steering_dv+0x2>
     22e:	50 93 64 04 	sts	0x0464, r21	; 0x800464 <steering_dv+0x3>
     232:	82 e0       	ldi	r24, 0x02	; 2
     234:	90 e0       	ldi	r25, 0x00	; 0
     236:	64 d4       	rcall	.+2248   	; 0xb00 <_Z10analogReadi>
     238:	8e 5f       	subi	r24, 0xFE	; 254
     23a:	91 40       	sbci	r25, 0x01	; 1
     23c:	9c 01       	movw	r18, r24
     23e:	2c 5f       	subi	r18, 0xFC	; 252
     240:	3f 4f       	sbci	r19, 0xFF	; 255
     242:	29 30       	cpi	r18, 0x09	; 9
     244:	31 05       	cpc	r19, r1
     246:	68 f0       	brcs	.+26     	; 0x262 <_Z13mode_joystickv+0x7e>
     248:	09 2e       	mov	r0, r25
     24a:	00 0c       	add	r0, r0
     24c:	aa 0b       	sbc	r26, r26
     24e:	bb 0b       	sbc	r27, r27
     250:	80 93 65 04 	sts	0x0465, r24	; 0x800465 <driving_dv>
     254:	90 93 66 04 	sts	0x0466, r25	; 0x800466 <driving_dv+0x1>
     258:	a0 93 67 04 	sts	0x0467, r26	; 0x800467 <driving_dv+0x2>
     25c:	b0 93 68 04 	sts	0x0468, r27	; 0x800468 <driving_dv+0x3>
     260:	08 c0       	rjmp	.+16     	; 0x272 <_Z13mode_joystickv+0x8e>
     262:	10 92 65 04 	sts	0x0465, r1	; 0x800465 <driving_dv>
     266:	10 92 66 04 	sts	0x0466, r1	; 0x800466 <driving_dv+0x1>
     26a:	10 92 67 04 	sts	0x0467, r1	; 0x800467 <driving_dv+0x2>
     26e:	10 92 68 04 	sts	0x0468, r1	; 0x800468 <driving_dv+0x3>
     272:	10 92 54 04 	sts	0x0454, r1	; 0x800454 <engine_dv>
     276:	10 92 55 04 	sts	0x0455, r1	; 0x800455 <engine_dv+0x1>
     27a:	10 92 56 04 	sts	0x0456, r1	; 0x800456 <engine_dv+0x2>
     27e:	10 92 57 04 	sts	0x0457, r1	; 0x800457 <engine_dv+0x3>
     282:	10 92 47 04 	sts	0x0447, r1	; 0x800447 <braking_dv>
     286:	10 92 48 04 	sts	0x0448, r1	; 0x800448 <braking_dv+0x1>
     28a:	10 92 49 04 	sts	0x0449, r1	; 0x800449 <braking_dv+0x2>
     28e:	10 92 4a 04 	sts	0x044A, r1	; 0x80044a <braking_dv+0x3>
     292:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__data_start>
     296:	88 23       	and	r24, r24
     298:	51 f1       	breq	.+84     	; 0x2ee <_Z13mode_joystickv+0x10a>
     29a:	80 91 65 04 	lds	r24, 0x0465	; 0x800465 <driving_dv>
     29e:	90 91 66 04 	lds	r25, 0x0466	; 0x800466 <driving_dv+0x1>
     2a2:	a0 91 67 04 	lds	r26, 0x0467	; 0x800467 <driving_dv+0x2>
     2a6:	b0 91 68 04 	lds	r27, 0x0468	; 0x800468 <driving_dv+0x3>
     2aa:	18 16       	cp	r1, r24
     2ac:	19 06       	cpc	r1, r25
     2ae:	1a 06       	cpc	r1, r26
     2b0:	1b 06       	cpc	r1, r27
     2b2:	4c f4       	brge	.+18     	; 0x2c6 <_Z13mode_joystickv+0xe2>
     2b4:	80 93 54 04 	sts	0x0454, r24	; 0x800454 <engine_dv>
     2b8:	90 93 55 04 	sts	0x0455, r25	; 0x800455 <engine_dv+0x1>
     2bc:	a0 93 56 04 	sts	0x0456, r26	; 0x800456 <engine_dv+0x2>
     2c0:	b0 93 57 04 	sts	0x0457, r27	; 0x800457 <engine_dv+0x3>
     2c4:	08 95       	ret
     2c6:	9c 01       	movw	r18, r24
     2c8:	99 23       	and	r25, r25
     2ca:	24 f4       	brge	.+8      	; 0x2d4 <_Z13mode_joystickv+0xf0>
     2cc:	22 27       	eor	r18, r18
     2ce:	33 27       	eor	r19, r19
     2d0:	28 1b       	sub	r18, r24
     2d2:	39 0b       	sbc	r19, r25
     2d4:	c9 01       	movw	r24, r18
     2d6:	33 0f       	add	r19, r19
     2d8:	aa 0b       	sbc	r26, r26
     2da:	bb 0b       	sbc	r27, r27
     2dc:	80 93 47 04 	sts	0x0447, r24	; 0x800447 <braking_dv>
     2e0:	90 93 48 04 	sts	0x0448, r25	; 0x800448 <braking_dv+0x1>
     2e4:	a0 93 49 04 	sts	0x0449, r26	; 0x800449 <braking_dv+0x2>
     2e8:	b0 93 4a 04 	sts	0x044A, r27	; 0x80044a <braking_dv+0x3>
     2ec:	08 95       	ret
     2ee:	80 91 65 04 	lds	r24, 0x0465	; 0x800465 <driving_dv>
     2f2:	90 91 66 04 	lds	r25, 0x0466	; 0x800466 <driving_dv+0x1>
     2f6:	a0 91 67 04 	lds	r26, 0x0467	; 0x800467 <driving_dv+0x2>
     2fa:	b0 91 68 04 	lds	r27, 0x0468	; 0x800468 <driving_dv+0x3>
     2fe:	18 16       	cp	r1, r24
     300:	19 06       	cpc	r1, r25
     302:	1a 06       	cpc	r1, r26
     304:	1b 06       	cpc	r1, r27
     306:	4c f4       	brge	.+18     	; 0x31a <_Z13mode_joystickv+0x136>
     308:	80 93 47 04 	sts	0x0447, r24	; 0x800447 <braking_dv>
     30c:	90 93 48 04 	sts	0x0448, r25	; 0x800448 <braking_dv+0x1>
     310:	a0 93 49 04 	sts	0x0449, r26	; 0x800449 <braking_dv+0x2>
     314:	b0 93 4a 04 	sts	0x044A, r27	; 0x80044a <braking_dv+0x3>
     318:	08 95       	ret
     31a:	9c 01       	movw	r18, r24
     31c:	99 23       	and	r25, r25
     31e:	24 f4       	brge	.+8      	; 0x328 <_Z13mode_joystickv+0x144>
     320:	22 27       	eor	r18, r18
     322:	33 27       	eor	r19, r19
     324:	28 1b       	sub	r18, r24
     326:	39 0b       	sbc	r19, r25
     328:	c9 01       	movw	r24, r18
     32a:	33 0f       	add	r19, r19
     32c:	aa 0b       	sbc	r26, r26
     32e:	bb 0b       	sbc	r27, r27
     330:	80 93 54 04 	sts	0x0454, r24	; 0x800454 <engine_dv>
     334:	90 93 55 04 	sts	0x0455, r25	; 0x800455 <engine_dv+0x1>
     338:	a0 93 56 04 	sts	0x0456, r26	; 0x800456 <engine_dv+0x2>
     33c:	b0 93 57 04 	sts	0x0457, r27	; 0x800457 <engine_dv+0x3>
     340:	08 95       	ret

00000342 <_Z9mode_idlev>:
     342:	10 92 54 04 	sts	0x0454, r1	; 0x800454 <engine_dv>
     346:	10 92 55 04 	sts	0x0455, r1	; 0x800455 <engine_dv+0x1>
     34a:	10 92 56 04 	sts	0x0456, r1	; 0x800456 <engine_dv+0x2>
     34e:	10 92 57 04 	sts	0x0457, r1	; 0x800457 <engine_dv+0x3>
     352:	8b ef       	ldi	r24, 0xFB	; 251
     354:	91 e0       	ldi	r25, 0x01	; 1
     356:	a0 e0       	ldi	r26, 0x00	; 0
     358:	b0 e0       	ldi	r27, 0x00	; 0
     35a:	80 93 61 04 	sts	0x0461, r24	; 0x800461 <steering_dv>
     35e:	90 93 62 04 	sts	0x0462, r25	; 0x800462 <steering_dv+0x1>
     362:	a0 93 63 04 	sts	0x0463, r26	; 0x800463 <steering_dv+0x2>
     366:	b0 93 64 04 	sts	0x0464, r27	; 0x800464 <steering_dv+0x3>
     36a:	84 e6       	ldi	r24, 0x64	; 100
     36c:	90 e0       	ldi	r25, 0x00	; 0
     36e:	a0 e0       	ldi	r26, 0x00	; 0
     370:	b0 e0       	ldi	r27, 0x00	; 0
     372:	80 93 47 04 	sts	0x0447, r24	; 0x800447 <braking_dv>
     376:	90 93 48 04 	sts	0x0448, r25	; 0x800448 <braking_dv+0x1>
     37a:	a0 93 49 04 	sts	0x0449, r26	; 0x800449 <braking_dv+0x2>
     37e:	b0 93 4a 04 	sts	0x044A, r27	; 0x80044a <braking_dv+0x3>
     382:	80 91 3a 04 	lds	r24, 0x043A	; 0x80043a <engine_rpm>
     386:	90 91 3b 04 	lds	r25, 0x043B	; 0x80043b <engine_rpm+0x1>
     38a:	89 2b       	or	r24, r25
     38c:	61 f4       	brne	.+24     	; 0x3a6 <_Z9mode_idlev+0x64>
     38e:	60 e0       	ldi	r22, 0x00	; 0
     390:	81 e2       	ldi	r24, 0x21	; 33
     392:	90 e0       	ldi	r25, 0x00	; 0
     394:	6a d2       	rcall	.+1236   	; 0x86a <_Z12digitalWriteib>
     396:	10 92 47 04 	sts	0x0447, r1	; 0x800447 <braking_dv>
     39a:	10 92 48 04 	sts	0x0448, r1	; 0x800448 <braking_dv+0x1>
     39e:	10 92 49 04 	sts	0x0449, r1	; 0x800449 <braking_dv+0x2>
     3a2:	10 92 4a 04 	sts	0x044A, r1	; 0x80044a <braking_dv+0x3>
     3a6:	08 95       	ret

000003a8 <_Z9run_brakev>:
	//digitalWrite(do_hv_relais,HIGH);
	//not (yet) implemented
}

void run_brake(){
	braking_cv = (long(analogRead(ai_brake_pressure) - braking_sensor_offset) * (250 / 1023));				//retrieve the current value of the brake pressure sensor
     3a8:	81 e0       	ldi	r24, 0x01	; 1
     3aa:	90 e0       	ldi	r25, 0x00	; 0
     3ac:	a9 d3       	rcall	.+1874   	; 0xb00 <_Z10analogReadi>
     3ae:	10 92 3f 04 	sts	0x043F, r1	; 0x80043f <braking_cv>
     3b2:	10 92 40 04 	sts	0x0440, r1	; 0x800440 <braking_cv+0x1>
     3b6:	10 92 41 04 	sts	0x0441, r1	; 0x800441 <braking_cv+0x2>
     3ba:	10 92 42 04 	sts	0x0442, r1	; 0x800442 <braking_cv+0x3>
	braking_delta = braking_dv - braking_cv;
     3be:	40 91 47 04 	lds	r20, 0x0447	; 0x800447 <braking_dv>
     3c2:	50 91 48 04 	lds	r21, 0x0448	; 0x800448 <braking_dv+0x1>
     3c6:	60 91 49 04 	lds	r22, 0x0449	; 0x800449 <braking_dv+0x2>
     3ca:	70 91 4a 04 	lds	r23, 0x044A	; 0x80044a <braking_dv+0x3>
	if(abs(braking_delta)<10)
     3ce:	ca 01       	movw	r24, r20
     3d0:	09 96       	adiw	r24, 0x09	; 9
     3d2:	43 97       	sbiw	r24, 0x13	; 19
     3d4:	48 f0       	brcs	.+18     	; 0x3e8 <_Z9run_brakev+0x40>
	//not (yet) implemented
}

void run_brake(){
	braking_cv = (long(analogRead(ai_brake_pressure) - braking_sensor_offset) * (250 / 1023));				//retrieve the current value of the brake pressure sensor
	braking_delta = braking_dv - braking_cv;
     3d6:	40 93 43 04 	sts	0x0443, r20	; 0x800443 <braking_delta>
     3da:	50 93 44 04 	sts	0x0444, r21	; 0x800444 <braking_delta+0x1>
     3de:	60 93 45 04 	sts	0x0445, r22	; 0x800445 <braking_delta+0x2>
     3e2:	70 93 46 04 	sts	0x0446, r23	; 0x800446 <braking_delta+0x3>
     3e6:	08 c0       	rjmp	.+16     	; 0x3f8 <_Z9run_brakev+0x50>
	if(abs(braking_delta)<10)
		braking_delta = 0;
     3e8:	10 92 43 04 	sts	0x0443, r1	; 0x800443 <braking_delta>
     3ec:	10 92 44 04 	sts	0x0444, r1	; 0x800444 <braking_delta+0x1>
     3f0:	10 92 45 04 	sts	0x0445, r1	; 0x800445 <braking_delta+0x2>
     3f4:	10 92 46 04 	sts	0x0446, r1	; 0x800446 <braking_delta+0x3>
	braking_ov = constrain(braking_dv * braking_kp, 0, 255);
     3f8:	db 01       	movw	r26, r22
     3fa:	ca 01       	movw	r24, r20
     3fc:	88 0f       	add	r24, r24
     3fe:	99 1f       	adc	r25, r25
     400:	aa 1f       	adc	r26, r26
     402:	bb 1f       	adc	r27, r27
     404:	84 0f       	add	r24, r20
     406:	95 1f       	adc	r25, r21
     408:	a6 1f       	adc	r26, r22
     40a:	b7 1f       	adc	r27, r23
     40c:	bb 23       	and	r27, r27
     40e:	5c f0       	brlt	.+22     	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
     410:	8f 3f       	cpi	r24, 0xFF	; 255
     412:	91 05       	cpc	r25, r1
     414:	a1 05       	cpc	r26, r1
     416:	b1 05       	cpc	r27, r1
     418:	39 f0       	breq	.+14     	; 0x428 <__LOCK_REGION_LENGTH__+0x28>
     41a:	34 f0       	brlt	.+12     	; 0x428 <__LOCK_REGION_LENGTH__+0x28>
     41c:	8f ef       	ldi	r24, 0xFF	; 255
     41e:	90 e0       	ldi	r25, 0x00	; 0
     420:	a0 e0       	ldi	r26, 0x00	; 0
     422:	b0 e0       	ldi	r27, 0x00	; 0
     424:	01 c0       	rjmp	.+2      	; 0x428 <__LOCK_REGION_LENGTH__+0x28>
     426:	80 e0       	ldi	r24, 0x00	; 0
     428:	80 93 3e 04 	sts	0x043E, r24	; 0x80043e <braking_ov>
	analogWrite(pwm_brake_pump, braking_dv);															//Write op to brake pump
     42c:	ba 01       	movw	r22, r20
     42e:	87 e0       	ldi	r24, 0x07	; 7
     430:	90 e0       	ldi	r25, 0x00	; 0
     432:	d4 c1       	rjmp	.+936    	; 0x7dc <_Z11analogWriteii>
     434:	08 95       	ret

00000436 <_Z9run_steerv>:
}

void run_steer(){
     436:	0f 93       	push	r16
     438:	1f 93       	push	r17
	steering_cv = -(long(analogRead(ai_steer_pot)- steering_sensor_offset) * 1000/1023);				//retrieve the current value of the steering potentiometer and convert it to 10th of degrees
     43a:	80 e0       	ldi	r24, 0x00	; 0
     43c:	90 e0       	ldi	r25, 0x00	; 0
     43e:	60 d3       	rcall	.+1728   	; 0xb00 <_Z10analogReadi>
     440:	dc 01       	movw	r26, r24
     442:	b2 50       	subi	r27, 0x02	; 2
     444:	28 ee       	ldi	r18, 0xE8	; 232
     446:	33 e0       	ldi	r19, 0x03	; 3
     448:	0e 94 ac 0c 	call	0x1958	; 0x1958 <__usmulhisi3>
     44c:	2f ef       	ldi	r18, 0xFF	; 255
     44e:	33 e0       	ldi	r19, 0x03	; 3
     450:	40 e0       	ldi	r20, 0x00	; 0
     452:	50 e0       	ldi	r21, 0x00	; 0
     454:	0e 94 88 0c 	call	0x1910	; 0x1910 <__divmodsi4>
     458:	88 27       	eor	r24, r24
     45a:	99 27       	eor	r25, r25
     45c:	dc 01       	movw	r26, r24
     45e:	82 1b       	sub	r24, r18
     460:	93 0b       	sbc	r25, r19
     462:	a4 0b       	sbc	r26, r20
     464:	b5 0b       	sbc	r27, r21
     466:	80 93 59 04 	sts	0x0459, r24	; 0x800459 <steering_cv>
     46a:	90 93 5a 04 	sts	0x045A, r25	; 0x80045a <steering_cv+0x1>
     46e:	a0 93 5b 04 	sts	0x045B, r26	; 0x80045b <steering_cv+0x2>
     472:	b0 93 5c 04 	sts	0x045C, r27	; 0x80045c <steering_cv+0x3>
	if(abs(steering_dv)<steering_deadzone)																//create a dead zone around default joystick position, desired value must at least be bigger then dead zone value (makes going straight easier
     476:	80 91 61 04 	lds	r24, 0x0461	; 0x800461 <steering_dv>
     47a:	90 91 62 04 	lds	r25, 0x0462	; 0x800462 <steering_dv+0x1>
     47e:	c1 96       	adiw	r24, 0x31	; 49
     480:	83 36       	cpi	r24, 0x63	; 99
     482:	91 05       	cpc	r25, r1
     484:	40 f4       	brcc	.+16     	; 0x496 <_Z9run_steerv+0x60>
		steering_dv = 0;
     486:	10 92 61 04 	sts	0x0461, r1	; 0x800461 <steering_dv>
     48a:	10 92 62 04 	sts	0x0462, r1	; 0x800462 <steering_dv+0x1>
     48e:	10 92 63 04 	sts	0x0463, r1	; 0x800463 <steering_dv+0x2>
     492:	10 92 64 04 	sts	0x0464, r1	; 0x800464 <steering_dv+0x3>
	steering_delta = steering_dv - steering_cv;															//difference between desired value and current value
     496:	80 91 61 04 	lds	r24, 0x0461	; 0x800461 <steering_dv>
     49a:	90 91 62 04 	lds	r25, 0x0462	; 0x800462 <steering_dv+0x1>
     49e:	a0 91 63 04 	lds	r26, 0x0463	; 0x800463 <steering_dv+0x2>
     4a2:	b0 91 64 04 	lds	r27, 0x0464	; 0x800464 <steering_dv+0x3>
     4a6:	89 01       	movw	r16, r18
     4a8:	9a 01       	movw	r18, r20
     4aa:	08 0f       	add	r16, r24
     4ac:	19 1f       	adc	r17, r25
     4ae:	2a 1f       	adc	r18, r26
     4b0:	3b 1f       	adc	r19, r27
     4b2:	00 93 5d 04 	sts	0x045D, r16	; 0x80045d <steering_delta>
     4b6:	10 93 5e 04 	sts	0x045E, r17	; 0x80045e <steering_delta+0x1>
     4ba:	20 93 5f 04 	sts	0x045F, r18	; 0x80045f <steering_delta+0x2>
     4be:	30 93 60 04 	sts	0x0460, r19	; 0x800460 <steering_delta+0x3>
	if(abs(steering_delta)<10)																			//if the two are too close together, don't steer, this to prevent the motor from constantly trying to make small movements which it is not capable of, so it starts skreeching
     4c2:	c8 01       	movw	r24, r16
     4c4:	09 96       	adiw	r24, 0x09	; 9
     4c6:	43 97       	sbiw	r24, 0x13	; 19
     4c8:	70 f4       	brcc	.+28     	; 0x4e6 <_Z9run_steerv+0xb0>
		steering_delta=0;
     4ca:	10 92 5d 04 	sts	0x045D, r1	; 0x80045d <steering_delta>
     4ce:	10 92 5e 04 	sts	0x045E, r1	; 0x80045e <steering_delta+0x1>
     4d2:	10 92 5f 04 	sts	0x045F, r1	; 0x80045f <steering_delta+0x2>
     4d6:	10 92 60 04 	sts	0x0460, r1	; 0x800460 <steering_delta+0x3>
	steering_ov = constrain((abs(steering_delta) * steering_kp), 0, 255);								//determine the output PMW value in such a way that the smaller the delta, the slower it goes to smooth out steering
     4da:	60 e0       	ldi	r22, 0x00	; 0
     4dc:	70 e0       	ldi	r23, 0x00	; 0
     4de:	00 e0       	ldi	r16, 0x00	; 0
     4e0:	10 e0       	ldi	r17, 0x00	; 0
     4e2:	98 01       	movw	r18, r16
     4e4:	11 c0       	rjmp	.+34     	; 0x508 <_Z9run_steerv+0xd2>
     4e6:	c8 01       	movw	r24, r16
     4e8:	99 23       	and	r25, r25
     4ea:	24 f4       	brge	.+8      	; 0x4f4 <_Z9run_steerv+0xbe>
     4ec:	88 27       	eor	r24, r24
     4ee:	99 27       	eor	r25, r25
     4f0:	80 1b       	sub	r24, r16
     4f2:	91 0b       	sbc	r25, r17
     4f4:	bc 01       	movw	r22, r24
     4f6:	66 0f       	add	r22, r22
     4f8:	77 1f       	adc	r23, r23
     4fa:	66 0f       	add	r22, r22
     4fc:	77 1f       	adc	r23, r23
     4fe:	66 0f       	add	r22, r22
     500:	77 1f       	adc	r23, r23
     502:	68 1b       	sub	r22, r24
     504:	79 0b       	sbc	r23, r25
     506:	3a f0       	brmi	.+14     	; 0x516 <_Z9run_steerv+0xe0>
     508:	6f 3f       	cpi	r22, 0xFF	; 255
     50a:	71 05       	cpc	r23, r1
     50c:	29 f0       	breq	.+10     	; 0x518 <_Z9run_steerv+0xe2>
     50e:	24 f0       	brlt	.+8      	; 0x518 <_Z9run_steerv+0xe2>
     510:	6f ef       	ldi	r22, 0xFF	; 255
     512:	70 e0       	ldi	r23, 0x00	; 0
     514:	01 c0       	rjmp	.+2      	; 0x518 <_Z9run_steerv+0xe2>
     516:	60 e0       	ldi	r22, 0x00	; 0
     518:	60 93 58 04 	sts	0x0458, r22	; 0x800458 <steering_ov>
	if (steering_delta < 0) {																			//H bridge settings, let the engine turn the correct way
     51c:	33 23       	and	r19, r19
     51e:	54 f4       	brge	.+20     	; 0x534 <_Z9run_steerv+0xfe>
		analogWrite(pwm_steer_rpwm, steering_ov);														
     520:	70 e0       	ldi	r23, 0x00	; 0
     522:	83 e0       	ldi	r24, 0x03	; 3
     524:	90 e0       	ldi	r25, 0x00	; 0
     526:	5a d1       	rcall	.+692    	; 0x7dc <_Z11analogWriteii>
		analogWrite(pwm_steer_lpwm, 0);
     528:	60 e0       	ldi	r22, 0x00	; 0
     52a:	70 e0       	ldi	r23, 0x00	; 0
     52c:	82 e0       	ldi	r24, 0x02	; 2
     52e:	90 e0       	ldi	r25, 0x00	; 0
     530:	55 d1       	rcall	.+682    	; 0x7dc <_Z11analogWriteii>
     532:	1b c0       	rjmp	.+54     	; 0x56a <_Z9run_steerv+0x134>
	}
	else if (steering_delta > 0) {
     534:	10 16       	cp	r1, r16
     536:	11 06       	cpc	r1, r17
     538:	12 06       	cpc	r1, r18
     53a:	13 06       	cpc	r1, r19
     53c:	64 f4       	brge	.+24     	; 0x556 <_Z9run_steerv+0x120>
		analogWrite(pwm_steer_rpwm, 0);
     53e:	60 e0       	ldi	r22, 0x00	; 0
     540:	70 e0       	ldi	r23, 0x00	; 0
     542:	83 e0       	ldi	r24, 0x03	; 3
     544:	90 e0       	ldi	r25, 0x00	; 0
     546:	4a d1       	rcall	.+660    	; 0x7dc <_Z11analogWriteii>
		analogWrite(pwm_steer_lpwm, steering_ov);
     548:	60 91 58 04 	lds	r22, 0x0458	; 0x800458 <steering_ov>
     54c:	70 e0       	ldi	r23, 0x00	; 0
     54e:	82 e0       	ldi	r24, 0x02	; 2
     550:	90 e0       	ldi	r25, 0x00	; 0
     552:	44 d1       	rcall	.+648    	; 0x7dc <_Z11analogWriteii>
     554:	0a c0       	rjmp	.+20     	; 0x56a <_Z9run_steerv+0x134>
	}
	else {
		analogWrite(pwm_steer_rpwm, 0);
     556:	60 e0       	ldi	r22, 0x00	; 0
     558:	70 e0       	ldi	r23, 0x00	; 0
     55a:	83 e0       	ldi	r24, 0x03	; 3
     55c:	90 e0       	ldi	r25, 0x00	; 0
     55e:	3e d1       	rcall	.+636    	; 0x7dc <_Z11analogWriteii>
		analogWrite(pwm_steer_lpwm, 0);
     560:	60 e0       	ldi	r22, 0x00	; 0
     562:	70 e0       	ldi	r23, 0x00	; 0
     564:	82 e0       	ldi	r24, 0x02	; 2
     566:	90 e0       	ldi	r25, 0x00	; 0
     568:	39 d1       	rcall	.+626    	; 0x7dc <_Z11analogWriteii>
     56a:	1f 91       	pop	r17
	}	
}
     56c:	0f 91       	pop	r16
     56e:	08 95       	ret

00000570 <_Z10run_curtisv>:
     570:	60 91 3a 04 	lds	r22, 0x043A	; 0x80043a <engine_rpm>

void run_curtis(){
	engine_cv = (engine_rpm * float(100 / 1023));												//the proces value of the engine system is the rpm which we read from the CAN-bus of the curtis
     574:	70 91 3b 04 	lds	r23, 0x043B	; 0x80043b <engine_rpm+0x1>
     578:	80 e0       	ldi	r24, 0x00	; 0
     57a:	90 e0       	ldi	r25, 0x00	; 0
     57c:	0e 94 97 0b 	call	0x172e	; 0x172e <__floatunsisf>
     580:	20 e0       	ldi	r18, 0x00	; 0
     582:	30 e0       	ldi	r19, 0x00	; 0
     584:	a9 01       	movw	r20, r18
     586:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <__mulsf3>
     58a:	0e 94 66 0b 	call	0x16cc	; 0x16cc <__fixsfsi>
     58e:	60 93 4c 04 	sts	0x044C, r22	; 0x80044c <engine_cv>
     592:	70 93 4d 04 	sts	0x044D, r23	; 0x80044d <engine_cv+0x1>
     596:	80 93 4e 04 	sts	0x044E, r24	; 0x80044e <engine_cv+0x2>
     59a:	90 93 4f 04 	sts	0x044F, r25	; 0x80044f <engine_cv+0x3>
	digitalWrite(do_drive_forward, driving_direction);											//give the curtiss the correct driving direction
     59e:	60 91 00 02 	lds	r22, 0x0200	; 0x800200 <__data_start>
     5a2:	8b e1       	ldi	r24, 0x1B	; 27
     5a4:	90 e0       	ldi	r25, 0x00	; 0
     5a6:	61 d1       	rcall	.+706    	; 0x86a <_Z12digitalWriteib>
	digitalWrite(do_drive_reverse, !driving_direction);
     5a8:	60 91 00 02 	lds	r22, 0x0200	; 0x800200 <__data_start>
     5ac:	81 e0       	ldi	r24, 0x01	; 1
     5ae:	68 27       	eor	r22, r24
     5b0:	8c e1       	ldi	r24, 0x1C	; 28
     5b2:	90 e0       	ldi	r25, 0x00	; 0
     5b4:	5a d1       	rcall	.+692    	; 0x86a <_Z12digitalWriteib>
	
	//Set the curtis in the right mode for braking, driving or neutral																		//if we want to brake
		digitalWrite(do_drive_throttleswitch, engine_dv);				//if there is an engine signal, enable listening to the throttle
     5b6:	61 e0       	ldi	r22, 0x01	; 1
     5b8:	80 91 54 04 	lds	r24, 0x0454	; 0x800454 <engine_dv>
     5bc:	90 91 55 04 	lds	r25, 0x0455	; 0x800455 <engine_dv+0x1>
     5c0:	a0 91 56 04 	lds	r26, 0x0456	; 0x800456 <engine_dv+0x2>
     5c4:	b0 91 57 04 	lds	r27, 0x0457	; 0x800457 <engine_dv+0x3>
     5c8:	89 2b       	or	r24, r25
     5ca:	8a 2b       	or	r24, r26
     5cc:	8b 2b       	or	r24, r27
     5ce:	09 f4       	brne	.+2      	; 0x5d2 <_Z10run_curtisv+0x62>
     5d0:	60 e0       	ldi	r22, 0x00	; 0
     5d2:	8e e1       	ldi	r24, 0x1E	; 30
     5d4:	90 e0       	ldi	r25, 0x00	; 0
     5d6:	49 d1       	rcall	.+658    	; 0x86a <_Z12digitalWriteib>
		digitalWrite(do_drive_brake, braking_dv);						//if there is an braking signal, turn on the braking 
     5d8:	61 e0       	ldi	r22, 0x01	; 1
     5da:	80 91 47 04 	lds	r24, 0x0447	; 0x800447 <braking_dv>
     5de:	90 91 48 04 	lds	r25, 0x0448	; 0x800448 <braking_dv+0x1>
     5e2:	a0 91 49 04 	lds	r26, 0x0449	; 0x800449 <braking_dv+0x2>
     5e6:	b0 91 4a 04 	lds	r27, 0x044A	; 0x80044a <braking_dv+0x3>
     5ea:	89 2b       	or	r24, r25
     5ec:	8a 2b       	or	r24, r26
     5ee:	8b 2b       	or	r24, r27
     5f0:	09 f4       	brne	.+2      	; 0x5f4 <_Z10run_curtisv+0x84>
     5f2:	60 e0       	ldi	r22, 0x00	; 0
     5f4:	8d e1       	ldi	r24, 0x1D	; 29
     5f6:	90 e0       	ldi	r25, 0x00	; 0
     5f8:	38 d1       	rcall	.+624    	; 0x86a <_Z12digitalWriteib>

	engine_delta = engine_dv - engine_cv;									//calculate delta
     5fa:	40 91 54 04 	lds	r20, 0x0454	; 0x800454 <engine_dv>
     5fe:	50 91 55 04 	lds	r21, 0x0455	; 0x800455 <engine_dv+0x1>
     602:	60 91 56 04 	lds	r22, 0x0456	; 0x800456 <engine_dv+0x2>
     606:	70 91 57 04 	lds	r23, 0x0457	; 0x800457 <engine_dv+0x3>
     60a:	80 91 4c 04 	lds	r24, 0x044C	; 0x80044c <engine_cv>
     60e:	90 91 4d 04 	lds	r25, 0x044D	; 0x80044d <engine_cv+0x1>
     612:	a0 91 4e 04 	lds	r26, 0x044E	; 0x80044e <engine_cv+0x2>
     616:	b0 91 4f 04 	lds	r27, 0x044F	; 0x80044f <engine_cv+0x3>
     61a:	9a 01       	movw	r18, r20
     61c:	ab 01       	movw	r20, r22
     61e:	28 1b       	sub	r18, r24
     620:	39 0b       	sbc	r19, r25
     622:	4a 0b       	sbc	r20, r26
     624:	5b 0b       	sbc	r21, r27
     626:	20 93 50 04 	sts	0x0450, r18	; 0x800450 <engine_delta>
     62a:	30 93 51 04 	sts	0x0451, r19	; 0x800451 <engine_delta+0x1>
     62e:	40 93 52 04 	sts	0x0452, r20	; 0x800452 <engine_delta+0x2>
     632:	50 93 53 04 	sts	0x0453, r21	; 0x800453 <engine_delta+0x3>
	engine_ov = constrain(engine_delta * engine_kp * 255 / 100, 0, 255);	//calculate output value
     636:	ad ef       	ldi	r26, 0xFD	; 253
     638:	b2 e0       	ldi	r27, 0x02	; 2
     63a:	0e 94 b2 0c 	call	0x1964	; 0x1964 <__muluhisi3>
     63e:	6d 39       	cpi	r22, 0x9D	; 157
     640:	2f ef       	ldi	r18, 0xFF	; 255
     642:	72 07       	cpc	r23, r18
     644:	82 07       	cpc	r24, r18
     646:	92 07       	cpc	r25, r18
     648:	6c f0       	brlt	.+26     	; 0x664 <_Z10run_curtisv+0xf4>
     64a:	61 15       	cp	r22, r1
     64c:	24 e6       	ldi	r18, 0x64	; 100
     64e:	72 07       	cpc	r23, r18
     650:	81 05       	cpc	r24, r1
     652:	91 05       	cpc	r25, r1
     654:	4c f4       	brge	.+18     	; 0x668 <_Z10run_curtisv+0xf8>
     656:	24 e6       	ldi	r18, 0x64	; 100
     658:	30 e0       	ldi	r19, 0x00	; 0
     65a:	40 e0       	ldi	r20, 0x00	; 0
     65c:	50 e0       	ldi	r21, 0x00	; 0
     65e:	0e 94 88 0c 	call	0x1910	; 0x1910 <__divmodsi4>
     662:	03 c0       	rjmp	.+6      	; 0x66a <_Z10run_curtisv+0xfa>
     664:	20 e0       	ldi	r18, 0x00	; 0
     666:	01 c0       	rjmp	.+2      	; 0x66a <_Z10run_curtisv+0xfa>
     668:	2f ef       	ldi	r18, 0xFF	; 255
     66a:	20 93 4b 04 	sts	0x044B, r18	; 0x80044b <engine_ov>
	analogWrite(pwm_drive_throttle, engine_ov);								//Write op to throttle signal of curtis
     66e:	62 2f       	mov	r22, r18
     670:	70 e0       	ldi	r23, 0x00	; 0
     672:	88 e0       	ldi	r24, 0x08	; 8
     674:	90 e0       	ldi	r25, 0x00	; 0
     676:	b2 c0       	rjmp	.+356    	; 0x7dc <_Z11analogWriteii>
     678:	08 95       	ret

0000067a <_Z5drivev>:
	}
}

void drive(){
	//get correct driving input parameters from selected source (remote and auto not implemented, thus being interpreted as idle)
	mode_select();
     67a:	71 dd       	rcall	.-1310   	; 0x15e <_Z11mode_selectv>
	switch(drivemode){
     67c:	80 91 69 04 	lds	r24, 0x0469	; 0x800469 <drivemode>
     680:	90 91 6a 04 	lds	r25, 0x046A	; 0x80046a <drivemode+0x1>
     684:	81 30       	cpi	r24, 0x01	; 1
     686:	91 05       	cpc	r25, r1
     688:	51 f0       	breq	.+20     	; 0x69e <_Z5drivev+0x24>
     68a:	1c f4       	brge	.+6      	; 0x692 <_Z5drivev+0x18>
     68c:	89 2b       	or	r24, r25
     68e:	49 f0       	breq	.+18     	; 0x6a2 <_Z5drivev+0x28>
     690:	0d c0       	rjmp	.+26     	; 0x6ac <_Z5drivev+0x32>
     692:	82 30       	cpi	r24, 0x02	; 2
     694:	91 05       	cpc	r25, r1
     696:	49 f0       	breq	.+18     	; 0x6aa <_Z5drivev+0x30>
     698:	03 97       	sbiw	r24, 0x03	; 3
     69a:	29 f0       	breq	.+10     	; 0x6a6 <_Z5drivev+0x2c>
		case drivemode_joystick:
			mode_joystick();
     69c:	07 c0       	rjmp	.+14     	; 0x6ac <_Z5drivev+0x32>
			break;
     69e:	a2 dd       	rcall	.-1212   	; 0x1e4 <_Z13mode_joystickv>
		case drivemode_idle:
			mode_idle();		
     6a0:	05 c0       	rjmp	.+10     	; 0x6ac <_Z5drivev+0x32>
			break;
		case drivemode_auto:
			mode_idle();		//not yet implemented
     6a2:	4f de       	rcall	.-866    	; 0x342 <_Z9mode_idlev>
			break;
		case drivemode_remote:
			mode_idle();		//not yet implemented
     6a4:	03 c0       	rjmp	.+6      	; 0x6ac <_Z5drivev+0x32>
     6a6:	4d de       	rcall	.-870    	; 0x342 <_Z9mode_idlev>
			break;	
	}
	run_steer();				//update the steering system
     6a8:	01 c0       	rjmp	.+2      	; 0x6ac <_Z5drivev+0x32>
     6aa:	4b de       	rcall	.-874    	; 0x342 <_Z9mode_idlev>
	run_brake();				//update the braking system
     6ac:	c4 de       	rcall	.-632    	; 0x436 <_Z9run_steerv>
     6ae:	7c de       	rcall	.-776    	; 0x3a8 <_Z9run_brakev>
	run_curtis();				//update the Curtis
     6b0:	5f cf       	rjmp	.-322    	; 0x570 <_Z10run_curtisv>
     6b2:	08 95       	ret

000006b4 <_Z6initIOv>:
     6b4:	cf 93       	push	r28
#include "IOPins.h"

//this funcion should be called when initializng the program. It writes the correct settings to the registry, allowing the use of analog and digital reading and writing of pins.
void initIO(){
     6b6:	df 93       	push	r29
	Serial.println("Applying IO settings...");
     6b8:	61 e0       	ldi	r22, 0x01	; 1
     6ba:	72 e0       	ldi	r23, 0x02	; 2
     6bc:	8a e8       	ldi	r24, 0x8A	; 138
     6be:	94 e0       	ldi	r25, 0x04	; 4
     6c0:	cc d7       	rcall	.+3992   	; 0x165a <_ZN5USART7printlnEPKc>
	//Read/Write pins
	//////////////////////////////////////
	//Disable the pullup resistor in these pins, making them output by writing a 1 to their respective registry entries. Pins not written to default to input pins.
	//when adding/altering pins, alter them in the respective switch case as well.
	//digitalwrite
	DDRA |= 0b11111111;
     6c2:	81 b1       	in	r24, 0x01	; 1
     6c4:	8f ef       	ldi	r24, 0xFF	; 255
     6c6:	81 b9       	out	0x01, r24	; 1
	//B pins are reserved for SPI, don't touch those
	DDRC |= 0b11111111;
     6c8:	97 b1       	in	r25, 0x07	; 7
     6ca:	87 b9       	out	0x07, r24	; 7
	DDRD |= 0b10000000;
     6cc:	57 9a       	sbi	0x0a, 7	; 10
	DDRG |= 0b00000111;
     6ce:	83 b3       	in	r24, 0x13	; 19
     6d0:	87 60       	ori	r24, 0x07	; 7
     6d2:	83 bb       	out	0x13, r24	; 19
	//DDRL |= 0b11111111;
	
	//analogwrite, Not all pins support PWM signals, please consult datasheets before altering.
	DDRB |= 0b11110000;
     6d4:	84 b1       	in	r24, 0x04	; 4
     6d6:	80 6f       	ori	r24, 0xF0	; 240
     6d8:	84 b9       	out	0x04, r24	; 4
	DDRE |= 0b00111000;
     6da:	8d b1       	in	r24, 0x0d	; 13
     6dc:	88 63       	ori	r24, 0x38	; 56
     6de:	8d b9       	out	0x0d, r24	; 13
	DDRG |= 0b00100000;
     6e0:	9d 9a       	sbi	0x13, 5	; 19
	DDRH |= 0b01111000;
     6e2:	e1 e0       	ldi	r30, 0x01	; 1
     6e4:	f1 e0       	ldi	r31, 0x01	; 1
     6e6:	80 81       	ld	r24, Z
     6e8:	88 67       	ori	r24, 0x78	; 120
     6ea:	80 83       	st	Z, r24
	DDRL |= 0b00111000;
     6ec:	ea e0       	ldi	r30, 0x0A	; 10
     6ee:	f1 e0       	ldi	r31, 0x01	; 1
     6f0:	80 81       	ld	r24, Z
     6f2:	88 63       	ori	r24, 0x38	; 56
     6f4:	80 83       	st	Z, r24
	//when something is unclear or you want to change some setting, please consult the datasheet first.
	
	//Compare output mode
	//determines how the PWN behaves, now it Clears OCxx on compare match. This makes it so that low value OCRxx will result in short pulses, while higher result in longer ones
	//COM0xx0 will make OCxx toggle on compare match, both will set om compare match. Neither will disable the pmw by disconnecting OCxx.
	TCCR0A |= (( 1 << COM0A1) | (1 << COM0B1));
     6f6:	84 b5       	in	r24, 0x24	; 36
     6f8:	80 6a       	ori	r24, 0xA0	; 160
     6fa:	84 bd       	out	0x24, r24	; 36
	TCCR1A |= (( 1 << COM1A1) | (1 << COM1B1));
     6fc:	c0 e8       	ldi	r28, 0x80	; 128
     6fe:	d0 e0       	ldi	r29, 0x00	; 0
     700:	88 81       	ld	r24, Y
     702:	80 6a       	ori	r24, 0xA0	; 160
     704:	88 83       	st	Y, r24
	TCCR2A |= (( 1 << COM2A1) | (1 << COM2B1));
     706:	a0 eb       	ldi	r26, 0xB0	; 176
     708:	b0 e0       	ldi	r27, 0x00	; 0
     70a:	8c 91       	ld	r24, X
     70c:	80 6a       	ori	r24, 0xA0	; 160
     70e:	8c 93       	st	X, r24
	TCCR3A |= (( 1 << COM3A1) | (1 << COM3B1));
     710:	e0 e9       	ldi	r30, 0x90	; 144
     712:	f0 e0       	ldi	r31, 0x00	; 0
     714:	80 81       	ld	r24, Z
     716:	80 6a       	ori	r24, 0xA0	; 160
     718:	80 83       	st	Z, r24
	//TCCR4A |= (( 1 << COM4A1) | (1 << COM4B1));
	
	//Waveform Generation
	//note that here OCRxA and OCRxB use the same registry and thus also use the same waveform.
	//the current PWM is Fast PMW, but in this case the PWM mode isn't really important.
	TCCR0A |= ((1 << WGM01) | (1 << WGM00));
     71a:	84 b5       	in	r24, 0x24	; 36
     71c:	83 60       	ori	r24, 0x03	; 3
     71e:	84 bd       	out	0x24, r24	; 36
	TCCR1A |= ((1 << WGM12) | (1 << WGM10));		//16 bit timer, scaled back to 8 bit. (TCCR0x and TCCR2x are 8 bit already)
     720:	88 81       	ld	r24, Y
     722:	89 60       	ori	r24, 0x09	; 9
     724:	88 83       	st	Y, r24
	TCCR2A |= ((1 << WGM21) | (1 << WGM20));
     726:	8c 91       	ld	r24, X
     728:	83 60       	ori	r24, 0x03	; 3
     72a:	8c 93       	st	X, r24
	TCCR3A |= ((1 << WGM32) | (1 << WGM30));		//16 bit
     72c:	80 81       	ld	r24, Z
     72e:	89 60       	ori	r24, 0x09	; 9
     730:	80 83       	st	Z, r24
	
	//clock Select
	//currently selected, Internal clock, /8 prescaler. this starts the PWM as well
	//F_CPU=16000000 / 256 / 8 ~= 7812Hz wave
	//again as with the OCRxx, these use the same registry as well and are thus linked
	TCCR0B |= (1 << CS01);
     732:	85 b5       	in	r24, 0x25	; 37
     734:	82 60       	ori	r24, 0x02	; 2
     736:	85 bd       	out	0x25, r24	; 37
	TCCR1B |= (1 << CS11);
     738:	e1 e8       	ldi	r30, 0x81	; 129
     73a:	f0 e0       	ldi	r31, 0x00	; 0
     73c:	80 81       	ld	r24, Z
     73e:	82 60       	ori	r24, 0x02	; 2
     740:	80 83       	st	Z, r24
	TCCR2B |= (1 << CS21);
     742:	e1 eb       	ldi	r30, 0xB1	; 177
     744:	f0 e0       	ldi	r31, 0x00	; 0
     746:	80 81       	ld	r24, Z
     748:	82 60       	ori	r24, 0x02	; 2
     74a:	80 83       	st	Z, r24
	TCCR3B |= (1 << CS31);
     74c:	e1 e9       	ldi	r30, 0x91	; 145
     74e:	f0 e0       	ldi	r31, 0x00	; 0
     750:	80 81       	ld	r24, Z
     752:	82 60       	ori	r24, 0x02	; 2
     754:	80 83       	st	Z, r24
	TCCR4B |= (1 << CS41);
     756:	e1 ea       	ldi	r30, 0xA1	; 161
     758:	f0 e0       	ldi	r31, 0x00	; 0
     75a:	80 81       	ld	r24, Z
     75c:	82 60       	ori	r24, 0x02	; 2
     75e:	80 83       	st	Z, r24
	
	//initialize each pwm as 0
	OCR3B=0;	//pin 2
     760:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <__TEXT_REGION_LENGTH__+0x70009b>
     764:	10 92 9a 00 	sts	0x009A, r1	; 0x80009a <__TEXT_REGION_LENGTH__+0x70009a>
	OCR3C=0;	//pin 3
     768:	10 92 9d 00 	sts	0x009D, r1	; 0x80009d <__TEXT_REGION_LENGTH__+0x70009d>
     76c:	10 92 9c 00 	sts	0x009C, r1	; 0x80009c <__TEXT_REGION_LENGTH__+0x70009c>
	OCR0B=0;	//pin 4
     770:	18 bc       	out	0x28, r1	; 40
	OCR3A=0;	//pin 5
     772:	10 92 99 00 	sts	0x0099, r1	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
     776:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
	OCR4A=0;	//pin 6
     77a:	10 92 a9 00 	sts	0x00A9, r1	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
     77e:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
	OCR4B=0;	//pin 7
     782:	10 92 ab 00 	sts	0x00AB, r1	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
     786:	10 92 aa 00 	sts	0x00AA, r1	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
	OCR4C=0;	//pin 8
     78a:	10 92 ad 00 	sts	0x00AD, r1	; 0x8000ad <__TEXT_REGION_LENGTH__+0x7000ad>
     78e:	10 92 ac 00 	sts	0x00AC, r1	; 0x8000ac <__TEXT_REGION_LENGTH__+0x7000ac>
	OCR2B=0;	//pin 9
     792:	10 92 b4 00 	sts	0x00B4, r1	; 0x8000b4 <__TEXT_REGION_LENGTH__+0x7000b4>
	OCR2A=0;	//pin 10
     796:	10 92 b3 00 	sts	0x00B3, r1	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
	OCR1A=0;	//pin 11
     79a:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     79e:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
	OCR1B=0;	//pin 12
     7a2:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     7a6:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
	OCR1C=0;	//pin 13
     7aa:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
     7ae:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
	//Analog Digital Converter, analogread
	//////////////////////////////////////
	
	//Analog Digital Multiplexer Selection Register, voltage reference selection
	//Current setting: AVcc with external capacitor at AREF pin (internal 5v)
	ADMUX |= (1 << REFS0);
     7b2:	ec e7       	ldi	r30, 0x7C	; 124
     7b4:	f0 e0       	ldi	r31, 0x00	; 0
     7b6:	80 81       	ld	r24, Z
     7b8:	80 64       	ori	r24, 0x40	; 64
     7ba:	80 83       	st	Z, r24
	
	// 1/128 prescaler
	ADCSRA |= (1 << ADPS0) | (1 << ADPS1) | (1 << ADPS2);
     7bc:	ea e7       	ldi	r30, 0x7A	; 122
     7be:	f0 e0       	ldi	r31, 0x00	; 0
     7c0:	80 81       	ld	r24, Z
     7c2:	87 60       	ori	r24, 0x07	; 7
     7c4:	80 83       	st	Z, r24
	
	//enable the ADC convector, and disable GPIO functionality on the ADC pins
	ADCSRA |= (1 << ADEN);
     7c6:	80 81       	ld	r24, Z
     7c8:	80 68       	ori	r24, 0x80	; 128
     7ca:	80 83       	st	Z, r24
	Serial.println("IO setting generated");
     7cc:	69 e1       	ldi	r22, 0x19	; 25
     7ce:	72 e0       	ldi	r23, 0x02	; 2
     7d0:	8a e8       	ldi	r24, 0x8A	; 138
     7d2:	94 e0       	ldi	r25, 0x04	; 4
     7d4:	42 d7       	rcall	.+3716   	; 0x165a <_ZN5USART7printlnEPKc>
	return;
}
     7d6:	df 91       	pop	r29
     7d8:	cf 91       	pop	r28
     7da:	08 95       	ret

000007dc <_Z11analogWriteii>:


//writes a value between 0 and 255 to the correct output compare register
//analogWrite(pin numer, value it should receive).
void analogWrite(int pin,int val){
     7dc:	6f 3f       	cpi	r22, 0xFF	; 255
     7de:	71 05       	cpc	r23, r1
     7e0:	19 f0       	breq	.+6      	; 0x7e8 <_Z11analogWriteii+0xc>
     7e2:	14 f0       	brlt	.+4      	; 0x7e8 <_Z11analogWriteii+0xc>
     7e4:	6f ef       	ldi	r22, 0xFF	; 255
     7e6:	70 e0       	ldi	r23, 0x00	; 0
	if(val>255)			//if the given value exeeds 255, make it 255
	val=255;
	switch(pin){
     7e8:	fc 01       	movw	r30, r24
     7ea:	32 97       	sbiw	r30, 0x02	; 2
     7ec:	eb 30       	cpi	r30, 0x0B	; 11
     7ee:	f1 05       	cpc	r31, r1
     7f0:	b0 f5       	brcc	.+108    	; 0x85e <_Z11analogWriteii+0x82>
     7f2:	88 27       	eor	r24, r24
     7f4:	ee 58       	subi	r30, 0x8E	; 142
     7f6:	ff 4f       	sbci	r31, 0xFF	; 255
     7f8:	8f 4f       	sbci	r24, 0xFF	; 255
     7fa:	0c 94 a4 0c 	jmp	0x1948	; 0x1948 <__tablejump2__>
		case 2:
		OCR3B=val;
     7fe:	70 93 9b 00 	sts	0x009B, r23	; 0x80009b <__TEXT_REGION_LENGTH__+0x70009b>
     802:	60 93 9a 00 	sts	0x009A, r22	; 0x80009a <__TEXT_REGION_LENGTH__+0x70009a>
		return;
     806:	08 95       	ret
		case 3:
		OCR3C=val;
     808:	70 93 9d 00 	sts	0x009D, r23	; 0x80009d <__TEXT_REGION_LENGTH__+0x70009d>
     80c:	60 93 9c 00 	sts	0x009C, r22	; 0x80009c <__TEXT_REGION_LENGTH__+0x70009c>
		return;
     810:	08 95       	ret
		case 4:
		OCR0B=val;
     812:	68 bd       	out	0x28, r22	; 40
		return;
     814:	08 95       	ret
		case 5:
		OCR3A=val;
     816:	70 93 99 00 	sts	0x0099, r23	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
     81a:	60 93 98 00 	sts	0x0098, r22	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
		return;
     81e:	08 95       	ret
		case 6:
		OCR4A=val;
     820:	70 93 a9 00 	sts	0x00A9, r23	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
     824:	60 93 a8 00 	sts	0x00A8, r22	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
		return;
     828:	08 95       	ret
		case 7:
		OCR4B=val;
     82a:	70 93 ab 00 	sts	0x00AB, r23	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
     82e:	60 93 aa 00 	sts	0x00AA, r22	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
		return;
     832:	08 95       	ret
		case 8:
		OCR4C=val;
     834:	70 93 ad 00 	sts	0x00AD, r23	; 0x8000ad <__TEXT_REGION_LENGTH__+0x7000ad>
     838:	60 93 ac 00 	sts	0x00AC, r22	; 0x8000ac <__TEXT_REGION_LENGTH__+0x7000ac>
		return;
     83c:	08 95       	ret
		case 9:
		OCR2B=val;
     83e:	60 93 b4 00 	sts	0x00B4, r22	; 0x8000b4 <__TEXT_REGION_LENGTH__+0x7000b4>
		return;
     842:	08 95       	ret
		case 10:
		OCR2A=val;
     844:	60 93 b3 00 	sts	0x00B3, r22	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
		return;
     848:	08 95       	ret
		case 11:
		OCR1A=val;
     84a:	70 93 89 00 	sts	0x0089, r23	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     84e:	60 93 88 00 	sts	0x0088, r22	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
		return;
     852:	08 95       	ret
		case 12:
		OCR1B=val;
     854:	70 93 8b 00 	sts	0x008B, r23	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     858:	60 93 8a 00 	sts	0x008A, r22	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
		return;
     85c:	08 95       	ret
		}
	Serial.println("ERROR: tried to write analog value to unsupported pin");
     85e:	6e e2       	ldi	r22, 0x2E	; 46
     860:	72 e0       	ldi	r23, 0x02	; 2
     862:	8a e8       	ldi	r24, 0x8A	; 138
     864:	94 e0       	ldi	r25, 0x04	; 4
     866:	f9 c6       	rjmp	.+3570   	; 0x165a <_ZN5USART7printlnEPKc>
     868:	08 95       	ret

0000086a <_Z12digitalWriteib>:
	return;
}

//writes a digital value to a pin.
void digitalWrite(int pin,bool val){
     86a:	cf 93       	push	r28
     86c:	df 93       	push	r29
	if(pin<22||pin>53){					//check if the pin is a digital IO pin
     86e:	9c 01       	movw	r18, r24
     870:	26 51       	subi	r18, 0x16	; 22
     872:	31 09       	sbc	r19, r1
     874:	20 32       	cpi	r18, 0x20	; 32
     876:	31 05       	cpc	r19, r1
     878:	58 f0       	brcs	.+22     	; 0x890 <_Z12digitalWriteib+0x26>
     87a:	ec 01       	movw	r28, r24
		Serial.print("ERROR: tried to write digital value to unsupported digital pin");
     87c:	64 e6       	ldi	r22, 0x64	; 100
     87e:	72 e0       	ldi	r23, 0x02	; 2
     880:	8a e8       	ldi	r24, 0x8A	; 138
     882:	94 e0       	ldi	r25, 0x04	; 4
     884:	d1 d6       	rcall	.+3490   	; 0x1628 <_ZN5USART5printEPKc>
		Serial.println(pin);
     886:	be 01       	movw	r22, r28
     888:	8a e8       	ldi	r24, 0x8A	; 138
     88a:	94 e0       	ldi	r25, 0x04	; 4
     88c:	14 d7       	rcall	.+3624   	; 0x16b6 <_ZN5USART7printlnEi>
     88e:	b9 c0       	rjmp	.+370    	; 0xa02 <_Z12digitalWriteib+0x198>
	}
	else if(pin<30){					//check if pin is in the A register
     890:	8e 31       	cpi	r24, 0x1E	; 30
     892:	91 05       	cpc	r25, r1
     894:	f4 f4       	brge	.+60     	; 0x8d2 <_Z12digitalWriteib+0x68>
		pin-=22;						//make pinrange 0-7
     896:	46 97       	sbiw	r24, 0x16	; 22
		if(val) PORTA |= (1<<pin);		//set correct bit in A register is val==true
     898:	66 23       	and	r22, r22
     89a:	69 f0       	breq	.+26     	; 0x8b6 <_Z12digitalWriteib+0x4c>
     89c:	42 b1       	in	r20, 0x02	; 2
     89e:	21 e0       	ldi	r18, 0x01	; 1
     8a0:	30 e0       	ldi	r19, 0x00	; 0
     8a2:	b9 01       	movw	r22, r18
     8a4:	02 c0       	rjmp	.+4      	; 0x8aa <_Z12digitalWriteib+0x40>
     8a6:	66 0f       	add	r22, r22
     8a8:	77 1f       	adc	r23, r23
     8aa:	8a 95       	dec	r24
     8ac:	e2 f7       	brpl	.-8      	; 0x8a6 <_Z12digitalWriteib+0x3c>
     8ae:	cb 01       	movw	r24, r22
     8b0:	84 2b       	or	r24, r20
     8b2:	82 b9       	out	0x02, r24	; 2
     8b4:	a6 c0       	rjmp	.+332    	; 0xa02 <_Z12digitalWriteib+0x198>
		else PORTA &= ~(1<<pin);		//unset bit if false
     8b6:	42 b1       	in	r20, 0x02	; 2
     8b8:	21 e0       	ldi	r18, 0x01	; 1
     8ba:	30 e0       	ldi	r19, 0x00	; 0
     8bc:	b9 01       	movw	r22, r18
     8be:	02 c0       	rjmp	.+4      	; 0x8c4 <_Z12digitalWriteib+0x5a>
     8c0:	66 0f       	add	r22, r22
     8c2:	77 1f       	adc	r23, r23
     8c4:	8a 95       	dec	r24
     8c6:	e2 f7       	brpl	.-8      	; 0x8c0 <_Z12digitalWriteib+0x56>
     8c8:	cb 01       	movw	r24, r22
     8ca:	80 95       	com	r24
     8cc:	84 23       	and	r24, r20
     8ce:	82 b9       	out	0x02, r24	; 2
     8d0:	98 c0       	rjmp	.+304    	; 0xa02 <_Z12digitalWriteib+0x198>
	}
	else if(pin<38){
     8d2:	86 32       	cpi	r24, 0x26	; 38
     8d4:	91 05       	cpc	r25, r1
     8d6:	1c f5       	brge	.+70     	; 0x91e <_Z12digitalWriteib+0xb4>
		pin=(37-pin);
     8d8:	25 e2       	ldi	r18, 0x25	; 37
     8da:	30 e0       	ldi	r19, 0x00	; 0
     8dc:	a9 01       	movw	r20, r18
     8de:	48 1b       	sub	r20, r24
     8e0:	59 0b       	sbc	r21, r25
     8e2:	ca 01       	movw	r24, r20
		if(val) PORTC |= (1<<pin);
     8e4:	66 23       	and	r22, r22
     8e6:	69 f0       	breq	.+26     	; 0x902 <_Z12digitalWriteib+0x98>
     8e8:	48 b1       	in	r20, 0x08	; 8
     8ea:	21 e0       	ldi	r18, 0x01	; 1
     8ec:	30 e0       	ldi	r19, 0x00	; 0
     8ee:	b9 01       	movw	r22, r18
     8f0:	02 c0       	rjmp	.+4      	; 0x8f6 <_Z12digitalWriteib+0x8c>
     8f2:	66 0f       	add	r22, r22
     8f4:	77 1f       	adc	r23, r23
     8f6:	8a 95       	dec	r24
     8f8:	e2 f7       	brpl	.-8      	; 0x8f2 <_Z12digitalWriteib+0x88>
     8fa:	cb 01       	movw	r24, r22
     8fc:	84 2b       	or	r24, r20
     8fe:	88 b9       	out	0x08, r24	; 8
     900:	80 c0       	rjmp	.+256    	; 0xa02 <_Z12digitalWriteib+0x198>
		else PORTC &= ~(1<<pin);
     902:	48 b1       	in	r20, 0x08	; 8
     904:	21 e0       	ldi	r18, 0x01	; 1
     906:	30 e0       	ldi	r19, 0x00	; 0
     908:	b9 01       	movw	r22, r18
     90a:	02 c0       	rjmp	.+4      	; 0x910 <_Z12digitalWriteib+0xa6>
     90c:	66 0f       	add	r22, r22
     90e:	77 1f       	adc	r23, r23
     910:	8a 95       	dec	r24
     912:	e2 f7       	brpl	.-8      	; 0x90c <_Z12digitalWriteib+0xa2>
     914:	cb 01       	movw	r24, r22
     916:	80 95       	com	r24
     918:	84 23       	and	r24, r20
     91a:	88 b9       	out	0x08, r24	; 8
     91c:	72 c0       	rjmp	.+228    	; 0xa02 <_Z12digitalWriteib+0x198>
	}
	else if(pin==38){
     91e:	86 32       	cpi	r24, 0x26	; 38
     920:	91 05       	cpc	r25, r1
     922:	31 f4       	brne	.+12     	; 0x930 <_Z12digitalWriteib+0xc6>
		if(val) PORTD |= (1<<PIND7);
     924:	66 23       	and	r22, r22
     926:	11 f0       	breq	.+4      	; 0x92c <_Z12digitalWriteib+0xc2>
     928:	5f 9a       	sbi	0x0b, 7	; 11
     92a:	6b c0       	rjmp	.+214    	; 0xa02 <_Z12digitalWriteib+0x198>
		else PORTD &= ~(1<<PIND7);
     92c:	5f 98       	cbi	0x0b, 7	; 11
     92e:	69 c0       	rjmp	.+210    	; 0xa02 <_Z12digitalWriteib+0x198>
	}
	else if(pin<42){
     930:	8a 32       	cpi	r24, 0x2A	; 42
     932:	91 05       	cpc	r25, r1
     934:	ec f4       	brge	.+58     	; 0x970 <_Z12digitalWriteib+0x106>
		pin=(41-pin);
     936:	29 e2       	ldi	r18, 0x29	; 41
     938:	30 e0       	ldi	r19, 0x00	; 0
     93a:	28 1b       	sub	r18, r24
     93c:	39 0b       	sbc	r19, r25
		if(val) PORTG |= (1<<pin);
     93e:	66 23       	and	r22, r22
     940:	59 f0       	breq	.+22     	; 0x958 <_Z12digitalWriteib+0xee>
     942:	34 b3       	in	r19, 0x14	; 20
     944:	81 e0       	ldi	r24, 0x01	; 1
     946:	90 e0       	ldi	r25, 0x00	; 0
     948:	02 c0       	rjmp	.+4      	; 0x94e <_Z12digitalWriteib+0xe4>
     94a:	88 0f       	add	r24, r24
     94c:	99 1f       	adc	r25, r25
     94e:	2a 95       	dec	r18
     950:	e2 f7       	brpl	.-8      	; 0x94a <_Z12digitalWriteib+0xe0>
     952:	83 2b       	or	r24, r19
     954:	84 bb       	out	0x14, r24	; 20
     956:	55 c0       	rjmp	.+170    	; 0xa02 <_Z12digitalWriteib+0x198>
		else PORTG &= ~(1<<pin);
     958:	34 b3       	in	r19, 0x14	; 20
     95a:	81 e0       	ldi	r24, 0x01	; 1
     95c:	90 e0       	ldi	r25, 0x00	; 0
     95e:	02 c0       	rjmp	.+4      	; 0x964 <_Z12digitalWriteib+0xfa>
     960:	88 0f       	add	r24, r24
     962:	99 1f       	adc	r25, r25
     964:	2a 95       	dec	r18
     966:	e2 f7       	brpl	.-8      	; 0x960 <_Z12digitalWriteib+0xf6>
     968:	80 95       	com	r24
     96a:	83 23       	and	r24, r19
     96c:	84 bb       	out	0x14, r24	; 20
     96e:	49 c0       	rjmp	.+146    	; 0xa02 <_Z12digitalWriteib+0x198>
	}
	else if(pin<50){
     970:	82 33       	cpi	r24, 0x32	; 50
     972:	91 05       	cpc	r25, r1
     974:	0c f5       	brge	.+66     	; 0x9b8 <_Z12digitalWriteib+0x14e>
		pin=(49-pin);
     976:	21 e3       	ldi	r18, 0x31	; 49
     978:	30 e0       	ldi	r19, 0x00	; 0
     97a:	28 1b       	sub	r18, r24
     97c:	39 0b       	sbc	r19, r25
		if(val) PORTL |= (1<<pin);
     97e:	66 23       	and	r22, r22
     980:	69 f0       	breq	.+26     	; 0x99c <_Z12digitalWriteib+0x132>
     982:	eb e0       	ldi	r30, 0x0B	; 11
     984:	f1 e0       	ldi	r31, 0x01	; 1
     986:	30 81       	ld	r19, Z
     988:	81 e0       	ldi	r24, 0x01	; 1
     98a:	90 e0       	ldi	r25, 0x00	; 0
     98c:	02 c0       	rjmp	.+4      	; 0x992 <_Z12digitalWriteib+0x128>
     98e:	88 0f       	add	r24, r24
     990:	99 1f       	adc	r25, r25
     992:	2a 95       	dec	r18
     994:	e2 f7       	brpl	.-8      	; 0x98e <_Z12digitalWriteib+0x124>
     996:	83 2b       	or	r24, r19
     998:	80 83       	st	Z, r24
     99a:	33 c0       	rjmp	.+102    	; 0xa02 <_Z12digitalWriteib+0x198>
		else PORTL &= ~(1<<pin);
     99c:	eb e0       	ldi	r30, 0x0B	; 11
     99e:	f1 e0       	ldi	r31, 0x01	; 1
     9a0:	30 81       	ld	r19, Z
     9a2:	81 e0       	ldi	r24, 0x01	; 1
     9a4:	90 e0       	ldi	r25, 0x00	; 0
     9a6:	02 c0       	rjmp	.+4      	; 0x9ac <_Z12digitalWriteib+0x142>
     9a8:	88 0f       	add	r24, r24
     9aa:	99 1f       	adc	r25, r25
     9ac:	2a 95       	dec	r18
     9ae:	e2 f7       	brpl	.-8      	; 0x9a8 <_Z12digitalWriteib+0x13e>
     9b0:	80 95       	com	r24
     9b2:	83 23       	and	r24, r19
     9b4:	80 83       	st	Z, r24
     9b6:	25 c0       	rjmp	.+74     	; 0xa02 <_Z12digitalWriteib+0x198>
	}
	else if(pin<54){
     9b8:	86 33       	cpi	r24, 0x36	; 54
     9ba:	91 05       	cpc	r25, r1
     9bc:	14 f5       	brge	.+68     	; 0xa02 <_Z12digitalWriteib+0x198>
		pin=(53-pin);
     9be:	25 e3       	ldi	r18, 0x35	; 53
     9c0:	30 e0       	ldi	r19, 0x00	; 0
     9c2:	a9 01       	movw	r20, r18
     9c4:	48 1b       	sub	r20, r24
     9c6:	59 0b       	sbc	r21, r25
     9c8:	ca 01       	movw	r24, r20
		if(val) PORTB |= (1<<pin);
     9ca:	66 23       	and	r22, r22
     9cc:	69 f0       	breq	.+26     	; 0x9e8 <_Z12digitalWriteib+0x17e>
     9ce:	45 b1       	in	r20, 0x05	; 5
     9d0:	21 e0       	ldi	r18, 0x01	; 1
     9d2:	30 e0       	ldi	r19, 0x00	; 0
     9d4:	b9 01       	movw	r22, r18
     9d6:	02 c0       	rjmp	.+4      	; 0x9dc <_Z12digitalWriteib+0x172>
     9d8:	66 0f       	add	r22, r22
     9da:	77 1f       	adc	r23, r23
     9dc:	8a 95       	dec	r24
     9de:	e2 f7       	brpl	.-8      	; 0x9d8 <_Z12digitalWriteib+0x16e>
     9e0:	cb 01       	movw	r24, r22
     9e2:	84 2b       	or	r24, r20
     9e4:	85 b9       	out	0x05, r24	; 5
     9e6:	0d c0       	rjmp	.+26     	; 0xa02 <_Z12digitalWriteib+0x198>
		else PORTB &= ~(1<<pin);
     9e8:	45 b1       	in	r20, 0x05	; 5
     9ea:	21 e0       	ldi	r18, 0x01	; 1
     9ec:	30 e0       	ldi	r19, 0x00	; 0
     9ee:	b9 01       	movw	r22, r18
     9f0:	02 c0       	rjmp	.+4      	; 0x9f6 <_Z12digitalWriteib+0x18c>
     9f2:	66 0f       	add	r22, r22
     9f4:	77 1f       	adc	r23, r23
     9f6:	8a 95       	dec	r24
     9f8:	e2 f7       	brpl	.-8      	; 0x9f2 <_Z12digitalWriteib+0x188>
     9fa:	cb 01       	movw	r24, r22
     9fc:	80 95       	com	r24
     9fe:	84 23       	and	r24, r20
     a00:	85 b9       	out	0x05, r24	; 5
	}
	return;
}
     a02:	df 91       	pop	r29
     a04:	cf 91       	pop	r28
     a06:	08 95       	ret

00000a08 <_Z11digitalReadi>:

bool digitalRead(int pin){
     a08:	cf 93       	push	r28
     a0a:	df 93       	push	r29
	if(pin==4){
     a0c:	84 30       	cpi	r24, 0x04	; 4
     a0e:	91 05       	cpc	r25, r1
     a10:	29 f4       	brne	.+10     	; 0xa1c <_Z11digitalReadi+0x14>
		if(PING&(1<<PING5))	return true;
     a12:	82 b3       	in	r24, 0x12	; 18
     a14:	85 fb       	bst	r24, 5
     a16:	88 27       	eor	r24, r24
     a18:	80 f9       	bld	r24, 0
     a1a:	6f c0       	rjmp	.+222    	; 0xafa <_Z11digitalReadi+0xf2>
	}
	else if(pin<30){					//check if pin is in the A register
     a1c:	8e 31       	cpi	r24, 0x1E	; 30
     a1e:	91 05       	cpc	r25, r1
     a20:	64 f4       	brge	.+24     	; 0xa3a <_Z11digitalReadi+0x32>
		pin-=22;						//make pinrange 0-7
		if(PINA&(1<<pin))	return true;							//break function
     a22:	20 b1       	in	r18, 0x00	; 0
     a24:	30 e0       	ldi	r19, 0x00	; 0
     a26:	46 97       	sbiw	r24, 0x16	; 22
     a28:	a9 01       	movw	r20, r18
     a2a:	02 c0       	rjmp	.+4      	; 0xa30 <_Z11digitalReadi+0x28>
     a2c:	55 95       	asr	r21
     a2e:	47 95       	ror	r20
     a30:	8a 95       	dec	r24
     a32:	e2 f7       	brpl	.-8      	; 0xa2c <_Z11digitalReadi+0x24>
     a34:	ca 01       	movw	r24, r20
     a36:	81 70       	andi	r24, 0x01	; 1
     a38:	60 c0       	rjmp	.+192    	; 0xafa <_Z11digitalReadi+0xf2>
	}
	else if(pin<38){
     a3a:	86 32       	cpi	r24, 0x26	; 38
     a3c:	91 05       	cpc	r25, r1
     a3e:	84 f4       	brge	.+32     	; 0xa60 <_Z11digitalReadi+0x58>
		pin=37-pin;
		if(PINC&(1<<pin))	return true;							//break function
     a40:	26 b1       	in	r18, 0x06	; 6
     a42:	30 e0       	ldi	r19, 0x00	; 0
     a44:	45 e2       	ldi	r20, 0x25	; 37
     a46:	50 e0       	ldi	r21, 0x00	; 0
     a48:	ba 01       	movw	r22, r20
     a4a:	68 1b       	sub	r22, r24
     a4c:	79 0b       	sbc	r23, r25
     a4e:	a9 01       	movw	r20, r18
     a50:	02 c0       	rjmp	.+4      	; 0xa56 <_Z11digitalReadi+0x4e>
     a52:	55 95       	asr	r21
     a54:	47 95       	ror	r20
     a56:	6a 95       	dec	r22
     a58:	e2 f7       	brpl	.-8      	; 0xa52 <_Z11digitalReadi+0x4a>
     a5a:	ca 01       	movw	r24, r20
     a5c:	81 70       	andi	r24, 0x01	; 1
     a5e:	4d c0       	rjmp	.+154    	; 0xafa <_Z11digitalReadi+0xf2>
	}
	else if(pin==38){
     a60:	86 32       	cpi	r24, 0x26	; 38
     a62:	91 05       	cpc	r25, r1
     a64:	29 f4       	brne	.+10     	; 0xa70 <_Z11digitalReadi+0x68>
		if(PIND&(1<<PIND7))	return true;							//break function
     a66:	89 b1       	in	r24, 0x09	; 9
     a68:	88 1f       	adc	r24, r24
     a6a:	88 27       	eor	r24, r24
     a6c:	88 1f       	adc	r24, r24
     a6e:	45 c0       	rjmp	.+138    	; 0xafa <_Z11digitalReadi+0xf2>
	}
	else if(pin<42){
     a70:	8a 32       	cpi	r24, 0x2A	; 42
     a72:	91 05       	cpc	r25, r1
     a74:	84 f4       	brge	.+32     	; 0xa96 <_Z11digitalReadi+0x8e>
		pin=41-pin;
		if(PING&(1<<pin))	return true;							//break function
     a76:	22 b3       	in	r18, 0x12	; 18
     a78:	30 e0       	ldi	r19, 0x00	; 0
     a7a:	49 e2       	ldi	r20, 0x29	; 41
     a7c:	50 e0       	ldi	r21, 0x00	; 0
     a7e:	ba 01       	movw	r22, r20
     a80:	68 1b       	sub	r22, r24
     a82:	79 0b       	sbc	r23, r25
     a84:	a9 01       	movw	r20, r18
     a86:	02 c0       	rjmp	.+4      	; 0xa8c <_Z11digitalReadi+0x84>
     a88:	55 95       	asr	r21
     a8a:	47 95       	ror	r20
     a8c:	6a 95       	dec	r22
     a8e:	e2 f7       	brpl	.-8      	; 0xa88 <_Z11digitalReadi+0x80>
     a90:	ca 01       	movw	r24, r20
     a92:	81 70       	andi	r24, 0x01	; 1
     a94:	32 c0       	rjmp	.+100    	; 0xafa <_Z11digitalReadi+0xf2>
	}
	else if(pin<50){
     a96:	82 33       	cpi	r24, 0x32	; 50
     a98:	91 05       	cpc	r25, r1
     a9a:	8c f4       	brge	.+34     	; 0xabe <_Z11digitalReadi+0xb6>
		pin=49-pin;
		if(PINL&(1<<pin))	return true;							//break function
     a9c:	20 91 09 01 	lds	r18, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
     aa0:	30 e0       	ldi	r19, 0x00	; 0
     aa2:	41 e3       	ldi	r20, 0x31	; 49
     aa4:	50 e0       	ldi	r21, 0x00	; 0
     aa6:	ba 01       	movw	r22, r20
     aa8:	68 1b       	sub	r22, r24
     aaa:	79 0b       	sbc	r23, r25
     aac:	a9 01       	movw	r20, r18
     aae:	02 c0       	rjmp	.+4      	; 0xab4 <_Z11digitalReadi+0xac>
     ab0:	55 95       	asr	r21
     ab2:	47 95       	ror	r20
     ab4:	6a 95       	dec	r22
     ab6:	e2 f7       	brpl	.-8      	; 0xab0 <_Z11digitalReadi+0xa8>
     ab8:	ca 01       	movw	r24, r20
     aba:	81 70       	andi	r24, 0x01	; 1
     abc:	1e c0       	rjmp	.+60     	; 0xafa <_Z11digitalReadi+0xf2>
	}
	else if(pin<54){
     abe:	86 33       	cpi	r24, 0x36	; 54
     ac0:	91 05       	cpc	r25, r1
     ac2:	84 f4       	brge	.+32     	; 0xae4 <_Z11digitalReadi+0xdc>
		pin=(53-pin);
		if(PINB&(1<<pin))	return true;							//break function
     ac4:	23 b1       	in	r18, 0x03	; 3
     ac6:	30 e0       	ldi	r19, 0x00	; 0
     ac8:	45 e3       	ldi	r20, 0x35	; 53
     aca:	50 e0       	ldi	r21, 0x00	; 0
     acc:	ba 01       	movw	r22, r20
     ace:	68 1b       	sub	r22, r24
     ad0:	79 0b       	sbc	r23, r25
     ad2:	a9 01       	movw	r20, r18
     ad4:	02 c0       	rjmp	.+4      	; 0xada <_Z11digitalReadi+0xd2>
     ad6:	55 95       	asr	r21
     ad8:	47 95       	ror	r20
     ada:	6a 95       	dec	r22
     adc:	e2 f7       	brpl	.-8      	; 0xad6 <_Z11digitalReadi+0xce>
     ade:	ca 01       	movw	r24, r20
     ae0:	81 70       	andi	r24, 0x01	; 1
     ae2:	0b c0       	rjmp	.+22     	; 0xafa <_Z11digitalReadi+0xf2>
     ae4:	ec 01       	movw	r28, r24
	}
	else{					//pin unsupported
		Serial.print("ERROR: tried to read digital value from unsupported digital pin: ");
     ae6:	63 ea       	ldi	r22, 0xA3	; 163
     ae8:	72 e0       	ldi	r23, 0x02	; 2
     aea:	8a e8       	ldi	r24, 0x8A	; 138
     aec:	94 e0       	ldi	r25, 0x04	; 4
     aee:	9c d5       	rcall	.+2872   	; 0x1628 <_ZN5USART5printEPKc>
		Serial.println(pin);
     af0:	be 01       	movw	r22, r28
     af2:	8a e8       	ldi	r24, 0x8A	; 138
     af4:	94 e0       	ldi	r25, 0x04	; 4
     af6:	df d5       	rcall	.+3006   	; 0x16b6 <_ZN5USART7printlnEi>
		return false;
     af8:	80 e0       	ldi	r24, 0x00	; 0
	}
	return false;	
}
     afa:	df 91       	pop	r29
     afc:	cf 91       	pop	r28
     afe:	08 95       	ret

00000b00 <_Z10analogReadi>:

int analogRead(int pin){
     b00:	cf 93       	push	r28
     b02:	df 93       	push	r29
	//set correct MUX registers, these determine on which pin the ADC should read it's value
	//first the MUXx bits are cleared, then filled to prevent old setting leaking though
	
	ADMUX &=(0b11100000);							//clear the bottom 4 bit
     b04:	ec e7       	ldi	r30, 0x7C	; 124
     b06:	f0 e0       	ldi	r31, 0x00	; 0
     b08:	20 81       	ld	r18, Z
     b0a:	20 7e       	andi	r18, 0xE0	; 224
     b0c:	20 83       	st	Z, r18
	ADCSRB &=(0b11110111);							//clear the top one bit
     b0e:	eb e7       	ldi	r30, 0x7B	; 123
     b10:	f0 e0       	ldi	r31, 0x00	; 0
     b12:	20 81       	ld	r18, Z
     b14:	27 7f       	andi	r18, 0xF7	; 247
     b16:	20 83       	st	Z, r18
	if(pin<8)										//if adc #0-7
     b18:	88 30       	cpi	r24, 0x08	; 8
     b1a:	91 05       	cpc	r25, r1
     b1c:	34 f4       	brge	.+12     	; 0xb2a <_Z10analogReadi+0x2a>
	ADMUX |= pin;								//write the full pin to the ADMUX registry
     b1e:	ec e7       	ldi	r30, 0x7C	; 124
     b20:	f0 e0       	ldi	r31, 0x00	; 0
     b22:	90 81       	ld	r25, Z
     b24:	89 2b       	or	r24, r25
     b26:	80 83       	st	Z, r24
     b28:	1c c0       	rjmp	.+56     	; 0xb62 <_Z10analogReadi+0x62>
	else if(pin<16){									//if adc #8-15
     b2a:	80 31       	cpi	r24, 0x10	; 16
     b2c:	91 05       	cpc	r25, r1
     b2e:	64 f4       	brge	.+24     	; 0xb48 <_Z10analogReadi+0x48>
		ADCSRB |= (1<<3);							//write upper bit to ADCSRB register
     b30:	eb e7       	ldi	r30, 0x7B	; 123
     b32:	f0 e0       	ldi	r31, 0x00	; 0
     b34:	90 81       	ld	r25, Z
     b36:	98 60       	ori	r25, 0x08	; 8
     b38:	90 83       	st	Z, r25
		ADMUX |= (pin-8);							//write lower bits to ADMUX registry
     b3a:	ec e7       	ldi	r30, 0x7C	; 124
     b3c:	f0 e0       	ldi	r31, 0x00	; 0
     b3e:	90 81       	ld	r25, Z
     b40:	88 50       	subi	r24, 0x08	; 8
     b42:	89 2b       	or	r24, r25
     b44:	80 83       	st	Z, r24
     b46:	0d c0       	rjmp	.+26     	; 0xb62 <_Z10analogReadi+0x62>
     b48:	ec 01       	movw	r28, r24
	}
	else{
		Serial.print("ERROR: tried to read digital value from unsupported analog pin ");
     b4a:	65 ee       	ldi	r22, 0xE5	; 229
     b4c:	72 e0       	ldi	r23, 0x02	; 2
     b4e:	8a e8       	ldi	r24, 0x8A	; 138
     b50:	94 e0       	ldi	r25, 0x04	; 4
     b52:	6a d5       	rcall	.+2772   	; 0x1628 <_ZN5USART5printEPKc>
		Serial.println(pin);
     b54:	be 01       	movw	r22, r28
     b56:	8a e8       	ldi	r24, 0x8A	; 138
     b58:	94 e0       	ldi	r25, 0x04	; 4
     b5a:	ad d5       	rcall	.+2906   	; 0x16b6 <_ZN5USART7printlnEi>
		return 0;
     b5c:	80 e0       	ldi	r24, 0x00	; 0
     b5e:	90 e0       	ldi	r25, 0x00	; 0
     b60:	0c c0       	rjmp	.+24     	; 0xb7a <_Z10analogReadi+0x7a>
	}
	ADCSRA |= (1<<ADSC);							//start ADC conversion
     b62:	ea e7       	ldi	r30, 0x7A	; 122
     b64:	f0 e0       	ldi	r31, 0x00	; 0
     b66:	80 81       	ld	r24, Z
     b68:	80 64       	ori	r24, 0x40	; 64
     b6a:	80 83       	st	Z, r24
	while(ADCSRA & (1<<ADSC));						//wait until the ADSC is 0 again and the conversion is done
     b6c:	80 81       	ld	r24, Z
     b6e:	86 fd       	sbrc	r24, 6
     b70:	fd cf       	rjmp	.-6      	; 0xb6c <_Z10analogReadi+0x6c>
	return ADC;										//return the byte in ADLAR, the result of the ADC conversion
     b72:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
     b76:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
}
     b7a:	df 91       	pop	r29
     b7c:	cf 91       	pop	r28
     b7e:	08 95       	ret

00000b80 <_Z9printinfov>:
}

#ifdef DEBUG_MODE									//only spam terminal when in debug mode
void printinfo(){

	Serial.print("DM: ");
     b80:	65 e2       	ldi	r22, 0x25	; 37
     b82:	73 e0       	ldi	r23, 0x03	; 3
     b84:	8a e8       	ldi	r24, 0x8A	; 138
     b86:	94 e0       	ldi	r25, 0x04	; 4
     b88:	4f d5       	rcall	.+2718   	; 0x1628 <_ZN5USART5printEPKc>
	Serial.print(drivemode);
     b8a:	60 91 69 04 	lds	r22, 0x0469	; 0x800469 <drivemode>
     b8e:	70 91 6a 04 	lds	r23, 0x046A	; 0x80046a <drivemode+0x1>
     b92:	8a e8       	ldi	r24, 0x8A	; 138
     b94:	94 e0       	ldi	r25, 0x04	; 4
     b96:	6c d5       	rcall	.+2776   	; 0x1670 <_ZN5USART5printEi>
	Serial.print(" drive dir: ");
     b98:	6a e2       	ldi	r22, 0x2A	; 42
     b9a:	73 e0       	ldi	r23, 0x03	; 3
     b9c:	8a e8       	ldi	r24, 0x8A	; 138
     b9e:	94 e0       	ldi	r25, 0x04	; 4
     ba0:	43 d5       	rcall	.+2694   	; 0x1628 <_ZN5USART5printEPKc>
	Serial.print(driving_direction);
     ba2:	60 91 00 02 	lds	r22, 0x0200	; 0x800200 <__data_start>
     ba6:	70 e0       	ldi	r23, 0x00	; 0
     ba8:	8a e8       	ldi	r24, 0x8A	; 138
     baa:	94 e0       	ldi	r25, 0x04	; 4
     bac:	61 d5       	rcall	.+2754   	; 0x1670 <_ZN5USART5printEi>
	Serial.print(" engine_dv = ");
     bae:	67 e3       	ldi	r22, 0x37	; 55
     bb0:	73 e0       	ldi	r23, 0x03	; 3
     bb2:	8a e8       	ldi	r24, 0x8A	; 138
     bb4:	94 e0       	ldi	r25, 0x04	; 4
     bb6:	38 d5       	rcall	.+2672   	; 0x1628 <_ZN5USART5printEPKc>
	Serial.print(engine_dv);
     bb8:	60 91 54 04 	lds	r22, 0x0454	; 0x800454 <engine_dv>
     bbc:	70 91 55 04 	lds	r23, 0x0455	; 0x800455 <engine_dv+0x1>
     bc0:	8a e8       	ldi	r24, 0x8A	; 138
     bc2:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" speed. = ");
     bc4:	55 d5       	rcall	.+2730   	; 0x1670 <_ZN5USART5printEi>
     bc6:	65 e4       	ldi	r22, 0x45	; 69
     bc8:	73 e0       	ldi	r23, 0x03	; 3
     bca:	8a e8       	ldi	r24, 0x8A	; 138
     bcc:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(engine_cv);
     bce:	2c d5       	rcall	.+2648   	; 0x1628 <_ZN5USART5printEPKc>
     bd0:	60 91 4c 04 	lds	r22, 0x044C	; 0x80044c <engine_cv>
     bd4:	70 91 4d 04 	lds	r23, 0x044D	; 0x80044d <engine_cv+0x1>
     bd8:	8a e8       	ldi	r24, 0x8A	; 138
     bda:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" engine_ov = ");
     bdc:	49 d5       	rcall	.+2706   	; 0x1670 <_ZN5USART5printEi>
     bde:	60 e5       	ldi	r22, 0x50	; 80
     be0:	73 e0       	ldi	r23, 0x03	; 3
     be2:	8a e8       	ldi	r24, 0x8A	; 138
     be4:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(engine_ov);
     be6:	20 d5       	rcall	.+2624   	; 0x1628 <_ZN5USART5printEPKc>
     be8:	60 91 4b 04 	lds	r22, 0x044B	; 0x80044b <engine_ov>
     bec:	70 e0       	ldi	r23, 0x00	; 0
     bee:	8a e8       	ldi	r24, 0x8A	; 138
     bf0:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" brake_dv = ");
     bf2:	3e d5       	rcall	.+2684   	; 0x1670 <_ZN5USART5printEi>
     bf4:	6e e5       	ldi	r22, 0x5E	; 94
     bf6:	73 e0       	ldi	r23, 0x03	; 3
     bf8:	8a e8       	ldi	r24, 0x8A	; 138
     bfa:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(braking_dv);
     bfc:	15 d5       	rcall	.+2602   	; 0x1628 <_ZN5USART5printEPKc>
     bfe:	60 91 47 04 	lds	r22, 0x0447	; 0x800447 <braking_dv>
     c02:	70 91 48 04 	lds	r23, 0x0448	; 0x800448 <braking_dv+0x1>
     c06:	8a e8       	ldi	r24, 0x8A	; 138
	Serial.print(" braking_ov = ");
     c08:	94 e0       	ldi	r25, 0x04	; 4
     c0a:	32 d5       	rcall	.+2660   	; 0x1670 <_ZN5USART5printEi>
     c0c:	6b e6       	ldi	r22, 0x6B	; 107
     c0e:	73 e0       	ldi	r23, 0x03	; 3
     c10:	8a e8       	ldi	r24, 0x8A	; 138
	Serial.print(braking_ov);
     c12:	94 e0       	ldi	r25, 0x04	; 4
     c14:	09 d5       	rcall	.+2578   	; 0x1628 <_ZN5USART5printEPKc>
     c16:	60 91 3e 04 	lds	r22, 0x043E	; 0x80043e <braking_ov>
     c1a:	70 e0       	ldi	r23, 0x00	; 0
     c1c:	8a e8       	ldi	r24, 0x8A	; 138

	Serial.print(" steering_dv = ");
     c1e:	94 e0       	ldi	r25, 0x04	; 4
     c20:	27 d5       	rcall	.+2638   	; 0x1670 <_ZN5USART5printEi>
     c22:	6a e7       	ldi	r22, 0x7A	; 122
     c24:	73 e0       	ldi	r23, 0x03	; 3
     c26:	8a e8       	ldi	r24, 0x8A	; 138
	Serial.print(steering_dv);
     c28:	94 e0       	ldi	r25, 0x04	; 4
     c2a:	fe d4       	rcall	.+2556   	; 0x1628 <_ZN5USART5printEPKc>
     c2c:	60 91 61 04 	lds	r22, 0x0461	; 0x800461 <steering_dv>
     c30:	70 91 62 04 	lds	r23, 0x0462	; 0x800462 <steering_dv+0x1>
     c34:	8a e8       	ldi	r24, 0x8A	; 138
	Serial.print(" steering_cv = ");
     c36:	94 e0       	ldi	r25, 0x04	; 4
     c38:	1b d5       	rcall	.+2614   	; 0x1670 <_ZN5USART5printEi>
     c3a:	6a e8       	ldi	r22, 0x8A	; 138
     c3c:	73 e0       	ldi	r23, 0x03	; 3
     c3e:	8a e8       	ldi	r24, 0x8A	; 138
	Serial.print(steering_cv);
     c40:	94 e0       	ldi	r25, 0x04	; 4
     c42:	f2 d4       	rcall	.+2532   	; 0x1628 <_ZN5USART5printEPKc>
     c44:	60 91 59 04 	lds	r22, 0x0459	; 0x800459 <steering_cv>
     c48:	70 91 5a 04 	lds	r23, 0x045A	; 0x80045a <steering_cv+0x1>
	Serial.print(" steering_ov = ");
     c4c:	8a e8       	ldi	r24, 0x8A	; 138
     c4e:	94 e0       	ldi	r25, 0x04	; 4
     c50:	0f d5       	rcall	.+2590   	; 0x1670 <_ZN5USART5printEi>
     c52:	6a e9       	ldi	r22, 0x9A	; 154
     c54:	73 e0       	ldi	r23, 0x03	; 3
	Serial.print(steering_ov);
     c56:	8a e8       	ldi	r24, 0x8A	; 138
     c58:	94 e0       	ldi	r25, 0x04	; 4
     c5a:	e6 d4       	rcall	.+2508   	; 0x1628 <_ZN5USART5printEPKc>
     c5c:	60 91 58 04 	lds	r22, 0x0458	; 0x800458 <steering_ov>
     c60:	70 e0       	ldi	r23, 0x00	; 0
	Serial.print(" delta = ");
     c62:	8a e8       	ldi	r24, 0x8A	; 138
     c64:	94 e0       	ldi	r25, 0x04	; 4
     c66:	04 d5       	rcall	.+2568   	; 0x1670 <_ZN5USART5printEi>
     c68:	6a ea       	ldi	r22, 0xAA	; 170
     c6a:	73 e0       	ldi	r23, 0x03	; 3
	Serial.print(steering_delta);
     c6c:	8a e8       	ldi	r24, 0x8A	; 138
     c6e:	94 e0       	ldi	r25, 0x04	; 4
     c70:	db d4       	rcall	.+2486   	; 0x1628 <_ZN5USART5printEPKc>
     c72:	60 91 5d 04 	lds	r22, 0x045D	; 0x80045d <steering_delta>
     c76:	70 91 5e 04 	lds	r23, 0x045E	; 0x80045e <steering_delta+0x1>
	Serial.print(" low volt = ");
     c7a:	8a e8       	ldi	r24, 0x8A	; 138
     c7c:	94 e0       	ldi	r25, 0x04	; 4
     c7e:	f8 d4       	rcall	.+2544   	; 0x1670 <_ZN5USART5printEi>
     c80:	64 eb       	ldi	r22, 0xB4	; 180
     c82:	73 e0       	ldi	r23, 0x03	; 3
	Serial.print(low_voltage);
     c84:	8a e8       	ldi	r24, 0x8A	; 138
     c86:	94 e0       	ldi	r25, 0x04	; 4
     c88:	cf d4       	rcall	.+2462   	; 0x1628 <_ZN5USART5printEPKc>
     c8a:	60 91 3c 04 	lds	r22, 0x043C	; 0x80043c <low_voltage>
     c8e:	70 91 3d 04 	lds	r23, 0x043D	; 0x80043d <low_voltage+0x1>
	Serial.print(" high volt = ");
     c92:	8a e8       	ldi	r24, 0x8A	; 138
     c94:	94 e0       	ldi	r25, 0x04	; 4
     c96:	ec d4       	rcall	.+2520   	; 0x1670 <_ZN5USART5printEi>
     c98:	61 ec       	ldi	r22, 0xC1	; 193
     c9a:	73 e0       	ldi	r23, 0x03	; 3
	Serial.print(high_voltage);
     c9c:	8a e8       	ldi	r24, 0x8A	; 138
     c9e:	94 e0       	ldi	r25, 0x04	; 4
     ca0:	c3 d4       	rcall	.+2438   	; 0x1628 <_ZN5USART5printEPKc>
     ca2:	60 91 34 04 	lds	r22, 0x0434	; 0x800434 <__data_end>
     ca6:	70 91 35 04 	lds	r23, 0x0435	; 0x800435 <__data_end+0x1>
	Serial.print(" rpm = ");
     caa:	8a e8       	ldi	r24, 0x8A	; 138
     cac:	94 e0       	ldi	r25, 0x04	; 4
     cae:	e0 d4       	rcall	.+2496   	; 0x1670 <_ZN5USART5printEi>
     cb0:	6f ec       	ldi	r22, 0xCF	; 207
     cb2:	73 e0       	ldi	r23, 0x03	; 3
     cb4:	8a e8       	ldi	r24, 0x8A	; 138
	Serial.print(engine_rpm);
     cb6:	94 e0       	ldi	r25, 0x04	; 4
     cb8:	b7 d4       	rcall	.+2414   	; 0x1628 <_ZN5USART5printEPKc>
     cba:	60 91 3a 04 	lds	r22, 0x043A	; 0x80043a <engine_rpm>
     cbe:	70 91 3b 04 	lds	r23, 0x043B	; 0x80043b <engine_rpm+0x1>
     cc2:	8a e8       	ldi	r24, 0x8A	; 138
     cc4:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" temp = ");
     cc6:	d4 d4       	rcall	.+2472   	; 0x1670 <_ZN5USART5printEi>
     cc8:	67 ed       	ldi	r22, 0xD7	; 215
     cca:	73 e0       	ldi	r23, 0x03	; 3
     ccc:	8a e8       	ldi	r24, 0x8A	; 138
     cce:	94 e0       	ldi	r25, 0x04	; 4
     cd0:	ab d4       	rcall	.+2390   	; 0x1628 <_ZN5USART5printEPKc>
	Serial.println(engine_temp);
     cd2:	60 91 38 04 	lds	r22, 0x0438	; 0x800438 <engine_temp>
     cd6:	70 91 39 04 	lds	r23, 0x0439	; 0x800439 <engine_temp+0x1>
     cda:	8a e8       	ldi	r24, 0x8A	; 138
     cdc:	94 e0       	ldi	r25, 0x04	; 4
     cde:	eb c4       	rjmp	.+2518   	; 0x16b6 <_ZN5USART7printlnEi>
     ce0:	08 95       	ret

00000ce2 <_Z13updateCurtissv>:
     ce2:	2b e6       	ldi	r18, 0x6B	; 107
}
#endif

void updateCurtiss(){
	CAN_Curt.readMsgBuf(&rxId_Curt, &len_Curt, rxBuf_Curt);	// Read data: len = data length, buf = data byte(s)
     ce4:	34 e0       	ldi	r19, 0x04	; 4
     ce6:	43 e7       	ldi	r20, 0x73	; 115
     ce8:	54 e0       	ldi	r21, 0x04	; 4
     cea:	64 e7       	ldi	r22, 0x74	; 116
     cec:	74 e0       	ldi	r23, 0x04	; 4
     cee:	88 e7       	ldi	r24, 0x78	; 120
     cf0:	94 e0       	ldi	r25, 0x04	; 4
     cf2:	0d d4       	rcall	.+2074   	; 0x150e <_ZN7MCP_CAN10readMsgBufEPmPhS1_>
	if((rxId_Curt & 0x40000000) == 0x40000000)					//Ignore remote requests
     cf4:	80 91 74 04 	lds	r24, 0x0474	; 0x800474 <rxId_Curt>
     cf8:	90 91 75 04 	lds	r25, 0x0475	; 0x800475 <rxId_Curt+0x1>
     cfc:	a0 91 76 04 	lds	r26, 0x0476	; 0x800476 <rxId_Curt+0x2>
     d00:	b0 91 77 04 	lds	r27, 0x0477	; 0x800477 <rxId_Curt+0x3>
     d04:	b6 fd       	sbrc	r27, 6
     d06:	36 c0       	rjmp	.+108    	; 0xd74 <_Z13updateCurtissv+0x92>
		return;	
	low_voltage = rxBuf_Curt[0] + (rxBuf_Curt[1] * 256);
     d08:	eb e6       	ldi	r30, 0x6B	; 107
     d0a:	f4 e0       	ldi	r31, 0x04	; 4
     d0c:	81 81       	ldd	r24, Z+1	; 0x01
     d0e:	90 e0       	ldi	r25, 0x00	; 0
     d10:	98 2f       	mov	r25, r24
     d12:	88 27       	eor	r24, r24
     d14:	20 81       	ld	r18, Z
     d16:	82 0f       	add	r24, r18
     d18:	91 1d       	adc	r25, r1
     d1a:	90 93 3d 04 	sts	0x043D, r25	; 0x80043d <low_voltage+0x1>
     d1e:	80 93 3c 04 	sts	0x043C, r24	; 0x80043c <low_voltage>
	engine_rpm = rxBuf_Curt[2] + (rxBuf_Curt[3] * 256);
     d22:	83 81       	ldd	r24, Z+3	; 0x03
     d24:	90 e0       	ldi	r25, 0x00	; 0
     d26:	98 2f       	mov	r25, r24
     d28:	88 27       	eor	r24, r24
     d2a:	22 81       	ldd	r18, Z+2	; 0x02
     d2c:	82 0f       	add	r24, r18
     d2e:	91 1d       	adc	r25, r1
     d30:	90 93 3b 04 	sts	0x043B, r25	; 0x80043b <engine_rpm+0x1>
     d34:	80 93 3a 04 	sts	0x043A, r24	; 0x80043a <engine_rpm>
	engine_temp = rxBuf_Curt[4] + (rxBuf_Curt[5] * 256);
     d38:	85 81       	ldd	r24, Z+5	; 0x05
     d3a:	90 e0       	ldi	r25, 0x00	; 0
     d3c:	98 2f       	mov	r25, r24
     d3e:	88 27       	eor	r24, r24
     d40:	24 81       	ldd	r18, Z+4	; 0x04
     d42:	82 0f       	add	r24, r18
     d44:	91 1d       	adc	r25, r1
     d46:	90 93 39 04 	sts	0x0439, r25	; 0x800439 <engine_temp+0x1>
     d4a:	80 93 38 04 	sts	0x0438, r24	; 0x800438 <engine_temp>
	control_temp = rxBuf_Curt[6] + (rxBuf_Curt[7] * 256);
     d4e:	87 81       	ldd	r24, Z+7	; 0x07
     d50:	90 e0       	ldi	r25, 0x00	; 0
     d52:	98 2f       	mov	r25, r24
     d54:	88 27       	eor	r24, r24
     d56:	26 81       	ldd	r18, Z+6	; 0x06
     d58:	ac 01       	movw	r20, r24
     d5a:	42 0f       	add	r20, r18
     d5c:	51 1d       	adc	r21, r1
     d5e:	50 93 37 04 	sts	0x0437, r21	; 0x800437 <control_temp+0x1>
     d62:	40 93 36 04 	sts	0x0436, r20	; 0x800436 <control_temp>
	high_voltage = rxBuf_Curt[8] + (rxBuf_Curt[7] * 256);	
     d66:	20 85       	ldd	r18, Z+8	; 0x08
     d68:	82 0f       	add	r24, r18
     d6a:	91 1d       	adc	r25, r1
     d6c:	90 93 35 04 	sts	0x0435, r25	; 0x800435 <__data_end+0x1>
     d70:	80 93 34 04 	sts	0x0434, r24	; 0x800434 <__data_end>
     d74:	08 95       	ret

00000d76 <main>:
unsigned char len_Curt;
unsigned char rxBuf_Curt[8];
char msgString_Curt[128]; 

int main(void){
	Serial.println("Alley Hoop V2.1");
     d76:	60 ee       	ldi	r22, 0xE0	; 224
     d78:	73 e0       	ldi	r23, 0x03	; 3
     d7a:	8a e8       	ldi	r24, 0x8A	; 138
     d7c:	94 e0       	ldi	r25, 0x04	; 4
     d7e:	6d d4       	rcall	.+2266   	; 0x165a <_ZN5USART7printlnEPKc>
	initIO();															//initializes the IO pins
     d80:	99 dc       	rcall	.-1742   	; 0x6b4 <_Z6initIOv>
	initDrive();														//detect steering modus
     d82:	16 da       	rcall	.-3028   	; 0x1b0 <_Z9initDrivev>
     d84:	21 e0       	ldi	r18, 0x01	; 1

	if(CAN_Curt.begin(MCP_ANY, CAN_500KBPS, MCP_16MHZ) == CAN_OK)		//initialize the CAN BUS
     d86:	4d e0       	ldi	r20, 0x0D	; 13
     d88:	63 e0       	ldi	r22, 0x03	; 3
     d8a:	88 e7       	ldi	r24, 0x78	; 120
     d8c:	94 e0       	ldi	r25, 0x04	; 4
     d8e:	85 d3       	rcall	.+1802   	; 0x149a <_ZN7MCP_CAN5beginEhhh>
     d90:	81 11       	cpse	r24, r1
     d92:	06 c0       	rjmp	.+12     	; 0xda0 <main+0x2a>
     d94:	60 ef       	ldi	r22, 0xF0	; 240
		Serial.println("MCP2515 Initialized Successfully!");
     d96:	73 e0       	ldi	r23, 0x03	; 3
     d98:	8a e8       	ldi	r24, 0x8A	; 138
     d9a:	94 e0       	ldi	r25, 0x04	; 4
     d9c:	5e d4       	rcall	.+2236   	; 0x165a <_ZN5USART7printlnEPKc>
     d9e:	05 c0       	rjmp	.+10     	; 0xdaa <main+0x34>
     da0:	62 e1       	ldi	r22, 0x12	; 18
	else
		Serial.println("Error Initializing MCP2515...");
     da2:	74 e0       	ldi	r23, 0x04	; 4
     da4:	8a e8       	ldi	r24, 0x8A	; 138
     da6:	94 e0       	ldi	r25, 0x04	; 4
     da8:	58 d4       	rcall	.+2224   	; 0x165a <_ZN5USART7printlnEPKc>
	CAN_Curt.setMode(MCP_NORMAL);										// Set operation mode to normal so the MCP2515 sends acks to received data.
     daa:	60 e0       	ldi	r22, 0x00	; 0
     dac:	88 e7       	ldi	r24, 0x78	; 120
     dae:	94 e0       	ldi	r25, 0x04	; 4
     db0:	d5 d1       	rcall	.+938    	; 0x115c <_ZN7MCP_CAN7setModeEh>

	while (1){				//main program loop	
		updateCurtiss();		//update the values retrieved from the Curtis
     db2:	97 df       	rcall	.-210    	; 0xce2 <_Z13updateCurtissv>
     db4:	62 dc       	rcall	.-1852   	; 0x67a <_Z5drivev>
		drive();				//update the values send to various components
     db6:	e4 de       	rcall	.-568    	; 0xb80 <_Z9printinfov>
     db8:	fc cf       	rjmp	.-8      	; 0xdb2 <main+0x3c>

00000dba <_GLOBAL__sub_I_Serial>:
		#ifdef DEBUG_MODE
			printinfo();			//print info in the terminal, only when debug mode is enabled
     dba:	8a e8       	ldi	r24, 0x8A	; 138
     dbc:	94 e0       	ldi	r25, 0x04	; 4
     dbe:	29 d4       	rcall	.+2130   	; 0x1612 <_ZN5USARTC1Ev>
#include <util/delay.h>		//allows usage of _delay_ms()
#include "overhead.h"		//defines and standard includes
#include "Drive.h"			//takes care of driving the car

USART Serial;				//global Serial
MCP_CAN CAN_Curt(47);		//the Curtiss CAN BUS
     dc0:	6f e2       	ldi	r22, 0x2F	; 47
     dc2:	88 e7       	ldi	r24, 0x78	; 120
     dc4:	94 e0       	ldi	r25, 0x04	; 4
     dc6:	5c c3       	rjmp	.+1720   	; 0x1480 <_ZN7MCP_CANC1Eh>
     dc8:	08 95       	ret

00000dca <_ZN7MCP_CAN13mcp2515_resetEv>:
		tbufdata[MCP_EID0] = 0;
		tbufdata[MCP_EID8] = 0;
	}

	mcp2515_setRegisterS( mcp_addr, tbufdata, 4 );
}
     dca:	0f 93       	push	r16
     dcc:	1f 93       	push	r17
     dce:	cf 93       	push	r28
     dd0:	df 93       	push	r29
     dd2:	1f 92       	push	r1
     dd4:	1f 92       	push	r1
     dd6:	cd b7       	in	r28, 0x3d	; 61
     dd8:	de b7       	in	r29, 0x3e	; 62
     dda:	00 e0       	ldi	r16, 0x00	; 0
     ddc:	21 e0       	ldi	r18, 0x01	; 1
     dde:	40 e8       	ldi	r20, 0x80	; 128
     de0:	56 e9       	ldi	r21, 0x96	; 150
     de2:	68 e9       	ldi	r22, 0x98	; 152
     de4:	70 e0       	ldi	r23, 0x00	; 0
     de6:	ce 01       	movw	r24, r28
     de8:	01 96       	adiw	r24, 0x01	; 1
     dea:	e3 d3       	rcall	.+1990   	; 0x15b2 <_ZN11SPISettingsC1Emhh>
     dec:	be 01       	movw	r22, r28
     dee:	6f 5f       	subi	r22, 0xFF	; 255
     df0:	7f 4f       	sbci	r23, 0xFF	; 255
     df2:	8c e8       	ldi	r24, 0x8C	; 140
     df4:	94 e0       	ldi	r25, 0x04	; 4
     df6:	01 d4       	rcall	.+2050   	; 0x15fa <_ZN8SPIClass16beginTransactionE11SPISettings>
     df8:	0b e0       	ldi	r16, 0x0B	; 11
     dfa:	11 e0       	ldi	r17, 0x01	; 1
     dfc:	f8 01       	movw	r30, r16
     dfe:	80 81       	ld	r24, Z
     e00:	8b 7f       	andi	r24, 0xFB	; 251
     e02:	80 83       	st	Z, r24
     e04:	60 ec       	ldi	r22, 0xC0	; 192
     e06:	8c e8       	ldi	r24, 0x8C	; 140
     e08:	94 e0       	ldi	r25, 0x04	; 4
     e0a:	fd d3       	rcall	.+2042   	; 0x1606 <_ZN8SPIClass8transferEh>
     e0c:	f8 01       	movw	r30, r16
     e0e:	80 81       	ld	r24, Z
     e10:	84 60       	ori	r24, 0x04	; 4
     e12:	80 83       	st	Z, r24
     e14:	83 ec       	ldi	r24, 0xC3	; 195
     e16:	99 e0       	ldi	r25, 0x09	; 9
     e18:	01 97       	sbiw	r24, 0x01	; 1
     e1a:	f1 f7       	brne	.-4      	; 0xe18 <_ZN7MCP_CAN13mcp2515_resetEv+0x4e>
     e1c:	00 c0       	rjmp	.+0      	; 0xe1e <_ZN7MCP_CAN13mcp2515_resetEv+0x54>
     e1e:	00 00       	nop
     e20:	0f 90       	pop	r0
     e22:	0f 90       	pop	r0
     e24:	df 91       	pop	r29
     e26:	cf 91       	pop	r28
     e28:	1f 91       	pop	r17
     e2a:	0f 91       	pop	r16
     e2c:	08 95       	ret

00000e2e <_ZN7MCP_CAN20mcp2515_readRegisterEh>:
     e2e:	ff 92       	push	r15
     e30:	0f 93       	push	r16
     e32:	1f 93       	push	r17
     e34:	cf 93       	push	r28
     e36:	df 93       	push	r29
     e38:	1f 92       	push	r1
     e3a:	1f 92       	push	r1
     e3c:	cd b7       	in	r28, 0x3d	; 61
     e3e:	de b7       	in	r29, 0x3e	; 62
     e40:	f6 2e       	mov	r15, r22
     e42:	00 e0       	ldi	r16, 0x00	; 0
     e44:	21 e0       	ldi	r18, 0x01	; 1
     e46:	40 e8       	ldi	r20, 0x80	; 128
     e48:	56 e9       	ldi	r21, 0x96	; 150
     e4a:	68 e9       	ldi	r22, 0x98	; 152
     e4c:	70 e0       	ldi	r23, 0x00	; 0
     e4e:	ce 01       	movw	r24, r28
     e50:	01 96       	adiw	r24, 0x01	; 1
     e52:	af d3       	rcall	.+1886   	; 0x15b2 <_ZN11SPISettingsC1Emhh>
     e54:	be 01       	movw	r22, r28
     e56:	6f 5f       	subi	r22, 0xFF	; 255
     e58:	7f 4f       	sbci	r23, 0xFF	; 255
     e5a:	8c e8       	ldi	r24, 0x8C	; 140
     e5c:	94 e0       	ldi	r25, 0x04	; 4
     e5e:	cd d3       	rcall	.+1946   	; 0x15fa <_ZN8SPIClass16beginTransactionE11SPISettings>
     e60:	0b e0       	ldi	r16, 0x0B	; 11
     e62:	11 e0       	ldi	r17, 0x01	; 1
     e64:	f8 01       	movw	r30, r16
     e66:	80 81       	ld	r24, Z
     e68:	8b 7f       	andi	r24, 0xFB	; 251
     e6a:	80 83       	st	Z, r24
     e6c:	63 e0       	ldi	r22, 0x03	; 3
     e6e:	8c e8       	ldi	r24, 0x8C	; 140
     e70:	94 e0       	ldi	r25, 0x04	; 4
     e72:	c9 d3       	rcall	.+1938   	; 0x1606 <_ZN8SPIClass8transferEh>
     e74:	6f 2d       	mov	r22, r15
     e76:	8c e8       	ldi	r24, 0x8C	; 140
     e78:	94 e0       	ldi	r25, 0x04	; 4
     e7a:	c5 d3       	rcall	.+1930   	; 0x1606 <_ZN8SPIClass8transferEh>
     e7c:	60 e0       	ldi	r22, 0x00	; 0
     e7e:	8c e8       	ldi	r24, 0x8C	; 140
     e80:	94 e0       	ldi	r25, 0x04	; 4
     e82:	c1 d3       	rcall	.+1922   	; 0x1606 <_ZN8SPIClass8transferEh>
     e84:	f8 01       	movw	r30, r16
     e86:	90 81       	ld	r25, Z
     e88:	94 60       	ori	r25, 0x04	; 4
     e8a:	90 83       	st	Z, r25
     e8c:	0f 90       	pop	r0
     e8e:	0f 90       	pop	r0
     e90:	df 91       	pop	r29
     e92:	cf 91       	pop	r28
     e94:	1f 91       	pop	r17
     e96:	0f 91       	pop	r16
     e98:	ff 90       	pop	r15
     e9a:	08 95       	ret

00000e9c <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh>:
     e9c:	cf 92       	push	r12
     e9e:	df 92       	push	r13
     ea0:	ef 92       	push	r14
     ea2:	ff 92       	push	r15
     ea4:	0f 93       	push	r16
     ea6:	1f 93       	push	r17
     ea8:	cf 93       	push	r28
     eaa:	df 93       	push	r29
     eac:	1f 92       	push	r1
     eae:	1f 92       	push	r1
     eb0:	cd b7       	in	r28, 0x3d	; 61
     eb2:	de b7       	in	r29, 0x3e	; 62
     eb4:	16 2f       	mov	r17, r22
     eb6:	6a 01       	movw	r12, r20
     eb8:	f2 2e       	mov	r15, r18
     eba:	00 e0       	ldi	r16, 0x00	; 0
     ebc:	21 e0       	ldi	r18, 0x01	; 1
     ebe:	40 e8       	ldi	r20, 0x80	; 128
     ec0:	56 e9       	ldi	r21, 0x96	; 150
     ec2:	68 e9       	ldi	r22, 0x98	; 152
     ec4:	70 e0       	ldi	r23, 0x00	; 0
     ec6:	ce 01       	movw	r24, r28
     ec8:	01 96       	adiw	r24, 0x01	; 1
     eca:	73 d3       	rcall	.+1766   	; 0x15b2 <_ZN11SPISettingsC1Emhh>
     ecc:	be 01       	movw	r22, r28
     ece:	6f 5f       	subi	r22, 0xFF	; 255
     ed0:	7f 4f       	sbci	r23, 0xFF	; 255
     ed2:	8c e8       	ldi	r24, 0x8C	; 140
     ed4:	94 e0       	ldi	r25, 0x04	; 4
     ed6:	91 d3       	rcall	.+1826   	; 0x15fa <_ZN8SPIClass16beginTransactionE11SPISettings>
     ed8:	eb e0       	ldi	r30, 0x0B	; 11
     eda:	f1 e0       	ldi	r31, 0x01	; 1
     edc:	80 81       	ld	r24, Z
     ede:	8b 7f       	andi	r24, 0xFB	; 251
     ee0:	80 83       	st	Z, r24
     ee2:	63 e0       	ldi	r22, 0x03	; 3
     ee4:	8c e8       	ldi	r24, 0x8C	; 140
     ee6:	94 e0       	ldi	r25, 0x04	; 4
     ee8:	8e d3       	rcall	.+1820   	; 0x1606 <_ZN8SPIClass8transferEh>
     eea:	61 2f       	mov	r22, r17
     eec:	8c e8       	ldi	r24, 0x8C	; 140
     eee:	94 e0       	ldi	r25, 0x04	; 4
     ef0:	8a d3       	rcall	.+1812   	; 0x1606 <_ZN8SPIClass8transferEh>
     ef2:	ff 20       	and	r15, r15
     ef4:	99 f0       	breq	.+38     	; 0xf1c <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh+0x80>
     ef6:	86 01       	movw	r16, r12
     ef8:	fa 94       	dec	r15
     efa:	ef 2c       	mov	r14, r15
     efc:	f1 2c       	mov	r15, r1
     efe:	8f ef       	ldi	r24, 0xFF	; 255
     f00:	e8 1a       	sub	r14, r24
     f02:	f8 0a       	sbc	r15, r24
     f04:	ec 0c       	add	r14, r12
     f06:	fd 1c       	adc	r15, r13
     f08:	60 e0       	ldi	r22, 0x00	; 0
     f0a:	8c e8       	ldi	r24, 0x8C	; 140
     f0c:	94 e0       	ldi	r25, 0x04	; 4
     f0e:	7b d3       	rcall	.+1782   	; 0x1606 <_ZN8SPIClass8transferEh>
     f10:	f8 01       	movw	r30, r16
     f12:	81 93       	st	Z+, r24
     f14:	8f 01       	movw	r16, r30
     f16:	ee 15       	cp	r30, r14
     f18:	ff 05       	cpc	r31, r15
     f1a:	b1 f7       	brne	.-20     	; 0xf08 <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh+0x6c>
     f1c:	eb e0       	ldi	r30, 0x0B	; 11
     f1e:	f1 e0       	ldi	r31, 0x01	; 1
     f20:	80 81       	ld	r24, Z
     f22:	84 60       	ori	r24, 0x04	; 4
     f24:	80 83       	st	Z, r24
     f26:	0f 90       	pop	r0
     f28:	0f 90       	pop	r0
     f2a:	df 91       	pop	r29
     f2c:	cf 91       	pop	r28
     f2e:	1f 91       	pop	r17
     f30:	0f 91       	pop	r16
     f32:	ff 90       	pop	r15
     f34:	ef 90       	pop	r14
     f36:	df 90       	pop	r13
     f38:	cf 90       	pop	r12
     f3a:	08 95       	ret

00000f3c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>:
     f3c:	ef 92       	push	r14
     f3e:	ff 92       	push	r15
     f40:	0f 93       	push	r16
     f42:	1f 93       	push	r17
     f44:	cf 93       	push	r28
     f46:	df 93       	push	r29
     f48:	1f 92       	push	r1
     f4a:	1f 92       	push	r1
     f4c:	cd b7       	in	r28, 0x3d	; 61
     f4e:	de b7       	in	r29, 0x3e	; 62
     f50:	e6 2e       	mov	r14, r22
     f52:	f4 2e       	mov	r15, r20
     f54:	00 e0       	ldi	r16, 0x00	; 0
     f56:	21 e0       	ldi	r18, 0x01	; 1
     f58:	40 e8       	ldi	r20, 0x80	; 128
     f5a:	56 e9       	ldi	r21, 0x96	; 150
     f5c:	68 e9       	ldi	r22, 0x98	; 152
     f5e:	70 e0       	ldi	r23, 0x00	; 0
     f60:	ce 01       	movw	r24, r28
     f62:	01 96       	adiw	r24, 0x01	; 1
     f64:	26 d3       	rcall	.+1612   	; 0x15b2 <_ZN11SPISettingsC1Emhh>
     f66:	be 01       	movw	r22, r28
     f68:	6f 5f       	subi	r22, 0xFF	; 255
     f6a:	7f 4f       	sbci	r23, 0xFF	; 255
     f6c:	8c e8       	ldi	r24, 0x8C	; 140
     f6e:	94 e0       	ldi	r25, 0x04	; 4
     f70:	44 d3       	rcall	.+1672   	; 0x15fa <_ZN8SPIClass16beginTransactionE11SPISettings>
     f72:	0b e0       	ldi	r16, 0x0B	; 11
     f74:	11 e0       	ldi	r17, 0x01	; 1
     f76:	f8 01       	movw	r30, r16
     f78:	80 81       	ld	r24, Z
     f7a:	8b 7f       	andi	r24, 0xFB	; 251
     f7c:	80 83       	st	Z, r24
     f7e:	62 e0       	ldi	r22, 0x02	; 2
     f80:	8c e8       	ldi	r24, 0x8C	; 140
     f82:	94 e0       	ldi	r25, 0x04	; 4
     f84:	40 d3       	rcall	.+1664   	; 0x1606 <_ZN8SPIClass8transferEh>
     f86:	6e 2d       	mov	r22, r14
     f88:	8c e8       	ldi	r24, 0x8C	; 140
     f8a:	94 e0       	ldi	r25, 0x04	; 4
     f8c:	3c d3       	rcall	.+1656   	; 0x1606 <_ZN8SPIClass8transferEh>
     f8e:	6f 2d       	mov	r22, r15
     f90:	8c e8       	ldi	r24, 0x8C	; 140
     f92:	94 e0       	ldi	r25, 0x04	; 4
     f94:	38 d3       	rcall	.+1648   	; 0x1606 <_ZN8SPIClass8transferEh>
     f96:	f8 01       	movw	r30, r16
     f98:	80 81       	ld	r24, Z
     f9a:	84 60       	ori	r24, 0x04	; 4
     f9c:	80 83       	st	Z, r24
     f9e:	0f 90       	pop	r0
     fa0:	0f 90       	pop	r0
     fa2:	df 91       	pop	r29
     fa4:	cf 91       	pop	r28
     fa6:	1f 91       	pop	r17
     fa8:	0f 91       	pop	r16
     faa:	ff 90       	pop	r15
     fac:	ef 90       	pop	r14
     fae:	08 95       	ret

00000fb0 <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh>:
     fb0:	cf 92       	push	r12
     fb2:	df 92       	push	r13
     fb4:	ef 92       	push	r14
     fb6:	ff 92       	push	r15
     fb8:	0f 93       	push	r16
     fba:	1f 93       	push	r17
     fbc:	cf 93       	push	r28
     fbe:	df 93       	push	r29
     fc0:	1f 92       	push	r1
     fc2:	1f 92       	push	r1
     fc4:	cd b7       	in	r28, 0x3d	; 61
     fc6:	de b7       	in	r29, 0x3e	; 62
     fc8:	16 2f       	mov	r17, r22
     fca:	6a 01       	movw	r12, r20
     fcc:	f2 2e       	mov	r15, r18
     fce:	00 e0       	ldi	r16, 0x00	; 0
     fd0:	21 e0       	ldi	r18, 0x01	; 1
     fd2:	40 e8       	ldi	r20, 0x80	; 128
     fd4:	56 e9       	ldi	r21, 0x96	; 150
     fd6:	68 e9       	ldi	r22, 0x98	; 152
     fd8:	70 e0       	ldi	r23, 0x00	; 0
     fda:	ce 01       	movw	r24, r28
     fdc:	01 96       	adiw	r24, 0x01	; 1
     fde:	e9 d2       	rcall	.+1490   	; 0x15b2 <_ZN11SPISettingsC1Emhh>
     fe0:	be 01       	movw	r22, r28
     fe2:	6f 5f       	subi	r22, 0xFF	; 255
     fe4:	7f 4f       	sbci	r23, 0xFF	; 255
     fe6:	8c e8       	ldi	r24, 0x8C	; 140
     fe8:	94 e0       	ldi	r25, 0x04	; 4
     fea:	07 d3       	rcall	.+1550   	; 0x15fa <_ZN8SPIClass16beginTransactionE11SPISettings>
     fec:	eb e0       	ldi	r30, 0x0B	; 11
     fee:	f1 e0       	ldi	r31, 0x01	; 1
     ff0:	80 81       	ld	r24, Z
     ff2:	8b 7f       	andi	r24, 0xFB	; 251
     ff4:	80 83       	st	Z, r24
     ff6:	62 e0       	ldi	r22, 0x02	; 2
     ff8:	8c e8       	ldi	r24, 0x8C	; 140
     ffa:	94 e0       	ldi	r25, 0x04	; 4
     ffc:	04 d3       	rcall	.+1544   	; 0x1606 <_ZN8SPIClass8transferEh>
     ffe:	61 2f       	mov	r22, r17
    1000:	8c e8       	ldi	r24, 0x8C	; 140
    1002:	94 e0       	ldi	r25, 0x04	; 4
    1004:	00 d3       	rcall	.+1536   	; 0x1606 <_ZN8SPIClass8transferEh>
    1006:	ff 20       	and	r15, r15
    1008:	91 f0       	breq	.+36     	; 0x102e <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh+0x7e>
    100a:	86 01       	movw	r16, r12
    100c:	fa 94       	dec	r15
    100e:	ef 2c       	mov	r14, r15
    1010:	f1 2c       	mov	r15, r1
    1012:	8f ef       	ldi	r24, 0xFF	; 255
    1014:	e8 1a       	sub	r14, r24
    1016:	f8 0a       	sbc	r15, r24
    1018:	ec 0c       	add	r14, r12
    101a:	fd 1c       	adc	r15, r13
    101c:	f8 01       	movw	r30, r16
    101e:	61 91       	ld	r22, Z+
    1020:	8f 01       	movw	r16, r30
    1022:	8c e8       	ldi	r24, 0x8C	; 140
    1024:	94 e0       	ldi	r25, 0x04	; 4
    1026:	ef d2       	rcall	.+1502   	; 0x1606 <_ZN8SPIClass8transferEh>
    1028:	0e 15       	cp	r16, r14
    102a:	1f 05       	cpc	r17, r15
    102c:	b9 f7       	brne	.-18     	; 0x101c <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh+0x6c>
    102e:	eb e0       	ldi	r30, 0x0B	; 11
    1030:	f1 e0       	ldi	r31, 0x01	; 1
    1032:	80 81       	ld	r24, Z
    1034:	84 60       	ori	r24, 0x04	; 4
    1036:	80 83       	st	Z, r24
    1038:	0f 90       	pop	r0
    103a:	0f 90       	pop	r0
    103c:	df 91       	pop	r29
    103e:	cf 91       	pop	r28
    1040:	1f 91       	pop	r17
    1042:	0f 91       	pop	r16
    1044:	ff 90       	pop	r15
    1046:	ef 90       	pop	r14
    1048:	df 90       	pop	r13
    104a:	cf 90       	pop	r12
    104c:	08 95       	ret

0000104e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>:
    104e:	df 92       	push	r13
    1050:	ef 92       	push	r14
    1052:	ff 92       	push	r15
    1054:	0f 93       	push	r16
    1056:	1f 93       	push	r17
    1058:	cf 93       	push	r28
    105a:	df 93       	push	r29
    105c:	1f 92       	push	r1
    105e:	1f 92       	push	r1
    1060:	cd b7       	in	r28, 0x3d	; 61
    1062:	de b7       	in	r29, 0x3e	; 62
    1064:	d6 2e       	mov	r13, r22
    1066:	e4 2e       	mov	r14, r20
    1068:	f2 2e       	mov	r15, r18
    106a:	00 e0       	ldi	r16, 0x00	; 0
    106c:	21 e0       	ldi	r18, 0x01	; 1
    106e:	40 e8       	ldi	r20, 0x80	; 128
    1070:	56 e9       	ldi	r21, 0x96	; 150
    1072:	68 e9       	ldi	r22, 0x98	; 152
    1074:	70 e0       	ldi	r23, 0x00	; 0
    1076:	ce 01       	movw	r24, r28
    1078:	01 96       	adiw	r24, 0x01	; 1
    107a:	9b d2       	rcall	.+1334   	; 0x15b2 <_ZN11SPISettingsC1Emhh>
    107c:	be 01       	movw	r22, r28
    107e:	6f 5f       	subi	r22, 0xFF	; 255
    1080:	7f 4f       	sbci	r23, 0xFF	; 255
    1082:	8c e8       	ldi	r24, 0x8C	; 140
    1084:	94 e0       	ldi	r25, 0x04	; 4
    1086:	b9 d2       	rcall	.+1394   	; 0x15fa <_ZN8SPIClass16beginTransactionE11SPISettings>
    1088:	0b e0       	ldi	r16, 0x0B	; 11
    108a:	11 e0       	ldi	r17, 0x01	; 1
    108c:	f8 01       	movw	r30, r16
    108e:	80 81       	ld	r24, Z
    1090:	8b 7f       	andi	r24, 0xFB	; 251
    1092:	80 83       	st	Z, r24
    1094:	65 e0       	ldi	r22, 0x05	; 5
    1096:	8c e8       	ldi	r24, 0x8C	; 140
    1098:	94 e0       	ldi	r25, 0x04	; 4
    109a:	b5 d2       	rcall	.+1386   	; 0x1606 <_ZN8SPIClass8transferEh>
    109c:	6d 2d       	mov	r22, r13
    109e:	8c e8       	ldi	r24, 0x8C	; 140
    10a0:	94 e0       	ldi	r25, 0x04	; 4
    10a2:	b1 d2       	rcall	.+1378   	; 0x1606 <_ZN8SPIClass8transferEh>
    10a4:	6e 2d       	mov	r22, r14
    10a6:	8c e8       	ldi	r24, 0x8C	; 140
    10a8:	94 e0       	ldi	r25, 0x04	; 4
    10aa:	ad d2       	rcall	.+1370   	; 0x1606 <_ZN8SPIClass8transferEh>
    10ac:	6f 2d       	mov	r22, r15
    10ae:	8c e8       	ldi	r24, 0x8C	; 140
    10b0:	94 e0       	ldi	r25, 0x04	; 4
    10b2:	a9 d2       	rcall	.+1362   	; 0x1606 <_ZN8SPIClass8transferEh>
    10b4:	f8 01       	movw	r30, r16
    10b6:	80 81       	ld	r24, Z
    10b8:	84 60       	ori	r24, 0x04	; 4
    10ba:	80 83       	st	Z, r24
    10bc:	0f 90       	pop	r0
    10be:	0f 90       	pop	r0
    10c0:	df 91       	pop	r29
    10c2:	cf 91       	pop	r28
    10c4:	1f 91       	pop	r17
    10c6:	0f 91       	pop	r16
    10c8:	ff 90       	pop	r15
    10ca:	ef 90       	pop	r14
    10cc:	df 90       	pop	r13
    10ce:	08 95       	ret

000010d0 <_ZN7MCP_CAN18mcp2515_readStatusEv>:
    10d0:	0f 93       	push	r16
    10d2:	1f 93       	push	r17
    10d4:	cf 93       	push	r28
    10d6:	df 93       	push	r29
    10d8:	1f 92       	push	r1
    10da:	1f 92       	push	r1
    10dc:	cd b7       	in	r28, 0x3d	; 61
    10de:	de b7       	in	r29, 0x3e	; 62
    10e0:	00 e0       	ldi	r16, 0x00	; 0
    10e2:	21 e0       	ldi	r18, 0x01	; 1
    10e4:	40 e8       	ldi	r20, 0x80	; 128
    10e6:	56 e9       	ldi	r21, 0x96	; 150
    10e8:	68 e9       	ldi	r22, 0x98	; 152
    10ea:	70 e0       	ldi	r23, 0x00	; 0
    10ec:	ce 01       	movw	r24, r28
    10ee:	01 96       	adiw	r24, 0x01	; 1
    10f0:	60 d2       	rcall	.+1216   	; 0x15b2 <_ZN11SPISettingsC1Emhh>
    10f2:	be 01       	movw	r22, r28
    10f4:	6f 5f       	subi	r22, 0xFF	; 255
    10f6:	7f 4f       	sbci	r23, 0xFF	; 255
    10f8:	8c e8       	ldi	r24, 0x8C	; 140
    10fa:	94 e0       	ldi	r25, 0x04	; 4
    10fc:	7e d2       	rcall	.+1276   	; 0x15fa <_ZN8SPIClass16beginTransactionE11SPISettings>
    10fe:	0b e0       	ldi	r16, 0x0B	; 11
    1100:	11 e0       	ldi	r17, 0x01	; 1
    1102:	f8 01       	movw	r30, r16
    1104:	80 81       	ld	r24, Z
    1106:	8b 7f       	andi	r24, 0xFB	; 251
    1108:	80 83       	st	Z, r24
    110a:	60 ea       	ldi	r22, 0xA0	; 160
    110c:	8c e8       	ldi	r24, 0x8C	; 140
    110e:	94 e0       	ldi	r25, 0x04	; 4
    1110:	7a d2       	rcall	.+1268   	; 0x1606 <_ZN8SPIClass8transferEh>
    1112:	60 e0       	ldi	r22, 0x00	; 0
    1114:	8c e8       	ldi	r24, 0x8C	; 140
    1116:	94 e0       	ldi	r25, 0x04	; 4
    1118:	76 d2       	rcall	.+1260   	; 0x1606 <_ZN8SPIClass8transferEh>
    111a:	f8 01       	movw	r30, r16
    111c:	90 81       	ld	r25, Z
    111e:	94 60       	ori	r25, 0x04	; 4
    1120:	90 83       	st	Z, r25
    1122:	0f 90       	pop	r0
    1124:	0f 90       	pop	r0
    1126:	df 91       	pop	r29
    1128:	cf 91       	pop	r28
    112a:	1f 91       	pop	r17
    112c:	0f 91       	pop	r16
    112e:	08 95       	ret

00001130 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>:
    1130:	0f 93       	push	r16
    1132:	1f 93       	push	r17
    1134:	cf 93       	push	r28
    1136:	8c 01       	movw	r16, r24
    1138:	c6 2f       	mov	r28, r22
    113a:	26 2f       	mov	r18, r22
    113c:	40 ee       	ldi	r20, 0xE0	; 224
    113e:	6f e0       	ldi	r22, 0x0F	; 15
    1140:	86 df       	rcall	.-244    	; 0x104e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    1142:	6f e0       	ldi	r22, 0x0F	; 15
    1144:	c8 01       	movw	r24, r16
    1146:	73 de       	rcall	.-794    	; 0xe2e <_ZN7MCP_CAN20mcp2515_readRegisterEh>
    1148:	98 2f       	mov	r25, r24
    114a:	90 7e       	andi	r25, 0xE0	; 224
    114c:	81 e0       	ldi	r24, 0x01	; 1
    114e:	9c 13       	cpse	r25, r28
    1150:	01 c0       	rjmp	.+2      	; 0x1154 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh+0x24>
    1152:	80 e0       	ldi	r24, 0x00	; 0
    1154:	cf 91       	pop	r28
    1156:	1f 91       	pop	r17
    1158:	0f 91       	pop	r16
    115a:	08 95       	ret

0000115c <_ZN7MCP_CAN7setModeEh>:
    115c:	fc 01       	movw	r30, r24
    115e:	61 8b       	std	Z+17, r22	; 0x11
    1160:	e7 cf       	rjmp	.-50     	; 0x1130 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>
    1162:	08 95       	ret

00001164 <_ZN7MCP_CAN18mcp2515_configRateEhh>:
    1164:	cf 93       	push	r28
    1166:	df 93       	push	r29
    1168:	ec 01       	movw	r28, r24
    116a:	40 e4       	ldi	r20, 0x40	; 64
    116c:	6a e2       	ldi	r22, 0x2A	; 42
    116e:	e6 de       	rcall	.-564    	; 0xf3c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1170:	45 ee       	ldi	r20, 0xE5	; 229
    1172:	69 e2       	ldi	r22, 0x29	; 41
    1174:	ce 01       	movw	r24, r28
    1176:	e2 de       	rcall	.-572    	; 0xf3c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1178:	43 e8       	ldi	r20, 0x83	; 131
    117a:	68 e2       	ldi	r22, 0x28	; 40
    117c:	ce 01       	movw	r24, r28
    117e:	de de       	rcall	.-580    	; 0xf3c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1180:	80 e0       	ldi	r24, 0x00	; 0
    1182:	df 91       	pop	r29
    1184:	cf 91       	pop	r28
    1186:	08 95       	ret

00001188 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>:

/*********************************************************************************************************
** Function name:           mcp2515_write_mf
** Descriptions:            Write Masks and Filters
*********************************************************************************************************/
void MCP_CAN::mcp2515_write_mf( const uint8_t mcp_addr, const uint8_t ext, const uint32_t id ){
    1188:	0f 93       	push	r16
    118a:	1f 93       	push	r17
    118c:	cf 93       	push	r28
    118e:	df 93       	push	r29
    1190:	00 d0       	rcall	.+0      	; 0x1192 <_ZN7MCP_CAN16mcp2515_write_mfEhhm+0xa>
    1192:	1f 92       	push	r1
    1194:	cd b7       	in	r28, 0x3d	; 61
    1196:	de b7       	in	r29, 0x3e	; 62
	uint16_t canid;
	uint8_t tbufdata[4];
	canid = (uint16_t)(id & 0x0FFFF);
	if ( ext == 1){
    1198:	41 30       	cpi	r20, 0x01	; 1
    119a:	c9 f4       	brne	.+50     	; 0x11ce <_ZN7MCP_CAN16mcp2515_write_mfEhhm+0x46>
		tbufdata[MCP_EID0] = (uint8_t) (canid & 0xFF);
    119c:	0c 83       	std	Y+4, r16	; 0x04
		tbufdata[MCP_EID8] = (uint8_t) (canid >> 8);
    119e:	1b 83       	std	Y+3, r17	; 0x03
		canid = (uint16_t)(id >> 16);
    11a0:	89 01       	movw	r16, r18
    11a2:	22 27       	eor	r18, r18
    11a4:	33 27       	eor	r19, r19
		tbufdata[MCP_SIDL] = (uint8_t) (canid & 0x03);
		tbufdata[MCP_SIDL] += (uint8_t) ((canid & 0x1C) << 3);
		tbufdata[MCP_SIDL] |= MCP_TXB_EXIDE_M;
    11a6:	40 2f       	mov	r20, r16
    11a8:	4c 71       	andi	r20, 0x1C	; 28
    11aa:	44 0f       	add	r20, r20
    11ac:	44 0f       	add	r20, r20
    11ae:	44 0f       	add	r20, r20
    11b0:	50 2f       	mov	r21, r16
    11b2:	53 70       	andi	r21, 0x03	; 3
    11b4:	45 0f       	add	r20, r21
    11b6:	48 60       	ori	r20, 0x08	; 8
    11b8:	4a 83       	std	Y+2, r20	; 0x02
		tbufdata[MCP_SIDH] = (uint8_t) (canid >> 5 );
    11ba:	16 95       	lsr	r17
    11bc:	07 95       	ror	r16
    11be:	12 95       	swap	r17
    11c0:	02 95       	swap	r16
    11c2:	0f 70       	andi	r16, 0x0F	; 15
    11c4:	01 27       	eor	r16, r17
    11c6:	1f 70       	andi	r17, 0x0F	; 15
    11c8:	01 27       	eor	r16, r17
    11ca:	09 83       	std	Y+1, r16	; 0x01
    11cc:	11 c0       	rjmp	.+34     	; 0x11f0 <_ZN7MCP_CAN16mcp2515_write_mfEhhm+0x68>
	} else {
		tbufdata[MCP_EID0] = (uint8_t) (canid & 0xFF);
    11ce:	0c 83       	std	Y+4, r16	; 0x04
		tbufdata[MCP_EID8] = (uint8_t) (canid >> 8);
    11d0:	1b 83       	std	Y+3, r17	; 0x03
		canid = (uint16_t)(id >> 16);
    11d2:	89 01       	movw	r16, r18
    11d4:	22 27       	eor	r18, r18
    11d6:	33 27       	eor	r19, r19
		tbufdata[MCP_SIDL] = (uint8_t) ((canid & 0x07) << 5);
    11d8:	40 2f       	mov	r20, r16
    11da:	42 95       	swap	r20
    11dc:	44 0f       	add	r20, r20
    11de:	40 7e       	andi	r20, 0xE0	; 224
    11e0:	4a 83       	std	Y+2, r20	; 0x02
		tbufdata[MCP_SIDH] = (uint8_t) (canid >> 3 );
    11e2:	16 95       	lsr	r17
    11e4:	07 95       	ror	r16
    11e6:	16 95       	lsr	r17
    11e8:	07 95       	ror	r16
    11ea:	16 95       	lsr	r17
    11ec:	07 95       	ror	r16
    11ee:	09 83       	std	Y+1, r16	; 0x01
	}
	mcp2515_setRegisterS( mcp_addr, tbufdata, 4 );
    11f0:	24 e0       	ldi	r18, 0x04	; 4
    11f2:	ae 01       	movw	r20, r28
    11f4:	4f 5f       	subi	r20, 0xFF	; 255
    11f6:	5f 4f       	sbci	r21, 0xFF	; 255
    11f8:	db de       	rcall	.-586    	; 0xfb0 <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh>
}
    11fa:	0f 90       	pop	r0
    11fc:	0f 90       	pop	r0
    11fe:	0f 90       	pop	r0
    1200:	0f 90       	pop	r0
    1202:	df 91       	pop	r29
    1204:	cf 91       	pop	r28
    1206:	1f 91       	pop	r17
    1208:	0f 91       	pop	r16
    120a:	08 95       	ret

0000120c <_ZN7MCP_CAN22mcp2515_initCANBuffersEv>:

/*********************************************************************************************************
** Function name:           mcp2515_initCANBuffers
** Descriptions:            Initialize Buffers, Masks, and Filters
*********************************************************************************************************/
void MCP_CAN::mcp2515_initCANBuffers(void){
    120c:	ef 92       	push	r14
    120e:	ff 92       	push	r15
    1210:	0f 93       	push	r16
    1212:	1f 93       	push	r17
    1214:	cf 93       	push	r28
    1216:	7c 01       	movw	r14, r24
	uint8_t std = 0;
	uint8_t ext = 1;
	uint32_t ulMask = 0x00, ulFilt = 0x00;


	mcp2515_write_mf(MCP_RXM0SIDH, ext, ulMask);			/*Set both masks to 0           */
    1218:	00 e0       	ldi	r16, 0x00	; 0
    121a:	10 e0       	ldi	r17, 0x00	; 0
    121c:	98 01       	movw	r18, r16
    121e:	41 e0       	ldi	r20, 0x01	; 1
    1220:	60 e2       	ldi	r22, 0x20	; 32
    1222:	b2 df       	rcall	.-156    	; 0x1188 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXM1SIDH, ext, ulMask);			/*Mask register ignores ext bit */
    1224:	00 e0       	ldi	r16, 0x00	; 0
    1226:	10 e0       	ldi	r17, 0x00	; 0
    1228:	98 01       	movw	r18, r16
    122a:	41 e0       	ldi	r20, 0x01	; 1
    122c:	64 e2       	ldi	r22, 0x24	; 36
    122e:	c7 01       	movw	r24, r14
    1230:	ab df       	rcall	.-170    	; 0x1188 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	
	/* Set all filters to 0         */
	mcp2515_write_mf(MCP_RXF0SIDH, ext, ulFilt);			/* RXB0: extended               */
    1232:	00 e0       	ldi	r16, 0x00	; 0
    1234:	10 e0       	ldi	r17, 0x00	; 0
    1236:	98 01       	movw	r18, r16
    1238:	41 e0       	ldi	r20, 0x01	; 1
    123a:	60 e0       	ldi	r22, 0x00	; 0
    123c:	c7 01       	movw	r24, r14
    123e:	a4 df       	rcall	.-184    	; 0x1188 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF1SIDH, std, ulFilt);			/* RXB1: standard               */
    1240:	00 e0       	ldi	r16, 0x00	; 0
    1242:	10 e0       	ldi	r17, 0x00	; 0
    1244:	98 01       	movw	r18, r16
    1246:	40 e0       	ldi	r20, 0x00	; 0
    1248:	64 e0       	ldi	r22, 0x04	; 4
    124a:	c7 01       	movw	r24, r14
    124c:	9d df       	rcall	.-198    	; 0x1188 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF2SIDH, ext, ulFilt);			/* RXB2: extended               */
    124e:	00 e0       	ldi	r16, 0x00	; 0
    1250:	10 e0       	ldi	r17, 0x00	; 0
    1252:	98 01       	movw	r18, r16
    1254:	41 e0       	ldi	r20, 0x01	; 1
    1256:	68 e0       	ldi	r22, 0x08	; 8
    1258:	c7 01       	movw	r24, r14
    125a:	96 df       	rcall	.-212    	; 0x1188 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF3SIDH, std, ulFilt);			/* RXB3: standard               */
    125c:	00 e0       	ldi	r16, 0x00	; 0
    125e:	10 e0       	ldi	r17, 0x00	; 0
    1260:	98 01       	movw	r18, r16
    1262:	40 e0       	ldi	r20, 0x00	; 0
    1264:	60 e1       	ldi	r22, 0x10	; 16
    1266:	c7 01       	movw	r24, r14
    1268:	8f df       	rcall	.-226    	; 0x1188 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF4SIDH, ext, ulFilt);
    126a:	00 e0       	ldi	r16, 0x00	; 0
    126c:	10 e0       	ldi	r17, 0x00	; 0
    126e:	98 01       	movw	r18, r16
    1270:	41 e0       	ldi	r20, 0x01	; 1
    1272:	64 e1       	ldi	r22, 0x14	; 20
    1274:	c7 01       	movw	r24, r14
    1276:	88 df       	rcall	.-240    	; 0x1188 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF5SIDH, std, ulFilt);
    1278:	00 e0       	ldi	r16, 0x00	; 0
    127a:	10 e0       	ldi	r17, 0x00	; 0
    127c:	98 01       	movw	r18, r16
    127e:	40 e0       	ldi	r20, 0x00	; 0
    1280:	68 e1       	ldi	r22, 0x18	; 24
    1282:	c7 01       	movw	r24, r14
    1284:	81 df       	rcall	.-254    	; 0x1188 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>

	/* Clear, deactivate the three  */
	/* transmit buffers             */
	/* TXBnCTRL -> TXBnD7           */
	a1 = MCP_TXB0CTRL;
    1286:	c0 e3       	ldi	r28, 0x30	; 48
	a2 = MCP_TXB1CTRL;
	a3 = MCP_TXB2CTRL;
	for (i = 0; i < 14; i++) {                                          /* in-buffer loop               */
		mcp2515_setRegister(a1, 0);
    1288:	40 e0       	ldi	r20, 0x00	; 0
    128a:	6c 2f       	mov	r22, r28
    128c:	c7 01       	movw	r24, r14
    128e:	56 de       	rcall	.-852    	; 0xf3c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		mcp2515_setRegister(a2, 0);
    1290:	60 e1       	ldi	r22, 0x10	; 16
    1292:	6c 0f       	add	r22, r28
    1294:	40 e0       	ldi	r20, 0x00	; 0
    1296:	c7 01       	movw	r24, r14
    1298:	51 de       	rcall	.-862    	; 0xf3c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		mcp2515_setRegister(a3, 0);
    129a:	60 e2       	ldi	r22, 0x20	; 32
    129c:	6c 0f       	add	r22, r28
    129e:	40 e0       	ldi	r20, 0x00	; 0
    12a0:	c7 01       	movw	r24, r14
    12a2:	4c de       	rcall	.-872    	; 0xf3c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		a1++;
    12a4:	cf 5f       	subi	r28, 0xFF	; 255
	/* transmit buffers             */
	/* TXBnCTRL -> TXBnD7           */
	a1 = MCP_TXB0CTRL;
	a2 = MCP_TXB1CTRL;
	a3 = MCP_TXB2CTRL;
	for (i = 0; i < 14; i++) {                                          /* in-buffer loop               */
    12a6:	ce 33       	cpi	r28, 0x3E	; 62
    12a8:	79 f7       	brne	.-34     	; 0x1288 <_ZN7MCP_CAN22mcp2515_initCANBuffersEv+0x7c>
		mcp2515_setRegister(a3, 0);
		a1++;
		a2++;
		a3++;
	}
	mcp2515_setRegister(MCP_RXB0CTRL, 0);
    12aa:	40 e0       	ldi	r20, 0x00	; 0
    12ac:	60 e6       	ldi	r22, 0x60	; 96
    12ae:	c7 01       	movw	r24, r14
    12b0:	45 de       	rcall	.-886    	; 0xf3c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    12b2:	40 e0       	ldi	r20, 0x00	; 0
	mcp2515_setRegister(MCP_RXB1CTRL, 0);
    12b4:	60 e7       	ldi	r22, 0x70	; 112
    12b6:	c7 01       	movw	r24, r14
    12b8:	41 de       	rcall	.-894    	; 0xf3c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    12ba:	cf 91       	pop	r28
    12bc:	1f 91       	pop	r17
}
    12be:	0f 91       	pop	r16
    12c0:	ff 90       	pop	r15
    12c2:	ef 90       	pop	r14
    12c4:	08 95       	ret

000012c6 <_ZN7MCP_CAN12mcp2515_initEhhh>:
    12c6:	ff 92       	push	r15
    12c8:	0f 93       	push	r16

/*********************************************************************************************************
** Function name:           mcp2515_init
** Descriptions:            Initialize the controller
*********************************************************************************************************/
uint8_t MCP_CAN::mcp2515_init(const uint8_t canIDMode, const uint8_t canSpeed, const uint8_t canClock){
    12ca:	1f 93       	push	r17
    12cc:	cf 93       	push	r28
    12ce:	df 93       	push	r29
    12d0:	ec 01       	movw	r28, r24
    12d2:	f6 2e       	mov	r15, r22
    12d4:	14 2f       	mov	r17, r20
    12d6:	02 2f       	mov	r16, r18
	uint8_t res;
	mcp2515_reset();
    12d8:	78 dd       	rcall	.-1296   	; 0xdca <_ZN7MCP_CAN13mcp2515_resetEv>
	mcpMode = MCP_LOOPBACK;
    12da:	80 e4       	ldi	r24, 0x40	; 64
    12dc:	89 8b       	std	Y+17, r24	; 0x11
	res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
    12de:	60 e8       	ldi	r22, 0x80	; 128
    12e0:	ce 01       	movw	r24, r28
    12e2:	26 df       	rcall	.-436    	; 0x1130 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>
	if(res > 0)
    12e4:	81 11       	cpse	r24, r1
    12e6:	35 c0       	rjmp	.+106    	; 0x1352 <_ZN7MCP_CAN12mcp2515_initEhhh+0x8c>
	return res;
	// Set Baudrate
	if(mcp2515_configRate(canSpeed, canClock))
    12e8:	40 2f       	mov	r20, r16
    12ea:	61 2f       	mov	r22, r17
    12ec:	ce 01       	movw	r24, r28
    12ee:	3a df       	rcall	.-396    	; 0x1164 <_ZN7MCP_CAN18mcp2515_configRateEhh>
    12f0:	81 11       	cpse	r24, r1
	return res;
	if ( res == MCP2515_OK ) {
		mcp2515_initCANBuffers();											//init canbuffers
    12f2:	2c c0       	rjmp	.+88     	; 0x134c <_ZN7MCP_CAN12mcp2515_initEhhh+0x86>
    12f4:	ce 01       	movw	r24, r28
		mcp2515_setRegister(MCP_CANINTE, MCP_RX0IF | MCP_RX1IF);			//interrupt mode
    12f6:	8a df       	rcall	.-236    	; 0x120c <_ZN7MCP_CAN22mcp2515_initCANBuffersEv>
    12f8:	43 e0       	ldi	r20, 0x03	; 3
    12fa:	6b e2       	ldi	r22, 0x2B	; 43
    12fc:	ce 01       	movw	r24, r28
		mcp2515_setRegister(MCP_BFPCTRL,MCP_BxBFS_MASK | MCP_BxBFE_MASK);	//Sets BF pins as GPO
    12fe:	1e de       	rcall	.-964    	; 0xf3c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1300:	4c e3       	ldi	r20, 0x3C	; 60
    1302:	6c e0       	ldi	r22, 0x0C	; 12
    1304:	ce 01       	movw	r24, r28
		mcp2515_setRegister(MCP_TXRTSCTRL,0x00);							//Sets RTS pins as GPI
    1306:	1a de       	rcall	.-972    	; 0xf3c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1308:	40 e0       	ldi	r20, 0x00	; 0
    130a:	6d e0       	ldi	r22, 0x0D	; 13
    130c:	ce 01       	movw	r24, r28
    130e:	16 de       	rcall	.-980    	; 0xf3c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		switch(canIDMode){
    1310:	ff 20       	and	r15, r15
    1312:	71 f0       	breq	.+28     	; 0x1330 <_ZN7MCP_CAN12mcp2515_initEhhh+0x6a>
    1314:	83 e0       	ldi	r24, 0x03	; 3
    1316:	f8 12       	cpse	r15, r24
			case (MCP_ANY):
			mcp2515_modifyRegister(MCP_RXB0CTRL,
			MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
			MCP_RXB_RX_ANY | MCP_RXB_BUKT_MASK);
    1318:	1b c0       	rjmp	.+54     	; 0x1350 <_ZN7MCP_CAN12mcp2515_initEhhh+0x8a>
    131a:	24 e6       	ldi	r18, 0x64	; 100
    131c:	44 e6       	ldi	r20, 0x64	; 100
    131e:	60 e6       	ldi	r22, 0x60	; 96
    1320:	ce 01       	movw	r24, r28
			mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
			MCP_RXB_RX_ANY);
    1322:	95 de       	rcall	.-726    	; 0x104e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    1324:	20 e6       	ldi	r18, 0x60	; 96
    1326:	40 e6       	ldi	r20, 0x60	; 96
    1328:	60 e7       	ldi	r22, 0x70	; 112
    132a:	ce 01       	movw	r24, r28
			break;
    132c:	90 de       	rcall	.-736    	; 0x104e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
			case (MCP_STDEXT):
			mcp2515_modifyRegister(MCP_RXB0CTRL,
			MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
			MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK );
    132e:	0a c0       	rjmp	.+20     	; 0x1344 <_ZN7MCP_CAN12mcp2515_initEhhh+0x7e>
    1330:	24 e0       	ldi	r18, 0x04	; 4
    1332:	44 e6       	ldi	r20, 0x64	; 100
    1334:	60 e6       	ldi	r22, 0x60	; 96
			mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
			MCP_RXB_RX_STDEXT);
    1336:	ce 01       	movw	r24, r28
    1338:	8a de       	rcall	.-748    	; 0x104e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    133a:	20 e0       	ldi	r18, 0x00	; 0
    133c:	40 e6       	ldi	r20, 0x60	; 96
    133e:	60 e7       	ldi	r22, 0x70	; 112
    1340:	ce 01       	movw	r24, r28
			break;
			default:
			return MCP2515_FAIL;
			break;
		}
		res = mcp2515_setCANCTRL_Mode(mcpMode);
    1342:	85 de       	rcall	.-758    	; 0x104e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    1344:	69 89       	ldd	r22, Y+17	; 0x11
    1346:	ce 01       	movw	r24, r28
    1348:	f3 de       	rcall	.-538    	; 0x1130 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>
    134a:	03 c0       	rjmp	.+6      	; 0x1352 <_ZN7MCP_CAN12mcp2515_initEhhh+0x8c>
	res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
	if(res > 0)
	return res;
	// Set Baudrate
	if(mcp2515_configRate(canSpeed, canClock))
	return res;
    134c:	80 e0       	ldi	r24, 0x00	; 0
    134e:	01 c0       	rjmp	.+2      	; 0x1352 <_ZN7MCP_CAN12mcp2515_initEhhh+0x8c>
			MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK );
			mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
			MCP_RXB_RX_STDEXT);
			break;
			default:
			return MCP2515_FAIL;
    1350:	81 e0       	ldi	r24, 0x01	; 1
		res = mcp2515_setCANCTRL_Mode(mcpMode);
		if(res)
		return res;
	}
	return res;
}
    1352:	df 91       	pop	r29
    1354:	cf 91       	pop	r28
    1356:	1f 91       	pop	r17
    1358:	0f 91       	pop	r16
    135a:	ff 90       	pop	r15
    135c:	08 95       	ret

0000135e <_ZN7MCP_CAN15mcp2515_read_idEhPhPm>:

/*********************************************************************************************************
** Function name:           mcp2515_read_id
** Descriptions:            Read CAN ID
*********************************************************************************************************/
void MCP_CAN::mcp2515_read_id( const uint8_t mcp_addr, uint8_t* ext, uint32_t* id ){
    135e:	ef 92       	push	r14
    1360:	ff 92       	push	r15
    1362:	0f 93       	push	r16
    1364:	1f 93       	push	r17
    1366:	cf 93       	push	r28
    1368:	df 93       	push	r29
    136a:	00 d0       	rcall	.+0      	; 0x136c <_ZN7MCP_CAN15mcp2515_read_idEhPhPm+0xe>
    136c:	1f 92       	push	r1
    136e:	cd b7       	in	r28, 0x3d	; 61
    1370:	de b7       	in	r29, 0x3e	; 62
    1372:	7a 01       	movw	r14, r20
    1374:	89 01       	movw	r16, r18
	uint8_t tbufdata[4];
	*ext = 0;
    1376:	fa 01       	movw	r30, r20
    1378:	10 82       	st	Z, r1
	*id = 0;
    137a:	f9 01       	movw	r30, r18
    137c:	10 82       	st	Z, r1
    137e:	11 82       	std	Z+1, r1	; 0x01
    1380:	12 82       	std	Z+2, r1	; 0x02
    1382:	13 82       	std	Z+3, r1	; 0x03
	mcp2515_readRegisterS( mcp_addr, tbufdata, 4 );
    1384:	24 e0       	ldi	r18, 0x04	; 4
    1386:	ae 01       	movw	r20, r28
    1388:	4f 5f       	subi	r20, 0xFF	; 255
    138a:	5f 4f       	sbci	r21, 0xFF	; 255
    138c:	87 dd       	rcall	.-1266   	; 0xe9c <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh>
	*id = (tbufdata[MCP_SIDH]<<3) + (tbufdata[MCP_SIDL]>>5);
    138e:	2a 81       	ldd	r18, Y+2	; 0x02
    1390:	39 81       	ldd	r19, Y+1	; 0x01
    1392:	82 2f       	mov	r24, r18
    1394:	90 e0       	ldi	r25, 0x00	; 0
    1396:	95 95       	asr	r25
    1398:	87 95       	ror	r24
    139a:	95 95       	asr	r25
    139c:	87 95       	ror	r24
    139e:	95 95       	asr	r25
    13a0:	87 95       	ror	r24
    13a2:	95 95       	asr	r25
    13a4:	87 95       	ror	r24
    13a6:	95 95       	asr	r25
    13a8:	87 95       	ror	r24
    13aa:	f8 e0       	ldi	r31, 0x08	; 8
    13ac:	3f 9f       	mul	r19, r31
    13ae:	80 0d       	add	r24, r0
    13b0:	91 1d       	adc	r25, r1
    13b2:	11 24       	eor	r1, r1
    13b4:	09 2e       	mov	r0, r25
    13b6:	00 0c       	add	r0, r0
    13b8:	aa 0b       	sbc	r26, r26
    13ba:	bb 0b       	sbc	r27, r27
    13bc:	f8 01       	movw	r30, r16
    13be:	80 83       	st	Z, r24
    13c0:	91 83       	std	Z+1, r25	; 0x01
    13c2:	a2 83       	std	Z+2, r26	; 0x02
    13c4:	b3 83       	std	Z+3, r27	; 0x03
	if ( (tbufdata[MCP_SIDL] & MCP_TXB_EXIDE_M) ==  MCP_TXB_EXIDE_M ){
    13c6:	23 ff       	sbrs	r18, 3
    13c8:	26 c0       	rjmp	.+76     	; 0x1416 <_ZN7MCP_CAN15mcp2515_read_idEhPhPm+0xb8>
		/* extended id                  */
		*id = (*id<<2) + (tbufdata[MCP_SIDL] & 0x03);
		*id = (*id<<8) + tbufdata[MCP_EID8];
		*id = (*id<<8) + tbufdata[MCP_EID0];
    13ca:	88 0f       	add	r24, r24
    13cc:	99 1f       	adc	r25, r25
    13ce:	aa 1f       	adc	r26, r26
    13d0:	bb 1f       	adc	r27, r27
    13d2:	88 0f       	add	r24, r24
    13d4:	99 1f       	adc	r25, r25
    13d6:	aa 1f       	adc	r26, r26
    13d8:	bb 1f       	adc	r27, r27
    13da:	23 70       	andi	r18, 0x03	; 3
    13dc:	82 0f       	add	r24, r18
    13de:	91 1d       	adc	r25, r1
    13e0:	a1 1d       	adc	r26, r1
    13e2:	b1 1d       	adc	r27, r1
    13e4:	ba 2f       	mov	r27, r26
    13e6:	a9 2f       	mov	r26, r25
    13e8:	98 2f       	mov	r25, r24
    13ea:	88 27       	eor	r24, r24
    13ec:	2b 81       	ldd	r18, Y+3	; 0x03
    13ee:	82 0f       	add	r24, r18
    13f0:	91 1d       	adc	r25, r1
    13f2:	a1 1d       	adc	r26, r1
    13f4:	b1 1d       	adc	r27, r1
    13f6:	ba 2f       	mov	r27, r26
    13f8:	a9 2f       	mov	r26, r25
    13fa:	98 2f       	mov	r25, r24
    13fc:	88 27       	eor	r24, r24
    13fe:	2c 81       	ldd	r18, Y+4	; 0x04
    1400:	82 0f       	add	r24, r18
    1402:	91 1d       	adc	r25, r1
    1404:	a1 1d       	adc	r26, r1
    1406:	b1 1d       	adc	r27, r1
    1408:	80 83       	st	Z, r24
    140a:	91 83       	std	Z+1, r25	; 0x01
    140c:	a2 83       	std	Z+2, r26	; 0x02
    140e:	b3 83       	std	Z+3, r27	; 0x03
		*ext = 1;
    1410:	81 e0       	ldi	r24, 0x01	; 1
    1412:	f7 01       	movw	r30, r14
    1414:	80 83       	st	Z, r24
	}
}
    1416:	0f 90       	pop	r0
    1418:	0f 90       	pop	r0
    141a:	0f 90       	pop	r0
    141c:	0f 90       	pop	r0
    141e:	df 91       	pop	r29
    1420:	cf 91       	pop	r28
    1422:	1f 91       	pop	r17
    1424:	0f 91       	pop	r16
    1426:	ff 90       	pop	r15
    1428:	ef 90       	pop	r14
    142a:	08 95       	ret

0000142c <_ZN7MCP_CAN19mcp2515_read_canMsgEh>:

/*********************************************************************************************************
** Function name:           mcp2515_read_canMsg
** Descriptions:            Read message
*********************************************************************************************************/
void MCP_CAN::mcp2515_read_canMsg( const uint8_t buffer_sidh_addr){        /* read can msg                 */
    142c:	0f 93       	push	r16
    142e:	1f 93       	push	r17
    1430:	cf 93       	push	r28
    1432:	df 93       	push	r29
    1434:	ec 01       	movw	r28, r24
    1436:	16 2f       	mov	r17, r22
	uint8_t mcp_addr, ctrl;
	mcp_addr = buffer_sidh_addr;
	mcp2515_read_id( mcp_addr, &m_nExtFlg,&m_nID );
    1438:	9c 01       	movw	r18, r24
    143a:	2f 5f       	subi	r18, 0xFF	; 255
    143c:	3f 4f       	sbci	r19, 0xFF	; 255
    143e:	ac 01       	movw	r20, r24
    1440:	8e df       	rcall	.-228    	; 0x135e <_ZN7MCP_CAN15mcp2515_read_idEhPhPm>
	ctrl = mcp2515_readRegister( mcp_addr-1 );
    1442:	6f ef       	ldi	r22, 0xFF	; 255
    1444:	61 0f       	add	r22, r17
    1446:	ce 01       	movw	r24, r28
    1448:	f2 dc       	rcall	.-1564   	; 0xe2e <_ZN7MCP_CAN20mcp2515_readRegisterEh>
    144a:	08 2f       	mov	r16, r24
	m_nDlc = mcp2515_readRegister( mcp_addr+4 );
    144c:	64 e0       	ldi	r22, 0x04	; 4
    144e:	61 0f       	add	r22, r17
    1450:	ce 01       	movw	r24, r28
    1452:	ed dc       	rcall	.-1574   	; 0xe2e <_ZN7MCP_CAN20mcp2515_readRegisterEh>
    1454:	8d 83       	std	Y+5, r24	; 0x05
	if (ctrl & 0x08)
    1456:	03 ff       	sbrs	r16, 3
    1458:	03 c0       	rjmp	.+6      	; 0x1460 <_ZN7MCP_CAN19mcp2515_read_canMsgEh+0x34>
		m_nRtr = 1;
    145a:	91 e0       	ldi	r25, 0x01	; 1
    145c:	9e 87       	std	Y+14, r25	; 0x0e
    145e:	01 c0       	rjmp	.+2      	; 0x1462 <_ZN7MCP_CAN19mcp2515_read_canMsgEh+0x36>
	else
		m_nRtr = 0;
    1460:	1e 86       	std	Y+14, r1	; 0x0e
	m_nDlc &= MCP_DLC_MASK;
    1462:	28 2f       	mov	r18, r24
    1464:	2f 70       	andi	r18, 0x0F	; 15
    1466:	2d 83       	std	Y+5, r18	; 0x05
	mcp2515_readRegisterS( mcp_addr+5, &(m_nDta[0]), m_nDlc );
    1468:	ae 01       	movw	r20, r28
    146a:	4a 5f       	subi	r20, 0xFA	; 250
    146c:	5f 4f       	sbci	r21, 0xFF	; 255
    146e:	65 e0       	ldi	r22, 0x05	; 5
    1470:	61 0f       	add	r22, r17
    1472:	ce 01       	movw	r24, r28
    1474:	13 dd       	rcall	.-1498   	; 0xe9c <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh>
}
    1476:	df 91       	pop	r29
    1478:	cf 91       	pop	r28
    147a:	1f 91       	pop	r17
    147c:	0f 91       	pop	r16
    147e:	08 95       	ret

00001480 <_ZN7MCP_CANC1Eh>:
** Function name:           MCP_CAN
** Descriptions:            Public function to declare CAN class and the /CS pin.
*********************************************************************************************************/
MCP_CAN::MCP_CAN(uint8_t _CS)
{
	MCPCS = _CS;
    1480:	fc 01       	movw	r30, r24
    1482:	60 8b       	std	Z+16, r22	; 0x10
	MCP2515_UNSELECT();
    1484:	eb e0       	ldi	r30, 0x0B	; 11
    1486:	f1 e0       	ldi	r31, 0x01	; 1
    1488:	80 81       	ld	r24, Z
    148a:	84 60       	ori	r24, 0x04	; 4
    148c:	80 83       	st	Z, r24
	DDRL |= (1 << PL2);		//????
    148e:	ea e0       	ldi	r30, 0x0A	; 10
    1490:	f1 e0       	ldi	r31, 0x01	; 1
    1492:	80 81       	ld	r24, Z
    1494:	84 60       	ori	r24, 0x04	; 4
    1496:	80 83       	st	Z, r24
    1498:	08 95       	ret

0000149a <_ZN7MCP_CAN5beginEhhh>:
/*********************************************************************************************************
** Function name:           begin
** Descriptions:            Public function to declare controller initialization parameters.
*********************************************************************************************************/
uint8_t MCP_CAN::begin(uint8_t idmodeset, uint8_t speedset, uint8_t clockset)
{
    149a:	ff 92       	push	r15
    149c:	0f 93       	push	r16
    149e:	1f 93       	push	r17
    14a0:	cf 93       	push	r28
    14a2:	df 93       	push	r29
    14a4:	ec 01       	movw	r28, r24
    14a6:	16 2f       	mov	r17, r22
    14a8:	04 2f       	mov	r16, r20
    14aa:	f2 2e       	mov	r15, r18
	uint8_t res;

	SPI.begin();
    14ac:	90 d0       	rcall	.+288    	; 0x15ce <_ZN8SPIClass5beginEv>
	res = mcp2515_init(idmodeset, speedset, clockset);
    14ae:	2f 2d       	mov	r18, r15
    14b0:	40 2f       	mov	r20, r16
    14b2:	61 2f       	mov	r22, r17
    14b4:	ce 01       	movw	r24, r28
    14b6:	07 df       	rcall	.-498    	; 0x12c6 <_ZN7MCP_CAN12mcp2515_initEhhh>
    14b8:	91 e0       	ldi	r25, 0x01	; 1
    14ba:	81 11       	cpse	r24, r1
    14bc:	01 c0       	rjmp	.+2      	; 0x14c0 <_ZN7MCP_CAN5beginEhhh+0x26>
    14be:	90 e0       	ldi	r25, 0x00	; 0
	if (res == MCP2515_OK)
	return CAN_OK;
	
	return CAN_FAILINIT;
}
    14c0:	89 2f       	mov	r24, r25
    14c2:	df 91       	pop	r29
    14c4:	cf 91       	pop	r28
    14c6:	1f 91       	pop	r17
    14c8:	0f 91       	pop	r16
    14ca:	ff 90       	pop	r15
    14cc:	08 95       	ret

000014ce <_ZN7MCP_CAN7readMsgEv>:

/*********************************************************************************************************
** Function name:           readMsg
** Descriptions:            Read message
*********************************************************************************************************/
uint8_t MCP_CAN::readMsg(){
    14ce:	cf 93       	push	r28
    14d0:	df 93       	push	r29
    14d2:	ec 01       	movw	r28, r24
	uint8_t stat, res;
	stat = mcp2515_readStatus();
    14d4:	fd dd       	rcall	.-1030   	; 0x10d0 <_ZN7MCP_CAN18mcp2515_readStatusEv>

	if ( stat & MCP_STAT_RX0IF )                                        /* Msg in Buffer 0              */
    14d6:	80 ff       	sbrs	r24, 0
    14d8:	0a c0       	rjmp	.+20     	; 0x14ee <_ZN7MCP_CAN7readMsgEv+0x20>
	{
		mcp2515_read_canMsg( MCP_RXBUF_0);
    14da:	61 e6       	ldi	r22, 0x61	; 97
    14dc:	ce 01       	movw	r24, r28
    14de:	a6 df       	rcall	.-180    	; 0x142c <_ZN7MCP_CAN19mcp2515_read_canMsgEh>
		mcp2515_modifyRegister(MCP_CANINTF, MCP_RX0IF, 0);
    14e0:	20 e0       	ldi	r18, 0x00	; 0
    14e2:	41 e0       	ldi	r20, 0x01	; 1
    14e4:	6c e2       	ldi	r22, 0x2C	; 44
    14e6:	ce 01       	movw	r24, r28
    14e8:	b2 dd       	rcall	.-1180   	; 0x104e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
		res = CAN_OK;
    14ea:	80 e0       	ldi	r24, 0x00	; 0
    14ec:	0d c0       	rjmp	.+26     	; 0x1508 <_ZN7MCP_CAN7readMsgEv+0x3a>
	}
	else if ( stat & MCP_STAT_RX1IF )                                   /* Msg in Buffer 1              */
    14ee:	81 ff       	sbrs	r24, 1
	{
		mcp2515_read_canMsg( MCP_RXBUF_1);
    14f0:	0a c0       	rjmp	.+20     	; 0x1506 <_ZN7MCP_CAN7readMsgEv+0x38>
    14f2:	61 e7       	ldi	r22, 0x71	; 113
    14f4:	ce 01       	movw	r24, r28
    14f6:	9a df       	rcall	.-204    	; 0x142c <_ZN7MCP_CAN19mcp2515_read_canMsgEh>
		mcp2515_modifyRegister(MCP_CANINTF, MCP_RX1IF, 0);
    14f8:	20 e0       	ldi	r18, 0x00	; 0
    14fa:	42 e0       	ldi	r20, 0x02	; 2
    14fc:	6c e2       	ldi	r22, 0x2C	; 44
    14fe:	ce 01       	movw	r24, r28
    1500:	a6 dd       	rcall	.-1204   	; 0x104e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
		res = CAN_OK;
    1502:	80 e0       	ldi	r24, 0x00	; 0
    1504:	01 c0       	rjmp	.+2      	; 0x1508 <_ZN7MCP_CAN7readMsgEv+0x3a>
	}
	else
	res = CAN_NOMSG;
    1506:	84 e0       	ldi	r24, 0x04	; 4
	
	return res;
}
    1508:	df 91       	pop	r29
    150a:	cf 91       	pop	r28
    150c:	08 95       	ret

0000150e <_ZN7MCP_CAN10readMsgBufEPmPhS1_>:

/*********************************************************************************************************
** Function name:           readMsgBuf
** Descriptions:            Public function, Reads message from receive buffer.
*********************************************************************************************************/
uint8_t MCP_CAN::readMsgBuf(uint32_t *id, uint8_t *len, uint8_t buf[]){
    150e:	cf 92       	push	r12
    1510:	df 92       	push	r13
    1512:	ef 92       	push	r14
    1514:	ff 92       	push	r15
    1516:	0f 93       	push	r16
    1518:	1f 93       	push	r17
    151a:	cf 93       	push	r28
    151c:	df 93       	push	r29
    151e:	ec 01       	movw	r28, r24
    1520:	7b 01       	movw	r14, r22
    1522:	8a 01       	movw	r16, r20
    1524:	c2 2e       	mov	r12, r18
    1526:	d3 2e       	mov	r13, r19
	if(readMsg() == CAN_NOMSG)
    1528:	d2 df       	rcall	.-92     	; 0x14ce <_ZN7MCP_CAN7readMsgEv>
    152a:	84 30       	cpi	r24, 0x04	; 4
    152c:	c9 f1       	breq	.+114    	; 0x15a0 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x92>
	return CAN_NOMSG;

	if (m_nExtFlg)
    152e:	88 81       	ld	r24, Y
    1530:	88 23       	and	r24, r24
    1532:	49 f0       	breq	.+18     	; 0x1546 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x38>
	m_nID |= 0x80000000;
    1534:	89 81       	ldd	r24, Y+1	; 0x01
    1536:	9a 81       	ldd	r25, Y+2	; 0x02
    1538:	ab 81       	ldd	r26, Y+3	; 0x03
    153a:	bc 81       	ldd	r27, Y+4	; 0x04
    153c:	b0 68       	ori	r27, 0x80	; 128
    153e:	89 83       	std	Y+1, r24	; 0x01
    1540:	9a 83       	std	Y+2, r25	; 0x02
    1542:	ab 83       	std	Y+3, r26	; 0x03
    1544:	bc 83       	std	Y+4, r27	; 0x04

	if (m_nRtr)
    1546:	8e 85       	ldd	r24, Y+14	; 0x0e
    1548:	88 23       	and	r24, r24
    154a:	49 f0       	breq	.+18     	; 0x155e <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x50>
	m_nID |= 0x40000000;
    154c:	89 81       	ldd	r24, Y+1	; 0x01
    154e:	9a 81       	ldd	r25, Y+2	; 0x02
    1550:	ab 81       	ldd	r26, Y+3	; 0x03
    1552:	bc 81       	ldd	r27, Y+4	; 0x04
    1554:	b0 64       	ori	r27, 0x40	; 64
    1556:	89 83       	std	Y+1, r24	; 0x01
    1558:	9a 83       	std	Y+2, r25	; 0x02
    155a:	ab 83       	std	Y+3, r26	; 0x03
    155c:	bc 83       	std	Y+4, r27	; 0x04
	*id  = m_nID;
    155e:	89 81       	ldd	r24, Y+1	; 0x01
    1560:	9a 81       	ldd	r25, Y+2	; 0x02
    1562:	ab 81       	ldd	r26, Y+3	; 0x03
    1564:	bc 81       	ldd	r27, Y+4	; 0x04
    1566:	f7 01       	movw	r30, r14
    1568:	80 83       	st	Z, r24
    156a:	91 83       	std	Z+1, r25	; 0x01
    156c:	a2 83       	std	Z+2, r26	; 0x02
    156e:	b3 83       	std	Z+3, r27	; 0x03
	*len = m_nDlc;
    1570:	8d 81       	ldd	r24, Y+5	; 0x05
    1572:	f8 01       	movw	r30, r16
    1574:	80 83       	st	Z, r24
	for(int i = 0; i<m_nDlc; i++)
    1576:	8d 81       	ldd	r24, Y+5	; 0x05
    1578:	88 23       	and	r24, r24
    157a:	89 f0       	breq	.+34     	; 0x159e <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x90>
    157c:	de 01       	movw	r26, r28
    157e:	16 96       	adiw	r26, 0x06	; 6
    1580:	ec 2d       	mov	r30, r12
    1582:	fd 2d       	mov	r31, r13
    1584:	20 e0       	ldi	r18, 0x00	; 0
    1586:	30 e0       	ldi	r19, 0x00	; 0
	buf[i] = m_nDta[i];
    1588:	8d 91       	ld	r24, X+
    158a:	81 93       	st	Z+, r24

	if (m_nRtr)
	m_nID |= 0x40000000;
	*id  = m_nID;
	*len = m_nDlc;
	for(int i = 0; i<m_nDlc; i++)
    158c:	2f 5f       	subi	r18, 0xFF	; 255
    158e:	3f 4f       	sbci	r19, 0xFF	; 255
    1590:	8d 81       	ldd	r24, Y+5	; 0x05
    1592:	90 e0       	ldi	r25, 0x00	; 0
    1594:	28 17       	cp	r18, r24
    1596:	39 07       	cpc	r19, r25
    1598:	bc f3       	brlt	.-18     	; 0x1588 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x7a>
	buf[i] = m_nDta[i];
	return CAN_OK;
    159a:	80 e0       	ldi	r24, 0x00	; 0
    159c:	01 c0       	rjmp	.+2      	; 0x15a0 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x92>
    159e:	80 e0       	ldi	r24, 0x00	; 0
}
    15a0:	df 91       	pop	r29
    15a2:	cf 91       	pop	r28
    15a4:	1f 91       	pop	r17
    15a6:	0f 91       	pop	r16
    15a8:	ff 90       	pop	r15
    15aa:	ef 90       	pop	r14
    15ac:	df 90       	pop	r13
    15ae:	cf 90       	pop	r12
    15b0:	08 95       	ret

000015b2 <_ZN11SPISettingsC1Emhh>:
void SPIClass::end() {
	cli();							// Protect from a scheduler and prevent transactionBegin
	if (initialized)					// Decrease the reference counter
		initialized--;
	if (!initialized)				
		SPCR &= ~(1 << SPE);
    15b2:	0f 93       	push	r16
    15b4:	fc 01       	movw	r30, r24
    15b6:	22 23       	and	r18, r18
    15b8:	11 f0       	breq	.+4      	; 0x15be <_ZN11SPISettingsC1Emhh+0xc>
    15ba:	90 e5       	ldi	r25, 0x50	; 80
    15bc:	01 c0       	rjmp	.+2      	; 0x15c0 <_ZN11SPISettingsC1Emhh+0xe>
    15be:	90 e7       	ldi	r25, 0x70	; 112
    15c0:	0c 70       	andi	r16, 0x0C	; 12
    15c2:	09 2b       	or	r16, r25
    15c4:	00 83       	st	Z, r16
    15c6:	81 e0       	ldi	r24, 0x01	; 1
    15c8:	81 83       	std	Z+1, r24	; 0x01
    15ca:	0f 91       	pop	r16
    15cc:	08 95       	ret

000015ce <_ZN8SPIClass5beginEv>:
    15ce:	f8 94       	cli
    15d0:	80 91 8b 04 	lds	r24, 0x048B	; 0x80048b <_ZN8SPIClass11initializedE>
    15d4:	81 11       	cpse	r24, r1
    15d6:	0b c0       	rjmp	.+22     	; 0x15ee <_ZN8SPIClass5beginEv+0x20>
    15d8:	58 9a       	sbi	0x0b, 0	; 11
    15da:	20 9a       	sbi	0x04, 0	; 4
    15dc:	84 b1       	in	r24, 0x04	; 4
    15de:	86 60       	ori	r24, 0x06	; 6
    15e0:	84 b9       	out	0x04, r24	; 4
    15e2:	8c b5       	in	r24, 0x2c	; 44
    15e4:	80 61       	ori	r24, 0x10	; 16
    15e6:	8c bd       	out	0x2c, r24	; 44
    15e8:	8c b5       	in	r24, 0x2c	; 44
    15ea:	80 64       	ori	r24, 0x40	; 64
    15ec:	8c bd       	out	0x2c, r24	; 44
    15ee:	80 91 8b 04 	lds	r24, 0x048B	; 0x80048b <_ZN8SPIClass11initializedE>
    15f2:	8f 5f       	subi	r24, 0xFF	; 255
    15f4:	80 93 8b 04 	sts	0x048B, r24	; 0x80048b <_ZN8SPIClass11initializedE>
    15f8:	08 95       	ret

000015fa <_ZN8SPIClass16beginTransactionE11SPISettings>:
}

void SPIClass::beginTransaction(SPISettings settings) {
	SPCR = settings.spcr;
    15fa:	fb 01       	movw	r30, r22
    15fc:	80 81       	ld	r24, Z
    15fe:	8c bd       	out	0x2c, r24	; 44
	SPSR = settings.spsr;
    1600:	81 81       	ldd	r24, Z+1	; 0x01
    1602:	8d bd       	out	0x2d, r24	; 45
    1604:	08 95       	ret

00001606 <_ZN8SPIClass8transferEh>:
}

uint8_t SPIClass::transfer(uint8_t data) {
SPDR = data;
    1606:	6e bd       	out	0x2e, r22	; 46
while (!(SPSR & (1 << SPIF))) ; // wait
    1608:	0d b4       	in	r0, 0x2d	; 45
    160a:	07 fe       	sbrs	r0, 7
    160c:	fd cf       	rjmp	.-6      	; 0x1608 <_ZN8SPIClass8transferEh+0x2>
return SPDR;
    160e:	8e b5       	in	r24, 0x2e	; 46
}
    1610:	08 95       	ret

00001612 <_ZN5USARTC1Ev>:
#include "USART.h"

//constructor with setup

USART::USART(){
	UCSR0B = (1 << TXEN0);						// Enable de USART Transmitter
    1612:	88 e0       	ldi	r24, 0x08	; 8
    1614:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);		// 8 data bits, 1 stop bit
    1618:	96 e0       	ldi	r25, 0x06	; 6
    161a:	90 93 c2 00 	sts	0x00C2, r25	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
	UBRR0H=0;									//write the baudrate (76800)
    161e:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
	UBRR0L=8;									// "
    1622:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    1626:	08 95       	ret

00001628 <_ZN5USART5printEPKc>:
}



//write a string in the Serial
void USART::print(const char st[]) {
    1628:	cf 93       	push	r28
    162a:	df 93       	push	r29
	for(uint8_t i = 0 ; st[i] != 0 ; i++) {		//iterate over every char in the string
    162c:	fb 01       	movw	r30, r22
    162e:	90 81       	ld	r25, Z
    1630:	99 23       	and	r25, r25
    1632:	81 f0       	breq	.+32     	; 0x1654 <_ZN5USART5printEPKc+0x2c>
    1634:	20 e0       	ldi	r18, 0x00	; 0
		while(~UCSR0A & (1 << UDRE0));			//wait till the transmit buffer is empty
    1636:	e0 ec       	ldi	r30, 0xC0	; 192
    1638:	f0 e0       	ldi	r31, 0x00	; 0
		UDR0 = (int)st[i];						//write the char in the transmit buffer
    163a:	c6 ec       	ldi	r28, 0xC6	; 198
    163c:	d0 e0       	ldi	r29, 0x00	; 0


//write a string in the Serial
void USART::print(const char st[]) {
	for(uint8_t i = 0 ; st[i] != 0 ; i++) {		//iterate over every char in the string
		while(~UCSR0A & (1 << UDRE0));			//wait till the transmit buffer is empty
    163e:	80 81       	ld	r24, Z
    1640:	85 ff       	sbrs	r24, 5
    1642:	fd cf       	rjmp	.-6      	; 0x163e <_ZN5USART5printEPKc+0x16>
		UDR0 = (int)st[i];						//write the char in the transmit buffer
    1644:	98 83       	st	Y, r25



//write a string in the Serial
void USART::print(const char st[]) {
	for(uint8_t i = 0 ; st[i] != 0 ; i++) {		//iterate over every char in the string
    1646:	2f 5f       	subi	r18, 0xFF	; 255
    1648:	db 01       	movw	r26, r22
    164a:	a2 0f       	add	r26, r18
    164c:	b1 1d       	adc	r27, r1
    164e:	9c 91       	ld	r25, X
    1650:	91 11       	cpse	r25, r1
    1652:	f5 cf       	rjmp	.-22     	; 0x163e <_ZN5USART5printEPKc+0x16>
		while(~UCSR0A & (1 << UDRE0));			//wait till the transmit buffer is empty
		UDR0 = (int)st[i];						//write the char in the transmit buffer
	}
}
    1654:	df 91       	pop	r29
    1656:	cf 91       	pop	r28
    1658:	08 95       	ret

0000165a <_ZN5USART7printlnEPKc>:

void USART::println(const char st[]){
    165a:	cf 93       	push	r28
    165c:	df 93       	push	r29
    165e:	ec 01       	movw	r28, r24
	this->print(st);
    1660:	e3 df       	rcall	.-58     	; 0x1628 <_ZN5USART5printEPKc>
	this->print("\n\r");
    1662:	60 e3       	ldi	r22, 0x30	; 48
    1664:	74 e0       	ldi	r23, 0x04	; 4
    1666:	ce 01       	movw	r24, r28
    1668:	df df       	rcall	.-66     	; 0x1628 <_ZN5USART5printEPKc>
}
    166a:	df 91       	pop	r29
    166c:	cf 91       	pop	r28
    166e:	08 95       	ret

00001670 <_ZN5USART5printEi>:

//write an integer in the Serial
void USART::print(int i) {
    1670:	0f 93       	push	r16
    1672:	1f 93       	push	r17
    1674:	cf 93       	push	r28
    1676:	df 93       	push	r29
    1678:	cd b7       	in	r28, 0x3d	; 61
    167a:	de b7       	in	r29, 0x3e	; 62
    167c:	60 97       	sbiw	r28, 0x10	; 16
    167e:	0f b6       	in	r0, 0x3f	; 63
    1680:	f8 94       	cli
    1682:	de bf       	out	0x3e, r29	; 62
    1684:	0f be       	out	0x3f, r0	; 63
    1686:	cd bf       	out	0x3d, r28	; 61
    1688:	8c 01       	movw	r16, r24
    168a:	cb 01       	movw	r24, r22
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    168c:	4a e0       	ldi	r20, 0x0A	; 10
    168e:	be 01       	movw	r22, r28
    1690:	6f 5f       	subi	r22, 0xFF	; 255
    1692:	7f 4f       	sbci	r23, 0xFF	; 255
    1694:	a2 d1       	rcall	.+836    	; 0x19da <__itoa_ncheck>
	char buffer[16];							//create a string
	itoa(i,buffer,10);							//parse the integer into the string
	print(buffer);						//print the string
    1696:	be 01       	movw	r22, r28
    1698:	6f 5f       	subi	r22, 0xFF	; 255
    169a:	7f 4f       	sbci	r23, 0xFF	; 255
    169c:	c8 01       	movw	r24, r16
    169e:	c4 df       	rcall	.-120    	; 0x1628 <_ZN5USART5printEPKc>
}
    16a0:	60 96       	adiw	r28, 0x10	; 16
    16a2:	0f b6       	in	r0, 0x3f	; 63
    16a4:	f8 94       	cli
    16a6:	de bf       	out	0x3e, r29	; 62
    16a8:	0f be       	out	0x3f, r0	; 63
    16aa:	cd bf       	out	0x3d, r28	; 61
    16ac:	df 91       	pop	r29
    16ae:	cf 91       	pop	r28
    16b0:	1f 91       	pop	r17
    16b2:	0f 91       	pop	r16
    16b4:	08 95       	ret

000016b6 <_ZN5USART7printlnEi>:

void USART::println(int i){
    16b6:	cf 93       	push	r28
    16b8:	df 93       	push	r29
    16ba:	ec 01       	movw	r28, r24
	this->print(i);
    16bc:	d9 df       	rcall	.-78     	; 0x1670 <_ZN5USART5printEi>
	this->print("\n\r");
    16be:	60 e3       	ldi	r22, 0x30	; 48
    16c0:	74 e0       	ldi	r23, 0x04	; 4
    16c2:	ce 01       	movw	r24, r28
    16c4:	b1 df       	rcall	.-158    	; 0x1628 <_ZN5USART5printEPKc>
}
    16c6:	df 91       	pop	r29
    16c8:	cf 91       	pop	r28
    16ca:	08 95       	ret

000016cc <__fixsfsi>:
    16cc:	04 d0       	rcall	.+8      	; 0x16d6 <__fixunssfsi>
    16ce:	68 94       	set
    16d0:	b1 11       	cpse	r27, r1
    16d2:	8d c0       	rjmp	.+282    	; 0x17ee <__fp_szero>
    16d4:	08 95       	ret

000016d6 <__fixunssfsi>:
    16d6:	70 d0       	rcall	.+224    	; 0x17b8 <__fp_splitA>
    16d8:	88 f0       	brcs	.+34     	; 0x16fc <__fixunssfsi+0x26>
    16da:	9f 57       	subi	r25, 0x7F	; 127
    16dc:	90 f0       	brcs	.+36     	; 0x1702 <__fixunssfsi+0x2c>
    16de:	b9 2f       	mov	r27, r25
    16e0:	99 27       	eor	r25, r25
    16e2:	b7 51       	subi	r27, 0x17	; 23
    16e4:	a0 f0       	brcs	.+40     	; 0x170e <__fixunssfsi+0x38>
    16e6:	d1 f0       	breq	.+52     	; 0x171c <__fixunssfsi+0x46>
    16e8:	66 0f       	add	r22, r22
    16ea:	77 1f       	adc	r23, r23
    16ec:	88 1f       	adc	r24, r24
    16ee:	99 1f       	adc	r25, r25
    16f0:	1a f0       	brmi	.+6      	; 0x16f8 <__fixunssfsi+0x22>
    16f2:	ba 95       	dec	r27
    16f4:	c9 f7       	brne	.-14     	; 0x16e8 <__fixunssfsi+0x12>
    16f6:	12 c0       	rjmp	.+36     	; 0x171c <__fixunssfsi+0x46>
    16f8:	b1 30       	cpi	r27, 0x01	; 1
    16fa:	81 f0       	breq	.+32     	; 0x171c <__fixunssfsi+0x46>
    16fc:	77 d0       	rcall	.+238    	; 0x17ec <__fp_zero>
    16fe:	b1 e0       	ldi	r27, 0x01	; 1
    1700:	08 95       	ret
    1702:	74 c0       	rjmp	.+232    	; 0x17ec <__fp_zero>
    1704:	67 2f       	mov	r22, r23
    1706:	78 2f       	mov	r23, r24
    1708:	88 27       	eor	r24, r24
    170a:	b8 5f       	subi	r27, 0xF8	; 248
    170c:	39 f0       	breq	.+14     	; 0x171c <__fixunssfsi+0x46>
    170e:	b9 3f       	cpi	r27, 0xF9	; 249
    1710:	cc f3       	brlt	.-14     	; 0x1704 <__fixunssfsi+0x2e>
    1712:	86 95       	lsr	r24
    1714:	77 95       	ror	r23
    1716:	67 95       	ror	r22
    1718:	b3 95       	inc	r27
    171a:	d9 f7       	brne	.-10     	; 0x1712 <__fixunssfsi+0x3c>
    171c:	3e f4       	brtc	.+14     	; 0x172c <__fixunssfsi+0x56>
    171e:	90 95       	com	r25
    1720:	80 95       	com	r24
    1722:	70 95       	com	r23
    1724:	61 95       	neg	r22
    1726:	7f 4f       	sbci	r23, 0xFF	; 255
    1728:	8f 4f       	sbci	r24, 0xFF	; 255
    172a:	9f 4f       	sbci	r25, 0xFF	; 255
    172c:	08 95       	ret

0000172e <__floatunsisf>:
    172e:	e8 94       	clt
    1730:	09 c0       	rjmp	.+18     	; 0x1744 <__floatsisf+0x12>

00001732 <__floatsisf>:
    1732:	97 fb       	bst	r25, 7
    1734:	3e f4       	brtc	.+14     	; 0x1744 <__floatsisf+0x12>
    1736:	90 95       	com	r25
    1738:	80 95       	com	r24
    173a:	70 95       	com	r23
    173c:	61 95       	neg	r22
    173e:	7f 4f       	sbci	r23, 0xFF	; 255
    1740:	8f 4f       	sbci	r24, 0xFF	; 255
    1742:	9f 4f       	sbci	r25, 0xFF	; 255
    1744:	99 23       	and	r25, r25
    1746:	a9 f0       	breq	.+42     	; 0x1772 <__floatsisf+0x40>
    1748:	f9 2f       	mov	r31, r25
    174a:	96 e9       	ldi	r25, 0x96	; 150
    174c:	bb 27       	eor	r27, r27
    174e:	93 95       	inc	r25
    1750:	f6 95       	lsr	r31
    1752:	87 95       	ror	r24
    1754:	77 95       	ror	r23
    1756:	67 95       	ror	r22
    1758:	b7 95       	ror	r27
    175a:	f1 11       	cpse	r31, r1
    175c:	f8 cf       	rjmp	.-16     	; 0x174e <__floatsisf+0x1c>
    175e:	fa f4       	brpl	.+62     	; 0x179e <__floatsisf+0x6c>
    1760:	bb 0f       	add	r27, r27
    1762:	11 f4       	brne	.+4      	; 0x1768 <__floatsisf+0x36>
    1764:	60 ff       	sbrs	r22, 0
    1766:	1b c0       	rjmp	.+54     	; 0x179e <__floatsisf+0x6c>
    1768:	6f 5f       	subi	r22, 0xFF	; 255
    176a:	7f 4f       	sbci	r23, 0xFF	; 255
    176c:	8f 4f       	sbci	r24, 0xFF	; 255
    176e:	9f 4f       	sbci	r25, 0xFF	; 255
    1770:	16 c0       	rjmp	.+44     	; 0x179e <__floatsisf+0x6c>
    1772:	88 23       	and	r24, r24
    1774:	11 f0       	breq	.+4      	; 0x177a <__floatsisf+0x48>
    1776:	96 e9       	ldi	r25, 0x96	; 150
    1778:	11 c0       	rjmp	.+34     	; 0x179c <__floatsisf+0x6a>
    177a:	77 23       	and	r23, r23
    177c:	21 f0       	breq	.+8      	; 0x1786 <__floatsisf+0x54>
    177e:	9e e8       	ldi	r25, 0x8E	; 142
    1780:	87 2f       	mov	r24, r23
    1782:	76 2f       	mov	r23, r22
    1784:	05 c0       	rjmp	.+10     	; 0x1790 <__floatsisf+0x5e>
    1786:	66 23       	and	r22, r22
    1788:	71 f0       	breq	.+28     	; 0x17a6 <__floatsisf+0x74>
    178a:	96 e8       	ldi	r25, 0x86	; 134
    178c:	86 2f       	mov	r24, r22
    178e:	70 e0       	ldi	r23, 0x00	; 0
    1790:	60 e0       	ldi	r22, 0x00	; 0
    1792:	2a f0       	brmi	.+10     	; 0x179e <__floatsisf+0x6c>
    1794:	9a 95       	dec	r25
    1796:	66 0f       	add	r22, r22
    1798:	77 1f       	adc	r23, r23
    179a:	88 1f       	adc	r24, r24
    179c:	da f7       	brpl	.-10     	; 0x1794 <__floatsisf+0x62>
    179e:	88 0f       	add	r24, r24
    17a0:	96 95       	lsr	r25
    17a2:	87 95       	ror	r24
    17a4:	97 f9       	bld	r25, 7
    17a6:	08 95       	ret

000017a8 <__fp_split3>:
    17a8:	57 fd       	sbrc	r21, 7
    17aa:	90 58       	subi	r25, 0x80	; 128
    17ac:	44 0f       	add	r20, r20
    17ae:	55 1f       	adc	r21, r21
    17b0:	59 f0       	breq	.+22     	; 0x17c8 <__fp_splitA+0x10>
    17b2:	5f 3f       	cpi	r21, 0xFF	; 255
    17b4:	71 f0       	breq	.+28     	; 0x17d2 <__fp_splitA+0x1a>
    17b6:	47 95       	ror	r20

000017b8 <__fp_splitA>:
    17b8:	88 0f       	add	r24, r24
    17ba:	97 fb       	bst	r25, 7
    17bc:	99 1f       	adc	r25, r25
    17be:	61 f0       	breq	.+24     	; 0x17d8 <__fp_splitA+0x20>
    17c0:	9f 3f       	cpi	r25, 0xFF	; 255
    17c2:	79 f0       	breq	.+30     	; 0x17e2 <__fp_splitA+0x2a>
    17c4:	87 95       	ror	r24
    17c6:	08 95       	ret
    17c8:	12 16       	cp	r1, r18
    17ca:	13 06       	cpc	r1, r19
    17cc:	14 06       	cpc	r1, r20
    17ce:	55 1f       	adc	r21, r21
    17d0:	f2 cf       	rjmp	.-28     	; 0x17b6 <__fp_split3+0xe>
    17d2:	46 95       	lsr	r20
    17d4:	f1 df       	rcall	.-30     	; 0x17b8 <__fp_splitA>
    17d6:	08 c0       	rjmp	.+16     	; 0x17e8 <__fp_splitA+0x30>
    17d8:	16 16       	cp	r1, r22
    17da:	17 06       	cpc	r1, r23
    17dc:	18 06       	cpc	r1, r24
    17de:	99 1f       	adc	r25, r25
    17e0:	f1 cf       	rjmp	.-30     	; 0x17c4 <__fp_splitA+0xc>
    17e2:	86 95       	lsr	r24
    17e4:	71 05       	cpc	r23, r1
    17e6:	61 05       	cpc	r22, r1
    17e8:	08 94       	sec
    17ea:	08 95       	ret

000017ec <__fp_zero>:
    17ec:	e8 94       	clt

000017ee <__fp_szero>:
    17ee:	bb 27       	eor	r27, r27
    17f0:	66 27       	eor	r22, r22
    17f2:	77 27       	eor	r23, r23
    17f4:	cb 01       	movw	r24, r22
    17f6:	97 f9       	bld	r25, 7
    17f8:	08 95       	ret

000017fa <__mulsf3>:
    17fa:	0b d0       	rcall	.+22     	; 0x1812 <__mulsf3x>
    17fc:	78 c0       	rjmp	.+240    	; 0x18ee <__fp_round>
    17fe:	69 d0       	rcall	.+210    	; 0x18d2 <__fp_pscA>
    1800:	28 f0       	brcs	.+10     	; 0x180c <__mulsf3+0x12>
    1802:	6e d0       	rcall	.+220    	; 0x18e0 <__fp_pscB>
    1804:	18 f0       	brcs	.+6      	; 0x180c <__mulsf3+0x12>
    1806:	95 23       	and	r25, r21
    1808:	09 f0       	breq	.+2      	; 0x180c <__mulsf3+0x12>
    180a:	5a c0       	rjmp	.+180    	; 0x18c0 <__fp_inf>
    180c:	5f c0       	rjmp	.+190    	; 0x18cc <__fp_nan>
    180e:	11 24       	eor	r1, r1
    1810:	ee cf       	rjmp	.-36     	; 0x17ee <__fp_szero>

00001812 <__mulsf3x>:
    1812:	ca df       	rcall	.-108    	; 0x17a8 <__fp_split3>
    1814:	a0 f3       	brcs	.-24     	; 0x17fe <__mulsf3+0x4>

00001816 <__mulsf3_pse>:
    1816:	95 9f       	mul	r25, r21
    1818:	d1 f3       	breq	.-12     	; 0x180e <__mulsf3+0x14>
    181a:	95 0f       	add	r25, r21
    181c:	50 e0       	ldi	r21, 0x00	; 0
    181e:	55 1f       	adc	r21, r21
    1820:	62 9f       	mul	r22, r18
    1822:	f0 01       	movw	r30, r0
    1824:	72 9f       	mul	r23, r18
    1826:	bb 27       	eor	r27, r27
    1828:	f0 0d       	add	r31, r0
    182a:	b1 1d       	adc	r27, r1
    182c:	63 9f       	mul	r22, r19
    182e:	aa 27       	eor	r26, r26
    1830:	f0 0d       	add	r31, r0
    1832:	b1 1d       	adc	r27, r1
    1834:	aa 1f       	adc	r26, r26
    1836:	64 9f       	mul	r22, r20
    1838:	66 27       	eor	r22, r22
    183a:	b0 0d       	add	r27, r0
    183c:	a1 1d       	adc	r26, r1
    183e:	66 1f       	adc	r22, r22
    1840:	82 9f       	mul	r24, r18
    1842:	22 27       	eor	r18, r18
    1844:	b0 0d       	add	r27, r0
    1846:	a1 1d       	adc	r26, r1
    1848:	62 1f       	adc	r22, r18
    184a:	73 9f       	mul	r23, r19
    184c:	b0 0d       	add	r27, r0
    184e:	a1 1d       	adc	r26, r1
    1850:	62 1f       	adc	r22, r18
    1852:	83 9f       	mul	r24, r19
    1854:	a0 0d       	add	r26, r0
    1856:	61 1d       	adc	r22, r1
    1858:	22 1f       	adc	r18, r18
    185a:	74 9f       	mul	r23, r20
    185c:	33 27       	eor	r19, r19
    185e:	a0 0d       	add	r26, r0
    1860:	61 1d       	adc	r22, r1
    1862:	23 1f       	adc	r18, r19
    1864:	84 9f       	mul	r24, r20
    1866:	60 0d       	add	r22, r0
    1868:	21 1d       	adc	r18, r1
    186a:	82 2f       	mov	r24, r18
    186c:	76 2f       	mov	r23, r22
    186e:	6a 2f       	mov	r22, r26
    1870:	11 24       	eor	r1, r1
    1872:	9f 57       	subi	r25, 0x7F	; 127
    1874:	50 40       	sbci	r21, 0x00	; 0
    1876:	8a f0       	brmi	.+34     	; 0x189a <__mulsf3_pse+0x84>
    1878:	e1 f0       	breq	.+56     	; 0x18b2 <__mulsf3_pse+0x9c>
    187a:	88 23       	and	r24, r24
    187c:	4a f0       	brmi	.+18     	; 0x1890 <__mulsf3_pse+0x7a>
    187e:	ee 0f       	add	r30, r30
    1880:	ff 1f       	adc	r31, r31
    1882:	bb 1f       	adc	r27, r27
    1884:	66 1f       	adc	r22, r22
    1886:	77 1f       	adc	r23, r23
    1888:	88 1f       	adc	r24, r24
    188a:	91 50       	subi	r25, 0x01	; 1
    188c:	50 40       	sbci	r21, 0x00	; 0
    188e:	a9 f7       	brne	.-22     	; 0x187a <__mulsf3_pse+0x64>
    1890:	9e 3f       	cpi	r25, 0xFE	; 254
    1892:	51 05       	cpc	r21, r1
    1894:	70 f0       	brcs	.+28     	; 0x18b2 <__mulsf3_pse+0x9c>
    1896:	14 c0       	rjmp	.+40     	; 0x18c0 <__fp_inf>
    1898:	aa cf       	rjmp	.-172    	; 0x17ee <__fp_szero>
    189a:	5f 3f       	cpi	r21, 0xFF	; 255
    189c:	ec f3       	brlt	.-6      	; 0x1898 <__mulsf3_pse+0x82>
    189e:	98 3e       	cpi	r25, 0xE8	; 232
    18a0:	dc f3       	brlt	.-10     	; 0x1898 <__mulsf3_pse+0x82>
    18a2:	86 95       	lsr	r24
    18a4:	77 95       	ror	r23
    18a6:	67 95       	ror	r22
    18a8:	b7 95       	ror	r27
    18aa:	f7 95       	ror	r31
    18ac:	e7 95       	ror	r30
    18ae:	9f 5f       	subi	r25, 0xFF	; 255
    18b0:	c1 f7       	brne	.-16     	; 0x18a2 <__mulsf3_pse+0x8c>
    18b2:	fe 2b       	or	r31, r30
    18b4:	88 0f       	add	r24, r24
    18b6:	91 1d       	adc	r25, r1
    18b8:	96 95       	lsr	r25
    18ba:	87 95       	ror	r24
    18bc:	97 f9       	bld	r25, 7
    18be:	08 95       	ret

000018c0 <__fp_inf>:
    18c0:	97 f9       	bld	r25, 7
    18c2:	9f 67       	ori	r25, 0x7F	; 127
    18c4:	80 e8       	ldi	r24, 0x80	; 128
    18c6:	70 e0       	ldi	r23, 0x00	; 0
    18c8:	60 e0       	ldi	r22, 0x00	; 0
    18ca:	08 95       	ret

000018cc <__fp_nan>:
    18cc:	9f ef       	ldi	r25, 0xFF	; 255
    18ce:	80 ec       	ldi	r24, 0xC0	; 192
    18d0:	08 95       	ret

000018d2 <__fp_pscA>:
    18d2:	00 24       	eor	r0, r0
    18d4:	0a 94       	dec	r0
    18d6:	16 16       	cp	r1, r22
    18d8:	17 06       	cpc	r1, r23
    18da:	18 06       	cpc	r1, r24
    18dc:	09 06       	cpc	r0, r25
    18de:	08 95       	ret

000018e0 <__fp_pscB>:
    18e0:	00 24       	eor	r0, r0
    18e2:	0a 94       	dec	r0
    18e4:	12 16       	cp	r1, r18
    18e6:	13 06       	cpc	r1, r19
    18e8:	14 06       	cpc	r1, r20
    18ea:	05 06       	cpc	r0, r21
    18ec:	08 95       	ret

000018ee <__fp_round>:
    18ee:	09 2e       	mov	r0, r25
    18f0:	03 94       	inc	r0
    18f2:	00 0c       	add	r0, r0
    18f4:	11 f4       	brne	.+4      	; 0x18fa <__fp_round+0xc>
    18f6:	88 23       	and	r24, r24
    18f8:	52 f0       	brmi	.+20     	; 0x190e <__fp_round+0x20>
    18fa:	bb 0f       	add	r27, r27
    18fc:	40 f4       	brcc	.+16     	; 0x190e <__fp_round+0x20>
    18fe:	bf 2b       	or	r27, r31
    1900:	11 f4       	brne	.+4      	; 0x1906 <__fp_round+0x18>
    1902:	60 ff       	sbrs	r22, 0
    1904:	04 c0       	rjmp	.+8      	; 0x190e <__fp_round+0x20>
    1906:	6f 5f       	subi	r22, 0xFF	; 255
    1908:	7f 4f       	sbci	r23, 0xFF	; 255
    190a:	8f 4f       	sbci	r24, 0xFF	; 255
    190c:	9f 4f       	sbci	r25, 0xFF	; 255
    190e:	08 95       	ret

00001910 <__divmodsi4>:
    1910:	05 2e       	mov	r0, r21
    1912:	97 fb       	bst	r25, 7
    1914:	16 f4       	brtc	.+4      	; 0x191a <__divmodsi4+0xa>
    1916:	00 94       	com	r0
    1918:	0f d0       	rcall	.+30     	; 0x1938 <__negsi2>
    191a:	57 fd       	sbrc	r21, 7
    191c:	05 d0       	rcall	.+10     	; 0x1928 <__divmodsi4_neg2>
    191e:	2c d0       	rcall	.+88     	; 0x1978 <__udivmodsi4>
    1920:	07 fc       	sbrc	r0, 7
    1922:	02 d0       	rcall	.+4      	; 0x1928 <__divmodsi4_neg2>
    1924:	46 f4       	brtc	.+16     	; 0x1936 <__divmodsi4_exit>
    1926:	08 c0       	rjmp	.+16     	; 0x1938 <__negsi2>

00001928 <__divmodsi4_neg2>:
    1928:	50 95       	com	r21
    192a:	40 95       	com	r20
    192c:	30 95       	com	r19
    192e:	21 95       	neg	r18
    1930:	3f 4f       	sbci	r19, 0xFF	; 255
    1932:	4f 4f       	sbci	r20, 0xFF	; 255
    1934:	5f 4f       	sbci	r21, 0xFF	; 255

00001936 <__divmodsi4_exit>:
    1936:	08 95       	ret

00001938 <__negsi2>:
    1938:	90 95       	com	r25
    193a:	80 95       	com	r24
    193c:	70 95       	com	r23
    193e:	61 95       	neg	r22
    1940:	7f 4f       	sbci	r23, 0xFF	; 255
    1942:	8f 4f       	sbci	r24, 0xFF	; 255
    1944:	9f 4f       	sbci	r25, 0xFF	; 255
    1946:	08 95       	ret

00001948 <__tablejump2__>:
    1948:	ee 0f       	add	r30, r30
    194a:	ff 1f       	adc	r31, r31
    194c:	88 1f       	adc	r24, r24
    194e:	8b bf       	out	0x3b, r24	; 59
    1950:	07 90       	elpm	r0, Z+
    1952:	f6 91       	elpm	r31, Z
    1954:	e0 2d       	mov	r30, r0
    1956:	19 94       	eijmp

00001958 <__usmulhisi3>:
    1958:	31 d0       	rcall	.+98     	; 0x19bc <__umulhisi3>

0000195a <__usmulhisi3_tail>:
    195a:	b7 ff       	sbrs	r27, 7
    195c:	08 95       	ret
    195e:	82 1b       	sub	r24, r18
    1960:	93 0b       	sbc	r25, r19
    1962:	08 95       	ret

00001964 <__muluhisi3>:
    1964:	2b d0       	rcall	.+86     	; 0x19bc <__umulhisi3>
    1966:	a5 9f       	mul	r26, r21
    1968:	90 0d       	add	r25, r0
    196a:	b4 9f       	mul	r27, r20
    196c:	90 0d       	add	r25, r0
    196e:	a4 9f       	mul	r26, r20
    1970:	80 0d       	add	r24, r0
    1972:	91 1d       	adc	r25, r1
    1974:	11 24       	eor	r1, r1
    1976:	08 95       	ret

00001978 <__udivmodsi4>:
    1978:	a1 e2       	ldi	r26, 0x21	; 33
    197a:	1a 2e       	mov	r1, r26
    197c:	aa 1b       	sub	r26, r26
    197e:	bb 1b       	sub	r27, r27
    1980:	fd 01       	movw	r30, r26
    1982:	0d c0       	rjmp	.+26     	; 0x199e <__udivmodsi4_ep>

00001984 <__udivmodsi4_loop>:
    1984:	aa 1f       	adc	r26, r26
    1986:	bb 1f       	adc	r27, r27
    1988:	ee 1f       	adc	r30, r30
    198a:	ff 1f       	adc	r31, r31
    198c:	a2 17       	cp	r26, r18
    198e:	b3 07       	cpc	r27, r19
    1990:	e4 07       	cpc	r30, r20
    1992:	f5 07       	cpc	r31, r21
    1994:	20 f0       	brcs	.+8      	; 0x199e <__udivmodsi4_ep>
    1996:	a2 1b       	sub	r26, r18
    1998:	b3 0b       	sbc	r27, r19
    199a:	e4 0b       	sbc	r30, r20
    199c:	f5 0b       	sbc	r31, r21

0000199e <__udivmodsi4_ep>:
    199e:	66 1f       	adc	r22, r22
    19a0:	77 1f       	adc	r23, r23
    19a2:	88 1f       	adc	r24, r24
    19a4:	99 1f       	adc	r25, r25
    19a6:	1a 94       	dec	r1
    19a8:	69 f7       	brne	.-38     	; 0x1984 <__udivmodsi4_loop>
    19aa:	60 95       	com	r22
    19ac:	70 95       	com	r23
    19ae:	80 95       	com	r24
    19b0:	90 95       	com	r25
    19b2:	9b 01       	movw	r18, r22
    19b4:	ac 01       	movw	r20, r24
    19b6:	bd 01       	movw	r22, r26
    19b8:	cf 01       	movw	r24, r30
    19ba:	08 95       	ret

000019bc <__umulhisi3>:
    19bc:	a2 9f       	mul	r26, r18
    19be:	b0 01       	movw	r22, r0
    19c0:	b3 9f       	mul	r27, r19
    19c2:	c0 01       	movw	r24, r0
    19c4:	a3 9f       	mul	r26, r19
    19c6:	70 0d       	add	r23, r0
    19c8:	81 1d       	adc	r24, r1
    19ca:	11 24       	eor	r1, r1
    19cc:	91 1d       	adc	r25, r1
    19ce:	b2 9f       	mul	r27, r18
    19d0:	70 0d       	add	r23, r0
    19d2:	81 1d       	adc	r24, r1
    19d4:	11 24       	eor	r1, r1
    19d6:	91 1d       	adc	r25, r1
    19d8:	08 95       	ret

000019da <__itoa_ncheck>:
    19da:	bb 27       	eor	r27, r27
    19dc:	4a 30       	cpi	r20, 0x0A	; 10
    19de:	31 f4       	brne	.+12     	; 0x19ec <__itoa_ncheck+0x12>
    19e0:	99 23       	and	r25, r25
    19e2:	22 f4       	brpl	.+8      	; 0x19ec <__itoa_ncheck+0x12>
    19e4:	bd e2       	ldi	r27, 0x2D	; 45
    19e6:	90 95       	com	r25
    19e8:	81 95       	neg	r24
    19ea:	9f 4f       	sbci	r25, 0xFF	; 255
    19ec:	01 c0       	rjmp	.+2      	; 0x19f0 <__utoa_common>

000019ee <__utoa_ncheck>:
    19ee:	bb 27       	eor	r27, r27

000019f0 <__utoa_common>:
    19f0:	fb 01       	movw	r30, r22
    19f2:	55 27       	eor	r21, r21
    19f4:	aa 27       	eor	r26, r26
    19f6:	88 0f       	add	r24, r24
    19f8:	99 1f       	adc	r25, r25
    19fa:	aa 1f       	adc	r26, r26
    19fc:	a4 17       	cp	r26, r20
    19fe:	10 f0       	brcs	.+4      	; 0x1a04 <__utoa_common+0x14>
    1a00:	a4 1b       	sub	r26, r20
    1a02:	83 95       	inc	r24
    1a04:	50 51       	subi	r21, 0x10	; 16
    1a06:	b9 f7       	brne	.-18     	; 0x19f6 <__utoa_common+0x6>
    1a08:	a0 5d       	subi	r26, 0xD0	; 208
    1a0a:	aa 33       	cpi	r26, 0x3A	; 58
    1a0c:	08 f0       	brcs	.+2      	; 0x1a10 <__utoa_common+0x20>
    1a0e:	a9 5d       	subi	r26, 0xD9	; 217
    1a10:	a1 93       	st	Z+, r26
    1a12:	00 97       	sbiw	r24, 0x00	; 0
    1a14:	79 f7       	brne	.-34     	; 0x19f4 <__utoa_common+0x4>
    1a16:	b1 11       	cpse	r27, r1
    1a18:	b1 93       	st	Z+, r27
    1a1a:	11 92       	st	Z+, r1
    1a1c:	cb 01       	movw	r24, r22
    1a1e:	00 c0       	rjmp	.+0      	; 0x1a20 <strrev>

00001a20 <strrev>:
    1a20:	dc 01       	movw	r26, r24
    1a22:	fc 01       	movw	r30, r24
    1a24:	67 2f       	mov	r22, r23
    1a26:	71 91       	ld	r23, Z+
    1a28:	77 23       	and	r23, r23
    1a2a:	e1 f7       	brne	.-8      	; 0x1a24 <strrev+0x4>
    1a2c:	32 97       	sbiw	r30, 0x02	; 2
    1a2e:	04 c0       	rjmp	.+8      	; 0x1a38 <strrev+0x18>
    1a30:	7c 91       	ld	r23, X
    1a32:	6d 93       	st	X+, r22
    1a34:	70 83       	st	Z, r23
    1a36:	62 91       	ld	r22, -Z
    1a38:	ae 17       	cp	r26, r30
    1a3a:	bf 07       	cpc	r27, r31
    1a3c:	c8 f3       	brcs	.-14     	; 0x1a30 <strrev+0x10>
    1a3e:	08 95       	ret

00001a40 <_exit>:
    1a40:	f8 94       	cli

00001a42 <__stop_program>:
    1a42:	ff cf       	rjmp	.-2      	; 0x1a42 <__stop_program>
