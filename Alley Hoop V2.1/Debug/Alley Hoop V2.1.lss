
Alley Hoop V2.1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000234  00800200  00001a34  00001ac8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001a34  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000059  00800434  00800434  00001cfc  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001cfc  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001d2c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000238  00000000  00000000  00001d6c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004627  00000000  00000000  00001fa4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000179d  00000000  00000000  000065cb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000173f  00000000  00000000  00007d68  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000670  00000000  00000000  000094a8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001148  00000000  00000000  00009b18  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001ef8  00000000  00000000  0000ac60  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001f0  00000000  00000000  0000cb58  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	7d c0       	rjmp	.+250    	; 0xfc <__ctors_end>
       2:	00 00       	nop
       4:	ab c0       	rjmp	.+342    	; 0x15c <__bad_interrupt>
       6:	00 00       	nop
       8:	a9 c0       	rjmp	.+338    	; 0x15c <__bad_interrupt>
       a:	00 00       	nop
       c:	a7 c0       	rjmp	.+334    	; 0x15c <__bad_interrupt>
       e:	00 00       	nop
      10:	a5 c0       	rjmp	.+330    	; 0x15c <__bad_interrupt>
      12:	00 00       	nop
      14:	a3 c0       	rjmp	.+326    	; 0x15c <__bad_interrupt>
      16:	00 00       	nop
      18:	a1 c0       	rjmp	.+322    	; 0x15c <__bad_interrupt>
      1a:	00 00       	nop
      1c:	9f c0       	rjmp	.+318    	; 0x15c <__bad_interrupt>
      1e:	00 00       	nop
      20:	9d c0       	rjmp	.+314    	; 0x15c <__bad_interrupt>
      22:	00 00       	nop
      24:	9b c0       	rjmp	.+310    	; 0x15c <__bad_interrupt>
      26:	00 00       	nop
      28:	99 c0       	rjmp	.+306    	; 0x15c <__bad_interrupt>
      2a:	00 00       	nop
      2c:	97 c0       	rjmp	.+302    	; 0x15c <__bad_interrupt>
      2e:	00 00       	nop
      30:	95 c0       	rjmp	.+298    	; 0x15c <__bad_interrupt>
      32:	00 00       	nop
      34:	93 c0       	rjmp	.+294    	; 0x15c <__bad_interrupt>
      36:	00 00       	nop
      38:	91 c0       	rjmp	.+290    	; 0x15c <__bad_interrupt>
      3a:	00 00       	nop
      3c:	8f c0       	rjmp	.+286    	; 0x15c <__bad_interrupt>
      3e:	00 00       	nop
      40:	8d c0       	rjmp	.+282    	; 0x15c <__bad_interrupt>
      42:	00 00       	nop
      44:	8b c0       	rjmp	.+278    	; 0x15c <__bad_interrupt>
      46:	00 00       	nop
      48:	89 c0       	rjmp	.+274    	; 0x15c <__bad_interrupt>
      4a:	00 00       	nop
      4c:	87 c0       	rjmp	.+270    	; 0x15c <__bad_interrupt>
      4e:	00 00       	nop
      50:	85 c0       	rjmp	.+266    	; 0x15c <__bad_interrupt>
      52:	00 00       	nop
      54:	83 c0       	rjmp	.+262    	; 0x15c <__bad_interrupt>
      56:	00 00       	nop
      58:	81 c0       	rjmp	.+258    	; 0x15c <__bad_interrupt>
      5a:	00 00       	nop
      5c:	7f c0       	rjmp	.+254    	; 0x15c <__bad_interrupt>
      5e:	00 00       	nop
      60:	7d c0       	rjmp	.+250    	; 0x15c <__bad_interrupt>
      62:	00 00       	nop
      64:	7b c0       	rjmp	.+246    	; 0x15c <__bad_interrupt>
      66:	00 00       	nop
      68:	79 c0       	rjmp	.+242    	; 0x15c <__bad_interrupt>
      6a:	00 00       	nop
      6c:	77 c0       	rjmp	.+238    	; 0x15c <__bad_interrupt>
      6e:	00 00       	nop
      70:	75 c0       	rjmp	.+234    	; 0x15c <__bad_interrupt>
      72:	00 00       	nop
      74:	73 c0       	rjmp	.+230    	; 0x15c <__bad_interrupt>
      76:	00 00       	nop
      78:	71 c0       	rjmp	.+226    	; 0x15c <__bad_interrupt>
      7a:	00 00       	nop
      7c:	6f c0       	rjmp	.+222    	; 0x15c <__bad_interrupt>
      7e:	00 00       	nop
      80:	6d c0       	rjmp	.+218    	; 0x15c <__bad_interrupt>
      82:	00 00       	nop
      84:	6b c0       	rjmp	.+214    	; 0x15c <__bad_interrupt>
      86:	00 00       	nop
      88:	69 c0       	rjmp	.+210    	; 0x15c <__bad_interrupt>
      8a:	00 00       	nop
      8c:	67 c0       	rjmp	.+206    	; 0x15c <__bad_interrupt>
      8e:	00 00       	nop
      90:	65 c0       	rjmp	.+202    	; 0x15c <__bad_interrupt>
      92:	00 00       	nop
      94:	63 c0       	rjmp	.+198    	; 0x15c <__bad_interrupt>
      96:	00 00       	nop
      98:	61 c0       	rjmp	.+194    	; 0x15c <__bad_interrupt>
      9a:	00 00       	nop
      9c:	5f c0       	rjmp	.+190    	; 0x15c <__bad_interrupt>
      9e:	00 00       	nop
      a0:	5d c0       	rjmp	.+186    	; 0x15c <__bad_interrupt>
      a2:	00 00       	nop
      a4:	5b c0       	rjmp	.+182    	; 0x15c <__bad_interrupt>
      a6:	00 00       	nop
      a8:	59 c0       	rjmp	.+178    	; 0x15c <__bad_interrupt>
      aa:	00 00       	nop
      ac:	57 c0       	rjmp	.+174    	; 0x15c <__bad_interrupt>
      ae:	00 00       	nop
      b0:	55 c0       	rjmp	.+170    	; 0x15c <__bad_interrupt>
      b2:	00 00       	nop
      b4:	53 c0       	rjmp	.+166    	; 0x15c <__bad_interrupt>
      b6:	00 00       	nop
      b8:	51 c0       	rjmp	.+162    	; 0x15c <__bad_interrupt>
      ba:	00 00       	nop
      bc:	4f c0       	rjmp	.+158    	; 0x15c <__bad_interrupt>
      be:	00 00       	nop
      c0:	4d c0       	rjmp	.+154    	; 0x15c <__bad_interrupt>
      c2:	00 00       	nop
      c4:	4b c0       	rjmp	.+150    	; 0x15c <__bad_interrupt>
      c6:	00 00       	nop
      c8:	49 c0       	rjmp	.+146    	; 0x15c <__bad_interrupt>
      ca:	00 00       	nop
      cc:	47 c0       	rjmp	.+142    	; 0x15c <__bad_interrupt>
      ce:	00 00       	nop
      d0:	45 c0       	rjmp	.+138    	; 0x15c <__bad_interrupt>
      d2:	00 00       	nop
      d4:	43 c0       	rjmp	.+134    	; 0x15c <__bad_interrupt>
      d6:	00 00       	nop
      d8:	41 c0       	rjmp	.+130    	; 0x15c <__bad_interrupt>
      da:	00 00       	nop
      dc:	3f c0       	rjmp	.+126    	; 0x15c <__bad_interrupt>
      de:	00 00       	nop
      e0:	3d c0       	rjmp	.+122    	; 0x15c <__bad_interrupt>
      e2:	00 00       	nop
      e4:	f7 03       	fmuls	r23, r23
      e6:	fc 03       	fmulsu	r23, r20
      e8:	01 04       	cpc	r0, r1
      ea:	03 04       	cpc	r0, r3
      ec:	08 04       	cpc	r0, r8
      ee:	0d 04       	cpc	r0, r13
      f0:	12 04       	cpc	r1, r2
      f2:	17 04       	cpc	r1, r7
      f4:	1a 04       	cpc	r1, r10
      f6:	1d 04       	cpc	r1, r13
      f8:	22 04       	cpc	r2, r2

000000fa <__ctors_start>:
      fa:	d5 06       	cpc	r13, r21

000000fc <__ctors_end>:
      fc:	11 24       	eor	r1, r1
      fe:	1f be       	out	0x3f, r1	; 63
     100:	cf ef       	ldi	r28, 0xFF	; 255
     102:	d1 e2       	ldi	r29, 0x21	; 33
     104:	de bf       	out	0x3e, r29	; 62
     106:	cd bf       	out	0x3d, r28	; 61
     108:	00 e0       	ldi	r16, 0x00	; 0
     10a:	0c bf       	out	0x3c, r16	; 60

0000010c <__do_copy_data>:
     10c:	14 e0       	ldi	r17, 0x04	; 4
     10e:	a0 e0       	ldi	r26, 0x00	; 0
     110:	b2 e0       	ldi	r27, 0x02	; 2
     112:	e4 e3       	ldi	r30, 0x34	; 52
     114:	fa e1       	ldi	r31, 0x1A	; 26
     116:	00 e0       	ldi	r16, 0x00	; 0
     118:	0b bf       	out	0x3b, r16	; 59
     11a:	02 c0       	rjmp	.+4      	; 0x120 <__do_copy_data+0x14>
     11c:	07 90       	elpm	r0, Z+
     11e:	0d 92       	st	X+, r0
     120:	a4 33       	cpi	r26, 0x34	; 52
     122:	b1 07       	cpc	r27, r17
     124:	d9 f7       	brne	.-10     	; 0x11c <__do_copy_data+0x10>

00000126 <__do_clear_bss>:
     126:	24 e0       	ldi	r18, 0x04	; 4
     128:	a4 e3       	ldi	r26, 0x34	; 52
     12a:	b4 e0       	ldi	r27, 0x04	; 4
     12c:	01 c0       	rjmp	.+2      	; 0x130 <.do_clear_bss_start>

0000012e <.do_clear_bss_loop>:
     12e:	1d 92       	st	X+, r1

00000130 <.do_clear_bss_start>:
     130:	ad 38       	cpi	r26, 0x8D	; 141
     132:	b2 07       	cpc	r27, r18
     134:	e1 f7       	brne	.-8      	; 0x12e <.do_clear_bss_loop>

00000136 <__do_global_ctors>:
     136:	10 e0       	ldi	r17, 0x00	; 0
     138:	ce e7       	ldi	r28, 0x7E	; 126
     13a:	d0 e0       	ldi	r29, 0x00	; 0
     13c:	00 e0       	ldi	r16, 0x00	; 0
     13e:	06 c0       	rjmp	.+12     	; 0x14c <__do_global_ctors+0x16>
     140:	21 97       	sbiw	r28, 0x01	; 1
     142:	01 09       	sbc	r16, r1
     144:	80 2f       	mov	r24, r16
     146:	fe 01       	movw	r30, r28
     148:	0e 94 9c 0c 	call	0x1938	; 0x1938 <__tablejump2__>
     14c:	cd 37       	cpi	r28, 0x7D	; 125
     14e:	d1 07       	cpc	r29, r17
     150:	80 e0       	ldi	r24, 0x00	; 0
     152:	08 07       	cpc	r16, r24
     154:	a9 f7       	brne	.-22     	; 0x140 <__do_global_ctors+0xa>
     156:	07 d6       	rcall	.+3086   	; 0xd66 <main>
     158:	0c 94 18 0d 	jmp	0x1a30	; 0x1a30 <_exit>

0000015c <__bad_interrupt>:
     15c:	51 cf       	rjmp	.-350    	; 0x0 <__vectors>

0000015e <_Z11mode_selectv>:
		digitalWrite(do_hv_relais,LOW);			//disengage engine relay
		braking_dv=0;							//stop braking
	}
}

void mode_remote(){
     15e:	8b e2       	ldi	r24, 0x2B	; 43
     160:	90 e0       	ldi	r25, 0x00	; 0
     162:	4a d4       	rcall	.+2196   	; 0x9f8 <_Z11digitalReadi>
     164:	88 23       	and	r24, r24
     166:	39 f0       	breq	.+14     	; 0x176 <_Z11mode_selectv+0x18>
     168:	81 e0       	ldi	r24, 0x01	; 1
     16a:	90 e0       	ldi	r25, 0x00	; 0
     16c:	90 93 6a 04 	sts	0x046A, r25	; 0x80046a <drivemode+0x1>
     170:	80 93 69 04 	sts	0x0469, r24	; 0x800469 <drivemode>
     174:	08 95       	ret
     176:	88 e2       	ldi	r24, 0x28	; 40
     178:	90 e0       	ldi	r25, 0x00	; 0
     17a:	3e d4       	rcall	.+2172   	; 0x9f8 <_Z11digitalReadi>
     17c:	88 23       	and	r24, r24
     17e:	39 f0       	breq	.+14     	; 0x18e <_Z11mode_selectv+0x30>
     180:	82 e0       	ldi	r24, 0x02	; 2
     182:	90 e0       	ldi	r25, 0x00	; 0
     184:	90 93 6a 04 	sts	0x046A, r25	; 0x80046a <drivemode+0x1>
     188:	80 93 69 04 	sts	0x0469, r24	; 0x800469 <drivemode>
     18c:	08 95       	ret
     18e:	89 e2       	ldi	r24, 0x29	; 41
     190:	90 e0       	ldi	r25, 0x00	; 0
     192:	32 d4       	rcall	.+2148   	; 0x9f8 <_Z11digitalReadi>
     194:	88 23       	and	r24, r24
     196:	39 f0       	breq	.+14     	; 0x1a6 <_Z11mode_selectv+0x48>
     198:	83 e0       	ldi	r24, 0x03	; 3
     19a:	90 e0       	ldi	r25, 0x00	; 0
     19c:	90 93 6a 04 	sts	0x046A, r25	; 0x80046a <drivemode+0x1>
     1a0:	80 93 69 04 	sts	0x0469, r24	; 0x800469 <drivemode>
     1a4:	08 95       	ret
     1a6:	10 92 6a 04 	sts	0x046A, r1	; 0x80046a <drivemode+0x1>
     1aa:	10 92 69 04 	sts	0x0469, r1	; 0x800469 <drivemode>
     1ae:	08 95       	ret

000001b0 <_Z9initDrivev>:
     1b0:	61 e0       	ldi	r22, 0x01	; 1
     1b2:	8a e1       	ldi	r24, 0x1A	; 26
     1b4:	90 e0       	ldi	r25, 0x00	; 0
     1b6:	51 d3       	rcall	.+1698   	; 0x85a <_Z12digitalWriteib>
     1b8:	61 e0       	ldi	r22, 0x01	; 1
     1ba:	88 e1       	ldi	r24, 0x18	; 24
     1bc:	90 e0       	ldi	r25, 0x00	; 0
     1be:	4d d3       	rcall	.+1690   	; 0x85a <_Z12digitalWriteib>
     1c0:	61 e0       	ldi	r22, 0x01	; 1
     1c2:	89 e1       	ldi	r24, 0x19	; 25
     1c4:	90 e0       	ldi	r25, 0x00	; 0
     1c6:	49 d3       	rcall	.+1682   	; 0x85a <_Z12digitalWriteib>
     1c8:	61 e0       	ldi	r22, 0x01	; 1
     1ca:	86 e1       	ldi	r24, 0x16	; 22
     1cc:	90 e0       	ldi	r25, 0x00	; 0
     1ce:	45 d3       	rcall	.+1674   	; 0x85a <_Z12digitalWriteib>
     1d0:	61 e0       	ldi	r22, 0x01	; 1
     1d2:	87 e1       	ldi	r24, 0x17	; 23
     1d4:	90 e0       	ldi	r25, 0x00	; 0
     1d6:	41 d3       	rcall	.+1666   	; 0x85a <_Z12digitalWriteib>
     1d8:	c2 cf       	rjmp	.-124    	; 0x15e <_Z11mode_selectv>
     1da:	08 95       	ret

000001dc <_Z13mode_joystickv>:
     1dc:	61 e0       	ldi	r22, 0x01	; 1
     1de:	81 e2       	ldi	r24, 0x21	; 33
     1e0:	90 e0       	ldi	r25, 0x00	; 0
     1e2:	3b d3       	rcall	.+1654   	; 0x85a <_Z12digitalWriteib>
     1e4:	80 91 3a 04 	lds	r24, 0x043A	; 0x80043a <engine_rpm>
     1e8:	90 91 3b 04 	lds	r25, 0x043B	; 0x80043b <engine_rpm+0x1>
     1ec:	89 2b       	or	r24, r25
     1ee:	29 f4       	brne	.+10     	; 0x1fa <_Z13mode_joystickv+0x1e>
     1f0:	8a e2       	ldi	r24, 0x2A	; 42
     1f2:	90 e0       	ldi	r25, 0x00	; 0
     1f4:	01 d4       	rcall	.+2050   	; 0x9f8 <_Z11digitalReadi>
     1f6:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
     1fa:	84 e0       	ldi	r24, 0x04	; 4
     1fc:	90 e0       	ldi	r25, 0x00	; 0
     1fe:	78 d4       	rcall	.+2288   	; 0xaf0 <_Z10analogReadi>
     200:	dc 01       	movw	r26, r24
     202:	ab 5f       	subi	r26, 0xFB	; 251
     204:	b1 40       	sbci	r27, 0x01	; 1
     206:	2e e5       	ldi	r18, 0x5E	; 94
     208:	31 e0       	ldi	r19, 0x01	; 1
     20a:	0e 94 a4 0c 	call	0x1948	; 0x1948 <__usmulhisi3>
     20e:	29 e8       	ldi	r18, 0x89	; 137
     210:	30 e0       	ldi	r19, 0x00	; 0
     212:	40 e0       	ldi	r20, 0x00	; 0
     214:	50 e0       	ldi	r21, 0x00	; 0
     216:	0e 94 80 0c 	call	0x1900	; 0x1900 <__divmodsi4>
     21a:	20 93 61 04 	sts	0x0461, r18	; 0x800461 <steering_dv>
     21e:	30 93 62 04 	sts	0x0462, r19	; 0x800462 <steering_dv+0x1>
     222:	40 93 63 04 	sts	0x0463, r20	; 0x800463 <steering_dv+0x2>
     226:	50 93 64 04 	sts	0x0464, r21	; 0x800464 <steering_dv+0x3>
     22a:	82 e0       	ldi	r24, 0x02	; 2
     22c:	90 e0       	ldi	r25, 0x00	; 0
     22e:	60 d4       	rcall	.+2240   	; 0xaf0 <_Z10analogReadi>
     230:	8e 5f       	subi	r24, 0xFE	; 254
     232:	91 40       	sbci	r25, 0x01	; 1
     234:	9c 01       	movw	r18, r24
     236:	2c 5f       	subi	r18, 0xFC	; 252
     238:	3f 4f       	sbci	r19, 0xFF	; 255
     23a:	29 30       	cpi	r18, 0x09	; 9
     23c:	31 05       	cpc	r19, r1
     23e:	68 f0       	brcs	.+26     	; 0x25a <_Z13mode_joystickv+0x7e>
     240:	09 2e       	mov	r0, r25
     242:	00 0c       	add	r0, r0
     244:	aa 0b       	sbc	r26, r26
     246:	bb 0b       	sbc	r27, r27
     248:	80 93 65 04 	sts	0x0465, r24	; 0x800465 <driving_dv>
     24c:	90 93 66 04 	sts	0x0466, r25	; 0x800466 <driving_dv+0x1>
     250:	a0 93 67 04 	sts	0x0467, r26	; 0x800467 <driving_dv+0x2>
     254:	b0 93 68 04 	sts	0x0468, r27	; 0x800468 <driving_dv+0x3>
     258:	08 c0       	rjmp	.+16     	; 0x26a <_Z13mode_joystickv+0x8e>
     25a:	10 92 65 04 	sts	0x0465, r1	; 0x800465 <driving_dv>
     25e:	10 92 66 04 	sts	0x0466, r1	; 0x800466 <driving_dv+0x1>
     262:	10 92 67 04 	sts	0x0467, r1	; 0x800467 <driving_dv+0x2>
     266:	10 92 68 04 	sts	0x0468, r1	; 0x800468 <driving_dv+0x3>
     26a:	10 92 54 04 	sts	0x0454, r1	; 0x800454 <engine_dv>
     26e:	10 92 55 04 	sts	0x0455, r1	; 0x800455 <engine_dv+0x1>
     272:	10 92 56 04 	sts	0x0456, r1	; 0x800456 <engine_dv+0x2>
     276:	10 92 57 04 	sts	0x0457, r1	; 0x800457 <engine_dv+0x3>
     27a:	10 92 47 04 	sts	0x0447, r1	; 0x800447 <braking_dv>
     27e:	10 92 48 04 	sts	0x0448, r1	; 0x800448 <braking_dv+0x1>
     282:	10 92 49 04 	sts	0x0449, r1	; 0x800449 <braking_dv+0x2>
     286:	10 92 4a 04 	sts	0x044A, r1	; 0x80044a <braking_dv+0x3>
     28a:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__data_start>
     28e:	88 23       	and	r24, r24
     290:	51 f1       	breq	.+84     	; 0x2e6 <_Z13mode_joystickv+0x10a>
     292:	80 91 65 04 	lds	r24, 0x0465	; 0x800465 <driving_dv>
     296:	90 91 66 04 	lds	r25, 0x0466	; 0x800466 <driving_dv+0x1>
     29a:	a0 91 67 04 	lds	r26, 0x0467	; 0x800467 <driving_dv+0x2>
     29e:	b0 91 68 04 	lds	r27, 0x0468	; 0x800468 <driving_dv+0x3>
     2a2:	18 16       	cp	r1, r24
     2a4:	19 06       	cpc	r1, r25
     2a6:	1a 06       	cpc	r1, r26
     2a8:	1b 06       	cpc	r1, r27
     2aa:	4c f4       	brge	.+18     	; 0x2be <_Z13mode_joystickv+0xe2>
     2ac:	80 93 54 04 	sts	0x0454, r24	; 0x800454 <engine_dv>
     2b0:	90 93 55 04 	sts	0x0455, r25	; 0x800455 <engine_dv+0x1>
     2b4:	a0 93 56 04 	sts	0x0456, r26	; 0x800456 <engine_dv+0x2>
     2b8:	b0 93 57 04 	sts	0x0457, r27	; 0x800457 <engine_dv+0x3>
     2bc:	08 95       	ret
     2be:	9c 01       	movw	r18, r24
     2c0:	99 23       	and	r25, r25
     2c2:	24 f4       	brge	.+8      	; 0x2cc <_Z13mode_joystickv+0xf0>
     2c4:	22 27       	eor	r18, r18
     2c6:	33 27       	eor	r19, r19
     2c8:	28 1b       	sub	r18, r24
     2ca:	39 0b       	sbc	r19, r25
     2cc:	c9 01       	movw	r24, r18
     2ce:	33 0f       	add	r19, r19
     2d0:	aa 0b       	sbc	r26, r26
     2d2:	bb 0b       	sbc	r27, r27
     2d4:	80 93 47 04 	sts	0x0447, r24	; 0x800447 <braking_dv>
     2d8:	90 93 48 04 	sts	0x0448, r25	; 0x800448 <braking_dv+0x1>
     2dc:	a0 93 49 04 	sts	0x0449, r26	; 0x800449 <braking_dv+0x2>
     2e0:	b0 93 4a 04 	sts	0x044A, r27	; 0x80044a <braking_dv+0x3>
     2e4:	08 95       	ret
     2e6:	80 91 65 04 	lds	r24, 0x0465	; 0x800465 <driving_dv>
     2ea:	90 91 66 04 	lds	r25, 0x0466	; 0x800466 <driving_dv+0x1>
     2ee:	a0 91 67 04 	lds	r26, 0x0467	; 0x800467 <driving_dv+0x2>
     2f2:	b0 91 68 04 	lds	r27, 0x0468	; 0x800468 <driving_dv+0x3>
     2f6:	18 16       	cp	r1, r24
     2f8:	19 06       	cpc	r1, r25
     2fa:	1a 06       	cpc	r1, r26
     2fc:	1b 06       	cpc	r1, r27
     2fe:	4c f4       	brge	.+18     	; 0x312 <_Z13mode_joystickv+0x136>
     300:	80 93 47 04 	sts	0x0447, r24	; 0x800447 <braking_dv>
     304:	90 93 48 04 	sts	0x0448, r25	; 0x800448 <braking_dv+0x1>
     308:	a0 93 49 04 	sts	0x0449, r26	; 0x800449 <braking_dv+0x2>
     30c:	b0 93 4a 04 	sts	0x044A, r27	; 0x80044a <braking_dv+0x3>
     310:	08 95       	ret
     312:	9c 01       	movw	r18, r24
     314:	99 23       	and	r25, r25
     316:	24 f4       	brge	.+8      	; 0x320 <_Z13mode_joystickv+0x144>
     318:	22 27       	eor	r18, r18
     31a:	33 27       	eor	r19, r19
     31c:	28 1b       	sub	r18, r24
     31e:	39 0b       	sbc	r19, r25
     320:	c9 01       	movw	r24, r18
     322:	33 0f       	add	r19, r19
     324:	aa 0b       	sbc	r26, r26
     326:	bb 0b       	sbc	r27, r27
     328:	80 93 54 04 	sts	0x0454, r24	; 0x800454 <engine_dv>
     32c:	90 93 55 04 	sts	0x0455, r25	; 0x800455 <engine_dv+0x1>
     330:	a0 93 56 04 	sts	0x0456, r26	; 0x800456 <engine_dv+0x2>
     334:	b0 93 57 04 	sts	0x0457, r27	; 0x800457 <engine_dv+0x3>
     338:	08 95       	ret

0000033a <_Z9mode_idlev>:
     33a:	10 92 54 04 	sts	0x0454, r1	; 0x800454 <engine_dv>
     33e:	10 92 55 04 	sts	0x0455, r1	; 0x800455 <engine_dv+0x1>
     342:	10 92 56 04 	sts	0x0456, r1	; 0x800456 <engine_dv+0x2>
     346:	10 92 57 04 	sts	0x0457, r1	; 0x800457 <engine_dv+0x3>
     34a:	10 92 61 04 	sts	0x0461, r1	; 0x800461 <steering_dv>
     34e:	10 92 62 04 	sts	0x0462, r1	; 0x800462 <steering_dv+0x1>
     352:	10 92 63 04 	sts	0x0463, r1	; 0x800463 <steering_dv+0x2>
     356:	10 92 64 04 	sts	0x0464, r1	; 0x800464 <steering_dv+0x3>
     35a:	84 e6       	ldi	r24, 0x64	; 100
     35c:	90 e0       	ldi	r25, 0x00	; 0
     35e:	a0 e0       	ldi	r26, 0x00	; 0
     360:	b0 e0       	ldi	r27, 0x00	; 0
     362:	80 93 47 04 	sts	0x0447, r24	; 0x800447 <braking_dv>
     366:	90 93 48 04 	sts	0x0448, r25	; 0x800448 <braking_dv+0x1>
     36a:	a0 93 49 04 	sts	0x0449, r26	; 0x800449 <braking_dv+0x2>
     36e:	b0 93 4a 04 	sts	0x044A, r27	; 0x80044a <braking_dv+0x3>
     372:	80 91 3a 04 	lds	r24, 0x043A	; 0x80043a <engine_rpm>
     376:	90 91 3b 04 	lds	r25, 0x043B	; 0x80043b <engine_rpm+0x1>
     37a:	89 2b       	or	r24, r25
     37c:	61 f4       	brne	.+24     	; 0x396 <_Z9mode_idlev+0x5c>
     37e:	60 e0       	ldi	r22, 0x00	; 0
     380:	81 e2       	ldi	r24, 0x21	; 33
     382:	90 e0       	ldi	r25, 0x00	; 0
     384:	6a d2       	rcall	.+1236   	; 0x85a <_Z12digitalWriteib>
     386:	10 92 47 04 	sts	0x0447, r1	; 0x800447 <braking_dv>
     38a:	10 92 48 04 	sts	0x0448, r1	; 0x800448 <braking_dv+0x1>
     38e:	10 92 49 04 	sts	0x0449, r1	; 0x800449 <braking_dv+0x2>
     392:	10 92 4a 04 	sts	0x044A, r1	; 0x80044a <braking_dv+0x3>
     396:	08 95       	ret

00000398 <_Z9run_brakev>:
	//digitalWrite(do_hv_relais,HIGH);
	//not (yet) implemented
}

void run_brake(){
	braking_cv = (long(analogRead(ai_brake_pressure) - braking_sensor_offset) * (250 / 1023));				//retrieve the current value of the brake pressure sensor
     398:	81 e0       	ldi	r24, 0x01	; 1
     39a:	90 e0       	ldi	r25, 0x00	; 0
     39c:	a9 d3       	rcall	.+1874   	; 0xaf0 <_Z10analogReadi>
     39e:	10 92 3f 04 	sts	0x043F, r1	; 0x80043f <braking_cv>
     3a2:	10 92 40 04 	sts	0x0440, r1	; 0x800440 <braking_cv+0x1>
     3a6:	10 92 41 04 	sts	0x0441, r1	; 0x800441 <braking_cv+0x2>
     3aa:	10 92 42 04 	sts	0x0442, r1	; 0x800442 <braking_cv+0x3>
	braking_delta = braking_dv - braking_cv;
     3ae:	40 91 47 04 	lds	r20, 0x0447	; 0x800447 <braking_dv>
     3b2:	50 91 48 04 	lds	r21, 0x0448	; 0x800448 <braking_dv+0x1>
     3b6:	60 91 49 04 	lds	r22, 0x0449	; 0x800449 <braking_dv+0x2>
     3ba:	70 91 4a 04 	lds	r23, 0x044A	; 0x80044a <braking_dv+0x3>
	if(abs(braking_delta)<10)
     3be:	ca 01       	movw	r24, r20
     3c0:	09 96       	adiw	r24, 0x09	; 9
     3c2:	43 97       	sbiw	r24, 0x13	; 19
     3c4:	48 f0       	brcs	.+18     	; 0x3d8 <_Z9run_brakev+0x40>
	//not (yet) implemented
}

void run_brake(){
	braking_cv = (long(analogRead(ai_brake_pressure) - braking_sensor_offset) * (250 / 1023));				//retrieve the current value of the brake pressure sensor
	braking_delta = braking_dv - braking_cv;
     3c6:	40 93 43 04 	sts	0x0443, r20	; 0x800443 <braking_delta>
     3ca:	50 93 44 04 	sts	0x0444, r21	; 0x800444 <braking_delta+0x1>
     3ce:	60 93 45 04 	sts	0x0445, r22	; 0x800445 <braking_delta+0x2>
     3d2:	70 93 46 04 	sts	0x0446, r23	; 0x800446 <braking_delta+0x3>
     3d6:	08 c0       	rjmp	.+16     	; 0x3e8 <_Z9run_brakev+0x50>
	if(abs(braking_delta)<10)
		braking_delta = 0;
     3d8:	10 92 43 04 	sts	0x0443, r1	; 0x800443 <braking_delta>
     3dc:	10 92 44 04 	sts	0x0444, r1	; 0x800444 <braking_delta+0x1>
     3e0:	10 92 45 04 	sts	0x0445, r1	; 0x800445 <braking_delta+0x2>
     3e4:	10 92 46 04 	sts	0x0446, r1	; 0x800446 <braking_delta+0x3>
	braking_ov = constrain(braking_dv * braking_kp, 0, 255);
     3e8:	db 01       	movw	r26, r22
     3ea:	ca 01       	movw	r24, r20
     3ec:	88 0f       	add	r24, r24
     3ee:	99 1f       	adc	r25, r25
     3f0:	aa 1f       	adc	r26, r26
     3f2:	bb 1f       	adc	r27, r27
     3f4:	84 0f       	add	r24, r20
     3f6:	95 1f       	adc	r25, r21
     3f8:	a6 1f       	adc	r26, r22
     3fa:	b7 1f       	adc	r27, r23
     3fc:	bb 23       	and	r27, r27
     3fe:	5c f0       	brlt	.+22     	; 0x416 <__LOCK_REGION_LENGTH__+0x16>
     400:	8f 3f       	cpi	r24, 0xFF	; 255
     402:	91 05       	cpc	r25, r1
     404:	a1 05       	cpc	r26, r1
     406:	b1 05       	cpc	r27, r1
     408:	39 f0       	breq	.+14     	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
     40a:	34 f0       	brlt	.+12     	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
     40c:	8f ef       	ldi	r24, 0xFF	; 255
     40e:	90 e0       	ldi	r25, 0x00	; 0
     410:	a0 e0       	ldi	r26, 0x00	; 0
     412:	b0 e0       	ldi	r27, 0x00	; 0
     414:	01 c0       	rjmp	.+2      	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
     416:	80 e0       	ldi	r24, 0x00	; 0
     418:	80 93 3e 04 	sts	0x043E, r24	; 0x80043e <braking_ov>
	analogWrite(pwm_brake_pump, braking_dv);															//Write op to brake pump
     41c:	ba 01       	movw	r22, r20
     41e:	87 e0       	ldi	r24, 0x07	; 7
     420:	90 e0       	ldi	r25, 0x00	; 0
     422:	d4 c1       	rjmp	.+936    	; 0x7cc <_Z11analogWriteii>
     424:	08 95       	ret

00000426 <_Z9run_steerv>:
}

void run_steer(){
     426:	0f 93       	push	r16
     428:	1f 93       	push	r17
	steering_cv = -(long(analogRead(ai_steer_pot)- steering_sensor_offset) * 1000/1023);				//retrieve the current value of the steering potentiometer and convert it to 10th of degrees
     42a:	80 e0       	ldi	r24, 0x00	; 0
     42c:	90 e0       	ldi	r25, 0x00	; 0
     42e:	60 d3       	rcall	.+1728   	; 0xaf0 <_Z10analogReadi>
     430:	dc 01       	movw	r26, r24
     432:	b2 50       	subi	r27, 0x02	; 2
     434:	28 ee       	ldi	r18, 0xE8	; 232
     436:	33 e0       	ldi	r19, 0x03	; 3
     438:	0e 94 a4 0c 	call	0x1948	; 0x1948 <__usmulhisi3>
     43c:	2f ef       	ldi	r18, 0xFF	; 255
     43e:	33 e0       	ldi	r19, 0x03	; 3
     440:	40 e0       	ldi	r20, 0x00	; 0
     442:	50 e0       	ldi	r21, 0x00	; 0
     444:	0e 94 80 0c 	call	0x1900	; 0x1900 <__divmodsi4>
     448:	88 27       	eor	r24, r24
     44a:	99 27       	eor	r25, r25
     44c:	dc 01       	movw	r26, r24
     44e:	82 1b       	sub	r24, r18
     450:	93 0b       	sbc	r25, r19
     452:	a4 0b       	sbc	r26, r20
     454:	b5 0b       	sbc	r27, r21
     456:	80 93 59 04 	sts	0x0459, r24	; 0x800459 <steering_cv>
     45a:	90 93 5a 04 	sts	0x045A, r25	; 0x80045a <steering_cv+0x1>
     45e:	a0 93 5b 04 	sts	0x045B, r26	; 0x80045b <steering_cv+0x2>
     462:	b0 93 5c 04 	sts	0x045C, r27	; 0x80045c <steering_cv+0x3>
	if(abs(steering_dv)<steering_deadzone)																//create a dead zone around default joystick position, desired value must at least be bigger then dead zone value (makes going straight easier
     466:	80 91 61 04 	lds	r24, 0x0461	; 0x800461 <steering_dv>
     46a:	90 91 62 04 	lds	r25, 0x0462	; 0x800462 <steering_dv+0x1>
     46e:	c1 96       	adiw	r24, 0x31	; 49
     470:	83 36       	cpi	r24, 0x63	; 99
     472:	91 05       	cpc	r25, r1
     474:	40 f4       	brcc	.+16     	; 0x486 <_Z9run_steerv+0x60>
		steering_dv = 0;
     476:	10 92 61 04 	sts	0x0461, r1	; 0x800461 <steering_dv>
     47a:	10 92 62 04 	sts	0x0462, r1	; 0x800462 <steering_dv+0x1>
     47e:	10 92 63 04 	sts	0x0463, r1	; 0x800463 <steering_dv+0x2>
     482:	10 92 64 04 	sts	0x0464, r1	; 0x800464 <steering_dv+0x3>
	steering_delta = steering_dv - steering_cv;															//difference between desired value and current value
     486:	80 91 61 04 	lds	r24, 0x0461	; 0x800461 <steering_dv>
     48a:	90 91 62 04 	lds	r25, 0x0462	; 0x800462 <steering_dv+0x1>
     48e:	a0 91 63 04 	lds	r26, 0x0463	; 0x800463 <steering_dv+0x2>
     492:	b0 91 64 04 	lds	r27, 0x0464	; 0x800464 <steering_dv+0x3>
     496:	89 01       	movw	r16, r18
     498:	9a 01       	movw	r18, r20
     49a:	08 0f       	add	r16, r24
     49c:	19 1f       	adc	r17, r25
     49e:	2a 1f       	adc	r18, r26
     4a0:	3b 1f       	adc	r19, r27
     4a2:	00 93 5d 04 	sts	0x045D, r16	; 0x80045d <steering_delta>
     4a6:	10 93 5e 04 	sts	0x045E, r17	; 0x80045e <steering_delta+0x1>
     4aa:	20 93 5f 04 	sts	0x045F, r18	; 0x80045f <steering_delta+0x2>
     4ae:	30 93 60 04 	sts	0x0460, r19	; 0x800460 <steering_delta+0x3>
	if(abs(steering_delta)<10)																			//if the two are too close together, don't steer, this to prevent the motor from constantly trying to make small movements which it is not capable of, so it starts skreeching
     4b2:	c8 01       	movw	r24, r16
     4b4:	09 96       	adiw	r24, 0x09	; 9
     4b6:	43 97       	sbiw	r24, 0x13	; 19
     4b8:	70 f4       	brcc	.+28     	; 0x4d6 <_Z9run_steerv+0xb0>
		steering_delta=0;
     4ba:	10 92 5d 04 	sts	0x045D, r1	; 0x80045d <steering_delta>
     4be:	10 92 5e 04 	sts	0x045E, r1	; 0x80045e <steering_delta+0x1>
     4c2:	10 92 5f 04 	sts	0x045F, r1	; 0x80045f <steering_delta+0x2>
     4c6:	10 92 60 04 	sts	0x0460, r1	; 0x800460 <steering_delta+0x3>
	steering_ov = constrain((abs(steering_delta) * steering_kp), 0, 255);								//determine the output PMW value in such a way that the smaller the delta, the slower it goes to smooth out steering
     4ca:	60 e0       	ldi	r22, 0x00	; 0
     4cc:	70 e0       	ldi	r23, 0x00	; 0
     4ce:	00 e0       	ldi	r16, 0x00	; 0
     4d0:	10 e0       	ldi	r17, 0x00	; 0
     4d2:	98 01       	movw	r18, r16
     4d4:	11 c0       	rjmp	.+34     	; 0x4f8 <_Z9run_steerv+0xd2>
     4d6:	c8 01       	movw	r24, r16
     4d8:	99 23       	and	r25, r25
     4da:	24 f4       	brge	.+8      	; 0x4e4 <_Z9run_steerv+0xbe>
     4dc:	88 27       	eor	r24, r24
     4de:	99 27       	eor	r25, r25
     4e0:	80 1b       	sub	r24, r16
     4e2:	91 0b       	sbc	r25, r17
     4e4:	bc 01       	movw	r22, r24
     4e6:	66 0f       	add	r22, r22
     4e8:	77 1f       	adc	r23, r23
     4ea:	66 0f       	add	r22, r22
     4ec:	77 1f       	adc	r23, r23
     4ee:	66 0f       	add	r22, r22
     4f0:	77 1f       	adc	r23, r23
     4f2:	68 1b       	sub	r22, r24
     4f4:	79 0b       	sbc	r23, r25
     4f6:	3a f0       	brmi	.+14     	; 0x506 <_Z9run_steerv+0xe0>
     4f8:	6f 3f       	cpi	r22, 0xFF	; 255
     4fa:	71 05       	cpc	r23, r1
     4fc:	29 f0       	breq	.+10     	; 0x508 <_Z9run_steerv+0xe2>
     4fe:	24 f0       	brlt	.+8      	; 0x508 <_Z9run_steerv+0xe2>
     500:	6f ef       	ldi	r22, 0xFF	; 255
     502:	70 e0       	ldi	r23, 0x00	; 0
     504:	01 c0       	rjmp	.+2      	; 0x508 <_Z9run_steerv+0xe2>
     506:	60 e0       	ldi	r22, 0x00	; 0
     508:	60 93 58 04 	sts	0x0458, r22	; 0x800458 <steering_ov>
	if (steering_delta < 0) {																			//H bridge settings, let the engine turn the correct way
     50c:	33 23       	and	r19, r19
     50e:	54 f4       	brge	.+20     	; 0x524 <_Z9run_steerv+0xfe>
		analogWrite(pwm_steer_rpwm, steering_ov);														
     510:	70 e0       	ldi	r23, 0x00	; 0
     512:	83 e0       	ldi	r24, 0x03	; 3
     514:	90 e0       	ldi	r25, 0x00	; 0
     516:	5a d1       	rcall	.+692    	; 0x7cc <_Z11analogWriteii>
		analogWrite(pwm_steer_lpwm, 0);
     518:	60 e0       	ldi	r22, 0x00	; 0
     51a:	70 e0       	ldi	r23, 0x00	; 0
     51c:	82 e0       	ldi	r24, 0x02	; 2
     51e:	90 e0       	ldi	r25, 0x00	; 0
     520:	55 d1       	rcall	.+682    	; 0x7cc <_Z11analogWriteii>
     522:	1b c0       	rjmp	.+54     	; 0x55a <_Z9run_steerv+0x134>
	}
	else if (steering_delta > 0) {
     524:	10 16       	cp	r1, r16
     526:	11 06       	cpc	r1, r17
     528:	12 06       	cpc	r1, r18
     52a:	13 06       	cpc	r1, r19
     52c:	64 f4       	brge	.+24     	; 0x546 <_Z9run_steerv+0x120>
		analogWrite(pwm_steer_rpwm, 0);
     52e:	60 e0       	ldi	r22, 0x00	; 0
     530:	70 e0       	ldi	r23, 0x00	; 0
     532:	83 e0       	ldi	r24, 0x03	; 3
     534:	90 e0       	ldi	r25, 0x00	; 0
     536:	4a d1       	rcall	.+660    	; 0x7cc <_Z11analogWriteii>
		analogWrite(pwm_steer_lpwm, steering_ov);
     538:	60 91 58 04 	lds	r22, 0x0458	; 0x800458 <steering_ov>
     53c:	70 e0       	ldi	r23, 0x00	; 0
     53e:	82 e0       	ldi	r24, 0x02	; 2
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	44 d1       	rcall	.+648    	; 0x7cc <_Z11analogWriteii>
     544:	0a c0       	rjmp	.+20     	; 0x55a <_Z9run_steerv+0x134>
	}
	else {
		analogWrite(pwm_steer_rpwm, 0);
     546:	60 e0       	ldi	r22, 0x00	; 0
     548:	70 e0       	ldi	r23, 0x00	; 0
     54a:	83 e0       	ldi	r24, 0x03	; 3
     54c:	90 e0       	ldi	r25, 0x00	; 0
     54e:	3e d1       	rcall	.+636    	; 0x7cc <_Z11analogWriteii>
		analogWrite(pwm_steer_lpwm, 0);
     550:	60 e0       	ldi	r22, 0x00	; 0
     552:	70 e0       	ldi	r23, 0x00	; 0
     554:	82 e0       	ldi	r24, 0x02	; 2
     556:	90 e0       	ldi	r25, 0x00	; 0
     558:	39 d1       	rcall	.+626    	; 0x7cc <_Z11analogWriteii>
     55a:	1f 91       	pop	r17
	}	
}
     55c:	0f 91       	pop	r16
     55e:	08 95       	ret

00000560 <_Z10run_curtisv>:
     560:	60 91 3a 04 	lds	r22, 0x043A	; 0x80043a <engine_rpm>

void run_curtis(){
	engine_cv = (engine_rpm * float(100 / 1023));												//the process value of the engine system is the rpm which we read from the CAN-bus of the Curtis
     564:	70 91 3b 04 	lds	r23, 0x043B	; 0x80043b <engine_rpm+0x1>
     568:	80 e0       	ldi	r24, 0x00	; 0
     56a:	90 e0       	ldi	r25, 0x00	; 0
     56c:	0e 94 8f 0b 	call	0x171e	; 0x171e <__floatunsisf>
     570:	20 e0       	ldi	r18, 0x00	; 0
     572:	30 e0       	ldi	r19, 0x00	; 0
     574:	a9 01       	movw	r20, r18
     576:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <__mulsf3>
     57a:	0e 94 5e 0b 	call	0x16bc	; 0x16bc <__fixsfsi>
     57e:	60 93 4c 04 	sts	0x044C, r22	; 0x80044c <engine_cv>
     582:	70 93 4d 04 	sts	0x044D, r23	; 0x80044d <engine_cv+0x1>
     586:	80 93 4e 04 	sts	0x044E, r24	; 0x80044e <engine_cv+0x2>
     58a:	90 93 4f 04 	sts	0x044F, r25	; 0x80044f <engine_cv+0x3>
	digitalWrite(do_drive_forward, driving_direction);											//give the Curtis the correct driving direction
     58e:	60 91 00 02 	lds	r22, 0x0200	; 0x800200 <__data_start>
     592:	8b e1       	ldi	r24, 0x1B	; 27
     594:	90 e0       	ldi	r25, 0x00	; 0
     596:	61 d1       	rcall	.+706    	; 0x85a <_Z12digitalWriteib>
	digitalWrite(do_drive_reverse, !driving_direction);
     598:	60 91 00 02 	lds	r22, 0x0200	; 0x800200 <__data_start>
     59c:	81 e0       	ldi	r24, 0x01	; 1
     59e:	68 27       	eor	r22, r24
     5a0:	8c e1       	ldi	r24, 0x1C	; 28
     5a2:	90 e0       	ldi	r25, 0x00	; 0
     5a4:	5a d1       	rcall	.+692    	; 0x85a <_Z12digitalWriteib>
	
	//Set the Curtis in the right mode for braking, driving or neutral																		//if we want to brake
		digitalWrite(do_drive_throttleswitch, engine_dv);				//if there is an engine signal, enable listening to the throttle
     5a6:	61 e0       	ldi	r22, 0x01	; 1
     5a8:	80 91 54 04 	lds	r24, 0x0454	; 0x800454 <engine_dv>
     5ac:	90 91 55 04 	lds	r25, 0x0455	; 0x800455 <engine_dv+0x1>
     5b0:	a0 91 56 04 	lds	r26, 0x0456	; 0x800456 <engine_dv+0x2>
     5b4:	b0 91 57 04 	lds	r27, 0x0457	; 0x800457 <engine_dv+0x3>
     5b8:	89 2b       	or	r24, r25
     5ba:	8a 2b       	or	r24, r26
     5bc:	8b 2b       	or	r24, r27
     5be:	09 f4       	brne	.+2      	; 0x5c2 <_Z10run_curtisv+0x62>
     5c0:	60 e0       	ldi	r22, 0x00	; 0
     5c2:	8e e1       	ldi	r24, 0x1E	; 30
     5c4:	90 e0       	ldi	r25, 0x00	; 0
     5c6:	49 d1       	rcall	.+658    	; 0x85a <_Z12digitalWriteib>
		digitalWrite(do_drive_brake, braking_dv);						//if there is an braking signal, turn on the braking 
     5c8:	61 e0       	ldi	r22, 0x01	; 1
     5ca:	80 91 47 04 	lds	r24, 0x0447	; 0x800447 <braking_dv>
     5ce:	90 91 48 04 	lds	r25, 0x0448	; 0x800448 <braking_dv+0x1>
     5d2:	a0 91 49 04 	lds	r26, 0x0449	; 0x800449 <braking_dv+0x2>
     5d6:	b0 91 4a 04 	lds	r27, 0x044A	; 0x80044a <braking_dv+0x3>
     5da:	89 2b       	or	r24, r25
     5dc:	8a 2b       	or	r24, r26
     5de:	8b 2b       	or	r24, r27
     5e0:	09 f4       	brne	.+2      	; 0x5e4 <_Z10run_curtisv+0x84>
     5e2:	60 e0       	ldi	r22, 0x00	; 0
     5e4:	8d e1       	ldi	r24, 0x1D	; 29
     5e6:	90 e0       	ldi	r25, 0x00	; 0
     5e8:	38 d1       	rcall	.+624    	; 0x85a <_Z12digitalWriteib>

	engine_delta = engine_dv - engine_cv;									//calculate delta
     5ea:	40 91 54 04 	lds	r20, 0x0454	; 0x800454 <engine_dv>
     5ee:	50 91 55 04 	lds	r21, 0x0455	; 0x800455 <engine_dv+0x1>
     5f2:	60 91 56 04 	lds	r22, 0x0456	; 0x800456 <engine_dv+0x2>
     5f6:	70 91 57 04 	lds	r23, 0x0457	; 0x800457 <engine_dv+0x3>
     5fa:	80 91 4c 04 	lds	r24, 0x044C	; 0x80044c <engine_cv>
     5fe:	90 91 4d 04 	lds	r25, 0x044D	; 0x80044d <engine_cv+0x1>
     602:	a0 91 4e 04 	lds	r26, 0x044E	; 0x80044e <engine_cv+0x2>
     606:	b0 91 4f 04 	lds	r27, 0x044F	; 0x80044f <engine_cv+0x3>
     60a:	9a 01       	movw	r18, r20
     60c:	ab 01       	movw	r20, r22
     60e:	28 1b       	sub	r18, r24
     610:	39 0b       	sbc	r19, r25
     612:	4a 0b       	sbc	r20, r26
     614:	5b 0b       	sbc	r21, r27
     616:	20 93 50 04 	sts	0x0450, r18	; 0x800450 <engine_delta>
     61a:	30 93 51 04 	sts	0x0451, r19	; 0x800451 <engine_delta+0x1>
     61e:	40 93 52 04 	sts	0x0452, r20	; 0x800452 <engine_delta+0x2>
     622:	50 93 53 04 	sts	0x0453, r21	; 0x800453 <engine_delta+0x3>
	engine_ov = constrain(engine_delta * engine_kp * 255 / 100, 0, 255);	//calculate output value
     626:	ad ef       	ldi	r26, 0xFD	; 253
     628:	b2 e0       	ldi	r27, 0x02	; 2
     62a:	0e 94 aa 0c 	call	0x1954	; 0x1954 <__muluhisi3>
     62e:	6d 39       	cpi	r22, 0x9D	; 157
     630:	2f ef       	ldi	r18, 0xFF	; 255
     632:	72 07       	cpc	r23, r18
     634:	82 07       	cpc	r24, r18
     636:	92 07       	cpc	r25, r18
     638:	6c f0       	brlt	.+26     	; 0x654 <_Z10run_curtisv+0xf4>
     63a:	61 15       	cp	r22, r1
     63c:	24 e6       	ldi	r18, 0x64	; 100
     63e:	72 07       	cpc	r23, r18
     640:	81 05       	cpc	r24, r1
     642:	91 05       	cpc	r25, r1
     644:	4c f4       	brge	.+18     	; 0x658 <_Z10run_curtisv+0xf8>
     646:	24 e6       	ldi	r18, 0x64	; 100
     648:	30 e0       	ldi	r19, 0x00	; 0
     64a:	40 e0       	ldi	r20, 0x00	; 0
     64c:	50 e0       	ldi	r21, 0x00	; 0
     64e:	0e 94 80 0c 	call	0x1900	; 0x1900 <__divmodsi4>
     652:	03 c0       	rjmp	.+6      	; 0x65a <_Z10run_curtisv+0xfa>
     654:	20 e0       	ldi	r18, 0x00	; 0
     656:	01 c0       	rjmp	.+2      	; 0x65a <_Z10run_curtisv+0xfa>
     658:	2f ef       	ldi	r18, 0xFF	; 255
     65a:	20 93 4b 04 	sts	0x044B, r18	; 0x80044b <engine_ov>
	analogWrite(pwm_drive_throttle, engine_ov);								//Write op to throttle signal of Curtis
     65e:	62 2f       	mov	r22, r18
     660:	70 e0       	ldi	r23, 0x00	; 0
     662:	88 e0       	ldi	r24, 0x08	; 8
     664:	90 e0       	ldi	r25, 0x00	; 0
     666:	b2 c0       	rjmp	.+356    	; 0x7cc <_Z11analogWriteii>
     668:	08 95       	ret

0000066a <_Z5drivev>:
	}
}

void drive(){
	//get correct driving input parameters from selected source (remote and auto not implemented, thus being interpreted as idle)
	mode_select();
     66a:	79 dd       	rcall	.-1294   	; 0x15e <_Z11mode_selectv>
	switch(drivemode){
     66c:	80 91 69 04 	lds	r24, 0x0469	; 0x800469 <drivemode>
     670:	90 91 6a 04 	lds	r25, 0x046A	; 0x80046a <drivemode+0x1>
     674:	81 30       	cpi	r24, 0x01	; 1
     676:	91 05       	cpc	r25, r1
     678:	51 f0       	breq	.+20     	; 0x68e <_Z5drivev+0x24>
     67a:	1c f4       	brge	.+6      	; 0x682 <_Z5drivev+0x18>
     67c:	89 2b       	or	r24, r25
     67e:	49 f0       	breq	.+18     	; 0x692 <_Z5drivev+0x28>
     680:	0d c0       	rjmp	.+26     	; 0x69c <_Z5drivev+0x32>
     682:	82 30       	cpi	r24, 0x02	; 2
     684:	91 05       	cpc	r25, r1
     686:	49 f0       	breq	.+18     	; 0x69a <_Z5drivev+0x30>
     688:	03 97       	sbiw	r24, 0x03	; 3
     68a:	29 f0       	breq	.+10     	; 0x696 <_Z5drivev+0x2c>
		case drivemode_joystick:
			mode_joystick();
     68c:	07 c0       	rjmp	.+14     	; 0x69c <_Z5drivev+0x32>
			break;
     68e:	a6 dd       	rcall	.-1204   	; 0x1dc <_Z13mode_joystickv>
		case drivemode_idle:
			mode_idle();		
     690:	05 c0       	rjmp	.+10     	; 0x69c <_Z5drivev+0x32>
			break;
		case drivemode_auto:
			mode_idle();		//not yet implemented
     692:	53 de       	rcall	.-858    	; 0x33a <_Z9mode_idlev>
			break;
		case drivemode_remote:
			mode_idle();		//not yet implemented
     694:	03 c0       	rjmp	.+6      	; 0x69c <_Z5drivev+0x32>
     696:	51 de       	rcall	.-862    	; 0x33a <_Z9mode_idlev>
			break;	
	}
	run_steer();				//update the steering system
     698:	01 c0       	rjmp	.+2      	; 0x69c <_Z5drivev+0x32>
     69a:	4f de       	rcall	.-866    	; 0x33a <_Z9mode_idlev>
	run_brake();				//update the braking system
     69c:	c4 de       	rcall	.-632    	; 0x426 <_Z9run_steerv>
     69e:	7c de       	rcall	.-776    	; 0x398 <_Z9run_brakev>
	run_curtis();				//update the Curtis
     6a0:	5f cf       	rjmp	.-322    	; 0x560 <_Z10run_curtisv>
     6a2:	08 95       	ret

000006a4 <_Z6initIOv>:
     6a4:	cf 93       	push	r28
#include "IOPins.h"

//this funcion should be called when initializng the program. It writes the correct settings to the registry, allowing the use of analog and digital reading and writing of pins.
void initIO(){
     6a6:	df 93       	push	r29
	Serial.println("Applying IO settings...");
     6a8:	61 e0       	ldi	r22, 0x01	; 1
     6aa:	72 e0       	ldi	r23, 0x02	; 2
     6ac:	8a e8       	ldi	r24, 0x8A	; 138
     6ae:	94 e0       	ldi	r25, 0x04	; 4
     6b0:	cc d7       	rcall	.+3992   	; 0x164a <_ZN5USART7printlnEPKc>
	//Read/Write pins
	//////////////////////////////////////
	//Disable the pullup resistor in these pins, making them output by writing a 1 to their respective registry entries. Pins not written to default to input pins.
	//when adding/altering pins, alter them in the respective switch case as well.
	//digitalwrite
	DDRA |= 0b11111111;
     6b2:	81 b1       	in	r24, 0x01	; 1
     6b4:	8f ef       	ldi	r24, 0xFF	; 255
     6b6:	81 b9       	out	0x01, r24	; 1
	//B pins are reserved for SPI, don't touch those
	DDRC |= 0b11111111;
     6b8:	97 b1       	in	r25, 0x07	; 7
     6ba:	87 b9       	out	0x07, r24	; 7
	DDRD |= 0b10000000;
     6bc:	57 9a       	sbi	0x0a, 7	; 10
	DDRG |= 0b00000111;
     6be:	83 b3       	in	r24, 0x13	; 19
     6c0:	87 60       	ori	r24, 0x07	; 7
     6c2:	83 bb       	out	0x13, r24	; 19
	//DDRL |= 0b11111111;
	
	//analogwrite, Not all pins support PWM signals, please consult datasheets before altering.
	DDRB |= 0b11110000;
     6c4:	84 b1       	in	r24, 0x04	; 4
     6c6:	80 6f       	ori	r24, 0xF0	; 240
     6c8:	84 b9       	out	0x04, r24	; 4
	DDRE |= 0b00111000;
     6ca:	8d b1       	in	r24, 0x0d	; 13
     6cc:	88 63       	ori	r24, 0x38	; 56
     6ce:	8d b9       	out	0x0d, r24	; 13
	DDRG |= 0b00100000;
     6d0:	9d 9a       	sbi	0x13, 5	; 19
	DDRH |= 0b01111000;
     6d2:	e1 e0       	ldi	r30, 0x01	; 1
     6d4:	f1 e0       	ldi	r31, 0x01	; 1
     6d6:	80 81       	ld	r24, Z
     6d8:	88 67       	ori	r24, 0x78	; 120
     6da:	80 83       	st	Z, r24
	DDRL |= 0b00111000;
     6dc:	ea e0       	ldi	r30, 0x0A	; 10
     6de:	f1 e0       	ldi	r31, 0x01	; 1
     6e0:	80 81       	ld	r24, Z
     6e2:	88 63       	ori	r24, 0x38	; 56
     6e4:	80 83       	st	Z, r24
	//when something is unclear or you want to change some setting, please consult the datasheet first.
	
	//Compare output mode
	//determines how the PWN behaves, now it Clears OCxx on compare match. This makes it so that low value OCRxx will result in short pulses, while higher result in longer ones
	//COM0xx0 will make OCxx toggle on compare match, both will set om compare match. Neither will disable the pmw by disconnecting OCxx.
	TCCR0A |= (( 1 << COM0A1) | (1 << COM0B1));
     6e6:	84 b5       	in	r24, 0x24	; 36
     6e8:	80 6a       	ori	r24, 0xA0	; 160
     6ea:	84 bd       	out	0x24, r24	; 36
	TCCR1A |= (( 1 << COM1A1) | (1 << COM1B1));
     6ec:	c0 e8       	ldi	r28, 0x80	; 128
     6ee:	d0 e0       	ldi	r29, 0x00	; 0
     6f0:	88 81       	ld	r24, Y
     6f2:	80 6a       	ori	r24, 0xA0	; 160
     6f4:	88 83       	st	Y, r24
	TCCR2A |= (( 1 << COM2A1) | (1 << COM2B1));
     6f6:	a0 eb       	ldi	r26, 0xB0	; 176
     6f8:	b0 e0       	ldi	r27, 0x00	; 0
     6fa:	8c 91       	ld	r24, X
     6fc:	80 6a       	ori	r24, 0xA0	; 160
     6fe:	8c 93       	st	X, r24
	TCCR3A |= (( 1 << COM3A1) | (1 << COM3B1));
     700:	e0 e9       	ldi	r30, 0x90	; 144
     702:	f0 e0       	ldi	r31, 0x00	; 0
     704:	80 81       	ld	r24, Z
     706:	80 6a       	ori	r24, 0xA0	; 160
     708:	80 83       	st	Z, r24
	//TCCR4A |= (( 1 << COM4A1) | (1 << COM4B1));
	
	//Waveform Generation
	//note that here OCRxA and OCRxB use the same registry and thus also use the same waveform.
	//the current PWM is Fast PMW, but in this case the PWM mode isn't really important.
	TCCR0A |= ((1 << WGM01) | (1 << WGM00));
     70a:	84 b5       	in	r24, 0x24	; 36
     70c:	83 60       	ori	r24, 0x03	; 3
     70e:	84 bd       	out	0x24, r24	; 36
	TCCR1A |= ((1 << WGM12) | (1 << WGM10));		//16 bit timer, scaled back to 8 bit. (TCCR0x and TCCR2x are 8 bit already)
     710:	88 81       	ld	r24, Y
     712:	89 60       	ori	r24, 0x09	; 9
     714:	88 83       	st	Y, r24
	TCCR2A |= ((1 << WGM21) | (1 << WGM20));
     716:	8c 91       	ld	r24, X
     718:	83 60       	ori	r24, 0x03	; 3
     71a:	8c 93       	st	X, r24
	TCCR3A |= ((1 << WGM32) | (1 << WGM30));		//16 bit
     71c:	80 81       	ld	r24, Z
     71e:	89 60       	ori	r24, 0x09	; 9
     720:	80 83       	st	Z, r24
	
	//clock Select
	//currently selected, Internal clock, /8 prescaler. this starts the PWM as well
	//F_CPU=16000000 / 256 / 8 ~= 7812Hz wave
	//again as with the OCRxx, these use the same registry as well and are thus linked
	TCCR0B |= (1 << CS01);
     722:	85 b5       	in	r24, 0x25	; 37
     724:	82 60       	ori	r24, 0x02	; 2
     726:	85 bd       	out	0x25, r24	; 37
	TCCR1B |= (1 << CS11);
     728:	e1 e8       	ldi	r30, 0x81	; 129
     72a:	f0 e0       	ldi	r31, 0x00	; 0
     72c:	80 81       	ld	r24, Z
     72e:	82 60       	ori	r24, 0x02	; 2
     730:	80 83       	st	Z, r24
	TCCR2B |= (1 << CS21);
     732:	e1 eb       	ldi	r30, 0xB1	; 177
     734:	f0 e0       	ldi	r31, 0x00	; 0
     736:	80 81       	ld	r24, Z
     738:	82 60       	ori	r24, 0x02	; 2
     73a:	80 83       	st	Z, r24
	TCCR3B |= (1 << CS31);
     73c:	e1 e9       	ldi	r30, 0x91	; 145
     73e:	f0 e0       	ldi	r31, 0x00	; 0
     740:	80 81       	ld	r24, Z
     742:	82 60       	ori	r24, 0x02	; 2
     744:	80 83       	st	Z, r24
	TCCR4B |= (1 << CS41);
     746:	e1 ea       	ldi	r30, 0xA1	; 161
     748:	f0 e0       	ldi	r31, 0x00	; 0
     74a:	80 81       	ld	r24, Z
     74c:	82 60       	ori	r24, 0x02	; 2
     74e:	80 83       	st	Z, r24
	
	//initialize each pwm as 0
	OCR3B=0;	//pin 2
     750:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <__TEXT_REGION_LENGTH__+0x70009b>
     754:	10 92 9a 00 	sts	0x009A, r1	; 0x80009a <__TEXT_REGION_LENGTH__+0x70009a>
	OCR3C=0;	//pin 3
     758:	10 92 9d 00 	sts	0x009D, r1	; 0x80009d <__TEXT_REGION_LENGTH__+0x70009d>
     75c:	10 92 9c 00 	sts	0x009C, r1	; 0x80009c <__TEXT_REGION_LENGTH__+0x70009c>
	OCR0B=0;	//pin 4
     760:	18 bc       	out	0x28, r1	; 40
	OCR3A=0;	//pin 5
     762:	10 92 99 00 	sts	0x0099, r1	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
     766:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
	OCR4A=0;	//pin 6
     76a:	10 92 a9 00 	sts	0x00A9, r1	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
     76e:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
	OCR4B=0;	//pin 7
     772:	10 92 ab 00 	sts	0x00AB, r1	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
     776:	10 92 aa 00 	sts	0x00AA, r1	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
	OCR4C=0;	//pin 8
     77a:	10 92 ad 00 	sts	0x00AD, r1	; 0x8000ad <__TEXT_REGION_LENGTH__+0x7000ad>
     77e:	10 92 ac 00 	sts	0x00AC, r1	; 0x8000ac <__TEXT_REGION_LENGTH__+0x7000ac>
	OCR2B=0;	//pin 9
     782:	10 92 b4 00 	sts	0x00B4, r1	; 0x8000b4 <__TEXT_REGION_LENGTH__+0x7000b4>
	OCR2A=0;	//pin 10
     786:	10 92 b3 00 	sts	0x00B3, r1	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
	OCR1A=0;	//pin 11
     78a:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     78e:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
	OCR1B=0;	//pin 12
     792:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     796:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
	OCR1C=0;	//pin 13
     79a:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
     79e:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
	//Analog Digital Converter, analogread
	//////////////////////////////////////
	
	//Analog Digital Multiplexer Selection Register, voltage reference selection
	//Current setting: AVcc with external capacitor at AREF pin (internal 5v)
	ADMUX |= (1 << REFS0);
     7a2:	ec e7       	ldi	r30, 0x7C	; 124
     7a4:	f0 e0       	ldi	r31, 0x00	; 0
     7a6:	80 81       	ld	r24, Z
     7a8:	80 64       	ori	r24, 0x40	; 64
     7aa:	80 83       	st	Z, r24
	
	// 1/128 prescaler
	ADCSRA |= (1 << ADPS0) | (1 << ADPS1) | (1 << ADPS2);
     7ac:	ea e7       	ldi	r30, 0x7A	; 122
     7ae:	f0 e0       	ldi	r31, 0x00	; 0
     7b0:	80 81       	ld	r24, Z
     7b2:	87 60       	ori	r24, 0x07	; 7
     7b4:	80 83       	st	Z, r24
	
	//enable the ADC convector, and disable GPIO functionality on the ADC pins
	ADCSRA |= (1 << ADEN);
     7b6:	80 81       	ld	r24, Z
     7b8:	80 68       	ori	r24, 0x80	; 128
     7ba:	80 83       	st	Z, r24
	Serial.println("IO setting generated");
     7bc:	69 e1       	ldi	r22, 0x19	; 25
     7be:	72 e0       	ldi	r23, 0x02	; 2
     7c0:	8a e8       	ldi	r24, 0x8A	; 138
     7c2:	94 e0       	ldi	r25, 0x04	; 4
     7c4:	42 d7       	rcall	.+3716   	; 0x164a <_ZN5USART7printlnEPKc>
	return;
}
     7c6:	df 91       	pop	r29
     7c8:	cf 91       	pop	r28
     7ca:	08 95       	ret

000007cc <_Z11analogWriteii>:


//writes a value between 0 and 255 to the correct output compare register
//analogWrite(pin numer, value it should receive).
void analogWrite(int pin,int val){
     7cc:	6f 3f       	cpi	r22, 0xFF	; 255
     7ce:	71 05       	cpc	r23, r1
     7d0:	19 f0       	breq	.+6      	; 0x7d8 <_Z11analogWriteii+0xc>
     7d2:	14 f0       	brlt	.+4      	; 0x7d8 <_Z11analogWriteii+0xc>
     7d4:	6f ef       	ldi	r22, 0xFF	; 255
     7d6:	70 e0       	ldi	r23, 0x00	; 0
	if(val>255)			//if the given value exeeds 255, make it 255
	val=255;
	switch(pin){
     7d8:	fc 01       	movw	r30, r24
     7da:	32 97       	sbiw	r30, 0x02	; 2
     7dc:	eb 30       	cpi	r30, 0x0B	; 11
     7de:	f1 05       	cpc	r31, r1
     7e0:	b0 f5       	brcc	.+108    	; 0x84e <_Z11analogWriteii+0x82>
     7e2:	88 27       	eor	r24, r24
     7e4:	ee 58       	subi	r30, 0x8E	; 142
     7e6:	ff 4f       	sbci	r31, 0xFF	; 255
     7e8:	8f 4f       	sbci	r24, 0xFF	; 255
     7ea:	0c 94 9c 0c 	jmp	0x1938	; 0x1938 <__tablejump2__>
		case 2:
		OCR3B=val;
     7ee:	70 93 9b 00 	sts	0x009B, r23	; 0x80009b <__TEXT_REGION_LENGTH__+0x70009b>
     7f2:	60 93 9a 00 	sts	0x009A, r22	; 0x80009a <__TEXT_REGION_LENGTH__+0x70009a>
		return;
     7f6:	08 95       	ret
		case 3:
		OCR3C=val;
     7f8:	70 93 9d 00 	sts	0x009D, r23	; 0x80009d <__TEXT_REGION_LENGTH__+0x70009d>
     7fc:	60 93 9c 00 	sts	0x009C, r22	; 0x80009c <__TEXT_REGION_LENGTH__+0x70009c>
		return;
     800:	08 95       	ret
		case 4:
		OCR0B=val;
     802:	68 bd       	out	0x28, r22	; 40
		return;
     804:	08 95       	ret
		case 5:
		OCR3A=val;
     806:	70 93 99 00 	sts	0x0099, r23	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
     80a:	60 93 98 00 	sts	0x0098, r22	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
		return;
     80e:	08 95       	ret
		case 6:
		OCR4A=val;
     810:	70 93 a9 00 	sts	0x00A9, r23	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
     814:	60 93 a8 00 	sts	0x00A8, r22	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
		return;
     818:	08 95       	ret
		case 7:
		OCR4B=val;
     81a:	70 93 ab 00 	sts	0x00AB, r23	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
     81e:	60 93 aa 00 	sts	0x00AA, r22	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
		return;
     822:	08 95       	ret
		case 8:
		OCR4C=val;
     824:	70 93 ad 00 	sts	0x00AD, r23	; 0x8000ad <__TEXT_REGION_LENGTH__+0x7000ad>
     828:	60 93 ac 00 	sts	0x00AC, r22	; 0x8000ac <__TEXT_REGION_LENGTH__+0x7000ac>
		return;
     82c:	08 95       	ret
		case 9:
		OCR2B=val;
     82e:	60 93 b4 00 	sts	0x00B4, r22	; 0x8000b4 <__TEXT_REGION_LENGTH__+0x7000b4>
		return;
     832:	08 95       	ret
		case 10:
		OCR2A=val;
     834:	60 93 b3 00 	sts	0x00B3, r22	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
		return;
     838:	08 95       	ret
		case 11:
		OCR1A=val;
     83a:	70 93 89 00 	sts	0x0089, r23	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     83e:	60 93 88 00 	sts	0x0088, r22	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
		return;
     842:	08 95       	ret
		case 12:
		OCR1B=val;
     844:	70 93 8b 00 	sts	0x008B, r23	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     848:	60 93 8a 00 	sts	0x008A, r22	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
		return;
     84c:	08 95       	ret
		}
	Serial.println("ERROR: tried to write analog value to unsupported pin");
     84e:	6e e2       	ldi	r22, 0x2E	; 46
     850:	72 e0       	ldi	r23, 0x02	; 2
     852:	8a e8       	ldi	r24, 0x8A	; 138
     854:	94 e0       	ldi	r25, 0x04	; 4
     856:	f9 c6       	rjmp	.+3570   	; 0x164a <_ZN5USART7printlnEPKc>
     858:	08 95       	ret

0000085a <_Z12digitalWriteib>:
	return;
}

//writes a digital value to a pin.
void digitalWrite(int pin,bool val){
     85a:	cf 93       	push	r28
     85c:	df 93       	push	r29
	if(pin<22||pin>53){					//check if the pin is a digital IO pin
     85e:	9c 01       	movw	r18, r24
     860:	26 51       	subi	r18, 0x16	; 22
     862:	31 09       	sbc	r19, r1
     864:	20 32       	cpi	r18, 0x20	; 32
     866:	31 05       	cpc	r19, r1
     868:	58 f0       	brcs	.+22     	; 0x880 <_Z12digitalWriteib+0x26>
     86a:	ec 01       	movw	r28, r24
		Serial.print("ERROR: tried to write digital value to unsupported digital pin");
     86c:	64 e6       	ldi	r22, 0x64	; 100
     86e:	72 e0       	ldi	r23, 0x02	; 2
     870:	8a e8       	ldi	r24, 0x8A	; 138
     872:	94 e0       	ldi	r25, 0x04	; 4
     874:	d1 d6       	rcall	.+3490   	; 0x1618 <_ZN5USART5printEPKc>
		Serial.println(pin);
     876:	be 01       	movw	r22, r28
     878:	8a e8       	ldi	r24, 0x8A	; 138
     87a:	94 e0       	ldi	r25, 0x04	; 4
     87c:	14 d7       	rcall	.+3624   	; 0x16a6 <_ZN5USART7printlnEi>
     87e:	b9 c0       	rjmp	.+370    	; 0x9f2 <_Z12digitalWriteib+0x198>
	}
	else if(pin<30){					//check if pin is in the A register
     880:	8e 31       	cpi	r24, 0x1E	; 30
     882:	91 05       	cpc	r25, r1
     884:	f4 f4       	brge	.+60     	; 0x8c2 <_Z12digitalWriteib+0x68>
		pin-=22;						//make pinrange 0-7
     886:	46 97       	sbiw	r24, 0x16	; 22
		if(val) PORTA |= (1<<pin);		//set correct bit in A register is val==true
     888:	66 23       	and	r22, r22
     88a:	69 f0       	breq	.+26     	; 0x8a6 <_Z12digitalWriteib+0x4c>
     88c:	42 b1       	in	r20, 0x02	; 2
     88e:	21 e0       	ldi	r18, 0x01	; 1
     890:	30 e0       	ldi	r19, 0x00	; 0
     892:	b9 01       	movw	r22, r18
     894:	02 c0       	rjmp	.+4      	; 0x89a <_Z12digitalWriteib+0x40>
     896:	66 0f       	add	r22, r22
     898:	77 1f       	adc	r23, r23
     89a:	8a 95       	dec	r24
     89c:	e2 f7       	brpl	.-8      	; 0x896 <_Z12digitalWriteib+0x3c>
     89e:	cb 01       	movw	r24, r22
     8a0:	84 2b       	or	r24, r20
     8a2:	82 b9       	out	0x02, r24	; 2
     8a4:	a6 c0       	rjmp	.+332    	; 0x9f2 <_Z12digitalWriteib+0x198>
		else PORTA &= ~(1<<pin);		//unset bit if false
     8a6:	42 b1       	in	r20, 0x02	; 2
     8a8:	21 e0       	ldi	r18, 0x01	; 1
     8aa:	30 e0       	ldi	r19, 0x00	; 0
     8ac:	b9 01       	movw	r22, r18
     8ae:	02 c0       	rjmp	.+4      	; 0x8b4 <_Z12digitalWriteib+0x5a>
     8b0:	66 0f       	add	r22, r22
     8b2:	77 1f       	adc	r23, r23
     8b4:	8a 95       	dec	r24
     8b6:	e2 f7       	brpl	.-8      	; 0x8b0 <_Z12digitalWriteib+0x56>
     8b8:	cb 01       	movw	r24, r22
     8ba:	80 95       	com	r24
     8bc:	84 23       	and	r24, r20
     8be:	82 b9       	out	0x02, r24	; 2
     8c0:	98 c0       	rjmp	.+304    	; 0x9f2 <_Z12digitalWriteib+0x198>
	}
	else if(pin<38){
     8c2:	86 32       	cpi	r24, 0x26	; 38
     8c4:	91 05       	cpc	r25, r1
     8c6:	1c f5       	brge	.+70     	; 0x90e <_Z12digitalWriteib+0xb4>
		pin=(37-pin);
     8c8:	25 e2       	ldi	r18, 0x25	; 37
     8ca:	30 e0       	ldi	r19, 0x00	; 0
     8cc:	a9 01       	movw	r20, r18
     8ce:	48 1b       	sub	r20, r24
     8d0:	59 0b       	sbc	r21, r25
     8d2:	ca 01       	movw	r24, r20
		if(val) PORTC |= (1<<pin);
     8d4:	66 23       	and	r22, r22
     8d6:	69 f0       	breq	.+26     	; 0x8f2 <_Z12digitalWriteib+0x98>
     8d8:	48 b1       	in	r20, 0x08	; 8
     8da:	21 e0       	ldi	r18, 0x01	; 1
     8dc:	30 e0       	ldi	r19, 0x00	; 0
     8de:	b9 01       	movw	r22, r18
     8e0:	02 c0       	rjmp	.+4      	; 0x8e6 <_Z12digitalWriteib+0x8c>
     8e2:	66 0f       	add	r22, r22
     8e4:	77 1f       	adc	r23, r23
     8e6:	8a 95       	dec	r24
     8e8:	e2 f7       	brpl	.-8      	; 0x8e2 <_Z12digitalWriteib+0x88>
     8ea:	cb 01       	movw	r24, r22
     8ec:	84 2b       	or	r24, r20
     8ee:	88 b9       	out	0x08, r24	; 8
     8f0:	80 c0       	rjmp	.+256    	; 0x9f2 <_Z12digitalWriteib+0x198>
		else PORTC &= ~(1<<pin);
     8f2:	48 b1       	in	r20, 0x08	; 8
     8f4:	21 e0       	ldi	r18, 0x01	; 1
     8f6:	30 e0       	ldi	r19, 0x00	; 0
     8f8:	b9 01       	movw	r22, r18
     8fa:	02 c0       	rjmp	.+4      	; 0x900 <_Z12digitalWriteib+0xa6>
     8fc:	66 0f       	add	r22, r22
     8fe:	77 1f       	adc	r23, r23
     900:	8a 95       	dec	r24
     902:	e2 f7       	brpl	.-8      	; 0x8fc <_Z12digitalWriteib+0xa2>
     904:	cb 01       	movw	r24, r22
     906:	80 95       	com	r24
     908:	84 23       	and	r24, r20
     90a:	88 b9       	out	0x08, r24	; 8
     90c:	72 c0       	rjmp	.+228    	; 0x9f2 <_Z12digitalWriteib+0x198>
	}
	else if(pin==38){
     90e:	86 32       	cpi	r24, 0x26	; 38
     910:	91 05       	cpc	r25, r1
     912:	31 f4       	brne	.+12     	; 0x920 <_Z12digitalWriteib+0xc6>
		if(val) PORTD |= (1<<PIND7);
     914:	66 23       	and	r22, r22
     916:	11 f0       	breq	.+4      	; 0x91c <_Z12digitalWriteib+0xc2>
     918:	5f 9a       	sbi	0x0b, 7	; 11
     91a:	6b c0       	rjmp	.+214    	; 0x9f2 <_Z12digitalWriteib+0x198>
		else PORTD &= ~(1<<PIND7);
     91c:	5f 98       	cbi	0x0b, 7	; 11
     91e:	69 c0       	rjmp	.+210    	; 0x9f2 <_Z12digitalWriteib+0x198>
	}
	else if(pin<42){
     920:	8a 32       	cpi	r24, 0x2A	; 42
     922:	91 05       	cpc	r25, r1
     924:	ec f4       	brge	.+58     	; 0x960 <_Z12digitalWriteib+0x106>
		pin=(41-pin);
     926:	29 e2       	ldi	r18, 0x29	; 41
     928:	30 e0       	ldi	r19, 0x00	; 0
     92a:	28 1b       	sub	r18, r24
     92c:	39 0b       	sbc	r19, r25
		if(val) PORTG |= (1<<pin);
     92e:	66 23       	and	r22, r22
     930:	59 f0       	breq	.+22     	; 0x948 <_Z12digitalWriteib+0xee>
     932:	34 b3       	in	r19, 0x14	; 20
     934:	81 e0       	ldi	r24, 0x01	; 1
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	02 c0       	rjmp	.+4      	; 0x93e <_Z12digitalWriteib+0xe4>
     93a:	88 0f       	add	r24, r24
     93c:	99 1f       	adc	r25, r25
     93e:	2a 95       	dec	r18
     940:	e2 f7       	brpl	.-8      	; 0x93a <_Z12digitalWriteib+0xe0>
     942:	83 2b       	or	r24, r19
     944:	84 bb       	out	0x14, r24	; 20
     946:	55 c0       	rjmp	.+170    	; 0x9f2 <_Z12digitalWriteib+0x198>
		else PORTG &= ~(1<<pin);
     948:	34 b3       	in	r19, 0x14	; 20
     94a:	81 e0       	ldi	r24, 0x01	; 1
     94c:	90 e0       	ldi	r25, 0x00	; 0
     94e:	02 c0       	rjmp	.+4      	; 0x954 <_Z12digitalWriteib+0xfa>
     950:	88 0f       	add	r24, r24
     952:	99 1f       	adc	r25, r25
     954:	2a 95       	dec	r18
     956:	e2 f7       	brpl	.-8      	; 0x950 <_Z12digitalWriteib+0xf6>
     958:	80 95       	com	r24
     95a:	83 23       	and	r24, r19
     95c:	84 bb       	out	0x14, r24	; 20
     95e:	49 c0       	rjmp	.+146    	; 0x9f2 <_Z12digitalWriteib+0x198>
	}
	else if(pin<50){
     960:	82 33       	cpi	r24, 0x32	; 50
     962:	91 05       	cpc	r25, r1
     964:	0c f5       	brge	.+66     	; 0x9a8 <_Z12digitalWriteib+0x14e>
		pin=(49-pin);
     966:	21 e3       	ldi	r18, 0x31	; 49
     968:	30 e0       	ldi	r19, 0x00	; 0
     96a:	28 1b       	sub	r18, r24
     96c:	39 0b       	sbc	r19, r25
		if(val) PORTL |= (1<<pin);
     96e:	66 23       	and	r22, r22
     970:	69 f0       	breq	.+26     	; 0x98c <_Z12digitalWriteib+0x132>
     972:	eb e0       	ldi	r30, 0x0B	; 11
     974:	f1 e0       	ldi	r31, 0x01	; 1
     976:	30 81       	ld	r19, Z
     978:	81 e0       	ldi	r24, 0x01	; 1
     97a:	90 e0       	ldi	r25, 0x00	; 0
     97c:	02 c0       	rjmp	.+4      	; 0x982 <_Z12digitalWriteib+0x128>
     97e:	88 0f       	add	r24, r24
     980:	99 1f       	adc	r25, r25
     982:	2a 95       	dec	r18
     984:	e2 f7       	brpl	.-8      	; 0x97e <_Z12digitalWriteib+0x124>
     986:	83 2b       	or	r24, r19
     988:	80 83       	st	Z, r24
     98a:	33 c0       	rjmp	.+102    	; 0x9f2 <_Z12digitalWriteib+0x198>
		else PORTL &= ~(1<<pin);
     98c:	eb e0       	ldi	r30, 0x0B	; 11
     98e:	f1 e0       	ldi	r31, 0x01	; 1
     990:	30 81       	ld	r19, Z
     992:	81 e0       	ldi	r24, 0x01	; 1
     994:	90 e0       	ldi	r25, 0x00	; 0
     996:	02 c0       	rjmp	.+4      	; 0x99c <_Z12digitalWriteib+0x142>
     998:	88 0f       	add	r24, r24
     99a:	99 1f       	adc	r25, r25
     99c:	2a 95       	dec	r18
     99e:	e2 f7       	brpl	.-8      	; 0x998 <_Z12digitalWriteib+0x13e>
     9a0:	80 95       	com	r24
     9a2:	83 23       	and	r24, r19
     9a4:	80 83       	st	Z, r24
     9a6:	25 c0       	rjmp	.+74     	; 0x9f2 <_Z12digitalWriteib+0x198>
	}
	else if(pin<54){
     9a8:	86 33       	cpi	r24, 0x36	; 54
     9aa:	91 05       	cpc	r25, r1
     9ac:	14 f5       	brge	.+68     	; 0x9f2 <_Z12digitalWriteib+0x198>
		pin=(53-pin);
     9ae:	25 e3       	ldi	r18, 0x35	; 53
     9b0:	30 e0       	ldi	r19, 0x00	; 0
     9b2:	a9 01       	movw	r20, r18
     9b4:	48 1b       	sub	r20, r24
     9b6:	59 0b       	sbc	r21, r25
     9b8:	ca 01       	movw	r24, r20
		if(val) PORTB |= (1<<pin);
     9ba:	66 23       	and	r22, r22
     9bc:	69 f0       	breq	.+26     	; 0x9d8 <_Z12digitalWriteib+0x17e>
     9be:	45 b1       	in	r20, 0x05	; 5
     9c0:	21 e0       	ldi	r18, 0x01	; 1
     9c2:	30 e0       	ldi	r19, 0x00	; 0
     9c4:	b9 01       	movw	r22, r18
     9c6:	02 c0       	rjmp	.+4      	; 0x9cc <_Z12digitalWriteib+0x172>
     9c8:	66 0f       	add	r22, r22
     9ca:	77 1f       	adc	r23, r23
     9cc:	8a 95       	dec	r24
     9ce:	e2 f7       	brpl	.-8      	; 0x9c8 <_Z12digitalWriteib+0x16e>
     9d0:	cb 01       	movw	r24, r22
     9d2:	84 2b       	or	r24, r20
     9d4:	85 b9       	out	0x05, r24	; 5
     9d6:	0d c0       	rjmp	.+26     	; 0x9f2 <_Z12digitalWriteib+0x198>
		else PORTB &= ~(1<<pin);
     9d8:	45 b1       	in	r20, 0x05	; 5
     9da:	21 e0       	ldi	r18, 0x01	; 1
     9dc:	30 e0       	ldi	r19, 0x00	; 0
     9de:	b9 01       	movw	r22, r18
     9e0:	02 c0       	rjmp	.+4      	; 0x9e6 <_Z12digitalWriteib+0x18c>
     9e2:	66 0f       	add	r22, r22
     9e4:	77 1f       	adc	r23, r23
     9e6:	8a 95       	dec	r24
     9e8:	e2 f7       	brpl	.-8      	; 0x9e2 <_Z12digitalWriteib+0x188>
     9ea:	cb 01       	movw	r24, r22
     9ec:	80 95       	com	r24
     9ee:	84 23       	and	r24, r20
     9f0:	85 b9       	out	0x05, r24	; 5
	}
	return;
}
     9f2:	df 91       	pop	r29
     9f4:	cf 91       	pop	r28
     9f6:	08 95       	ret

000009f8 <_Z11digitalReadi>:

bool digitalRead(int pin){
     9f8:	cf 93       	push	r28
     9fa:	df 93       	push	r29
	if(pin==4){
     9fc:	84 30       	cpi	r24, 0x04	; 4
     9fe:	91 05       	cpc	r25, r1
     a00:	29 f4       	brne	.+10     	; 0xa0c <_Z11digitalReadi+0x14>
		if(PING&(1<<PING5))	return true;
     a02:	82 b3       	in	r24, 0x12	; 18
     a04:	85 fb       	bst	r24, 5
     a06:	88 27       	eor	r24, r24
     a08:	80 f9       	bld	r24, 0
     a0a:	6f c0       	rjmp	.+222    	; 0xaea <_Z11digitalReadi+0xf2>
	}
	else if(pin<30){					//check if pin is in the A register
     a0c:	8e 31       	cpi	r24, 0x1E	; 30
     a0e:	91 05       	cpc	r25, r1
     a10:	64 f4       	brge	.+24     	; 0xa2a <_Z11digitalReadi+0x32>
		pin-=22;						//make pinrange 0-7
		if(PINA&(1<<pin))	return true;							//break function
     a12:	20 b1       	in	r18, 0x00	; 0
     a14:	30 e0       	ldi	r19, 0x00	; 0
     a16:	46 97       	sbiw	r24, 0x16	; 22
     a18:	a9 01       	movw	r20, r18
     a1a:	02 c0       	rjmp	.+4      	; 0xa20 <_Z11digitalReadi+0x28>
     a1c:	55 95       	asr	r21
     a1e:	47 95       	ror	r20
     a20:	8a 95       	dec	r24
     a22:	e2 f7       	brpl	.-8      	; 0xa1c <_Z11digitalReadi+0x24>
     a24:	ca 01       	movw	r24, r20
     a26:	81 70       	andi	r24, 0x01	; 1
     a28:	60 c0       	rjmp	.+192    	; 0xaea <_Z11digitalReadi+0xf2>
	}
	else if(pin<38){
     a2a:	86 32       	cpi	r24, 0x26	; 38
     a2c:	91 05       	cpc	r25, r1
     a2e:	84 f4       	brge	.+32     	; 0xa50 <_Z11digitalReadi+0x58>
		pin=37-pin;
		if(PINC&(1<<pin))	return true;							//break function
     a30:	26 b1       	in	r18, 0x06	; 6
     a32:	30 e0       	ldi	r19, 0x00	; 0
     a34:	45 e2       	ldi	r20, 0x25	; 37
     a36:	50 e0       	ldi	r21, 0x00	; 0
     a38:	ba 01       	movw	r22, r20
     a3a:	68 1b       	sub	r22, r24
     a3c:	79 0b       	sbc	r23, r25
     a3e:	a9 01       	movw	r20, r18
     a40:	02 c0       	rjmp	.+4      	; 0xa46 <_Z11digitalReadi+0x4e>
     a42:	55 95       	asr	r21
     a44:	47 95       	ror	r20
     a46:	6a 95       	dec	r22
     a48:	e2 f7       	brpl	.-8      	; 0xa42 <_Z11digitalReadi+0x4a>
     a4a:	ca 01       	movw	r24, r20
     a4c:	81 70       	andi	r24, 0x01	; 1
     a4e:	4d c0       	rjmp	.+154    	; 0xaea <_Z11digitalReadi+0xf2>
	}
	else if(pin==38){
     a50:	86 32       	cpi	r24, 0x26	; 38
     a52:	91 05       	cpc	r25, r1
     a54:	29 f4       	brne	.+10     	; 0xa60 <_Z11digitalReadi+0x68>
		if(PIND&(1<<PIND7))	return true;							//break function
     a56:	89 b1       	in	r24, 0x09	; 9
     a58:	88 1f       	adc	r24, r24
     a5a:	88 27       	eor	r24, r24
     a5c:	88 1f       	adc	r24, r24
     a5e:	45 c0       	rjmp	.+138    	; 0xaea <_Z11digitalReadi+0xf2>
	}
	else if(pin<42){
     a60:	8a 32       	cpi	r24, 0x2A	; 42
     a62:	91 05       	cpc	r25, r1
     a64:	84 f4       	brge	.+32     	; 0xa86 <_Z11digitalReadi+0x8e>
		pin=41-pin;
		if(PING&(1<<pin))	return true;							//break function
     a66:	22 b3       	in	r18, 0x12	; 18
     a68:	30 e0       	ldi	r19, 0x00	; 0
     a6a:	49 e2       	ldi	r20, 0x29	; 41
     a6c:	50 e0       	ldi	r21, 0x00	; 0
     a6e:	ba 01       	movw	r22, r20
     a70:	68 1b       	sub	r22, r24
     a72:	79 0b       	sbc	r23, r25
     a74:	a9 01       	movw	r20, r18
     a76:	02 c0       	rjmp	.+4      	; 0xa7c <_Z11digitalReadi+0x84>
     a78:	55 95       	asr	r21
     a7a:	47 95       	ror	r20
     a7c:	6a 95       	dec	r22
     a7e:	e2 f7       	brpl	.-8      	; 0xa78 <_Z11digitalReadi+0x80>
     a80:	ca 01       	movw	r24, r20
     a82:	81 70       	andi	r24, 0x01	; 1
     a84:	32 c0       	rjmp	.+100    	; 0xaea <_Z11digitalReadi+0xf2>
	}
	else if(pin<50){
     a86:	82 33       	cpi	r24, 0x32	; 50
     a88:	91 05       	cpc	r25, r1
     a8a:	8c f4       	brge	.+34     	; 0xaae <_Z11digitalReadi+0xb6>
		pin=49-pin;
		if(PINL&(1<<pin))	return true;							//break function
     a8c:	20 91 09 01 	lds	r18, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
     a90:	30 e0       	ldi	r19, 0x00	; 0
     a92:	41 e3       	ldi	r20, 0x31	; 49
     a94:	50 e0       	ldi	r21, 0x00	; 0
     a96:	ba 01       	movw	r22, r20
     a98:	68 1b       	sub	r22, r24
     a9a:	79 0b       	sbc	r23, r25
     a9c:	a9 01       	movw	r20, r18
     a9e:	02 c0       	rjmp	.+4      	; 0xaa4 <_Z11digitalReadi+0xac>
     aa0:	55 95       	asr	r21
     aa2:	47 95       	ror	r20
     aa4:	6a 95       	dec	r22
     aa6:	e2 f7       	brpl	.-8      	; 0xaa0 <_Z11digitalReadi+0xa8>
     aa8:	ca 01       	movw	r24, r20
     aaa:	81 70       	andi	r24, 0x01	; 1
     aac:	1e c0       	rjmp	.+60     	; 0xaea <_Z11digitalReadi+0xf2>
	}
	else if(pin<54){
     aae:	86 33       	cpi	r24, 0x36	; 54
     ab0:	91 05       	cpc	r25, r1
     ab2:	84 f4       	brge	.+32     	; 0xad4 <_Z11digitalReadi+0xdc>
		pin=(53-pin);
		if(PINB&(1<<pin))	return true;							//break function
     ab4:	23 b1       	in	r18, 0x03	; 3
     ab6:	30 e0       	ldi	r19, 0x00	; 0
     ab8:	45 e3       	ldi	r20, 0x35	; 53
     aba:	50 e0       	ldi	r21, 0x00	; 0
     abc:	ba 01       	movw	r22, r20
     abe:	68 1b       	sub	r22, r24
     ac0:	79 0b       	sbc	r23, r25
     ac2:	a9 01       	movw	r20, r18
     ac4:	02 c0       	rjmp	.+4      	; 0xaca <_Z11digitalReadi+0xd2>
     ac6:	55 95       	asr	r21
     ac8:	47 95       	ror	r20
     aca:	6a 95       	dec	r22
     acc:	e2 f7       	brpl	.-8      	; 0xac6 <_Z11digitalReadi+0xce>
     ace:	ca 01       	movw	r24, r20
     ad0:	81 70       	andi	r24, 0x01	; 1
     ad2:	0b c0       	rjmp	.+22     	; 0xaea <_Z11digitalReadi+0xf2>
     ad4:	ec 01       	movw	r28, r24
	}
	else{					//pin unsupported
		Serial.print("ERROR: tried to read digital value from unsupported digital pin: ");
     ad6:	63 ea       	ldi	r22, 0xA3	; 163
     ad8:	72 e0       	ldi	r23, 0x02	; 2
     ada:	8a e8       	ldi	r24, 0x8A	; 138
     adc:	94 e0       	ldi	r25, 0x04	; 4
     ade:	9c d5       	rcall	.+2872   	; 0x1618 <_ZN5USART5printEPKc>
		Serial.println(pin);
     ae0:	be 01       	movw	r22, r28
     ae2:	8a e8       	ldi	r24, 0x8A	; 138
     ae4:	94 e0       	ldi	r25, 0x04	; 4
     ae6:	df d5       	rcall	.+3006   	; 0x16a6 <_ZN5USART7printlnEi>
		return false;
     ae8:	80 e0       	ldi	r24, 0x00	; 0
	}
	return false;	
}
     aea:	df 91       	pop	r29
     aec:	cf 91       	pop	r28
     aee:	08 95       	ret

00000af0 <_Z10analogReadi>:

int analogRead(int pin){
     af0:	cf 93       	push	r28
     af2:	df 93       	push	r29
	//set correct MUX registers, these determine on which pin the ADC should read it's value
	//first the MUXx bits are cleared, then filled to prevent old setting leaking though
	
	ADMUX &=(0b11100000);							//clear the bottom 4 bit
     af4:	ec e7       	ldi	r30, 0x7C	; 124
     af6:	f0 e0       	ldi	r31, 0x00	; 0
     af8:	20 81       	ld	r18, Z
     afa:	20 7e       	andi	r18, 0xE0	; 224
     afc:	20 83       	st	Z, r18
	ADCSRB &=(0b11110111);							//clear the top one bit
     afe:	eb e7       	ldi	r30, 0x7B	; 123
     b00:	f0 e0       	ldi	r31, 0x00	; 0
     b02:	20 81       	ld	r18, Z
     b04:	27 7f       	andi	r18, 0xF7	; 247
     b06:	20 83       	st	Z, r18
	if(pin<8)										//if adc #0-7
     b08:	88 30       	cpi	r24, 0x08	; 8
     b0a:	91 05       	cpc	r25, r1
     b0c:	34 f4       	brge	.+12     	; 0xb1a <_Z10analogReadi+0x2a>
	ADMUX |= pin;								//write the full pin to the ADMUX registry
     b0e:	ec e7       	ldi	r30, 0x7C	; 124
     b10:	f0 e0       	ldi	r31, 0x00	; 0
     b12:	90 81       	ld	r25, Z
     b14:	89 2b       	or	r24, r25
     b16:	80 83       	st	Z, r24
     b18:	1c c0       	rjmp	.+56     	; 0xb52 <_Z10analogReadi+0x62>
	else if(pin<16){									//if adc #8-15
     b1a:	80 31       	cpi	r24, 0x10	; 16
     b1c:	91 05       	cpc	r25, r1
     b1e:	64 f4       	brge	.+24     	; 0xb38 <_Z10analogReadi+0x48>
		ADCSRB |= (1<<3);							//write upper bit to ADCSRB register
     b20:	eb e7       	ldi	r30, 0x7B	; 123
     b22:	f0 e0       	ldi	r31, 0x00	; 0
     b24:	90 81       	ld	r25, Z
     b26:	98 60       	ori	r25, 0x08	; 8
     b28:	90 83       	st	Z, r25
		ADMUX |= (pin-8);							//write lower bits to ADMUX registry
     b2a:	ec e7       	ldi	r30, 0x7C	; 124
     b2c:	f0 e0       	ldi	r31, 0x00	; 0
     b2e:	90 81       	ld	r25, Z
     b30:	88 50       	subi	r24, 0x08	; 8
     b32:	89 2b       	or	r24, r25
     b34:	80 83       	st	Z, r24
     b36:	0d c0       	rjmp	.+26     	; 0xb52 <_Z10analogReadi+0x62>
     b38:	ec 01       	movw	r28, r24
	}
	else{
		Serial.print("ERROR: tried to read digital value from unsupported analog pin ");
     b3a:	65 ee       	ldi	r22, 0xE5	; 229
     b3c:	72 e0       	ldi	r23, 0x02	; 2
     b3e:	8a e8       	ldi	r24, 0x8A	; 138
     b40:	94 e0       	ldi	r25, 0x04	; 4
     b42:	6a d5       	rcall	.+2772   	; 0x1618 <_ZN5USART5printEPKc>
		Serial.println(pin);
     b44:	be 01       	movw	r22, r28
     b46:	8a e8       	ldi	r24, 0x8A	; 138
     b48:	94 e0       	ldi	r25, 0x04	; 4
     b4a:	ad d5       	rcall	.+2906   	; 0x16a6 <_ZN5USART7printlnEi>
		return 0;
     b4c:	80 e0       	ldi	r24, 0x00	; 0
     b4e:	90 e0       	ldi	r25, 0x00	; 0
     b50:	0c c0       	rjmp	.+24     	; 0xb6a <_Z10analogReadi+0x7a>
	}
	ADCSRA |= (1<<ADSC);							//start ADC conversion
     b52:	ea e7       	ldi	r30, 0x7A	; 122
     b54:	f0 e0       	ldi	r31, 0x00	; 0
     b56:	80 81       	ld	r24, Z
     b58:	80 64       	ori	r24, 0x40	; 64
     b5a:	80 83       	st	Z, r24
	while(ADCSRA & (1<<ADSC));						//wait until the ADSC is 0 again and the conversion is done
     b5c:	80 81       	ld	r24, Z
     b5e:	86 fd       	sbrc	r24, 6
     b60:	fd cf       	rjmp	.-6      	; 0xb5c <_Z10analogReadi+0x6c>
	return ADC;										//return the byte in ADLAR, the result of the ADC conversion
     b62:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
     b66:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
}
     b6a:	df 91       	pop	r29
     b6c:	cf 91       	pop	r28
     b6e:	08 95       	ret

00000b70 <_Z9printinfov>:
}

#ifdef DEBUG_MODE									//only spam terminal when in debug mode
void printinfo(){

	Serial.print("DM: ");
     b70:	65 e2       	ldi	r22, 0x25	; 37
     b72:	73 e0       	ldi	r23, 0x03	; 3
     b74:	8a e8       	ldi	r24, 0x8A	; 138
     b76:	94 e0       	ldi	r25, 0x04	; 4
     b78:	4f d5       	rcall	.+2718   	; 0x1618 <_ZN5USART5printEPKc>
	Serial.print(drivemode);
     b7a:	60 91 69 04 	lds	r22, 0x0469	; 0x800469 <drivemode>
     b7e:	70 91 6a 04 	lds	r23, 0x046A	; 0x80046a <drivemode+0x1>
     b82:	8a e8       	ldi	r24, 0x8A	; 138
     b84:	94 e0       	ldi	r25, 0x04	; 4
     b86:	6c d5       	rcall	.+2776   	; 0x1660 <_ZN5USART5printEi>
	Serial.print(" drive dir: ");
     b88:	6a e2       	ldi	r22, 0x2A	; 42
     b8a:	73 e0       	ldi	r23, 0x03	; 3
     b8c:	8a e8       	ldi	r24, 0x8A	; 138
     b8e:	94 e0       	ldi	r25, 0x04	; 4
     b90:	43 d5       	rcall	.+2694   	; 0x1618 <_ZN5USART5printEPKc>
	Serial.print(driving_direction);
     b92:	60 91 00 02 	lds	r22, 0x0200	; 0x800200 <__data_start>
     b96:	70 e0       	ldi	r23, 0x00	; 0
     b98:	8a e8       	ldi	r24, 0x8A	; 138
     b9a:	94 e0       	ldi	r25, 0x04	; 4
     b9c:	61 d5       	rcall	.+2754   	; 0x1660 <_ZN5USART5printEi>
	Serial.print(" engine_dv = ");
     b9e:	67 e3       	ldi	r22, 0x37	; 55
     ba0:	73 e0       	ldi	r23, 0x03	; 3
     ba2:	8a e8       	ldi	r24, 0x8A	; 138
     ba4:	94 e0       	ldi	r25, 0x04	; 4
     ba6:	38 d5       	rcall	.+2672   	; 0x1618 <_ZN5USART5printEPKc>
	Serial.print(engine_dv);
     ba8:	60 91 54 04 	lds	r22, 0x0454	; 0x800454 <engine_dv>
     bac:	70 91 55 04 	lds	r23, 0x0455	; 0x800455 <engine_dv+0x1>
     bb0:	8a e8       	ldi	r24, 0x8A	; 138
     bb2:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" speed. = ");
     bb4:	55 d5       	rcall	.+2730   	; 0x1660 <_ZN5USART5printEi>
     bb6:	65 e4       	ldi	r22, 0x45	; 69
     bb8:	73 e0       	ldi	r23, 0x03	; 3
     bba:	8a e8       	ldi	r24, 0x8A	; 138
     bbc:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(engine_cv);
     bbe:	2c d5       	rcall	.+2648   	; 0x1618 <_ZN5USART5printEPKc>
     bc0:	60 91 4c 04 	lds	r22, 0x044C	; 0x80044c <engine_cv>
     bc4:	70 91 4d 04 	lds	r23, 0x044D	; 0x80044d <engine_cv+0x1>
     bc8:	8a e8       	ldi	r24, 0x8A	; 138
     bca:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" engine_ov = ");
     bcc:	49 d5       	rcall	.+2706   	; 0x1660 <_ZN5USART5printEi>
     bce:	60 e5       	ldi	r22, 0x50	; 80
     bd0:	73 e0       	ldi	r23, 0x03	; 3
     bd2:	8a e8       	ldi	r24, 0x8A	; 138
     bd4:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(engine_ov);
     bd6:	20 d5       	rcall	.+2624   	; 0x1618 <_ZN5USART5printEPKc>
     bd8:	60 91 4b 04 	lds	r22, 0x044B	; 0x80044b <engine_ov>
     bdc:	70 e0       	ldi	r23, 0x00	; 0
     bde:	8a e8       	ldi	r24, 0x8A	; 138
     be0:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" brake_dv = ");
     be2:	3e d5       	rcall	.+2684   	; 0x1660 <_ZN5USART5printEi>
     be4:	6e e5       	ldi	r22, 0x5E	; 94
     be6:	73 e0       	ldi	r23, 0x03	; 3
     be8:	8a e8       	ldi	r24, 0x8A	; 138
     bea:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(braking_dv);
     bec:	15 d5       	rcall	.+2602   	; 0x1618 <_ZN5USART5printEPKc>
     bee:	60 91 47 04 	lds	r22, 0x0447	; 0x800447 <braking_dv>
     bf2:	70 91 48 04 	lds	r23, 0x0448	; 0x800448 <braking_dv+0x1>
     bf6:	8a e8       	ldi	r24, 0x8A	; 138
	Serial.print(" braking_ov = ");
     bf8:	94 e0       	ldi	r25, 0x04	; 4
     bfa:	32 d5       	rcall	.+2660   	; 0x1660 <_ZN5USART5printEi>
     bfc:	6b e6       	ldi	r22, 0x6B	; 107
     bfe:	73 e0       	ldi	r23, 0x03	; 3
     c00:	8a e8       	ldi	r24, 0x8A	; 138
	Serial.print(braking_ov);
     c02:	94 e0       	ldi	r25, 0x04	; 4
     c04:	09 d5       	rcall	.+2578   	; 0x1618 <_ZN5USART5printEPKc>
     c06:	60 91 3e 04 	lds	r22, 0x043E	; 0x80043e <braking_ov>
     c0a:	70 e0       	ldi	r23, 0x00	; 0
     c0c:	8a e8       	ldi	r24, 0x8A	; 138

	Serial.print(" steering_dv = ");
     c0e:	94 e0       	ldi	r25, 0x04	; 4
     c10:	27 d5       	rcall	.+2638   	; 0x1660 <_ZN5USART5printEi>
     c12:	6a e7       	ldi	r22, 0x7A	; 122
     c14:	73 e0       	ldi	r23, 0x03	; 3
     c16:	8a e8       	ldi	r24, 0x8A	; 138
	Serial.print(steering_dv);
     c18:	94 e0       	ldi	r25, 0x04	; 4
     c1a:	fe d4       	rcall	.+2556   	; 0x1618 <_ZN5USART5printEPKc>
     c1c:	60 91 61 04 	lds	r22, 0x0461	; 0x800461 <steering_dv>
     c20:	70 91 62 04 	lds	r23, 0x0462	; 0x800462 <steering_dv+0x1>
     c24:	8a e8       	ldi	r24, 0x8A	; 138
	Serial.print(" steering_cv = ");
     c26:	94 e0       	ldi	r25, 0x04	; 4
     c28:	1b d5       	rcall	.+2614   	; 0x1660 <_ZN5USART5printEi>
     c2a:	6a e8       	ldi	r22, 0x8A	; 138
     c2c:	73 e0       	ldi	r23, 0x03	; 3
     c2e:	8a e8       	ldi	r24, 0x8A	; 138
	Serial.print(steering_cv);
     c30:	94 e0       	ldi	r25, 0x04	; 4
     c32:	f2 d4       	rcall	.+2532   	; 0x1618 <_ZN5USART5printEPKc>
     c34:	60 91 59 04 	lds	r22, 0x0459	; 0x800459 <steering_cv>
     c38:	70 91 5a 04 	lds	r23, 0x045A	; 0x80045a <steering_cv+0x1>
	Serial.print(" steering_ov = ");
     c3c:	8a e8       	ldi	r24, 0x8A	; 138
     c3e:	94 e0       	ldi	r25, 0x04	; 4
     c40:	0f d5       	rcall	.+2590   	; 0x1660 <_ZN5USART5printEi>
     c42:	6a e9       	ldi	r22, 0x9A	; 154
     c44:	73 e0       	ldi	r23, 0x03	; 3
	Serial.print(steering_ov);
     c46:	8a e8       	ldi	r24, 0x8A	; 138
     c48:	94 e0       	ldi	r25, 0x04	; 4
     c4a:	e6 d4       	rcall	.+2508   	; 0x1618 <_ZN5USART5printEPKc>
     c4c:	60 91 58 04 	lds	r22, 0x0458	; 0x800458 <steering_ov>
     c50:	70 e0       	ldi	r23, 0x00	; 0
	Serial.print(" delta = ");
     c52:	8a e8       	ldi	r24, 0x8A	; 138
     c54:	94 e0       	ldi	r25, 0x04	; 4
     c56:	04 d5       	rcall	.+2568   	; 0x1660 <_ZN5USART5printEi>
     c58:	6a ea       	ldi	r22, 0xAA	; 170
     c5a:	73 e0       	ldi	r23, 0x03	; 3
	Serial.print(steering_delta);
     c5c:	8a e8       	ldi	r24, 0x8A	; 138
     c5e:	94 e0       	ldi	r25, 0x04	; 4
     c60:	db d4       	rcall	.+2486   	; 0x1618 <_ZN5USART5printEPKc>
     c62:	60 91 5d 04 	lds	r22, 0x045D	; 0x80045d <steering_delta>
     c66:	70 91 5e 04 	lds	r23, 0x045E	; 0x80045e <steering_delta+0x1>
	Serial.print(" low volt = ");
     c6a:	8a e8       	ldi	r24, 0x8A	; 138
     c6c:	94 e0       	ldi	r25, 0x04	; 4
     c6e:	f8 d4       	rcall	.+2544   	; 0x1660 <_ZN5USART5printEi>
     c70:	64 eb       	ldi	r22, 0xB4	; 180
     c72:	73 e0       	ldi	r23, 0x03	; 3
	Serial.print(low_voltage);
     c74:	8a e8       	ldi	r24, 0x8A	; 138
     c76:	94 e0       	ldi	r25, 0x04	; 4
     c78:	cf d4       	rcall	.+2462   	; 0x1618 <_ZN5USART5printEPKc>
     c7a:	60 91 3c 04 	lds	r22, 0x043C	; 0x80043c <low_voltage>
     c7e:	70 91 3d 04 	lds	r23, 0x043D	; 0x80043d <low_voltage+0x1>
	Serial.print(" high volt = ");
     c82:	8a e8       	ldi	r24, 0x8A	; 138
     c84:	94 e0       	ldi	r25, 0x04	; 4
     c86:	ec d4       	rcall	.+2520   	; 0x1660 <_ZN5USART5printEi>
     c88:	61 ec       	ldi	r22, 0xC1	; 193
     c8a:	73 e0       	ldi	r23, 0x03	; 3
	Serial.print(high_voltage);
     c8c:	8a e8       	ldi	r24, 0x8A	; 138
     c8e:	94 e0       	ldi	r25, 0x04	; 4
     c90:	c3 d4       	rcall	.+2438   	; 0x1618 <_ZN5USART5printEPKc>
     c92:	60 91 34 04 	lds	r22, 0x0434	; 0x800434 <__data_end>
     c96:	70 91 35 04 	lds	r23, 0x0435	; 0x800435 <__data_end+0x1>
	Serial.print(" rpm = ");
     c9a:	8a e8       	ldi	r24, 0x8A	; 138
     c9c:	94 e0       	ldi	r25, 0x04	; 4
     c9e:	e0 d4       	rcall	.+2496   	; 0x1660 <_ZN5USART5printEi>
     ca0:	6f ec       	ldi	r22, 0xCF	; 207
     ca2:	73 e0       	ldi	r23, 0x03	; 3
     ca4:	8a e8       	ldi	r24, 0x8A	; 138
	Serial.print(engine_rpm);
     ca6:	94 e0       	ldi	r25, 0x04	; 4
     ca8:	b7 d4       	rcall	.+2414   	; 0x1618 <_ZN5USART5printEPKc>
     caa:	60 91 3a 04 	lds	r22, 0x043A	; 0x80043a <engine_rpm>
     cae:	70 91 3b 04 	lds	r23, 0x043B	; 0x80043b <engine_rpm+0x1>
     cb2:	8a e8       	ldi	r24, 0x8A	; 138
     cb4:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" temp = ");
     cb6:	d4 d4       	rcall	.+2472   	; 0x1660 <_ZN5USART5printEi>
     cb8:	67 ed       	ldi	r22, 0xD7	; 215
     cba:	73 e0       	ldi	r23, 0x03	; 3
     cbc:	8a e8       	ldi	r24, 0x8A	; 138
     cbe:	94 e0       	ldi	r25, 0x04	; 4
     cc0:	ab d4       	rcall	.+2390   	; 0x1618 <_ZN5USART5printEPKc>
	Serial.println(engine_temp);
     cc2:	60 91 38 04 	lds	r22, 0x0438	; 0x800438 <engine_temp>
     cc6:	70 91 39 04 	lds	r23, 0x0439	; 0x800439 <engine_temp+0x1>
     cca:	8a e8       	ldi	r24, 0x8A	; 138
     ccc:	94 e0       	ldi	r25, 0x04	; 4
     cce:	eb c4       	rjmp	.+2518   	; 0x16a6 <_ZN5USART7printlnEi>
     cd0:	08 95       	ret

00000cd2 <_Z13updateCurtissv>:
     cd2:	2b e6       	ldi	r18, 0x6B	; 107
}
#endif

void updateCurtiss(){
	CAN_Curt.readMsgBuf(&rxId_Curt, &len_Curt, rxBuf_Curt);	// Read data: len = data length, buf = data byte(s)
     cd4:	34 e0       	ldi	r19, 0x04	; 4
     cd6:	43 e7       	ldi	r20, 0x73	; 115
     cd8:	54 e0       	ldi	r21, 0x04	; 4
     cda:	64 e7       	ldi	r22, 0x74	; 116
     cdc:	74 e0       	ldi	r23, 0x04	; 4
     cde:	88 e7       	ldi	r24, 0x78	; 120
     ce0:	94 e0       	ldi	r25, 0x04	; 4
     ce2:	0d d4       	rcall	.+2074   	; 0x14fe <_ZN7MCP_CAN10readMsgBufEPmPhS1_>
	if((rxId_Curt & 0x40000000) == 0x40000000)					//Ignore remote requests
     ce4:	80 91 74 04 	lds	r24, 0x0474	; 0x800474 <rxId_Curt>
     ce8:	90 91 75 04 	lds	r25, 0x0475	; 0x800475 <rxId_Curt+0x1>
     cec:	a0 91 76 04 	lds	r26, 0x0476	; 0x800476 <rxId_Curt+0x2>
     cf0:	b0 91 77 04 	lds	r27, 0x0477	; 0x800477 <rxId_Curt+0x3>
     cf4:	b6 fd       	sbrc	r27, 6
     cf6:	36 c0       	rjmp	.+108    	; 0xd64 <_Z13updateCurtissv+0x92>
		return;	
	low_voltage = rxBuf_Curt[0] + (rxBuf_Curt[1] * 256);
     cf8:	eb e6       	ldi	r30, 0x6B	; 107
     cfa:	f4 e0       	ldi	r31, 0x04	; 4
     cfc:	81 81       	ldd	r24, Z+1	; 0x01
     cfe:	90 e0       	ldi	r25, 0x00	; 0
     d00:	98 2f       	mov	r25, r24
     d02:	88 27       	eor	r24, r24
     d04:	20 81       	ld	r18, Z
     d06:	82 0f       	add	r24, r18
     d08:	91 1d       	adc	r25, r1
     d0a:	90 93 3d 04 	sts	0x043D, r25	; 0x80043d <low_voltage+0x1>
     d0e:	80 93 3c 04 	sts	0x043C, r24	; 0x80043c <low_voltage>
	engine_rpm = rxBuf_Curt[2] + (rxBuf_Curt[3] * 256);
     d12:	83 81       	ldd	r24, Z+3	; 0x03
     d14:	90 e0       	ldi	r25, 0x00	; 0
     d16:	98 2f       	mov	r25, r24
     d18:	88 27       	eor	r24, r24
     d1a:	22 81       	ldd	r18, Z+2	; 0x02
     d1c:	82 0f       	add	r24, r18
     d1e:	91 1d       	adc	r25, r1
     d20:	90 93 3b 04 	sts	0x043B, r25	; 0x80043b <engine_rpm+0x1>
     d24:	80 93 3a 04 	sts	0x043A, r24	; 0x80043a <engine_rpm>
	engine_temp = rxBuf_Curt[4] + (rxBuf_Curt[5] * 256);
     d28:	85 81       	ldd	r24, Z+5	; 0x05
     d2a:	90 e0       	ldi	r25, 0x00	; 0
     d2c:	98 2f       	mov	r25, r24
     d2e:	88 27       	eor	r24, r24
     d30:	24 81       	ldd	r18, Z+4	; 0x04
     d32:	82 0f       	add	r24, r18
     d34:	91 1d       	adc	r25, r1
     d36:	90 93 39 04 	sts	0x0439, r25	; 0x800439 <engine_temp+0x1>
     d3a:	80 93 38 04 	sts	0x0438, r24	; 0x800438 <engine_temp>
	control_temp = rxBuf_Curt[6] + (rxBuf_Curt[7] * 256);
     d3e:	87 81       	ldd	r24, Z+7	; 0x07
     d40:	90 e0       	ldi	r25, 0x00	; 0
     d42:	98 2f       	mov	r25, r24
     d44:	88 27       	eor	r24, r24
     d46:	26 81       	ldd	r18, Z+6	; 0x06
     d48:	ac 01       	movw	r20, r24
     d4a:	42 0f       	add	r20, r18
     d4c:	51 1d       	adc	r21, r1
     d4e:	50 93 37 04 	sts	0x0437, r21	; 0x800437 <control_temp+0x1>
     d52:	40 93 36 04 	sts	0x0436, r20	; 0x800436 <control_temp>
	high_voltage = rxBuf_Curt[8] + (rxBuf_Curt[7] * 256);	
     d56:	20 85       	ldd	r18, Z+8	; 0x08
     d58:	82 0f       	add	r24, r18
     d5a:	91 1d       	adc	r25, r1
     d5c:	90 93 35 04 	sts	0x0435, r25	; 0x800435 <__data_end+0x1>
     d60:	80 93 34 04 	sts	0x0434, r24	; 0x800434 <__data_end>
     d64:	08 95       	ret

00000d66 <main>:
unsigned char len_Curt;
unsigned char rxBuf_Curt[8];
char msgString_Curt[128]; 

int main(void){
	Serial.println("Alley Hoop V2.1");
     d66:	60 ee       	ldi	r22, 0xE0	; 224
     d68:	73 e0       	ldi	r23, 0x03	; 3
     d6a:	8a e8       	ldi	r24, 0x8A	; 138
     d6c:	94 e0       	ldi	r25, 0x04	; 4
     d6e:	6d d4       	rcall	.+2266   	; 0x164a <_ZN5USART7printlnEPKc>
	initIO();															//initializes the IO pins
     d70:	99 dc       	rcall	.-1742   	; 0x6a4 <_Z6initIOv>
	initDrive();														//detect steering modus
     d72:	1e da       	rcall	.-3012   	; 0x1b0 <_Z9initDrivev>
     d74:	21 e0       	ldi	r18, 0x01	; 1

	if(CAN_Curt.begin(MCP_ANY, CAN_500KBPS, MCP_16MHZ) == CAN_OK)		//initialize the CAN BUS
     d76:	4d e0       	ldi	r20, 0x0D	; 13
     d78:	63 e0       	ldi	r22, 0x03	; 3
     d7a:	88 e7       	ldi	r24, 0x78	; 120
     d7c:	94 e0       	ldi	r25, 0x04	; 4
     d7e:	85 d3       	rcall	.+1802   	; 0x148a <_ZN7MCP_CAN5beginEhhh>
     d80:	81 11       	cpse	r24, r1
     d82:	06 c0       	rjmp	.+12     	; 0xd90 <main+0x2a>
     d84:	60 ef       	ldi	r22, 0xF0	; 240
		Serial.println("MCP2515 Initialized Successfully!");
     d86:	73 e0       	ldi	r23, 0x03	; 3
     d88:	8a e8       	ldi	r24, 0x8A	; 138
     d8a:	94 e0       	ldi	r25, 0x04	; 4
     d8c:	5e d4       	rcall	.+2236   	; 0x164a <_ZN5USART7printlnEPKc>
     d8e:	05 c0       	rjmp	.+10     	; 0xd9a <main+0x34>
     d90:	62 e1       	ldi	r22, 0x12	; 18
	else
		Serial.println("Error Initializing MCP2515...");
     d92:	74 e0       	ldi	r23, 0x04	; 4
     d94:	8a e8       	ldi	r24, 0x8A	; 138
     d96:	94 e0       	ldi	r25, 0x04	; 4
     d98:	58 d4       	rcall	.+2224   	; 0x164a <_ZN5USART7printlnEPKc>
	CAN_Curt.setMode(MCP_NORMAL);										// Set operation mode to normal so the MCP2515 sends acks to received data.
     d9a:	60 e0       	ldi	r22, 0x00	; 0
     d9c:	88 e7       	ldi	r24, 0x78	; 120
     d9e:	94 e0       	ldi	r25, 0x04	; 4
     da0:	d5 d1       	rcall	.+938    	; 0x114c <_ZN7MCP_CAN7setModeEh>

	while (1){				//main program loop	
		updateCurtiss();		//update the values retrieved from the Curtis
     da2:	97 df       	rcall	.-210    	; 0xcd2 <_Z13updateCurtissv>
     da4:	62 dc       	rcall	.-1852   	; 0x66a <_Z5drivev>
		drive();				//update the values send to various components
     da6:	e4 de       	rcall	.-568    	; 0xb70 <_Z9printinfov>
     da8:	fc cf       	rjmp	.-8      	; 0xda2 <main+0x3c>

00000daa <_GLOBAL__sub_I_Serial>:
		#ifdef DEBUG_MODE
			printinfo();			//print info in the terminal, only when debug mode is enabled
     daa:	8a e8       	ldi	r24, 0x8A	; 138
     dac:	94 e0       	ldi	r25, 0x04	; 4
     dae:	29 d4       	rcall	.+2130   	; 0x1602 <_ZN5USARTC1Ev>
#include <util/delay.h>		//allows usage of _delay_ms()
#include "overhead.h"		//defines and standard includes
#include "Drive.h"			//takes care of driving the car

USART Serial;				//global Serial
MCP_CAN CAN_Curt(47);		//the Curtiss CAN BUS
     db0:	6f e2       	ldi	r22, 0x2F	; 47
     db2:	88 e7       	ldi	r24, 0x78	; 120
     db4:	94 e0       	ldi	r25, 0x04	; 4
     db6:	5c c3       	rjmp	.+1720   	; 0x1470 <_ZN7MCP_CANC1Eh>
     db8:	08 95       	ret

00000dba <_ZN7MCP_CAN13mcp2515_resetEv>:
		tbufdata[MCP_EID0] = 0;
		tbufdata[MCP_EID8] = 0;
	}

	mcp2515_setRegisterS( mcp_addr, tbufdata, 4 );
}
     dba:	0f 93       	push	r16
     dbc:	1f 93       	push	r17
     dbe:	cf 93       	push	r28
     dc0:	df 93       	push	r29
     dc2:	1f 92       	push	r1
     dc4:	1f 92       	push	r1
     dc6:	cd b7       	in	r28, 0x3d	; 61
     dc8:	de b7       	in	r29, 0x3e	; 62
     dca:	00 e0       	ldi	r16, 0x00	; 0
     dcc:	21 e0       	ldi	r18, 0x01	; 1
     dce:	40 e8       	ldi	r20, 0x80	; 128
     dd0:	56 e9       	ldi	r21, 0x96	; 150
     dd2:	68 e9       	ldi	r22, 0x98	; 152
     dd4:	70 e0       	ldi	r23, 0x00	; 0
     dd6:	ce 01       	movw	r24, r28
     dd8:	01 96       	adiw	r24, 0x01	; 1
     dda:	e3 d3       	rcall	.+1990   	; 0x15a2 <_ZN11SPISettingsC1Emhh>
     ddc:	be 01       	movw	r22, r28
     dde:	6f 5f       	subi	r22, 0xFF	; 255
     de0:	7f 4f       	sbci	r23, 0xFF	; 255
     de2:	8c e8       	ldi	r24, 0x8C	; 140
     de4:	94 e0       	ldi	r25, 0x04	; 4
     de6:	01 d4       	rcall	.+2050   	; 0x15ea <_ZN8SPIClass16beginTransactionE11SPISettings>
     de8:	0b e0       	ldi	r16, 0x0B	; 11
     dea:	11 e0       	ldi	r17, 0x01	; 1
     dec:	f8 01       	movw	r30, r16
     dee:	80 81       	ld	r24, Z
     df0:	8b 7f       	andi	r24, 0xFB	; 251
     df2:	80 83       	st	Z, r24
     df4:	60 ec       	ldi	r22, 0xC0	; 192
     df6:	8c e8       	ldi	r24, 0x8C	; 140
     df8:	94 e0       	ldi	r25, 0x04	; 4
     dfa:	fd d3       	rcall	.+2042   	; 0x15f6 <_ZN8SPIClass8transferEh>
     dfc:	f8 01       	movw	r30, r16
     dfe:	80 81       	ld	r24, Z
     e00:	84 60       	ori	r24, 0x04	; 4
     e02:	80 83       	st	Z, r24
     e04:	83 ec       	ldi	r24, 0xC3	; 195
     e06:	99 e0       	ldi	r25, 0x09	; 9
     e08:	01 97       	sbiw	r24, 0x01	; 1
     e0a:	f1 f7       	brne	.-4      	; 0xe08 <_ZN7MCP_CAN13mcp2515_resetEv+0x4e>
     e0c:	00 c0       	rjmp	.+0      	; 0xe0e <_ZN7MCP_CAN13mcp2515_resetEv+0x54>
     e0e:	00 00       	nop
     e10:	0f 90       	pop	r0
     e12:	0f 90       	pop	r0
     e14:	df 91       	pop	r29
     e16:	cf 91       	pop	r28
     e18:	1f 91       	pop	r17
     e1a:	0f 91       	pop	r16
     e1c:	08 95       	ret

00000e1e <_ZN7MCP_CAN20mcp2515_readRegisterEh>:
     e1e:	ff 92       	push	r15
     e20:	0f 93       	push	r16
     e22:	1f 93       	push	r17
     e24:	cf 93       	push	r28
     e26:	df 93       	push	r29
     e28:	1f 92       	push	r1
     e2a:	1f 92       	push	r1
     e2c:	cd b7       	in	r28, 0x3d	; 61
     e2e:	de b7       	in	r29, 0x3e	; 62
     e30:	f6 2e       	mov	r15, r22
     e32:	00 e0       	ldi	r16, 0x00	; 0
     e34:	21 e0       	ldi	r18, 0x01	; 1
     e36:	40 e8       	ldi	r20, 0x80	; 128
     e38:	56 e9       	ldi	r21, 0x96	; 150
     e3a:	68 e9       	ldi	r22, 0x98	; 152
     e3c:	70 e0       	ldi	r23, 0x00	; 0
     e3e:	ce 01       	movw	r24, r28
     e40:	01 96       	adiw	r24, 0x01	; 1
     e42:	af d3       	rcall	.+1886   	; 0x15a2 <_ZN11SPISettingsC1Emhh>
     e44:	be 01       	movw	r22, r28
     e46:	6f 5f       	subi	r22, 0xFF	; 255
     e48:	7f 4f       	sbci	r23, 0xFF	; 255
     e4a:	8c e8       	ldi	r24, 0x8C	; 140
     e4c:	94 e0       	ldi	r25, 0x04	; 4
     e4e:	cd d3       	rcall	.+1946   	; 0x15ea <_ZN8SPIClass16beginTransactionE11SPISettings>
     e50:	0b e0       	ldi	r16, 0x0B	; 11
     e52:	11 e0       	ldi	r17, 0x01	; 1
     e54:	f8 01       	movw	r30, r16
     e56:	80 81       	ld	r24, Z
     e58:	8b 7f       	andi	r24, 0xFB	; 251
     e5a:	80 83       	st	Z, r24
     e5c:	63 e0       	ldi	r22, 0x03	; 3
     e5e:	8c e8       	ldi	r24, 0x8C	; 140
     e60:	94 e0       	ldi	r25, 0x04	; 4
     e62:	c9 d3       	rcall	.+1938   	; 0x15f6 <_ZN8SPIClass8transferEh>
     e64:	6f 2d       	mov	r22, r15
     e66:	8c e8       	ldi	r24, 0x8C	; 140
     e68:	94 e0       	ldi	r25, 0x04	; 4
     e6a:	c5 d3       	rcall	.+1930   	; 0x15f6 <_ZN8SPIClass8transferEh>
     e6c:	60 e0       	ldi	r22, 0x00	; 0
     e6e:	8c e8       	ldi	r24, 0x8C	; 140
     e70:	94 e0       	ldi	r25, 0x04	; 4
     e72:	c1 d3       	rcall	.+1922   	; 0x15f6 <_ZN8SPIClass8transferEh>
     e74:	f8 01       	movw	r30, r16
     e76:	90 81       	ld	r25, Z
     e78:	94 60       	ori	r25, 0x04	; 4
     e7a:	90 83       	st	Z, r25
     e7c:	0f 90       	pop	r0
     e7e:	0f 90       	pop	r0
     e80:	df 91       	pop	r29
     e82:	cf 91       	pop	r28
     e84:	1f 91       	pop	r17
     e86:	0f 91       	pop	r16
     e88:	ff 90       	pop	r15
     e8a:	08 95       	ret

00000e8c <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh>:
     e8c:	cf 92       	push	r12
     e8e:	df 92       	push	r13
     e90:	ef 92       	push	r14
     e92:	ff 92       	push	r15
     e94:	0f 93       	push	r16
     e96:	1f 93       	push	r17
     e98:	cf 93       	push	r28
     e9a:	df 93       	push	r29
     e9c:	1f 92       	push	r1
     e9e:	1f 92       	push	r1
     ea0:	cd b7       	in	r28, 0x3d	; 61
     ea2:	de b7       	in	r29, 0x3e	; 62
     ea4:	16 2f       	mov	r17, r22
     ea6:	6a 01       	movw	r12, r20
     ea8:	f2 2e       	mov	r15, r18
     eaa:	00 e0       	ldi	r16, 0x00	; 0
     eac:	21 e0       	ldi	r18, 0x01	; 1
     eae:	40 e8       	ldi	r20, 0x80	; 128
     eb0:	56 e9       	ldi	r21, 0x96	; 150
     eb2:	68 e9       	ldi	r22, 0x98	; 152
     eb4:	70 e0       	ldi	r23, 0x00	; 0
     eb6:	ce 01       	movw	r24, r28
     eb8:	01 96       	adiw	r24, 0x01	; 1
     eba:	73 d3       	rcall	.+1766   	; 0x15a2 <_ZN11SPISettingsC1Emhh>
     ebc:	be 01       	movw	r22, r28
     ebe:	6f 5f       	subi	r22, 0xFF	; 255
     ec0:	7f 4f       	sbci	r23, 0xFF	; 255
     ec2:	8c e8       	ldi	r24, 0x8C	; 140
     ec4:	94 e0       	ldi	r25, 0x04	; 4
     ec6:	91 d3       	rcall	.+1826   	; 0x15ea <_ZN8SPIClass16beginTransactionE11SPISettings>
     ec8:	eb e0       	ldi	r30, 0x0B	; 11
     eca:	f1 e0       	ldi	r31, 0x01	; 1
     ecc:	80 81       	ld	r24, Z
     ece:	8b 7f       	andi	r24, 0xFB	; 251
     ed0:	80 83       	st	Z, r24
     ed2:	63 e0       	ldi	r22, 0x03	; 3
     ed4:	8c e8       	ldi	r24, 0x8C	; 140
     ed6:	94 e0       	ldi	r25, 0x04	; 4
     ed8:	8e d3       	rcall	.+1820   	; 0x15f6 <_ZN8SPIClass8transferEh>
     eda:	61 2f       	mov	r22, r17
     edc:	8c e8       	ldi	r24, 0x8C	; 140
     ede:	94 e0       	ldi	r25, 0x04	; 4
     ee0:	8a d3       	rcall	.+1812   	; 0x15f6 <_ZN8SPIClass8transferEh>
     ee2:	ff 20       	and	r15, r15
     ee4:	99 f0       	breq	.+38     	; 0xf0c <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh+0x80>
     ee6:	86 01       	movw	r16, r12
     ee8:	fa 94       	dec	r15
     eea:	ef 2c       	mov	r14, r15
     eec:	f1 2c       	mov	r15, r1
     eee:	8f ef       	ldi	r24, 0xFF	; 255
     ef0:	e8 1a       	sub	r14, r24
     ef2:	f8 0a       	sbc	r15, r24
     ef4:	ec 0c       	add	r14, r12
     ef6:	fd 1c       	adc	r15, r13
     ef8:	60 e0       	ldi	r22, 0x00	; 0
     efa:	8c e8       	ldi	r24, 0x8C	; 140
     efc:	94 e0       	ldi	r25, 0x04	; 4
     efe:	7b d3       	rcall	.+1782   	; 0x15f6 <_ZN8SPIClass8transferEh>
     f00:	f8 01       	movw	r30, r16
     f02:	81 93       	st	Z+, r24
     f04:	8f 01       	movw	r16, r30
     f06:	ee 15       	cp	r30, r14
     f08:	ff 05       	cpc	r31, r15
     f0a:	b1 f7       	brne	.-20     	; 0xef8 <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh+0x6c>
     f0c:	eb e0       	ldi	r30, 0x0B	; 11
     f0e:	f1 e0       	ldi	r31, 0x01	; 1
     f10:	80 81       	ld	r24, Z
     f12:	84 60       	ori	r24, 0x04	; 4
     f14:	80 83       	st	Z, r24
     f16:	0f 90       	pop	r0
     f18:	0f 90       	pop	r0
     f1a:	df 91       	pop	r29
     f1c:	cf 91       	pop	r28
     f1e:	1f 91       	pop	r17
     f20:	0f 91       	pop	r16
     f22:	ff 90       	pop	r15
     f24:	ef 90       	pop	r14
     f26:	df 90       	pop	r13
     f28:	cf 90       	pop	r12
     f2a:	08 95       	ret

00000f2c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>:
     f2c:	ef 92       	push	r14
     f2e:	ff 92       	push	r15
     f30:	0f 93       	push	r16
     f32:	1f 93       	push	r17
     f34:	cf 93       	push	r28
     f36:	df 93       	push	r29
     f38:	1f 92       	push	r1
     f3a:	1f 92       	push	r1
     f3c:	cd b7       	in	r28, 0x3d	; 61
     f3e:	de b7       	in	r29, 0x3e	; 62
     f40:	e6 2e       	mov	r14, r22
     f42:	f4 2e       	mov	r15, r20
     f44:	00 e0       	ldi	r16, 0x00	; 0
     f46:	21 e0       	ldi	r18, 0x01	; 1
     f48:	40 e8       	ldi	r20, 0x80	; 128
     f4a:	56 e9       	ldi	r21, 0x96	; 150
     f4c:	68 e9       	ldi	r22, 0x98	; 152
     f4e:	70 e0       	ldi	r23, 0x00	; 0
     f50:	ce 01       	movw	r24, r28
     f52:	01 96       	adiw	r24, 0x01	; 1
     f54:	26 d3       	rcall	.+1612   	; 0x15a2 <_ZN11SPISettingsC1Emhh>
     f56:	be 01       	movw	r22, r28
     f58:	6f 5f       	subi	r22, 0xFF	; 255
     f5a:	7f 4f       	sbci	r23, 0xFF	; 255
     f5c:	8c e8       	ldi	r24, 0x8C	; 140
     f5e:	94 e0       	ldi	r25, 0x04	; 4
     f60:	44 d3       	rcall	.+1672   	; 0x15ea <_ZN8SPIClass16beginTransactionE11SPISettings>
     f62:	0b e0       	ldi	r16, 0x0B	; 11
     f64:	11 e0       	ldi	r17, 0x01	; 1
     f66:	f8 01       	movw	r30, r16
     f68:	80 81       	ld	r24, Z
     f6a:	8b 7f       	andi	r24, 0xFB	; 251
     f6c:	80 83       	st	Z, r24
     f6e:	62 e0       	ldi	r22, 0x02	; 2
     f70:	8c e8       	ldi	r24, 0x8C	; 140
     f72:	94 e0       	ldi	r25, 0x04	; 4
     f74:	40 d3       	rcall	.+1664   	; 0x15f6 <_ZN8SPIClass8transferEh>
     f76:	6e 2d       	mov	r22, r14
     f78:	8c e8       	ldi	r24, 0x8C	; 140
     f7a:	94 e0       	ldi	r25, 0x04	; 4
     f7c:	3c d3       	rcall	.+1656   	; 0x15f6 <_ZN8SPIClass8transferEh>
     f7e:	6f 2d       	mov	r22, r15
     f80:	8c e8       	ldi	r24, 0x8C	; 140
     f82:	94 e0       	ldi	r25, 0x04	; 4
     f84:	38 d3       	rcall	.+1648   	; 0x15f6 <_ZN8SPIClass8transferEh>
     f86:	f8 01       	movw	r30, r16
     f88:	80 81       	ld	r24, Z
     f8a:	84 60       	ori	r24, 0x04	; 4
     f8c:	80 83       	st	Z, r24
     f8e:	0f 90       	pop	r0
     f90:	0f 90       	pop	r0
     f92:	df 91       	pop	r29
     f94:	cf 91       	pop	r28
     f96:	1f 91       	pop	r17
     f98:	0f 91       	pop	r16
     f9a:	ff 90       	pop	r15
     f9c:	ef 90       	pop	r14
     f9e:	08 95       	ret

00000fa0 <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh>:
     fa0:	cf 92       	push	r12
     fa2:	df 92       	push	r13
     fa4:	ef 92       	push	r14
     fa6:	ff 92       	push	r15
     fa8:	0f 93       	push	r16
     faa:	1f 93       	push	r17
     fac:	cf 93       	push	r28
     fae:	df 93       	push	r29
     fb0:	1f 92       	push	r1
     fb2:	1f 92       	push	r1
     fb4:	cd b7       	in	r28, 0x3d	; 61
     fb6:	de b7       	in	r29, 0x3e	; 62
     fb8:	16 2f       	mov	r17, r22
     fba:	6a 01       	movw	r12, r20
     fbc:	f2 2e       	mov	r15, r18
     fbe:	00 e0       	ldi	r16, 0x00	; 0
     fc0:	21 e0       	ldi	r18, 0x01	; 1
     fc2:	40 e8       	ldi	r20, 0x80	; 128
     fc4:	56 e9       	ldi	r21, 0x96	; 150
     fc6:	68 e9       	ldi	r22, 0x98	; 152
     fc8:	70 e0       	ldi	r23, 0x00	; 0
     fca:	ce 01       	movw	r24, r28
     fcc:	01 96       	adiw	r24, 0x01	; 1
     fce:	e9 d2       	rcall	.+1490   	; 0x15a2 <_ZN11SPISettingsC1Emhh>
     fd0:	be 01       	movw	r22, r28
     fd2:	6f 5f       	subi	r22, 0xFF	; 255
     fd4:	7f 4f       	sbci	r23, 0xFF	; 255
     fd6:	8c e8       	ldi	r24, 0x8C	; 140
     fd8:	94 e0       	ldi	r25, 0x04	; 4
     fda:	07 d3       	rcall	.+1550   	; 0x15ea <_ZN8SPIClass16beginTransactionE11SPISettings>
     fdc:	eb e0       	ldi	r30, 0x0B	; 11
     fde:	f1 e0       	ldi	r31, 0x01	; 1
     fe0:	80 81       	ld	r24, Z
     fe2:	8b 7f       	andi	r24, 0xFB	; 251
     fe4:	80 83       	st	Z, r24
     fe6:	62 e0       	ldi	r22, 0x02	; 2
     fe8:	8c e8       	ldi	r24, 0x8C	; 140
     fea:	94 e0       	ldi	r25, 0x04	; 4
     fec:	04 d3       	rcall	.+1544   	; 0x15f6 <_ZN8SPIClass8transferEh>
     fee:	61 2f       	mov	r22, r17
     ff0:	8c e8       	ldi	r24, 0x8C	; 140
     ff2:	94 e0       	ldi	r25, 0x04	; 4
     ff4:	00 d3       	rcall	.+1536   	; 0x15f6 <_ZN8SPIClass8transferEh>
     ff6:	ff 20       	and	r15, r15
     ff8:	91 f0       	breq	.+36     	; 0x101e <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh+0x7e>
     ffa:	86 01       	movw	r16, r12
     ffc:	fa 94       	dec	r15
     ffe:	ef 2c       	mov	r14, r15
    1000:	f1 2c       	mov	r15, r1
    1002:	8f ef       	ldi	r24, 0xFF	; 255
    1004:	e8 1a       	sub	r14, r24
    1006:	f8 0a       	sbc	r15, r24
    1008:	ec 0c       	add	r14, r12
    100a:	fd 1c       	adc	r15, r13
    100c:	f8 01       	movw	r30, r16
    100e:	61 91       	ld	r22, Z+
    1010:	8f 01       	movw	r16, r30
    1012:	8c e8       	ldi	r24, 0x8C	; 140
    1014:	94 e0       	ldi	r25, 0x04	; 4
    1016:	ef d2       	rcall	.+1502   	; 0x15f6 <_ZN8SPIClass8transferEh>
    1018:	0e 15       	cp	r16, r14
    101a:	1f 05       	cpc	r17, r15
    101c:	b9 f7       	brne	.-18     	; 0x100c <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh+0x6c>
    101e:	eb e0       	ldi	r30, 0x0B	; 11
    1020:	f1 e0       	ldi	r31, 0x01	; 1
    1022:	80 81       	ld	r24, Z
    1024:	84 60       	ori	r24, 0x04	; 4
    1026:	80 83       	st	Z, r24
    1028:	0f 90       	pop	r0
    102a:	0f 90       	pop	r0
    102c:	df 91       	pop	r29
    102e:	cf 91       	pop	r28
    1030:	1f 91       	pop	r17
    1032:	0f 91       	pop	r16
    1034:	ff 90       	pop	r15
    1036:	ef 90       	pop	r14
    1038:	df 90       	pop	r13
    103a:	cf 90       	pop	r12
    103c:	08 95       	ret

0000103e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>:
    103e:	df 92       	push	r13
    1040:	ef 92       	push	r14
    1042:	ff 92       	push	r15
    1044:	0f 93       	push	r16
    1046:	1f 93       	push	r17
    1048:	cf 93       	push	r28
    104a:	df 93       	push	r29
    104c:	1f 92       	push	r1
    104e:	1f 92       	push	r1
    1050:	cd b7       	in	r28, 0x3d	; 61
    1052:	de b7       	in	r29, 0x3e	; 62
    1054:	d6 2e       	mov	r13, r22
    1056:	e4 2e       	mov	r14, r20
    1058:	f2 2e       	mov	r15, r18
    105a:	00 e0       	ldi	r16, 0x00	; 0
    105c:	21 e0       	ldi	r18, 0x01	; 1
    105e:	40 e8       	ldi	r20, 0x80	; 128
    1060:	56 e9       	ldi	r21, 0x96	; 150
    1062:	68 e9       	ldi	r22, 0x98	; 152
    1064:	70 e0       	ldi	r23, 0x00	; 0
    1066:	ce 01       	movw	r24, r28
    1068:	01 96       	adiw	r24, 0x01	; 1
    106a:	9b d2       	rcall	.+1334   	; 0x15a2 <_ZN11SPISettingsC1Emhh>
    106c:	be 01       	movw	r22, r28
    106e:	6f 5f       	subi	r22, 0xFF	; 255
    1070:	7f 4f       	sbci	r23, 0xFF	; 255
    1072:	8c e8       	ldi	r24, 0x8C	; 140
    1074:	94 e0       	ldi	r25, 0x04	; 4
    1076:	b9 d2       	rcall	.+1394   	; 0x15ea <_ZN8SPIClass16beginTransactionE11SPISettings>
    1078:	0b e0       	ldi	r16, 0x0B	; 11
    107a:	11 e0       	ldi	r17, 0x01	; 1
    107c:	f8 01       	movw	r30, r16
    107e:	80 81       	ld	r24, Z
    1080:	8b 7f       	andi	r24, 0xFB	; 251
    1082:	80 83       	st	Z, r24
    1084:	65 e0       	ldi	r22, 0x05	; 5
    1086:	8c e8       	ldi	r24, 0x8C	; 140
    1088:	94 e0       	ldi	r25, 0x04	; 4
    108a:	b5 d2       	rcall	.+1386   	; 0x15f6 <_ZN8SPIClass8transferEh>
    108c:	6d 2d       	mov	r22, r13
    108e:	8c e8       	ldi	r24, 0x8C	; 140
    1090:	94 e0       	ldi	r25, 0x04	; 4
    1092:	b1 d2       	rcall	.+1378   	; 0x15f6 <_ZN8SPIClass8transferEh>
    1094:	6e 2d       	mov	r22, r14
    1096:	8c e8       	ldi	r24, 0x8C	; 140
    1098:	94 e0       	ldi	r25, 0x04	; 4
    109a:	ad d2       	rcall	.+1370   	; 0x15f6 <_ZN8SPIClass8transferEh>
    109c:	6f 2d       	mov	r22, r15
    109e:	8c e8       	ldi	r24, 0x8C	; 140
    10a0:	94 e0       	ldi	r25, 0x04	; 4
    10a2:	a9 d2       	rcall	.+1362   	; 0x15f6 <_ZN8SPIClass8transferEh>
    10a4:	f8 01       	movw	r30, r16
    10a6:	80 81       	ld	r24, Z
    10a8:	84 60       	ori	r24, 0x04	; 4
    10aa:	80 83       	st	Z, r24
    10ac:	0f 90       	pop	r0
    10ae:	0f 90       	pop	r0
    10b0:	df 91       	pop	r29
    10b2:	cf 91       	pop	r28
    10b4:	1f 91       	pop	r17
    10b6:	0f 91       	pop	r16
    10b8:	ff 90       	pop	r15
    10ba:	ef 90       	pop	r14
    10bc:	df 90       	pop	r13
    10be:	08 95       	ret

000010c0 <_ZN7MCP_CAN18mcp2515_readStatusEv>:
    10c0:	0f 93       	push	r16
    10c2:	1f 93       	push	r17
    10c4:	cf 93       	push	r28
    10c6:	df 93       	push	r29
    10c8:	1f 92       	push	r1
    10ca:	1f 92       	push	r1
    10cc:	cd b7       	in	r28, 0x3d	; 61
    10ce:	de b7       	in	r29, 0x3e	; 62
    10d0:	00 e0       	ldi	r16, 0x00	; 0
    10d2:	21 e0       	ldi	r18, 0x01	; 1
    10d4:	40 e8       	ldi	r20, 0x80	; 128
    10d6:	56 e9       	ldi	r21, 0x96	; 150
    10d8:	68 e9       	ldi	r22, 0x98	; 152
    10da:	70 e0       	ldi	r23, 0x00	; 0
    10dc:	ce 01       	movw	r24, r28
    10de:	01 96       	adiw	r24, 0x01	; 1
    10e0:	60 d2       	rcall	.+1216   	; 0x15a2 <_ZN11SPISettingsC1Emhh>
    10e2:	be 01       	movw	r22, r28
    10e4:	6f 5f       	subi	r22, 0xFF	; 255
    10e6:	7f 4f       	sbci	r23, 0xFF	; 255
    10e8:	8c e8       	ldi	r24, 0x8C	; 140
    10ea:	94 e0       	ldi	r25, 0x04	; 4
    10ec:	7e d2       	rcall	.+1276   	; 0x15ea <_ZN8SPIClass16beginTransactionE11SPISettings>
    10ee:	0b e0       	ldi	r16, 0x0B	; 11
    10f0:	11 e0       	ldi	r17, 0x01	; 1
    10f2:	f8 01       	movw	r30, r16
    10f4:	80 81       	ld	r24, Z
    10f6:	8b 7f       	andi	r24, 0xFB	; 251
    10f8:	80 83       	st	Z, r24
    10fa:	60 ea       	ldi	r22, 0xA0	; 160
    10fc:	8c e8       	ldi	r24, 0x8C	; 140
    10fe:	94 e0       	ldi	r25, 0x04	; 4
    1100:	7a d2       	rcall	.+1268   	; 0x15f6 <_ZN8SPIClass8transferEh>
    1102:	60 e0       	ldi	r22, 0x00	; 0
    1104:	8c e8       	ldi	r24, 0x8C	; 140
    1106:	94 e0       	ldi	r25, 0x04	; 4
    1108:	76 d2       	rcall	.+1260   	; 0x15f6 <_ZN8SPIClass8transferEh>
    110a:	f8 01       	movw	r30, r16
    110c:	90 81       	ld	r25, Z
    110e:	94 60       	ori	r25, 0x04	; 4
    1110:	90 83       	st	Z, r25
    1112:	0f 90       	pop	r0
    1114:	0f 90       	pop	r0
    1116:	df 91       	pop	r29
    1118:	cf 91       	pop	r28
    111a:	1f 91       	pop	r17
    111c:	0f 91       	pop	r16
    111e:	08 95       	ret

00001120 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>:
    1120:	0f 93       	push	r16
    1122:	1f 93       	push	r17
    1124:	cf 93       	push	r28
    1126:	8c 01       	movw	r16, r24
    1128:	c6 2f       	mov	r28, r22
    112a:	26 2f       	mov	r18, r22
    112c:	40 ee       	ldi	r20, 0xE0	; 224
    112e:	6f e0       	ldi	r22, 0x0F	; 15
    1130:	86 df       	rcall	.-244    	; 0x103e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    1132:	6f e0       	ldi	r22, 0x0F	; 15
    1134:	c8 01       	movw	r24, r16
    1136:	73 de       	rcall	.-794    	; 0xe1e <_ZN7MCP_CAN20mcp2515_readRegisterEh>
    1138:	98 2f       	mov	r25, r24
    113a:	90 7e       	andi	r25, 0xE0	; 224
    113c:	81 e0       	ldi	r24, 0x01	; 1
    113e:	9c 13       	cpse	r25, r28
    1140:	01 c0       	rjmp	.+2      	; 0x1144 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh+0x24>
    1142:	80 e0       	ldi	r24, 0x00	; 0
    1144:	cf 91       	pop	r28
    1146:	1f 91       	pop	r17
    1148:	0f 91       	pop	r16
    114a:	08 95       	ret

0000114c <_ZN7MCP_CAN7setModeEh>:
    114c:	fc 01       	movw	r30, r24
    114e:	61 8b       	std	Z+17, r22	; 0x11
    1150:	e7 cf       	rjmp	.-50     	; 0x1120 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>
    1152:	08 95       	ret

00001154 <_ZN7MCP_CAN18mcp2515_configRateEhh>:
    1154:	cf 93       	push	r28
    1156:	df 93       	push	r29
    1158:	ec 01       	movw	r28, r24
    115a:	40 e4       	ldi	r20, 0x40	; 64
    115c:	6a e2       	ldi	r22, 0x2A	; 42
    115e:	e6 de       	rcall	.-564    	; 0xf2c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1160:	45 ee       	ldi	r20, 0xE5	; 229
    1162:	69 e2       	ldi	r22, 0x29	; 41
    1164:	ce 01       	movw	r24, r28
    1166:	e2 de       	rcall	.-572    	; 0xf2c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1168:	43 e8       	ldi	r20, 0x83	; 131
    116a:	68 e2       	ldi	r22, 0x28	; 40
    116c:	ce 01       	movw	r24, r28
    116e:	de de       	rcall	.-580    	; 0xf2c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1170:	80 e0       	ldi	r24, 0x00	; 0
    1172:	df 91       	pop	r29
    1174:	cf 91       	pop	r28
    1176:	08 95       	ret

00001178 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>:

/*********************************************************************************************************
** Function name:           mcp2515_write_mf
** Descriptions:            Write Masks and Filters
*********************************************************************************************************/
void MCP_CAN::mcp2515_write_mf( const uint8_t mcp_addr, const uint8_t ext, const uint32_t id ){
    1178:	0f 93       	push	r16
    117a:	1f 93       	push	r17
    117c:	cf 93       	push	r28
    117e:	df 93       	push	r29
    1180:	00 d0       	rcall	.+0      	; 0x1182 <_ZN7MCP_CAN16mcp2515_write_mfEhhm+0xa>
    1182:	1f 92       	push	r1
    1184:	cd b7       	in	r28, 0x3d	; 61
    1186:	de b7       	in	r29, 0x3e	; 62
	uint16_t canid;
	uint8_t tbufdata[4];
	canid = (uint16_t)(id & 0x0FFFF);
	if ( ext == 1){
    1188:	41 30       	cpi	r20, 0x01	; 1
    118a:	c9 f4       	brne	.+50     	; 0x11be <_ZN7MCP_CAN16mcp2515_write_mfEhhm+0x46>
		tbufdata[MCP_EID0] = (uint8_t) (canid & 0xFF);
    118c:	0c 83       	std	Y+4, r16	; 0x04
		tbufdata[MCP_EID8] = (uint8_t) (canid >> 8);
    118e:	1b 83       	std	Y+3, r17	; 0x03
		canid = (uint16_t)(id >> 16);
    1190:	89 01       	movw	r16, r18
    1192:	22 27       	eor	r18, r18
    1194:	33 27       	eor	r19, r19
		tbufdata[MCP_SIDL] = (uint8_t) (canid & 0x03);
		tbufdata[MCP_SIDL] += (uint8_t) ((canid & 0x1C) << 3);
		tbufdata[MCP_SIDL] |= MCP_TXB_EXIDE_M;
    1196:	40 2f       	mov	r20, r16
    1198:	4c 71       	andi	r20, 0x1C	; 28
    119a:	44 0f       	add	r20, r20
    119c:	44 0f       	add	r20, r20
    119e:	44 0f       	add	r20, r20
    11a0:	50 2f       	mov	r21, r16
    11a2:	53 70       	andi	r21, 0x03	; 3
    11a4:	45 0f       	add	r20, r21
    11a6:	48 60       	ori	r20, 0x08	; 8
    11a8:	4a 83       	std	Y+2, r20	; 0x02
		tbufdata[MCP_SIDH] = (uint8_t) (canid >> 5 );
    11aa:	16 95       	lsr	r17
    11ac:	07 95       	ror	r16
    11ae:	12 95       	swap	r17
    11b0:	02 95       	swap	r16
    11b2:	0f 70       	andi	r16, 0x0F	; 15
    11b4:	01 27       	eor	r16, r17
    11b6:	1f 70       	andi	r17, 0x0F	; 15
    11b8:	01 27       	eor	r16, r17
    11ba:	09 83       	std	Y+1, r16	; 0x01
    11bc:	11 c0       	rjmp	.+34     	; 0x11e0 <_ZN7MCP_CAN16mcp2515_write_mfEhhm+0x68>
	} else {
		tbufdata[MCP_EID0] = (uint8_t) (canid & 0xFF);
    11be:	0c 83       	std	Y+4, r16	; 0x04
		tbufdata[MCP_EID8] = (uint8_t) (canid >> 8);
    11c0:	1b 83       	std	Y+3, r17	; 0x03
		canid = (uint16_t)(id >> 16);
    11c2:	89 01       	movw	r16, r18
    11c4:	22 27       	eor	r18, r18
    11c6:	33 27       	eor	r19, r19
		tbufdata[MCP_SIDL] = (uint8_t) ((canid & 0x07) << 5);
    11c8:	40 2f       	mov	r20, r16
    11ca:	42 95       	swap	r20
    11cc:	44 0f       	add	r20, r20
    11ce:	40 7e       	andi	r20, 0xE0	; 224
    11d0:	4a 83       	std	Y+2, r20	; 0x02
		tbufdata[MCP_SIDH] = (uint8_t) (canid >> 3 );
    11d2:	16 95       	lsr	r17
    11d4:	07 95       	ror	r16
    11d6:	16 95       	lsr	r17
    11d8:	07 95       	ror	r16
    11da:	16 95       	lsr	r17
    11dc:	07 95       	ror	r16
    11de:	09 83       	std	Y+1, r16	; 0x01
	}
	mcp2515_setRegisterS( mcp_addr, tbufdata, 4 );
    11e0:	24 e0       	ldi	r18, 0x04	; 4
    11e2:	ae 01       	movw	r20, r28
    11e4:	4f 5f       	subi	r20, 0xFF	; 255
    11e6:	5f 4f       	sbci	r21, 0xFF	; 255
    11e8:	db de       	rcall	.-586    	; 0xfa0 <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh>
}
    11ea:	0f 90       	pop	r0
    11ec:	0f 90       	pop	r0
    11ee:	0f 90       	pop	r0
    11f0:	0f 90       	pop	r0
    11f2:	df 91       	pop	r29
    11f4:	cf 91       	pop	r28
    11f6:	1f 91       	pop	r17
    11f8:	0f 91       	pop	r16
    11fa:	08 95       	ret

000011fc <_ZN7MCP_CAN22mcp2515_initCANBuffersEv>:

/*********************************************************************************************************
** Function name:           mcp2515_initCANBuffers
** Descriptions:            Initialize Buffers, Masks, and Filters
*********************************************************************************************************/
void MCP_CAN::mcp2515_initCANBuffers(void){
    11fc:	ef 92       	push	r14
    11fe:	ff 92       	push	r15
    1200:	0f 93       	push	r16
    1202:	1f 93       	push	r17
    1204:	cf 93       	push	r28
    1206:	7c 01       	movw	r14, r24
	uint8_t std = 0;
	uint8_t ext = 1;
	uint32_t ulMask = 0x00, ulFilt = 0x00;


	mcp2515_write_mf(MCP_RXM0SIDH, ext, ulMask);			/*Set both masks to 0           */
    1208:	00 e0       	ldi	r16, 0x00	; 0
    120a:	10 e0       	ldi	r17, 0x00	; 0
    120c:	98 01       	movw	r18, r16
    120e:	41 e0       	ldi	r20, 0x01	; 1
    1210:	60 e2       	ldi	r22, 0x20	; 32
    1212:	b2 df       	rcall	.-156    	; 0x1178 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXM1SIDH, ext, ulMask);			/*Mask register ignores ext bit */
    1214:	00 e0       	ldi	r16, 0x00	; 0
    1216:	10 e0       	ldi	r17, 0x00	; 0
    1218:	98 01       	movw	r18, r16
    121a:	41 e0       	ldi	r20, 0x01	; 1
    121c:	64 e2       	ldi	r22, 0x24	; 36
    121e:	c7 01       	movw	r24, r14
    1220:	ab df       	rcall	.-170    	; 0x1178 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	
	/* Set all filters to 0         */
	mcp2515_write_mf(MCP_RXF0SIDH, ext, ulFilt);			/* RXB0: extended               */
    1222:	00 e0       	ldi	r16, 0x00	; 0
    1224:	10 e0       	ldi	r17, 0x00	; 0
    1226:	98 01       	movw	r18, r16
    1228:	41 e0       	ldi	r20, 0x01	; 1
    122a:	60 e0       	ldi	r22, 0x00	; 0
    122c:	c7 01       	movw	r24, r14
    122e:	a4 df       	rcall	.-184    	; 0x1178 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF1SIDH, std, ulFilt);			/* RXB1: standard               */
    1230:	00 e0       	ldi	r16, 0x00	; 0
    1232:	10 e0       	ldi	r17, 0x00	; 0
    1234:	98 01       	movw	r18, r16
    1236:	40 e0       	ldi	r20, 0x00	; 0
    1238:	64 e0       	ldi	r22, 0x04	; 4
    123a:	c7 01       	movw	r24, r14
    123c:	9d df       	rcall	.-198    	; 0x1178 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF2SIDH, ext, ulFilt);			/* RXB2: extended               */
    123e:	00 e0       	ldi	r16, 0x00	; 0
    1240:	10 e0       	ldi	r17, 0x00	; 0
    1242:	98 01       	movw	r18, r16
    1244:	41 e0       	ldi	r20, 0x01	; 1
    1246:	68 e0       	ldi	r22, 0x08	; 8
    1248:	c7 01       	movw	r24, r14
    124a:	96 df       	rcall	.-212    	; 0x1178 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF3SIDH, std, ulFilt);			/* RXB3: standard               */
    124c:	00 e0       	ldi	r16, 0x00	; 0
    124e:	10 e0       	ldi	r17, 0x00	; 0
    1250:	98 01       	movw	r18, r16
    1252:	40 e0       	ldi	r20, 0x00	; 0
    1254:	60 e1       	ldi	r22, 0x10	; 16
    1256:	c7 01       	movw	r24, r14
    1258:	8f df       	rcall	.-226    	; 0x1178 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF4SIDH, ext, ulFilt);
    125a:	00 e0       	ldi	r16, 0x00	; 0
    125c:	10 e0       	ldi	r17, 0x00	; 0
    125e:	98 01       	movw	r18, r16
    1260:	41 e0       	ldi	r20, 0x01	; 1
    1262:	64 e1       	ldi	r22, 0x14	; 20
    1264:	c7 01       	movw	r24, r14
    1266:	88 df       	rcall	.-240    	; 0x1178 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF5SIDH, std, ulFilt);
    1268:	00 e0       	ldi	r16, 0x00	; 0
    126a:	10 e0       	ldi	r17, 0x00	; 0
    126c:	98 01       	movw	r18, r16
    126e:	40 e0       	ldi	r20, 0x00	; 0
    1270:	68 e1       	ldi	r22, 0x18	; 24
    1272:	c7 01       	movw	r24, r14
    1274:	81 df       	rcall	.-254    	; 0x1178 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>

	/* Clear, deactivate the three  */
	/* transmit buffers             */
	/* TXBnCTRL -> TXBnD7           */
	a1 = MCP_TXB0CTRL;
    1276:	c0 e3       	ldi	r28, 0x30	; 48
	a2 = MCP_TXB1CTRL;
	a3 = MCP_TXB2CTRL;
	for (i = 0; i < 14; i++) {                                          /* in-buffer loop               */
		mcp2515_setRegister(a1, 0);
    1278:	40 e0       	ldi	r20, 0x00	; 0
    127a:	6c 2f       	mov	r22, r28
    127c:	c7 01       	movw	r24, r14
    127e:	56 de       	rcall	.-852    	; 0xf2c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		mcp2515_setRegister(a2, 0);
    1280:	60 e1       	ldi	r22, 0x10	; 16
    1282:	6c 0f       	add	r22, r28
    1284:	40 e0       	ldi	r20, 0x00	; 0
    1286:	c7 01       	movw	r24, r14
    1288:	51 de       	rcall	.-862    	; 0xf2c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		mcp2515_setRegister(a3, 0);
    128a:	60 e2       	ldi	r22, 0x20	; 32
    128c:	6c 0f       	add	r22, r28
    128e:	40 e0       	ldi	r20, 0x00	; 0
    1290:	c7 01       	movw	r24, r14
    1292:	4c de       	rcall	.-872    	; 0xf2c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		a1++;
    1294:	cf 5f       	subi	r28, 0xFF	; 255
	/* transmit buffers             */
	/* TXBnCTRL -> TXBnD7           */
	a1 = MCP_TXB0CTRL;
	a2 = MCP_TXB1CTRL;
	a3 = MCP_TXB2CTRL;
	for (i = 0; i < 14; i++) {                                          /* in-buffer loop               */
    1296:	ce 33       	cpi	r28, 0x3E	; 62
    1298:	79 f7       	brne	.-34     	; 0x1278 <_ZN7MCP_CAN22mcp2515_initCANBuffersEv+0x7c>
		mcp2515_setRegister(a3, 0);
		a1++;
		a2++;
		a3++;
	}
	mcp2515_setRegister(MCP_RXB0CTRL, 0);
    129a:	40 e0       	ldi	r20, 0x00	; 0
    129c:	60 e6       	ldi	r22, 0x60	; 96
    129e:	c7 01       	movw	r24, r14
    12a0:	45 de       	rcall	.-886    	; 0xf2c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    12a2:	40 e0       	ldi	r20, 0x00	; 0
	mcp2515_setRegister(MCP_RXB1CTRL, 0);
    12a4:	60 e7       	ldi	r22, 0x70	; 112
    12a6:	c7 01       	movw	r24, r14
    12a8:	41 de       	rcall	.-894    	; 0xf2c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    12aa:	cf 91       	pop	r28
    12ac:	1f 91       	pop	r17
}
    12ae:	0f 91       	pop	r16
    12b0:	ff 90       	pop	r15
    12b2:	ef 90       	pop	r14
    12b4:	08 95       	ret

000012b6 <_ZN7MCP_CAN12mcp2515_initEhhh>:
    12b6:	ff 92       	push	r15
    12b8:	0f 93       	push	r16

/*********************************************************************************************************
** Function name:           mcp2515_init
** Descriptions:            Initialize the controller
*********************************************************************************************************/
uint8_t MCP_CAN::mcp2515_init(const uint8_t canIDMode, const uint8_t canSpeed, const uint8_t canClock){
    12ba:	1f 93       	push	r17
    12bc:	cf 93       	push	r28
    12be:	df 93       	push	r29
    12c0:	ec 01       	movw	r28, r24
    12c2:	f6 2e       	mov	r15, r22
    12c4:	14 2f       	mov	r17, r20
    12c6:	02 2f       	mov	r16, r18
	uint8_t res;
	mcp2515_reset();
    12c8:	78 dd       	rcall	.-1296   	; 0xdba <_ZN7MCP_CAN13mcp2515_resetEv>
	mcpMode = MCP_LOOPBACK;
    12ca:	80 e4       	ldi	r24, 0x40	; 64
    12cc:	89 8b       	std	Y+17, r24	; 0x11
	res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
    12ce:	60 e8       	ldi	r22, 0x80	; 128
    12d0:	ce 01       	movw	r24, r28
    12d2:	26 df       	rcall	.-436    	; 0x1120 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>
	if(res > 0)
    12d4:	81 11       	cpse	r24, r1
    12d6:	35 c0       	rjmp	.+106    	; 0x1342 <_ZN7MCP_CAN12mcp2515_initEhhh+0x8c>
	return res;
	// Set Baudrate
	if(mcp2515_configRate(canSpeed, canClock))
    12d8:	40 2f       	mov	r20, r16
    12da:	61 2f       	mov	r22, r17
    12dc:	ce 01       	movw	r24, r28
    12de:	3a df       	rcall	.-396    	; 0x1154 <_ZN7MCP_CAN18mcp2515_configRateEhh>
    12e0:	81 11       	cpse	r24, r1
	return res;
	if ( res == MCP2515_OK ) {
		mcp2515_initCANBuffers();											//init canbuffers
    12e2:	2c c0       	rjmp	.+88     	; 0x133c <_ZN7MCP_CAN12mcp2515_initEhhh+0x86>
    12e4:	ce 01       	movw	r24, r28
		mcp2515_setRegister(MCP_CANINTE, MCP_RX0IF | MCP_RX1IF);			//interrupt mode
    12e6:	8a df       	rcall	.-236    	; 0x11fc <_ZN7MCP_CAN22mcp2515_initCANBuffersEv>
    12e8:	43 e0       	ldi	r20, 0x03	; 3
    12ea:	6b e2       	ldi	r22, 0x2B	; 43
    12ec:	ce 01       	movw	r24, r28
		mcp2515_setRegister(MCP_BFPCTRL,MCP_BxBFS_MASK | MCP_BxBFE_MASK);	//Sets BF pins as GPO
    12ee:	1e de       	rcall	.-964    	; 0xf2c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    12f0:	4c e3       	ldi	r20, 0x3C	; 60
    12f2:	6c e0       	ldi	r22, 0x0C	; 12
    12f4:	ce 01       	movw	r24, r28
		mcp2515_setRegister(MCP_TXRTSCTRL,0x00);							//Sets RTS pins as GPI
    12f6:	1a de       	rcall	.-972    	; 0xf2c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    12f8:	40 e0       	ldi	r20, 0x00	; 0
    12fa:	6d e0       	ldi	r22, 0x0D	; 13
    12fc:	ce 01       	movw	r24, r28
    12fe:	16 de       	rcall	.-980    	; 0xf2c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		switch(canIDMode){
    1300:	ff 20       	and	r15, r15
    1302:	71 f0       	breq	.+28     	; 0x1320 <_ZN7MCP_CAN12mcp2515_initEhhh+0x6a>
    1304:	83 e0       	ldi	r24, 0x03	; 3
    1306:	f8 12       	cpse	r15, r24
			case (MCP_ANY):
			mcp2515_modifyRegister(MCP_RXB0CTRL,
			MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
			MCP_RXB_RX_ANY | MCP_RXB_BUKT_MASK);
    1308:	1b c0       	rjmp	.+54     	; 0x1340 <_ZN7MCP_CAN12mcp2515_initEhhh+0x8a>
    130a:	24 e6       	ldi	r18, 0x64	; 100
    130c:	44 e6       	ldi	r20, 0x64	; 100
    130e:	60 e6       	ldi	r22, 0x60	; 96
    1310:	ce 01       	movw	r24, r28
			mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
			MCP_RXB_RX_ANY);
    1312:	95 de       	rcall	.-726    	; 0x103e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    1314:	20 e6       	ldi	r18, 0x60	; 96
    1316:	40 e6       	ldi	r20, 0x60	; 96
    1318:	60 e7       	ldi	r22, 0x70	; 112
    131a:	ce 01       	movw	r24, r28
			break;
    131c:	90 de       	rcall	.-736    	; 0x103e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
			case (MCP_STDEXT):
			mcp2515_modifyRegister(MCP_RXB0CTRL,
			MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
			MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK );
    131e:	0a c0       	rjmp	.+20     	; 0x1334 <_ZN7MCP_CAN12mcp2515_initEhhh+0x7e>
    1320:	24 e0       	ldi	r18, 0x04	; 4
    1322:	44 e6       	ldi	r20, 0x64	; 100
    1324:	60 e6       	ldi	r22, 0x60	; 96
			mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
			MCP_RXB_RX_STDEXT);
    1326:	ce 01       	movw	r24, r28
    1328:	8a de       	rcall	.-748    	; 0x103e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    132a:	20 e0       	ldi	r18, 0x00	; 0
    132c:	40 e6       	ldi	r20, 0x60	; 96
    132e:	60 e7       	ldi	r22, 0x70	; 112
    1330:	ce 01       	movw	r24, r28
			break;
			default:
			return MCP2515_FAIL;
			break;
		}
		res = mcp2515_setCANCTRL_Mode(mcpMode);
    1332:	85 de       	rcall	.-758    	; 0x103e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    1334:	69 89       	ldd	r22, Y+17	; 0x11
    1336:	ce 01       	movw	r24, r28
    1338:	f3 de       	rcall	.-538    	; 0x1120 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>
    133a:	03 c0       	rjmp	.+6      	; 0x1342 <_ZN7MCP_CAN12mcp2515_initEhhh+0x8c>
	res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
	if(res > 0)
	return res;
	// Set Baudrate
	if(mcp2515_configRate(canSpeed, canClock))
	return res;
    133c:	80 e0       	ldi	r24, 0x00	; 0
    133e:	01 c0       	rjmp	.+2      	; 0x1342 <_ZN7MCP_CAN12mcp2515_initEhhh+0x8c>
			MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK );
			mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
			MCP_RXB_RX_STDEXT);
			break;
			default:
			return MCP2515_FAIL;
    1340:	81 e0       	ldi	r24, 0x01	; 1
		res = mcp2515_setCANCTRL_Mode(mcpMode);
		if(res)
		return res;
	}
	return res;
}
    1342:	df 91       	pop	r29
    1344:	cf 91       	pop	r28
    1346:	1f 91       	pop	r17
    1348:	0f 91       	pop	r16
    134a:	ff 90       	pop	r15
    134c:	08 95       	ret

0000134e <_ZN7MCP_CAN15mcp2515_read_idEhPhPm>:

/*********************************************************************************************************
** Function name:           mcp2515_read_id
** Descriptions:            Read CAN ID
*********************************************************************************************************/
void MCP_CAN::mcp2515_read_id( const uint8_t mcp_addr, uint8_t* ext, uint32_t* id ){
    134e:	ef 92       	push	r14
    1350:	ff 92       	push	r15
    1352:	0f 93       	push	r16
    1354:	1f 93       	push	r17
    1356:	cf 93       	push	r28
    1358:	df 93       	push	r29
    135a:	00 d0       	rcall	.+0      	; 0x135c <_ZN7MCP_CAN15mcp2515_read_idEhPhPm+0xe>
    135c:	1f 92       	push	r1
    135e:	cd b7       	in	r28, 0x3d	; 61
    1360:	de b7       	in	r29, 0x3e	; 62
    1362:	7a 01       	movw	r14, r20
    1364:	89 01       	movw	r16, r18
	uint8_t tbufdata[4];
	*ext = 0;
    1366:	fa 01       	movw	r30, r20
    1368:	10 82       	st	Z, r1
	*id = 0;
    136a:	f9 01       	movw	r30, r18
    136c:	10 82       	st	Z, r1
    136e:	11 82       	std	Z+1, r1	; 0x01
    1370:	12 82       	std	Z+2, r1	; 0x02
    1372:	13 82       	std	Z+3, r1	; 0x03
	mcp2515_readRegisterS( mcp_addr, tbufdata, 4 );
    1374:	24 e0       	ldi	r18, 0x04	; 4
    1376:	ae 01       	movw	r20, r28
    1378:	4f 5f       	subi	r20, 0xFF	; 255
    137a:	5f 4f       	sbci	r21, 0xFF	; 255
    137c:	87 dd       	rcall	.-1266   	; 0xe8c <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh>
	*id = (tbufdata[MCP_SIDH]<<3) + (tbufdata[MCP_SIDL]>>5);
    137e:	2a 81       	ldd	r18, Y+2	; 0x02
    1380:	39 81       	ldd	r19, Y+1	; 0x01
    1382:	82 2f       	mov	r24, r18
    1384:	90 e0       	ldi	r25, 0x00	; 0
    1386:	95 95       	asr	r25
    1388:	87 95       	ror	r24
    138a:	95 95       	asr	r25
    138c:	87 95       	ror	r24
    138e:	95 95       	asr	r25
    1390:	87 95       	ror	r24
    1392:	95 95       	asr	r25
    1394:	87 95       	ror	r24
    1396:	95 95       	asr	r25
    1398:	87 95       	ror	r24
    139a:	f8 e0       	ldi	r31, 0x08	; 8
    139c:	3f 9f       	mul	r19, r31
    139e:	80 0d       	add	r24, r0
    13a0:	91 1d       	adc	r25, r1
    13a2:	11 24       	eor	r1, r1
    13a4:	09 2e       	mov	r0, r25
    13a6:	00 0c       	add	r0, r0
    13a8:	aa 0b       	sbc	r26, r26
    13aa:	bb 0b       	sbc	r27, r27
    13ac:	f8 01       	movw	r30, r16
    13ae:	80 83       	st	Z, r24
    13b0:	91 83       	std	Z+1, r25	; 0x01
    13b2:	a2 83       	std	Z+2, r26	; 0x02
    13b4:	b3 83       	std	Z+3, r27	; 0x03
	if ( (tbufdata[MCP_SIDL] & MCP_TXB_EXIDE_M) ==  MCP_TXB_EXIDE_M ){
    13b6:	23 ff       	sbrs	r18, 3
    13b8:	26 c0       	rjmp	.+76     	; 0x1406 <_ZN7MCP_CAN15mcp2515_read_idEhPhPm+0xb8>
		/* extended id                  */
		*id = (*id<<2) + (tbufdata[MCP_SIDL] & 0x03);
		*id = (*id<<8) + tbufdata[MCP_EID8];
		*id = (*id<<8) + tbufdata[MCP_EID0];
    13ba:	88 0f       	add	r24, r24
    13bc:	99 1f       	adc	r25, r25
    13be:	aa 1f       	adc	r26, r26
    13c0:	bb 1f       	adc	r27, r27
    13c2:	88 0f       	add	r24, r24
    13c4:	99 1f       	adc	r25, r25
    13c6:	aa 1f       	adc	r26, r26
    13c8:	bb 1f       	adc	r27, r27
    13ca:	23 70       	andi	r18, 0x03	; 3
    13cc:	82 0f       	add	r24, r18
    13ce:	91 1d       	adc	r25, r1
    13d0:	a1 1d       	adc	r26, r1
    13d2:	b1 1d       	adc	r27, r1
    13d4:	ba 2f       	mov	r27, r26
    13d6:	a9 2f       	mov	r26, r25
    13d8:	98 2f       	mov	r25, r24
    13da:	88 27       	eor	r24, r24
    13dc:	2b 81       	ldd	r18, Y+3	; 0x03
    13de:	82 0f       	add	r24, r18
    13e0:	91 1d       	adc	r25, r1
    13e2:	a1 1d       	adc	r26, r1
    13e4:	b1 1d       	adc	r27, r1
    13e6:	ba 2f       	mov	r27, r26
    13e8:	a9 2f       	mov	r26, r25
    13ea:	98 2f       	mov	r25, r24
    13ec:	88 27       	eor	r24, r24
    13ee:	2c 81       	ldd	r18, Y+4	; 0x04
    13f0:	82 0f       	add	r24, r18
    13f2:	91 1d       	adc	r25, r1
    13f4:	a1 1d       	adc	r26, r1
    13f6:	b1 1d       	adc	r27, r1
    13f8:	80 83       	st	Z, r24
    13fa:	91 83       	std	Z+1, r25	; 0x01
    13fc:	a2 83       	std	Z+2, r26	; 0x02
    13fe:	b3 83       	std	Z+3, r27	; 0x03
		*ext = 1;
    1400:	81 e0       	ldi	r24, 0x01	; 1
    1402:	f7 01       	movw	r30, r14
    1404:	80 83       	st	Z, r24
	}
}
    1406:	0f 90       	pop	r0
    1408:	0f 90       	pop	r0
    140a:	0f 90       	pop	r0
    140c:	0f 90       	pop	r0
    140e:	df 91       	pop	r29
    1410:	cf 91       	pop	r28
    1412:	1f 91       	pop	r17
    1414:	0f 91       	pop	r16
    1416:	ff 90       	pop	r15
    1418:	ef 90       	pop	r14
    141a:	08 95       	ret

0000141c <_ZN7MCP_CAN19mcp2515_read_canMsgEh>:

/*********************************************************************************************************
** Function name:           mcp2515_read_canMsg
** Descriptions:            Read message
*********************************************************************************************************/
void MCP_CAN::mcp2515_read_canMsg( const uint8_t buffer_sidh_addr){        /* read can msg                 */
    141c:	0f 93       	push	r16
    141e:	1f 93       	push	r17
    1420:	cf 93       	push	r28
    1422:	df 93       	push	r29
    1424:	ec 01       	movw	r28, r24
    1426:	16 2f       	mov	r17, r22
	uint8_t mcp_addr, ctrl;
	mcp_addr = buffer_sidh_addr;
	mcp2515_read_id( mcp_addr, &m_nExtFlg,&m_nID );
    1428:	9c 01       	movw	r18, r24
    142a:	2f 5f       	subi	r18, 0xFF	; 255
    142c:	3f 4f       	sbci	r19, 0xFF	; 255
    142e:	ac 01       	movw	r20, r24
    1430:	8e df       	rcall	.-228    	; 0x134e <_ZN7MCP_CAN15mcp2515_read_idEhPhPm>
	ctrl = mcp2515_readRegister( mcp_addr-1 );
    1432:	6f ef       	ldi	r22, 0xFF	; 255
    1434:	61 0f       	add	r22, r17
    1436:	ce 01       	movw	r24, r28
    1438:	f2 dc       	rcall	.-1564   	; 0xe1e <_ZN7MCP_CAN20mcp2515_readRegisterEh>
    143a:	08 2f       	mov	r16, r24
	m_nDlc = mcp2515_readRegister( mcp_addr+4 );
    143c:	64 e0       	ldi	r22, 0x04	; 4
    143e:	61 0f       	add	r22, r17
    1440:	ce 01       	movw	r24, r28
    1442:	ed dc       	rcall	.-1574   	; 0xe1e <_ZN7MCP_CAN20mcp2515_readRegisterEh>
    1444:	8d 83       	std	Y+5, r24	; 0x05
	if (ctrl & 0x08)
    1446:	03 ff       	sbrs	r16, 3
    1448:	03 c0       	rjmp	.+6      	; 0x1450 <_ZN7MCP_CAN19mcp2515_read_canMsgEh+0x34>
		m_nRtr = 1;
    144a:	91 e0       	ldi	r25, 0x01	; 1
    144c:	9e 87       	std	Y+14, r25	; 0x0e
    144e:	01 c0       	rjmp	.+2      	; 0x1452 <_ZN7MCP_CAN19mcp2515_read_canMsgEh+0x36>
	else
		m_nRtr = 0;
    1450:	1e 86       	std	Y+14, r1	; 0x0e
	m_nDlc &= MCP_DLC_MASK;
    1452:	28 2f       	mov	r18, r24
    1454:	2f 70       	andi	r18, 0x0F	; 15
    1456:	2d 83       	std	Y+5, r18	; 0x05
	mcp2515_readRegisterS( mcp_addr+5, &(m_nDta[0]), m_nDlc );
    1458:	ae 01       	movw	r20, r28
    145a:	4a 5f       	subi	r20, 0xFA	; 250
    145c:	5f 4f       	sbci	r21, 0xFF	; 255
    145e:	65 e0       	ldi	r22, 0x05	; 5
    1460:	61 0f       	add	r22, r17
    1462:	ce 01       	movw	r24, r28
    1464:	13 dd       	rcall	.-1498   	; 0xe8c <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh>
}
    1466:	df 91       	pop	r29
    1468:	cf 91       	pop	r28
    146a:	1f 91       	pop	r17
    146c:	0f 91       	pop	r16
    146e:	08 95       	ret

00001470 <_ZN7MCP_CANC1Eh>:
** Function name:           MCP_CAN
** Descriptions:            Public function to declare CAN class and the /CS pin.
*********************************************************************************************************/
MCP_CAN::MCP_CAN(uint8_t _CS)
{
	MCPCS = _CS;
    1470:	fc 01       	movw	r30, r24
    1472:	60 8b       	std	Z+16, r22	; 0x10
	MCP2515_UNSELECT();
    1474:	eb e0       	ldi	r30, 0x0B	; 11
    1476:	f1 e0       	ldi	r31, 0x01	; 1
    1478:	80 81       	ld	r24, Z
    147a:	84 60       	ori	r24, 0x04	; 4
    147c:	80 83       	st	Z, r24
	DDRL |= (1 << PL2);		//????
    147e:	ea e0       	ldi	r30, 0x0A	; 10
    1480:	f1 e0       	ldi	r31, 0x01	; 1
    1482:	80 81       	ld	r24, Z
    1484:	84 60       	ori	r24, 0x04	; 4
    1486:	80 83       	st	Z, r24
    1488:	08 95       	ret

0000148a <_ZN7MCP_CAN5beginEhhh>:
/*********************************************************************************************************
** Function name:           begin
** Descriptions:            Public function to declare controller initialization parameters.
*********************************************************************************************************/
uint8_t MCP_CAN::begin(uint8_t idmodeset, uint8_t speedset, uint8_t clockset)
{
    148a:	ff 92       	push	r15
    148c:	0f 93       	push	r16
    148e:	1f 93       	push	r17
    1490:	cf 93       	push	r28
    1492:	df 93       	push	r29
    1494:	ec 01       	movw	r28, r24
    1496:	16 2f       	mov	r17, r22
    1498:	04 2f       	mov	r16, r20
    149a:	f2 2e       	mov	r15, r18
	uint8_t res;

	SPI.begin();
    149c:	90 d0       	rcall	.+288    	; 0x15be <_ZN8SPIClass5beginEv>
	res = mcp2515_init(idmodeset, speedset, clockset);
    149e:	2f 2d       	mov	r18, r15
    14a0:	40 2f       	mov	r20, r16
    14a2:	61 2f       	mov	r22, r17
    14a4:	ce 01       	movw	r24, r28
    14a6:	07 df       	rcall	.-498    	; 0x12b6 <_ZN7MCP_CAN12mcp2515_initEhhh>
    14a8:	91 e0       	ldi	r25, 0x01	; 1
    14aa:	81 11       	cpse	r24, r1
    14ac:	01 c0       	rjmp	.+2      	; 0x14b0 <_ZN7MCP_CAN5beginEhhh+0x26>
    14ae:	90 e0       	ldi	r25, 0x00	; 0
	if (res == MCP2515_OK)
	return CAN_OK;
	
	return CAN_FAILINIT;
}
    14b0:	89 2f       	mov	r24, r25
    14b2:	df 91       	pop	r29
    14b4:	cf 91       	pop	r28
    14b6:	1f 91       	pop	r17
    14b8:	0f 91       	pop	r16
    14ba:	ff 90       	pop	r15
    14bc:	08 95       	ret

000014be <_ZN7MCP_CAN7readMsgEv>:

/*********************************************************************************************************
** Function name:           readMsg
** Descriptions:            Read message
*********************************************************************************************************/
uint8_t MCP_CAN::readMsg(){
    14be:	cf 93       	push	r28
    14c0:	df 93       	push	r29
    14c2:	ec 01       	movw	r28, r24
	uint8_t stat, res;
	stat = mcp2515_readStatus();
    14c4:	fd dd       	rcall	.-1030   	; 0x10c0 <_ZN7MCP_CAN18mcp2515_readStatusEv>

	if ( stat & MCP_STAT_RX0IF )                                        /* Msg in Buffer 0              */
    14c6:	80 ff       	sbrs	r24, 0
    14c8:	0a c0       	rjmp	.+20     	; 0x14de <_ZN7MCP_CAN7readMsgEv+0x20>
	{
		mcp2515_read_canMsg( MCP_RXBUF_0);
    14ca:	61 e6       	ldi	r22, 0x61	; 97
    14cc:	ce 01       	movw	r24, r28
    14ce:	a6 df       	rcall	.-180    	; 0x141c <_ZN7MCP_CAN19mcp2515_read_canMsgEh>
		mcp2515_modifyRegister(MCP_CANINTF, MCP_RX0IF, 0);
    14d0:	20 e0       	ldi	r18, 0x00	; 0
    14d2:	41 e0       	ldi	r20, 0x01	; 1
    14d4:	6c e2       	ldi	r22, 0x2C	; 44
    14d6:	ce 01       	movw	r24, r28
    14d8:	b2 dd       	rcall	.-1180   	; 0x103e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
		res = CAN_OK;
    14da:	80 e0       	ldi	r24, 0x00	; 0
    14dc:	0d c0       	rjmp	.+26     	; 0x14f8 <_ZN7MCP_CAN7readMsgEv+0x3a>
	}
	else if ( stat & MCP_STAT_RX1IF )                                   /* Msg in Buffer 1              */
    14de:	81 ff       	sbrs	r24, 1
	{
		mcp2515_read_canMsg( MCP_RXBUF_1);
    14e0:	0a c0       	rjmp	.+20     	; 0x14f6 <_ZN7MCP_CAN7readMsgEv+0x38>
    14e2:	61 e7       	ldi	r22, 0x71	; 113
    14e4:	ce 01       	movw	r24, r28
    14e6:	9a df       	rcall	.-204    	; 0x141c <_ZN7MCP_CAN19mcp2515_read_canMsgEh>
		mcp2515_modifyRegister(MCP_CANINTF, MCP_RX1IF, 0);
    14e8:	20 e0       	ldi	r18, 0x00	; 0
    14ea:	42 e0       	ldi	r20, 0x02	; 2
    14ec:	6c e2       	ldi	r22, 0x2C	; 44
    14ee:	ce 01       	movw	r24, r28
    14f0:	a6 dd       	rcall	.-1204   	; 0x103e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
		res = CAN_OK;
    14f2:	80 e0       	ldi	r24, 0x00	; 0
    14f4:	01 c0       	rjmp	.+2      	; 0x14f8 <_ZN7MCP_CAN7readMsgEv+0x3a>
	}
	else
	res = CAN_NOMSG;
    14f6:	84 e0       	ldi	r24, 0x04	; 4
	
	return res;
}
    14f8:	df 91       	pop	r29
    14fa:	cf 91       	pop	r28
    14fc:	08 95       	ret

000014fe <_ZN7MCP_CAN10readMsgBufEPmPhS1_>:

/*********************************************************************************************************
** Function name:           readMsgBuf
** Descriptions:            Public function, Reads message from receive buffer.
*********************************************************************************************************/
uint8_t MCP_CAN::readMsgBuf(uint32_t *id, uint8_t *len, uint8_t buf[]){
    14fe:	cf 92       	push	r12
    1500:	df 92       	push	r13
    1502:	ef 92       	push	r14
    1504:	ff 92       	push	r15
    1506:	0f 93       	push	r16
    1508:	1f 93       	push	r17
    150a:	cf 93       	push	r28
    150c:	df 93       	push	r29
    150e:	ec 01       	movw	r28, r24
    1510:	7b 01       	movw	r14, r22
    1512:	8a 01       	movw	r16, r20
    1514:	c2 2e       	mov	r12, r18
    1516:	d3 2e       	mov	r13, r19
	if(readMsg() == CAN_NOMSG)
    1518:	d2 df       	rcall	.-92     	; 0x14be <_ZN7MCP_CAN7readMsgEv>
    151a:	84 30       	cpi	r24, 0x04	; 4
    151c:	c9 f1       	breq	.+114    	; 0x1590 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x92>
	return CAN_NOMSG;

	if (m_nExtFlg)
    151e:	88 81       	ld	r24, Y
    1520:	88 23       	and	r24, r24
    1522:	49 f0       	breq	.+18     	; 0x1536 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x38>
	m_nID |= 0x80000000;
    1524:	89 81       	ldd	r24, Y+1	; 0x01
    1526:	9a 81       	ldd	r25, Y+2	; 0x02
    1528:	ab 81       	ldd	r26, Y+3	; 0x03
    152a:	bc 81       	ldd	r27, Y+4	; 0x04
    152c:	b0 68       	ori	r27, 0x80	; 128
    152e:	89 83       	std	Y+1, r24	; 0x01
    1530:	9a 83       	std	Y+2, r25	; 0x02
    1532:	ab 83       	std	Y+3, r26	; 0x03
    1534:	bc 83       	std	Y+4, r27	; 0x04

	if (m_nRtr)
    1536:	8e 85       	ldd	r24, Y+14	; 0x0e
    1538:	88 23       	and	r24, r24
    153a:	49 f0       	breq	.+18     	; 0x154e <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x50>
	m_nID |= 0x40000000;
    153c:	89 81       	ldd	r24, Y+1	; 0x01
    153e:	9a 81       	ldd	r25, Y+2	; 0x02
    1540:	ab 81       	ldd	r26, Y+3	; 0x03
    1542:	bc 81       	ldd	r27, Y+4	; 0x04
    1544:	b0 64       	ori	r27, 0x40	; 64
    1546:	89 83       	std	Y+1, r24	; 0x01
    1548:	9a 83       	std	Y+2, r25	; 0x02
    154a:	ab 83       	std	Y+3, r26	; 0x03
    154c:	bc 83       	std	Y+4, r27	; 0x04
	*id  = m_nID;
    154e:	89 81       	ldd	r24, Y+1	; 0x01
    1550:	9a 81       	ldd	r25, Y+2	; 0x02
    1552:	ab 81       	ldd	r26, Y+3	; 0x03
    1554:	bc 81       	ldd	r27, Y+4	; 0x04
    1556:	f7 01       	movw	r30, r14
    1558:	80 83       	st	Z, r24
    155a:	91 83       	std	Z+1, r25	; 0x01
    155c:	a2 83       	std	Z+2, r26	; 0x02
    155e:	b3 83       	std	Z+3, r27	; 0x03
	*len = m_nDlc;
    1560:	8d 81       	ldd	r24, Y+5	; 0x05
    1562:	f8 01       	movw	r30, r16
    1564:	80 83       	st	Z, r24
	for(int i = 0; i<m_nDlc; i++)
    1566:	8d 81       	ldd	r24, Y+5	; 0x05
    1568:	88 23       	and	r24, r24
    156a:	89 f0       	breq	.+34     	; 0x158e <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x90>
    156c:	de 01       	movw	r26, r28
    156e:	16 96       	adiw	r26, 0x06	; 6
    1570:	ec 2d       	mov	r30, r12
    1572:	fd 2d       	mov	r31, r13
    1574:	20 e0       	ldi	r18, 0x00	; 0
    1576:	30 e0       	ldi	r19, 0x00	; 0
	buf[i] = m_nDta[i];
    1578:	8d 91       	ld	r24, X+
    157a:	81 93       	st	Z+, r24

	if (m_nRtr)
	m_nID |= 0x40000000;
	*id  = m_nID;
	*len = m_nDlc;
	for(int i = 0; i<m_nDlc; i++)
    157c:	2f 5f       	subi	r18, 0xFF	; 255
    157e:	3f 4f       	sbci	r19, 0xFF	; 255
    1580:	8d 81       	ldd	r24, Y+5	; 0x05
    1582:	90 e0       	ldi	r25, 0x00	; 0
    1584:	28 17       	cp	r18, r24
    1586:	39 07       	cpc	r19, r25
    1588:	bc f3       	brlt	.-18     	; 0x1578 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x7a>
	buf[i] = m_nDta[i];
	return CAN_OK;
    158a:	80 e0       	ldi	r24, 0x00	; 0
    158c:	01 c0       	rjmp	.+2      	; 0x1590 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x92>
    158e:	80 e0       	ldi	r24, 0x00	; 0
}
    1590:	df 91       	pop	r29
    1592:	cf 91       	pop	r28
    1594:	1f 91       	pop	r17
    1596:	0f 91       	pop	r16
    1598:	ff 90       	pop	r15
    159a:	ef 90       	pop	r14
    159c:	df 90       	pop	r13
    159e:	cf 90       	pop	r12
    15a0:	08 95       	ret

000015a2 <_ZN11SPISettingsC1Emhh>:
void SPIClass::end() {
	cli();							// Protect from a scheduler and prevent transactionBegin
	if (initialized)					// Decrease the reference counter
		initialized--;
	if (!initialized)				
		SPCR &= ~(1 << SPE);
    15a2:	0f 93       	push	r16
    15a4:	fc 01       	movw	r30, r24
    15a6:	22 23       	and	r18, r18
    15a8:	11 f0       	breq	.+4      	; 0x15ae <_ZN11SPISettingsC1Emhh+0xc>
    15aa:	90 e5       	ldi	r25, 0x50	; 80
    15ac:	01 c0       	rjmp	.+2      	; 0x15b0 <_ZN11SPISettingsC1Emhh+0xe>
    15ae:	90 e7       	ldi	r25, 0x70	; 112
    15b0:	0c 70       	andi	r16, 0x0C	; 12
    15b2:	09 2b       	or	r16, r25
    15b4:	00 83       	st	Z, r16
    15b6:	81 e0       	ldi	r24, 0x01	; 1
    15b8:	81 83       	std	Z+1, r24	; 0x01
    15ba:	0f 91       	pop	r16
    15bc:	08 95       	ret

000015be <_ZN8SPIClass5beginEv>:
    15be:	f8 94       	cli
    15c0:	80 91 8b 04 	lds	r24, 0x048B	; 0x80048b <_ZN8SPIClass11initializedE>
    15c4:	81 11       	cpse	r24, r1
    15c6:	0b c0       	rjmp	.+22     	; 0x15de <_ZN8SPIClass5beginEv+0x20>
    15c8:	58 9a       	sbi	0x0b, 0	; 11
    15ca:	20 9a       	sbi	0x04, 0	; 4
    15cc:	84 b1       	in	r24, 0x04	; 4
    15ce:	86 60       	ori	r24, 0x06	; 6
    15d0:	84 b9       	out	0x04, r24	; 4
    15d2:	8c b5       	in	r24, 0x2c	; 44
    15d4:	80 61       	ori	r24, 0x10	; 16
    15d6:	8c bd       	out	0x2c, r24	; 44
    15d8:	8c b5       	in	r24, 0x2c	; 44
    15da:	80 64       	ori	r24, 0x40	; 64
    15dc:	8c bd       	out	0x2c, r24	; 44
    15de:	80 91 8b 04 	lds	r24, 0x048B	; 0x80048b <_ZN8SPIClass11initializedE>
    15e2:	8f 5f       	subi	r24, 0xFF	; 255
    15e4:	80 93 8b 04 	sts	0x048B, r24	; 0x80048b <_ZN8SPIClass11initializedE>
    15e8:	08 95       	ret

000015ea <_ZN8SPIClass16beginTransactionE11SPISettings>:
}

void SPIClass::beginTransaction(SPISettings settings) {
	SPCR = settings.spcr;
    15ea:	fb 01       	movw	r30, r22
    15ec:	80 81       	ld	r24, Z
    15ee:	8c bd       	out	0x2c, r24	; 44
	SPSR = settings.spsr;
    15f0:	81 81       	ldd	r24, Z+1	; 0x01
    15f2:	8d bd       	out	0x2d, r24	; 45
    15f4:	08 95       	ret

000015f6 <_ZN8SPIClass8transferEh>:
}

uint8_t SPIClass::transfer(uint8_t data) {
SPDR = data;
    15f6:	6e bd       	out	0x2e, r22	; 46
while (!(SPSR & (1 << SPIF))) ; // wait
    15f8:	0d b4       	in	r0, 0x2d	; 45
    15fa:	07 fe       	sbrs	r0, 7
    15fc:	fd cf       	rjmp	.-6      	; 0x15f8 <_ZN8SPIClass8transferEh+0x2>
return SPDR;
    15fe:	8e b5       	in	r24, 0x2e	; 46
}
    1600:	08 95       	ret

00001602 <_ZN5USARTC1Ev>:
#include "USART.h"

//constructor with setup

USART::USART(){
	UCSR0B = (1 << TXEN0);						// Enable de USART Transmitter
    1602:	88 e0       	ldi	r24, 0x08	; 8
    1604:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);		// 8 data bits, 1 stop bit
    1608:	96 e0       	ldi	r25, 0x06	; 6
    160a:	90 93 c2 00 	sts	0x00C2, r25	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
	UBRR0H=0;									//write the baudrate (76800)
    160e:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
	UBRR0L=8;									// "
    1612:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    1616:	08 95       	ret

00001618 <_ZN5USART5printEPKc>:
}



//write a string in the Serial
void USART::print(const char st[]) {
    1618:	cf 93       	push	r28
    161a:	df 93       	push	r29
	for(uint8_t i = 0 ; st[i] != 0 ; i++) {		//iterate over every char in the string
    161c:	fb 01       	movw	r30, r22
    161e:	90 81       	ld	r25, Z
    1620:	99 23       	and	r25, r25
    1622:	81 f0       	breq	.+32     	; 0x1644 <_ZN5USART5printEPKc+0x2c>
    1624:	20 e0       	ldi	r18, 0x00	; 0
		while(~UCSR0A & (1 << UDRE0));			//wait till the transmit buffer is empty
    1626:	e0 ec       	ldi	r30, 0xC0	; 192
    1628:	f0 e0       	ldi	r31, 0x00	; 0
		UDR0 = (int)st[i];						//write the char in the transmit buffer
    162a:	c6 ec       	ldi	r28, 0xC6	; 198
    162c:	d0 e0       	ldi	r29, 0x00	; 0


//write a string in the Serial
void USART::print(const char st[]) {
	for(uint8_t i = 0 ; st[i] != 0 ; i++) {		//iterate over every char in the string
		while(~UCSR0A & (1 << UDRE0));			//wait till the transmit buffer is empty
    162e:	80 81       	ld	r24, Z
    1630:	85 ff       	sbrs	r24, 5
    1632:	fd cf       	rjmp	.-6      	; 0x162e <_ZN5USART5printEPKc+0x16>
		UDR0 = (int)st[i];						//write the char in the transmit buffer
    1634:	98 83       	st	Y, r25



//write a string in the Serial
void USART::print(const char st[]) {
	for(uint8_t i = 0 ; st[i] != 0 ; i++) {		//iterate over every char in the string
    1636:	2f 5f       	subi	r18, 0xFF	; 255
    1638:	db 01       	movw	r26, r22
    163a:	a2 0f       	add	r26, r18
    163c:	b1 1d       	adc	r27, r1
    163e:	9c 91       	ld	r25, X
    1640:	91 11       	cpse	r25, r1
    1642:	f5 cf       	rjmp	.-22     	; 0x162e <_ZN5USART5printEPKc+0x16>
		while(~UCSR0A & (1 << UDRE0));			//wait till the transmit buffer is empty
		UDR0 = (int)st[i];						//write the char in the transmit buffer
	}
}
    1644:	df 91       	pop	r29
    1646:	cf 91       	pop	r28
    1648:	08 95       	ret

0000164a <_ZN5USART7printlnEPKc>:

void USART::println(const char st[]){
    164a:	cf 93       	push	r28
    164c:	df 93       	push	r29
    164e:	ec 01       	movw	r28, r24
	this->print(st);
    1650:	e3 df       	rcall	.-58     	; 0x1618 <_ZN5USART5printEPKc>
	this->print("\n\r");
    1652:	60 e3       	ldi	r22, 0x30	; 48
    1654:	74 e0       	ldi	r23, 0x04	; 4
    1656:	ce 01       	movw	r24, r28
    1658:	df df       	rcall	.-66     	; 0x1618 <_ZN5USART5printEPKc>
}
    165a:	df 91       	pop	r29
    165c:	cf 91       	pop	r28
    165e:	08 95       	ret

00001660 <_ZN5USART5printEi>:

//write an integer in the Serial
void USART::print(int i) {
    1660:	0f 93       	push	r16
    1662:	1f 93       	push	r17
    1664:	cf 93       	push	r28
    1666:	df 93       	push	r29
    1668:	cd b7       	in	r28, 0x3d	; 61
    166a:	de b7       	in	r29, 0x3e	; 62
    166c:	60 97       	sbiw	r28, 0x10	; 16
    166e:	0f b6       	in	r0, 0x3f	; 63
    1670:	f8 94       	cli
    1672:	de bf       	out	0x3e, r29	; 62
    1674:	0f be       	out	0x3f, r0	; 63
    1676:	cd bf       	out	0x3d, r28	; 61
    1678:	8c 01       	movw	r16, r24
    167a:	cb 01       	movw	r24, r22
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    167c:	4a e0       	ldi	r20, 0x0A	; 10
    167e:	be 01       	movw	r22, r28
    1680:	6f 5f       	subi	r22, 0xFF	; 255
    1682:	7f 4f       	sbci	r23, 0xFF	; 255
    1684:	a2 d1       	rcall	.+836    	; 0x19ca <__itoa_ncheck>
	char buffer[16];							//create a string
	itoa(i,buffer,10);							//parse the integer into the string
	print(buffer);						//print the string
    1686:	be 01       	movw	r22, r28
    1688:	6f 5f       	subi	r22, 0xFF	; 255
    168a:	7f 4f       	sbci	r23, 0xFF	; 255
    168c:	c8 01       	movw	r24, r16
    168e:	c4 df       	rcall	.-120    	; 0x1618 <_ZN5USART5printEPKc>
}
    1690:	60 96       	adiw	r28, 0x10	; 16
    1692:	0f b6       	in	r0, 0x3f	; 63
    1694:	f8 94       	cli
    1696:	de bf       	out	0x3e, r29	; 62
    1698:	0f be       	out	0x3f, r0	; 63
    169a:	cd bf       	out	0x3d, r28	; 61
    169c:	df 91       	pop	r29
    169e:	cf 91       	pop	r28
    16a0:	1f 91       	pop	r17
    16a2:	0f 91       	pop	r16
    16a4:	08 95       	ret

000016a6 <_ZN5USART7printlnEi>:

void USART::println(int i){
    16a6:	cf 93       	push	r28
    16a8:	df 93       	push	r29
    16aa:	ec 01       	movw	r28, r24
	this->print(i);
    16ac:	d9 df       	rcall	.-78     	; 0x1660 <_ZN5USART5printEi>
	this->print("\n\r");
    16ae:	60 e3       	ldi	r22, 0x30	; 48
    16b0:	74 e0       	ldi	r23, 0x04	; 4
    16b2:	ce 01       	movw	r24, r28
    16b4:	b1 df       	rcall	.-158    	; 0x1618 <_ZN5USART5printEPKc>
}
    16b6:	df 91       	pop	r29
    16b8:	cf 91       	pop	r28
    16ba:	08 95       	ret

000016bc <__fixsfsi>:
    16bc:	04 d0       	rcall	.+8      	; 0x16c6 <__fixunssfsi>
    16be:	68 94       	set
    16c0:	b1 11       	cpse	r27, r1
    16c2:	8d c0       	rjmp	.+282    	; 0x17de <__fp_szero>
    16c4:	08 95       	ret

000016c6 <__fixunssfsi>:
    16c6:	70 d0       	rcall	.+224    	; 0x17a8 <__fp_splitA>
    16c8:	88 f0       	brcs	.+34     	; 0x16ec <__fixunssfsi+0x26>
    16ca:	9f 57       	subi	r25, 0x7F	; 127
    16cc:	90 f0       	brcs	.+36     	; 0x16f2 <__fixunssfsi+0x2c>
    16ce:	b9 2f       	mov	r27, r25
    16d0:	99 27       	eor	r25, r25
    16d2:	b7 51       	subi	r27, 0x17	; 23
    16d4:	a0 f0       	brcs	.+40     	; 0x16fe <__fixunssfsi+0x38>
    16d6:	d1 f0       	breq	.+52     	; 0x170c <__fixunssfsi+0x46>
    16d8:	66 0f       	add	r22, r22
    16da:	77 1f       	adc	r23, r23
    16dc:	88 1f       	adc	r24, r24
    16de:	99 1f       	adc	r25, r25
    16e0:	1a f0       	brmi	.+6      	; 0x16e8 <__fixunssfsi+0x22>
    16e2:	ba 95       	dec	r27
    16e4:	c9 f7       	brne	.-14     	; 0x16d8 <__fixunssfsi+0x12>
    16e6:	12 c0       	rjmp	.+36     	; 0x170c <__fixunssfsi+0x46>
    16e8:	b1 30       	cpi	r27, 0x01	; 1
    16ea:	81 f0       	breq	.+32     	; 0x170c <__fixunssfsi+0x46>
    16ec:	77 d0       	rcall	.+238    	; 0x17dc <__fp_zero>
    16ee:	b1 e0       	ldi	r27, 0x01	; 1
    16f0:	08 95       	ret
    16f2:	74 c0       	rjmp	.+232    	; 0x17dc <__fp_zero>
    16f4:	67 2f       	mov	r22, r23
    16f6:	78 2f       	mov	r23, r24
    16f8:	88 27       	eor	r24, r24
    16fa:	b8 5f       	subi	r27, 0xF8	; 248
    16fc:	39 f0       	breq	.+14     	; 0x170c <__fixunssfsi+0x46>
    16fe:	b9 3f       	cpi	r27, 0xF9	; 249
    1700:	cc f3       	brlt	.-14     	; 0x16f4 <__fixunssfsi+0x2e>
    1702:	86 95       	lsr	r24
    1704:	77 95       	ror	r23
    1706:	67 95       	ror	r22
    1708:	b3 95       	inc	r27
    170a:	d9 f7       	brne	.-10     	; 0x1702 <__fixunssfsi+0x3c>
    170c:	3e f4       	brtc	.+14     	; 0x171c <__fixunssfsi+0x56>
    170e:	90 95       	com	r25
    1710:	80 95       	com	r24
    1712:	70 95       	com	r23
    1714:	61 95       	neg	r22
    1716:	7f 4f       	sbci	r23, 0xFF	; 255
    1718:	8f 4f       	sbci	r24, 0xFF	; 255
    171a:	9f 4f       	sbci	r25, 0xFF	; 255
    171c:	08 95       	ret

0000171e <__floatunsisf>:
    171e:	e8 94       	clt
    1720:	09 c0       	rjmp	.+18     	; 0x1734 <__floatsisf+0x12>

00001722 <__floatsisf>:
    1722:	97 fb       	bst	r25, 7
    1724:	3e f4       	brtc	.+14     	; 0x1734 <__floatsisf+0x12>
    1726:	90 95       	com	r25
    1728:	80 95       	com	r24
    172a:	70 95       	com	r23
    172c:	61 95       	neg	r22
    172e:	7f 4f       	sbci	r23, 0xFF	; 255
    1730:	8f 4f       	sbci	r24, 0xFF	; 255
    1732:	9f 4f       	sbci	r25, 0xFF	; 255
    1734:	99 23       	and	r25, r25
    1736:	a9 f0       	breq	.+42     	; 0x1762 <__floatsisf+0x40>
    1738:	f9 2f       	mov	r31, r25
    173a:	96 e9       	ldi	r25, 0x96	; 150
    173c:	bb 27       	eor	r27, r27
    173e:	93 95       	inc	r25
    1740:	f6 95       	lsr	r31
    1742:	87 95       	ror	r24
    1744:	77 95       	ror	r23
    1746:	67 95       	ror	r22
    1748:	b7 95       	ror	r27
    174a:	f1 11       	cpse	r31, r1
    174c:	f8 cf       	rjmp	.-16     	; 0x173e <__floatsisf+0x1c>
    174e:	fa f4       	brpl	.+62     	; 0x178e <__floatsisf+0x6c>
    1750:	bb 0f       	add	r27, r27
    1752:	11 f4       	brne	.+4      	; 0x1758 <__floatsisf+0x36>
    1754:	60 ff       	sbrs	r22, 0
    1756:	1b c0       	rjmp	.+54     	; 0x178e <__floatsisf+0x6c>
    1758:	6f 5f       	subi	r22, 0xFF	; 255
    175a:	7f 4f       	sbci	r23, 0xFF	; 255
    175c:	8f 4f       	sbci	r24, 0xFF	; 255
    175e:	9f 4f       	sbci	r25, 0xFF	; 255
    1760:	16 c0       	rjmp	.+44     	; 0x178e <__floatsisf+0x6c>
    1762:	88 23       	and	r24, r24
    1764:	11 f0       	breq	.+4      	; 0x176a <__floatsisf+0x48>
    1766:	96 e9       	ldi	r25, 0x96	; 150
    1768:	11 c0       	rjmp	.+34     	; 0x178c <__floatsisf+0x6a>
    176a:	77 23       	and	r23, r23
    176c:	21 f0       	breq	.+8      	; 0x1776 <__floatsisf+0x54>
    176e:	9e e8       	ldi	r25, 0x8E	; 142
    1770:	87 2f       	mov	r24, r23
    1772:	76 2f       	mov	r23, r22
    1774:	05 c0       	rjmp	.+10     	; 0x1780 <__floatsisf+0x5e>
    1776:	66 23       	and	r22, r22
    1778:	71 f0       	breq	.+28     	; 0x1796 <__floatsisf+0x74>
    177a:	96 e8       	ldi	r25, 0x86	; 134
    177c:	86 2f       	mov	r24, r22
    177e:	70 e0       	ldi	r23, 0x00	; 0
    1780:	60 e0       	ldi	r22, 0x00	; 0
    1782:	2a f0       	brmi	.+10     	; 0x178e <__floatsisf+0x6c>
    1784:	9a 95       	dec	r25
    1786:	66 0f       	add	r22, r22
    1788:	77 1f       	adc	r23, r23
    178a:	88 1f       	adc	r24, r24
    178c:	da f7       	brpl	.-10     	; 0x1784 <__floatsisf+0x62>
    178e:	88 0f       	add	r24, r24
    1790:	96 95       	lsr	r25
    1792:	87 95       	ror	r24
    1794:	97 f9       	bld	r25, 7
    1796:	08 95       	ret

00001798 <__fp_split3>:
    1798:	57 fd       	sbrc	r21, 7
    179a:	90 58       	subi	r25, 0x80	; 128
    179c:	44 0f       	add	r20, r20
    179e:	55 1f       	adc	r21, r21
    17a0:	59 f0       	breq	.+22     	; 0x17b8 <__fp_splitA+0x10>
    17a2:	5f 3f       	cpi	r21, 0xFF	; 255
    17a4:	71 f0       	breq	.+28     	; 0x17c2 <__fp_splitA+0x1a>
    17a6:	47 95       	ror	r20

000017a8 <__fp_splitA>:
    17a8:	88 0f       	add	r24, r24
    17aa:	97 fb       	bst	r25, 7
    17ac:	99 1f       	adc	r25, r25
    17ae:	61 f0       	breq	.+24     	; 0x17c8 <__fp_splitA+0x20>
    17b0:	9f 3f       	cpi	r25, 0xFF	; 255
    17b2:	79 f0       	breq	.+30     	; 0x17d2 <__fp_splitA+0x2a>
    17b4:	87 95       	ror	r24
    17b6:	08 95       	ret
    17b8:	12 16       	cp	r1, r18
    17ba:	13 06       	cpc	r1, r19
    17bc:	14 06       	cpc	r1, r20
    17be:	55 1f       	adc	r21, r21
    17c0:	f2 cf       	rjmp	.-28     	; 0x17a6 <__fp_split3+0xe>
    17c2:	46 95       	lsr	r20
    17c4:	f1 df       	rcall	.-30     	; 0x17a8 <__fp_splitA>
    17c6:	08 c0       	rjmp	.+16     	; 0x17d8 <__fp_splitA+0x30>
    17c8:	16 16       	cp	r1, r22
    17ca:	17 06       	cpc	r1, r23
    17cc:	18 06       	cpc	r1, r24
    17ce:	99 1f       	adc	r25, r25
    17d0:	f1 cf       	rjmp	.-30     	; 0x17b4 <__fp_splitA+0xc>
    17d2:	86 95       	lsr	r24
    17d4:	71 05       	cpc	r23, r1
    17d6:	61 05       	cpc	r22, r1
    17d8:	08 94       	sec
    17da:	08 95       	ret

000017dc <__fp_zero>:
    17dc:	e8 94       	clt

000017de <__fp_szero>:
    17de:	bb 27       	eor	r27, r27
    17e0:	66 27       	eor	r22, r22
    17e2:	77 27       	eor	r23, r23
    17e4:	cb 01       	movw	r24, r22
    17e6:	97 f9       	bld	r25, 7
    17e8:	08 95       	ret

000017ea <__mulsf3>:
    17ea:	0b d0       	rcall	.+22     	; 0x1802 <__mulsf3x>
    17ec:	78 c0       	rjmp	.+240    	; 0x18de <__fp_round>
    17ee:	69 d0       	rcall	.+210    	; 0x18c2 <__fp_pscA>
    17f0:	28 f0       	brcs	.+10     	; 0x17fc <__mulsf3+0x12>
    17f2:	6e d0       	rcall	.+220    	; 0x18d0 <__fp_pscB>
    17f4:	18 f0       	brcs	.+6      	; 0x17fc <__mulsf3+0x12>
    17f6:	95 23       	and	r25, r21
    17f8:	09 f0       	breq	.+2      	; 0x17fc <__mulsf3+0x12>
    17fa:	5a c0       	rjmp	.+180    	; 0x18b0 <__fp_inf>
    17fc:	5f c0       	rjmp	.+190    	; 0x18bc <__fp_nan>
    17fe:	11 24       	eor	r1, r1
    1800:	ee cf       	rjmp	.-36     	; 0x17de <__fp_szero>

00001802 <__mulsf3x>:
    1802:	ca df       	rcall	.-108    	; 0x1798 <__fp_split3>
    1804:	a0 f3       	brcs	.-24     	; 0x17ee <__mulsf3+0x4>

00001806 <__mulsf3_pse>:
    1806:	95 9f       	mul	r25, r21
    1808:	d1 f3       	breq	.-12     	; 0x17fe <__mulsf3+0x14>
    180a:	95 0f       	add	r25, r21
    180c:	50 e0       	ldi	r21, 0x00	; 0
    180e:	55 1f       	adc	r21, r21
    1810:	62 9f       	mul	r22, r18
    1812:	f0 01       	movw	r30, r0
    1814:	72 9f       	mul	r23, r18
    1816:	bb 27       	eor	r27, r27
    1818:	f0 0d       	add	r31, r0
    181a:	b1 1d       	adc	r27, r1
    181c:	63 9f       	mul	r22, r19
    181e:	aa 27       	eor	r26, r26
    1820:	f0 0d       	add	r31, r0
    1822:	b1 1d       	adc	r27, r1
    1824:	aa 1f       	adc	r26, r26
    1826:	64 9f       	mul	r22, r20
    1828:	66 27       	eor	r22, r22
    182a:	b0 0d       	add	r27, r0
    182c:	a1 1d       	adc	r26, r1
    182e:	66 1f       	adc	r22, r22
    1830:	82 9f       	mul	r24, r18
    1832:	22 27       	eor	r18, r18
    1834:	b0 0d       	add	r27, r0
    1836:	a1 1d       	adc	r26, r1
    1838:	62 1f       	adc	r22, r18
    183a:	73 9f       	mul	r23, r19
    183c:	b0 0d       	add	r27, r0
    183e:	a1 1d       	adc	r26, r1
    1840:	62 1f       	adc	r22, r18
    1842:	83 9f       	mul	r24, r19
    1844:	a0 0d       	add	r26, r0
    1846:	61 1d       	adc	r22, r1
    1848:	22 1f       	adc	r18, r18
    184a:	74 9f       	mul	r23, r20
    184c:	33 27       	eor	r19, r19
    184e:	a0 0d       	add	r26, r0
    1850:	61 1d       	adc	r22, r1
    1852:	23 1f       	adc	r18, r19
    1854:	84 9f       	mul	r24, r20
    1856:	60 0d       	add	r22, r0
    1858:	21 1d       	adc	r18, r1
    185a:	82 2f       	mov	r24, r18
    185c:	76 2f       	mov	r23, r22
    185e:	6a 2f       	mov	r22, r26
    1860:	11 24       	eor	r1, r1
    1862:	9f 57       	subi	r25, 0x7F	; 127
    1864:	50 40       	sbci	r21, 0x00	; 0
    1866:	8a f0       	brmi	.+34     	; 0x188a <__mulsf3_pse+0x84>
    1868:	e1 f0       	breq	.+56     	; 0x18a2 <__mulsf3_pse+0x9c>
    186a:	88 23       	and	r24, r24
    186c:	4a f0       	brmi	.+18     	; 0x1880 <__mulsf3_pse+0x7a>
    186e:	ee 0f       	add	r30, r30
    1870:	ff 1f       	adc	r31, r31
    1872:	bb 1f       	adc	r27, r27
    1874:	66 1f       	adc	r22, r22
    1876:	77 1f       	adc	r23, r23
    1878:	88 1f       	adc	r24, r24
    187a:	91 50       	subi	r25, 0x01	; 1
    187c:	50 40       	sbci	r21, 0x00	; 0
    187e:	a9 f7       	brne	.-22     	; 0x186a <__mulsf3_pse+0x64>
    1880:	9e 3f       	cpi	r25, 0xFE	; 254
    1882:	51 05       	cpc	r21, r1
    1884:	70 f0       	brcs	.+28     	; 0x18a2 <__mulsf3_pse+0x9c>
    1886:	14 c0       	rjmp	.+40     	; 0x18b0 <__fp_inf>
    1888:	aa cf       	rjmp	.-172    	; 0x17de <__fp_szero>
    188a:	5f 3f       	cpi	r21, 0xFF	; 255
    188c:	ec f3       	brlt	.-6      	; 0x1888 <__mulsf3_pse+0x82>
    188e:	98 3e       	cpi	r25, 0xE8	; 232
    1890:	dc f3       	brlt	.-10     	; 0x1888 <__mulsf3_pse+0x82>
    1892:	86 95       	lsr	r24
    1894:	77 95       	ror	r23
    1896:	67 95       	ror	r22
    1898:	b7 95       	ror	r27
    189a:	f7 95       	ror	r31
    189c:	e7 95       	ror	r30
    189e:	9f 5f       	subi	r25, 0xFF	; 255
    18a0:	c1 f7       	brne	.-16     	; 0x1892 <__mulsf3_pse+0x8c>
    18a2:	fe 2b       	or	r31, r30
    18a4:	88 0f       	add	r24, r24
    18a6:	91 1d       	adc	r25, r1
    18a8:	96 95       	lsr	r25
    18aa:	87 95       	ror	r24
    18ac:	97 f9       	bld	r25, 7
    18ae:	08 95       	ret

000018b0 <__fp_inf>:
    18b0:	97 f9       	bld	r25, 7
    18b2:	9f 67       	ori	r25, 0x7F	; 127
    18b4:	80 e8       	ldi	r24, 0x80	; 128
    18b6:	70 e0       	ldi	r23, 0x00	; 0
    18b8:	60 e0       	ldi	r22, 0x00	; 0
    18ba:	08 95       	ret

000018bc <__fp_nan>:
    18bc:	9f ef       	ldi	r25, 0xFF	; 255
    18be:	80 ec       	ldi	r24, 0xC0	; 192
    18c0:	08 95       	ret

000018c2 <__fp_pscA>:
    18c2:	00 24       	eor	r0, r0
    18c4:	0a 94       	dec	r0
    18c6:	16 16       	cp	r1, r22
    18c8:	17 06       	cpc	r1, r23
    18ca:	18 06       	cpc	r1, r24
    18cc:	09 06       	cpc	r0, r25
    18ce:	08 95       	ret

000018d0 <__fp_pscB>:
    18d0:	00 24       	eor	r0, r0
    18d2:	0a 94       	dec	r0
    18d4:	12 16       	cp	r1, r18
    18d6:	13 06       	cpc	r1, r19
    18d8:	14 06       	cpc	r1, r20
    18da:	05 06       	cpc	r0, r21
    18dc:	08 95       	ret

000018de <__fp_round>:
    18de:	09 2e       	mov	r0, r25
    18e0:	03 94       	inc	r0
    18e2:	00 0c       	add	r0, r0
    18e4:	11 f4       	brne	.+4      	; 0x18ea <__fp_round+0xc>
    18e6:	88 23       	and	r24, r24
    18e8:	52 f0       	brmi	.+20     	; 0x18fe <__fp_round+0x20>
    18ea:	bb 0f       	add	r27, r27
    18ec:	40 f4       	brcc	.+16     	; 0x18fe <__fp_round+0x20>
    18ee:	bf 2b       	or	r27, r31
    18f0:	11 f4       	brne	.+4      	; 0x18f6 <__fp_round+0x18>
    18f2:	60 ff       	sbrs	r22, 0
    18f4:	04 c0       	rjmp	.+8      	; 0x18fe <__fp_round+0x20>
    18f6:	6f 5f       	subi	r22, 0xFF	; 255
    18f8:	7f 4f       	sbci	r23, 0xFF	; 255
    18fa:	8f 4f       	sbci	r24, 0xFF	; 255
    18fc:	9f 4f       	sbci	r25, 0xFF	; 255
    18fe:	08 95       	ret

00001900 <__divmodsi4>:
    1900:	05 2e       	mov	r0, r21
    1902:	97 fb       	bst	r25, 7
    1904:	16 f4       	brtc	.+4      	; 0x190a <__divmodsi4+0xa>
    1906:	00 94       	com	r0
    1908:	0f d0       	rcall	.+30     	; 0x1928 <__negsi2>
    190a:	57 fd       	sbrc	r21, 7
    190c:	05 d0       	rcall	.+10     	; 0x1918 <__divmodsi4_neg2>
    190e:	2c d0       	rcall	.+88     	; 0x1968 <__udivmodsi4>
    1910:	07 fc       	sbrc	r0, 7
    1912:	02 d0       	rcall	.+4      	; 0x1918 <__divmodsi4_neg2>
    1914:	46 f4       	brtc	.+16     	; 0x1926 <__divmodsi4_exit>
    1916:	08 c0       	rjmp	.+16     	; 0x1928 <__negsi2>

00001918 <__divmodsi4_neg2>:
    1918:	50 95       	com	r21
    191a:	40 95       	com	r20
    191c:	30 95       	com	r19
    191e:	21 95       	neg	r18
    1920:	3f 4f       	sbci	r19, 0xFF	; 255
    1922:	4f 4f       	sbci	r20, 0xFF	; 255
    1924:	5f 4f       	sbci	r21, 0xFF	; 255

00001926 <__divmodsi4_exit>:
    1926:	08 95       	ret

00001928 <__negsi2>:
    1928:	90 95       	com	r25
    192a:	80 95       	com	r24
    192c:	70 95       	com	r23
    192e:	61 95       	neg	r22
    1930:	7f 4f       	sbci	r23, 0xFF	; 255
    1932:	8f 4f       	sbci	r24, 0xFF	; 255
    1934:	9f 4f       	sbci	r25, 0xFF	; 255
    1936:	08 95       	ret

00001938 <__tablejump2__>:
    1938:	ee 0f       	add	r30, r30
    193a:	ff 1f       	adc	r31, r31
    193c:	88 1f       	adc	r24, r24
    193e:	8b bf       	out	0x3b, r24	; 59
    1940:	07 90       	elpm	r0, Z+
    1942:	f6 91       	elpm	r31, Z
    1944:	e0 2d       	mov	r30, r0
    1946:	19 94       	eijmp

00001948 <__usmulhisi3>:
    1948:	31 d0       	rcall	.+98     	; 0x19ac <__umulhisi3>

0000194a <__usmulhisi3_tail>:
    194a:	b7 ff       	sbrs	r27, 7
    194c:	08 95       	ret
    194e:	82 1b       	sub	r24, r18
    1950:	93 0b       	sbc	r25, r19
    1952:	08 95       	ret

00001954 <__muluhisi3>:
    1954:	2b d0       	rcall	.+86     	; 0x19ac <__umulhisi3>
    1956:	a5 9f       	mul	r26, r21
    1958:	90 0d       	add	r25, r0
    195a:	b4 9f       	mul	r27, r20
    195c:	90 0d       	add	r25, r0
    195e:	a4 9f       	mul	r26, r20
    1960:	80 0d       	add	r24, r0
    1962:	91 1d       	adc	r25, r1
    1964:	11 24       	eor	r1, r1
    1966:	08 95       	ret

00001968 <__udivmodsi4>:
    1968:	a1 e2       	ldi	r26, 0x21	; 33
    196a:	1a 2e       	mov	r1, r26
    196c:	aa 1b       	sub	r26, r26
    196e:	bb 1b       	sub	r27, r27
    1970:	fd 01       	movw	r30, r26
    1972:	0d c0       	rjmp	.+26     	; 0x198e <__udivmodsi4_ep>

00001974 <__udivmodsi4_loop>:
    1974:	aa 1f       	adc	r26, r26
    1976:	bb 1f       	adc	r27, r27
    1978:	ee 1f       	adc	r30, r30
    197a:	ff 1f       	adc	r31, r31
    197c:	a2 17       	cp	r26, r18
    197e:	b3 07       	cpc	r27, r19
    1980:	e4 07       	cpc	r30, r20
    1982:	f5 07       	cpc	r31, r21
    1984:	20 f0       	brcs	.+8      	; 0x198e <__udivmodsi4_ep>
    1986:	a2 1b       	sub	r26, r18
    1988:	b3 0b       	sbc	r27, r19
    198a:	e4 0b       	sbc	r30, r20
    198c:	f5 0b       	sbc	r31, r21

0000198e <__udivmodsi4_ep>:
    198e:	66 1f       	adc	r22, r22
    1990:	77 1f       	adc	r23, r23
    1992:	88 1f       	adc	r24, r24
    1994:	99 1f       	adc	r25, r25
    1996:	1a 94       	dec	r1
    1998:	69 f7       	brne	.-38     	; 0x1974 <__udivmodsi4_loop>
    199a:	60 95       	com	r22
    199c:	70 95       	com	r23
    199e:	80 95       	com	r24
    19a0:	90 95       	com	r25
    19a2:	9b 01       	movw	r18, r22
    19a4:	ac 01       	movw	r20, r24
    19a6:	bd 01       	movw	r22, r26
    19a8:	cf 01       	movw	r24, r30
    19aa:	08 95       	ret

000019ac <__umulhisi3>:
    19ac:	a2 9f       	mul	r26, r18
    19ae:	b0 01       	movw	r22, r0
    19b0:	b3 9f       	mul	r27, r19
    19b2:	c0 01       	movw	r24, r0
    19b4:	a3 9f       	mul	r26, r19
    19b6:	70 0d       	add	r23, r0
    19b8:	81 1d       	adc	r24, r1
    19ba:	11 24       	eor	r1, r1
    19bc:	91 1d       	adc	r25, r1
    19be:	b2 9f       	mul	r27, r18
    19c0:	70 0d       	add	r23, r0
    19c2:	81 1d       	adc	r24, r1
    19c4:	11 24       	eor	r1, r1
    19c6:	91 1d       	adc	r25, r1
    19c8:	08 95       	ret

000019ca <__itoa_ncheck>:
    19ca:	bb 27       	eor	r27, r27
    19cc:	4a 30       	cpi	r20, 0x0A	; 10
    19ce:	31 f4       	brne	.+12     	; 0x19dc <__itoa_ncheck+0x12>
    19d0:	99 23       	and	r25, r25
    19d2:	22 f4       	brpl	.+8      	; 0x19dc <__itoa_ncheck+0x12>
    19d4:	bd e2       	ldi	r27, 0x2D	; 45
    19d6:	90 95       	com	r25
    19d8:	81 95       	neg	r24
    19da:	9f 4f       	sbci	r25, 0xFF	; 255
    19dc:	01 c0       	rjmp	.+2      	; 0x19e0 <__utoa_common>

000019de <__utoa_ncheck>:
    19de:	bb 27       	eor	r27, r27

000019e0 <__utoa_common>:
    19e0:	fb 01       	movw	r30, r22
    19e2:	55 27       	eor	r21, r21
    19e4:	aa 27       	eor	r26, r26
    19e6:	88 0f       	add	r24, r24
    19e8:	99 1f       	adc	r25, r25
    19ea:	aa 1f       	adc	r26, r26
    19ec:	a4 17       	cp	r26, r20
    19ee:	10 f0       	brcs	.+4      	; 0x19f4 <__utoa_common+0x14>
    19f0:	a4 1b       	sub	r26, r20
    19f2:	83 95       	inc	r24
    19f4:	50 51       	subi	r21, 0x10	; 16
    19f6:	b9 f7       	brne	.-18     	; 0x19e6 <__utoa_common+0x6>
    19f8:	a0 5d       	subi	r26, 0xD0	; 208
    19fa:	aa 33       	cpi	r26, 0x3A	; 58
    19fc:	08 f0       	brcs	.+2      	; 0x1a00 <__utoa_common+0x20>
    19fe:	a9 5d       	subi	r26, 0xD9	; 217
    1a00:	a1 93       	st	Z+, r26
    1a02:	00 97       	sbiw	r24, 0x00	; 0
    1a04:	79 f7       	brne	.-34     	; 0x19e4 <__utoa_common+0x4>
    1a06:	b1 11       	cpse	r27, r1
    1a08:	b1 93       	st	Z+, r27
    1a0a:	11 92       	st	Z+, r1
    1a0c:	cb 01       	movw	r24, r22
    1a0e:	00 c0       	rjmp	.+0      	; 0x1a10 <strrev>

00001a10 <strrev>:
    1a10:	dc 01       	movw	r26, r24
    1a12:	fc 01       	movw	r30, r24
    1a14:	67 2f       	mov	r22, r23
    1a16:	71 91       	ld	r23, Z+
    1a18:	77 23       	and	r23, r23
    1a1a:	e1 f7       	brne	.-8      	; 0x1a14 <strrev+0x4>
    1a1c:	32 97       	sbiw	r30, 0x02	; 2
    1a1e:	04 c0       	rjmp	.+8      	; 0x1a28 <strrev+0x18>
    1a20:	7c 91       	ld	r23, X
    1a22:	6d 93       	st	X+, r22
    1a24:	70 83       	st	Z, r23
    1a26:	62 91       	ld	r22, -Z
    1a28:	ae 17       	cp	r26, r30
    1a2a:	bf 07       	cpc	r27, r31
    1a2c:	c8 f3       	brcs	.-14     	; 0x1a20 <strrev+0x10>
    1a2e:	08 95       	ret

00001a30 <_exit>:
    1a30:	f8 94       	cli

00001a32 <__stop_program>:
    1a32:	ff cf       	rjmp	.-2      	; 0x1a32 <__stop_program>
