
Alley Hoop V2.1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000023e  00800200  00001a24  00001ab8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001a24  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000059  0080043e  0080043e  00001cf6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001cf6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001d28  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000238  00000000  00000000  00001d68  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004645  00000000  00000000  00001fa0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000179d  00000000  00000000  000065e5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000173f  00000000  00000000  00007d82  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000670  00000000  00000000  000094c4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001148  00000000  00000000  00009b34  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001ef8  00000000  00000000  0000ac7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001f0  00000000  00000000  0000cb74  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	7d c0       	rjmp	.+250    	; 0xfc <__ctors_end>
       2:	00 00       	nop
       4:	ab c0       	rjmp	.+342    	; 0x15c <__bad_interrupt>
       6:	00 00       	nop
       8:	a9 c0       	rjmp	.+338    	; 0x15c <__bad_interrupt>
       a:	00 00       	nop
       c:	a7 c0       	rjmp	.+334    	; 0x15c <__bad_interrupt>
       e:	00 00       	nop
      10:	a5 c0       	rjmp	.+330    	; 0x15c <__bad_interrupt>
      12:	00 00       	nop
      14:	a3 c0       	rjmp	.+326    	; 0x15c <__bad_interrupt>
      16:	00 00       	nop
      18:	a1 c0       	rjmp	.+322    	; 0x15c <__bad_interrupt>
      1a:	00 00       	nop
      1c:	9f c0       	rjmp	.+318    	; 0x15c <__bad_interrupt>
      1e:	00 00       	nop
      20:	9d c0       	rjmp	.+314    	; 0x15c <__bad_interrupt>
      22:	00 00       	nop
      24:	9b c0       	rjmp	.+310    	; 0x15c <__bad_interrupt>
      26:	00 00       	nop
      28:	99 c0       	rjmp	.+306    	; 0x15c <__bad_interrupt>
      2a:	00 00       	nop
      2c:	97 c0       	rjmp	.+302    	; 0x15c <__bad_interrupt>
      2e:	00 00       	nop
      30:	95 c0       	rjmp	.+298    	; 0x15c <__bad_interrupt>
      32:	00 00       	nop
      34:	93 c0       	rjmp	.+294    	; 0x15c <__bad_interrupt>
      36:	00 00       	nop
      38:	91 c0       	rjmp	.+290    	; 0x15c <__bad_interrupt>
      3a:	00 00       	nop
      3c:	8f c0       	rjmp	.+286    	; 0x15c <__bad_interrupt>
      3e:	00 00       	nop
      40:	8d c0       	rjmp	.+282    	; 0x15c <__bad_interrupt>
      42:	00 00       	nop
      44:	8b c0       	rjmp	.+278    	; 0x15c <__bad_interrupt>
      46:	00 00       	nop
      48:	89 c0       	rjmp	.+274    	; 0x15c <__bad_interrupt>
      4a:	00 00       	nop
      4c:	87 c0       	rjmp	.+270    	; 0x15c <__bad_interrupt>
      4e:	00 00       	nop
      50:	85 c0       	rjmp	.+266    	; 0x15c <__bad_interrupt>
      52:	00 00       	nop
      54:	83 c0       	rjmp	.+262    	; 0x15c <__bad_interrupt>
      56:	00 00       	nop
      58:	81 c0       	rjmp	.+258    	; 0x15c <__bad_interrupt>
      5a:	00 00       	nop
      5c:	7f c0       	rjmp	.+254    	; 0x15c <__bad_interrupt>
      5e:	00 00       	nop
      60:	7d c0       	rjmp	.+250    	; 0x15c <__bad_interrupt>
      62:	00 00       	nop
      64:	7b c0       	rjmp	.+246    	; 0x15c <__bad_interrupt>
      66:	00 00       	nop
      68:	79 c0       	rjmp	.+242    	; 0x15c <__bad_interrupt>
      6a:	00 00       	nop
      6c:	77 c0       	rjmp	.+238    	; 0x15c <__bad_interrupt>
      6e:	00 00       	nop
      70:	75 c0       	rjmp	.+234    	; 0x15c <__bad_interrupt>
      72:	00 00       	nop
      74:	73 c0       	rjmp	.+230    	; 0x15c <__bad_interrupt>
      76:	00 00       	nop
      78:	71 c0       	rjmp	.+226    	; 0x15c <__bad_interrupt>
      7a:	00 00       	nop
      7c:	6f c0       	rjmp	.+222    	; 0x15c <__bad_interrupt>
      7e:	00 00       	nop
      80:	6d c0       	rjmp	.+218    	; 0x15c <__bad_interrupt>
      82:	00 00       	nop
      84:	6b c0       	rjmp	.+214    	; 0x15c <__bad_interrupt>
      86:	00 00       	nop
      88:	69 c0       	rjmp	.+210    	; 0x15c <__bad_interrupt>
      8a:	00 00       	nop
      8c:	67 c0       	rjmp	.+206    	; 0x15c <__bad_interrupt>
      8e:	00 00       	nop
      90:	65 c0       	rjmp	.+202    	; 0x15c <__bad_interrupt>
      92:	00 00       	nop
      94:	63 c0       	rjmp	.+198    	; 0x15c <__bad_interrupt>
      96:	00 00       	nop
      98:	61 c0       	rjmp	.+194    	; 0x15c <__bad_interrupt>
      9a:	00 00       	nop
      9c:	5f c0       	rjmp	.+190    	; 0x15c <__bad_interrupt>
      9e:	00 00       	nop
      a0:	5d c0       	rjmp	.+186    	; 0x15c <__bad_interrupt>
      a2:	00 00       	nop
      a4:	5b c0       	rjmp	.+182    	; 0x15c <__bad_interrupt>
      a6:	00 00       	nop
      a8:	59 c0       	rjmp	.+178    	; 0x15c <__bad_interrupt>
      aa:	00 00       	nop
      ac:	57 c0       	rjmp	.+174    	; 0x15c <__bad_interrupt>
      ae:	00 00       	nop
      b0:	55 c0       	rjmp	.+170    	; 0x15c <__bad_interrupt>
      b2:	00 00       	nop
      b4:	53 c0       	rjmp	.+166    	; 0x15c <__bad_interrupt>
      b6:	00 00       	nop
      b8:	51 c0       	rjmp	.+162    	; 0x15c <__bad_interrupt>
      ba:	00 00       	nop
      bc:	4f c0       	rjmp	.+158    	; 0x15c <__bad_interrupt>
      be:	00 00       	nop
      c0:	4d c0       	rjmp	.+154    	; 0x15c <__bad_interrupt>
      c2:	00 00       	nop
      c4:	4b c0       	rjmp	.+150    	; 0x15c <__bad_interrupt>
      c6:	00 00       	nop
      c8:	49 c0       	rjmp	.+146    	; 0x15c <__bad_interrupt>
      ca:	00 00       	nop
      cc:	47 c0       	rjmp	.+142    	; 0x15c <__bad_interrupt>
      ce:	00 00       	nop
      d0:	45 c0       	rjmp	.+138    	; 0x15c <__bad_interrupt>
      d2:	00 00       	nop
      d4:	43 c0       	rjmp	.+134    	; 0x15c <__bad_interrupt>
      d6:	00 00       	nop
      d8:	41 c0       	rjmp	.+130    	; 0x15c <__bad_interrupt>
      da:	00 00       	nop
      dc:	3f c0       	rjmp	.+126    	; 0x15c <__bad_interrupt>
      de:	00 00       	nop
      e0:	3d c0       	rjmp	.+122    	; 0x15c <__bad_interrupt>
      e2:	00 00       	nop
      e4:	ef 03       	fmulsu	r22, r23
      e6:	f4 03       	fmuls	r23, r20
      e8:	f9 03       	fmulsu	r23, r17
      ea:	fb 03       	fmulsu	r23, r19
      ec:	00 04       	cpc	r0, r0
      ee:	05 04       	cpc	r0, r5
      f0:	0a 04       	cpc	r0, r10
      f2:	0f 04       	cpc	r0, r15
      f4:	12 04       	cpc	r1, r2
      f6:	15 04       	cpc	r1, r5
      f8:	1a 04       	cpc	r1, r10

000000fa <__ctors_start>:
      fa:	cd 06       	cpc	r12, r29

000000fc <__ctors_end>:
      fc:	11 24       	eor	r1, r1
      fe:	1f be       	out	0x3f, r1	; 63
     100:	cf ef       	ldi	r28, 0xFF	; 255
     102:	d1 e2       	ldi	r29, 0x21	; 33
     104:	de bf       	out	0x3e, r29	; 62
     106:	cd bf       	out	0x3d, r28	; 61
     108:	00 e0       	ldi	r16, 0x00	; 0
     10a:	0c bf       	out	0x3c, r16	; 60

0000010c <__do_copy_data>:
     10c:	14 e0       	ldi	r17, 0x04	; 4
     10e:	a0 e0       	ldi	r26, 0x00	; 0
     110:	b2 e0       	ldi	r27, 0x02	; 2
     112:	e4 e2       	ldi	r30, 0x24	; 36
     114:	fa e1       	ldi	r31, 0x1A	; 26
     116:	00 e0       	ldi	r16, 0x00	; 0
     118:	0b bf       	out	0x3b, r16	; 59
     11a:	02 c0       	rjmp	.+4      	; 0x120 <__do_copy_data+0x14>
     11c:	07 90       	elpm	r0, Z+
     11e:	0d 92       	st	X+, r0
     120:	ae 33       	cpi	r26, 0x3E	; 62
     122:	b1 07       	cpc	r27, r17
     124:	d9 f7       	brne	.-10     	; 0x11c <__do_copy_data+0x10>

00000126 <__do_clear_bss>:
     126:	24 e0       	ldi	r18, 0x04	; 4
     128:	ae e3       	ldi	r26, 0x3E	; 62
     12a:	b4 e0       	ldi	r27, 0x04	; 4
     12c:	01 c0       	rjmp	.+2      	; 0x130 <.do_clear_bss_start>

0000012e <.do_clear_bss_loop>:
     12e:	1d 92       	st	X+, r1

00000130 <.do_clear_bss_start>:
     130:	a7 39       	cpi	r26, 0x97	; 151
     132:	b2 07       	cpc	r27, r18
     134:	e1 f7       	brne	.-8      	; 0x12e <.do_clear_bss_loop>

00000136 <__do_global_ctors>:
     136:	10 e0       	ldi	r17, 0x00	; 0
     138:	ce e7       	ldi	r28, 0x7E	; 126
     13a:	d0 e0       	ldi	r29, 0x00	; 0
     13c:	00 e0       	ldi	r16, 0x00	; 0
     13e:	06 c0       	rjmp	.+12     	; 0x14c <__do_global_ctors+0x16>
     140:	21 97       	sbiw	r28, 0x01	; 1
     142:	01 09       	sbc	r16, r1
     144:	80 2f       	mov	r24, r16
     146:	fe 01       	movw	r30, r28
     148:	0e 94 94 0c 	call	0x1928	; 0x1928 <__tablejump2__>
     14c:	cd 37       	cpi	r28, 0x7D	; 125
     14e:	d1 07       	cpc	r29, r17
     150:	80 e0       	ldi	r24, 0x00	; 0
     152:	08 07       	cpc	r16, r24
     154:	a9 f7       	brne	.-22     	; 0x140 <__do_global_ctors+0xa>
     156:	ff d5       	rcall	.+3070   	; 0xd56 <main>
     158:	0c 94 10 0d 	jmp	0x1a20	; 0x1a20 <_exit>

0000015c <__bad_interrupt>:
     15c:	51 cf       	rjmp	.-350    	; 0x0 <__vectors>

0000015e <_Z11mode_selectv>:
	if(engine_rpm==0){
		digitalWrite(do_hv_relais,LOW);
	}
}

void mode_remote(){
     15e:	8b e2       	ldi	r24, 0x2B	; 43
     160:	90 e0       	ldi	r25, 0x00	; 0
     162:	42 d4       	rcall	.+2180   	; 0x9e8 <_Z11digitalReadi>
     164:	88 23       	and	r24, r24
     166:	39 f0       	breq	.+14     	; 0x176 <_Z11mode_selectv+0x18>
     168:	81 e0       	ldi	r24, 0x01	; 1
     16a:	90 e0       	ldi	r25, 0x00	; 0
     16c:	90 93 74 04 	sts	0x0474, r25	; 0x800474 <drivemode+0x1>
     170:	80 93 73 04 	sts	0x0473, r24	; 0x800473 <drivemode>
     174:	08 95       	ret
     176:	88 e2       	ldi	r24, 0x28	; 40
     178:	90 e0       	ldi	r25, 0x00	; 0
     17a:	36 d4       	rcall	.+2156   	; 0x9e8 <_Z11digitalReadi>
     17c:	88 23       	and	r24, r24
     17e:	39 f0       	breq	.+14     	; 0x18e <_Z11mode_selectv+0x30>
     180:	82 e0       	ldi	r24, 0x02	; 2
     182:	90 e0       	ldi	r25, 0x00	; 0
     184:	90 93 74 04 	sts	0x0474, r25	; 0x800474 <drivemode+0x1>
     188:	80 93 73 04 	sts	0x0473, r24	; 0x800473 <drivemode>
     18c:	08 95       	ret
     18e:	89 e2       	ldi	r24, 0x29	; 41
     190:	90 e0       	ldi	r25, 0x00	; 0
     192:	2a d4       	rcall	.+2132   	; 0x9e8 <_Z11digitalReadi>
     194:	88 23       	and	r24, r24
     196:	39 f0       	breq	.+14     	; 0x1a6 <_Z11mode_selectv+0x48>
     198:	83 e0       	ldi	r24, 0x03	; 3
     19a:	90 e0       	ldi	r25, 0x00	; 0
     19c:	90 93 74 04 	sts	0x0474, r25	; 0x800474 <drivemode+0x1>
     1a0:	80 93 73 04 	sts	0x0473, r24	; 0x800473 <drivemode>
     1a4:	08 95       	ret
     1a6:	10 92 74 04 	sts	0x0474, r1	; 0x800474 <drivemode+0x1>
     1aa:	10 92 73 04 	sts	0x0473, r1	; 0x800473 <drivemode>
     1ae:	08 95       	ret

000001b0 <_Z9initDrivev>:
     1b0:	61 e0       	ldi	r22, 0x01	; 1
     1b2:	8a e1       	ldi	r24, 0x1A	; 26
     1b4:	90 e0       	ldi	r25, 0x00	; 0
     1b6:	49 d3       	rcall	.+1682   	; 0x84a <_Z12digitalWriteib>
     1b8:	61 e0       	ldi	r22, 0x01	; 1
     1ba:	88 e1       	ldi	r24, 0x18	; 24
     1bc:	90 e0       	ldi	r25, 0x00	; 0
     1be:	45 d3       	rcall	.+1674   	; 0x84a <_Z12digitalWriteib>
     1c0:	61 e0       	ldi	r22, 0x01	; 1
     1c2:	89 e1       	ldi	r24, 0x19	; 25
     1c4:	90 e0       	ldi	r25, 0x00	; 0
     1c6:	41 d3       	rcall	.+1666   	; 0x84a <_Z12digitalWriteib>
     1c8:	61 e0       	ldi	r22, 0x01	; 1
     1ca:	86 e1       	ldi	r24, 0x16	; 22
     1cc:	90 e0       	ldi	r25, 0x00	; 0
     1ce:	3d d3       	rcall	.+1658   	; 0x84a <_Z12digitalWriteib>
     1d0:	61 e0       	ldi	r22, 0x01	; 1
     1d2:	87 e1       	ldi	r24, 0x17	; 23
     1d4:	90 e0       	ldi	r25, 0x00	; 0
     1d6:	39 d3       	rcall	.+1650   	; 0x84a <_Z12digitalWriteib>
     1d8:	61 e0       	ldi	r22, 0x01	; 1
     1da:	82 e2       	ldi	r24, 0x22	; 34
     1dc:	90 e0       	ldi	r25, 0x00	; 0
     1de:	35 d3       	rcall	.+1642   	; 0x84a <_Z12digitalWriteib>
     1e0:	be cf       	rjmp	.-132    	; 0x15e <_Z11mode_selectv>
     1e2:	08 95       	ret

000001e4 <_Z13mode_joystickv>:
     1e4:	61 e0       	ldi	r22, 0x01	; 1
     1e6:	81 e2       	ldi	r24, 0x21	; 33
     1e8:	90 e0       	ldi	r25, 0x00	; 0
     1ea:	2f d3       	rcall	.+1630   	; 0x84a <_Z12digitalWriteib>
     1ec:	80 91 44 04 	lds	r24, 0x0444	; 0x800444 <engine_rpm>
     1f0:	90 91 45 04 	lds	r25, 0x0445	; 0x800445 <engine_rpm+0x1>
     1f4:	89 2b       	or	r24, r25
     1f6:	29 f4       	brne	.+10     	; 0x202 <_Z13mode_joystickv+0x1e>
     1f8:	8a e2       	ldi	r24, 0x2A	; 42
     1fa:	90 e0       	ldi	r25, 0x00	; 0
     1fc:	f5 d3       	rcall	.+2026   	; 0x9e8 <_Z11digitalReadi>
     1fe:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
     202:	84 e0       	ldi	r24, 0x04	; 4
     204:	90 e0       	ldi	r25, 0x00	; 0
     206:	6c d4       	rcall	.+2264   	; 0xae0 <_Z10analogReadi>
     208:	dc 01       	movw	r26, r24
     20a:	ab 5f       	subi	r26, 0xFB	; 251
     20c:	b1 40       	sbci	r27, 0x01	; 1
     20e:	2e e5       	ldi	r18, 0x5E	; 94
     210:	31 e0       	ldi	r19, 0x01	; 1
     212:	0e 94 9c 0c 	call	0x1938	; 0x1938 <__usmulhisi3>
     216:	29 e8       	ldi	r18, 0x89	; 137
     218:	30 e0       	ldi	r19, 0x00	; 0
     21a:	40 e0       	ldi	r20, 0x00	; 0
     21c:	50 e0       	ldi	r21, 0x00	; 0
     21e:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <__divmodsi4>
     222:	20 93 6b 04 	sts	0x046B, r18	; 0x80046b <steering_dv>
     226:	30 93 6c 04 	sts	0x046C, r19	; 0x80046c <steering_dv+0x1>
     22a:	40 93 6d 04 	sts	0x046D, r20	; 0x80046d <steering_dv+0x2>
     22e:	50 93 6e 04 	sts	0x046E, r21	; 0x80046e <steering_dv+0x3>
     232:	82 e0       	ldi	r24, 0x02	; 2
     234:	90 e0       	ldi	r25, 0x00	; 0
     236:	54 d4       	rcall	.+2216   	; 0xae0 <_Z10analogReadi>
     238:	8e 5f       	subi	r24, 0xFE	; 254
     23a:	91 40       	sbci	r25, 0x01	; 1
     23c:	9c 01       	movw	r18, r24
     23e:	2c 5f       	subi	r18, 0xFC	; 252
     240:	3f 4f       	sbci	r19, 0xFF	; 255
     242:	29 30       	cpi	r18, 0x09	; 9
     244:	31 05       	cpc	r19, r1
     246:	68 f0       	brcs	.+26     	; 0x262 <_Z13mode_joystickv+0x7e>
     248:	09 2e       	mov	r0, r25
     24a:	00 0c       	add	r0, r0
     24c:	aa 0b       	sbc	r26, r26
     24e:	bb 0b       	sbc	r27, r27
     250:	80 93 6f 04 	sts	0x046F, r24	; 0x80046f <driving_dv>
     254:	90 93 70 04 	sts	0x0470, r25	; 0x800470 <driving_dv+0x1>
     258:	a0 93 71 04 	sts	0x0471, r26	; 0x800471 <driving_dv+0x2>
     25c:	b0 93 72 04 	sts	0x0472, r27	; 0x800472 <driving_dv+0x3>
     260:	08 c0       	rjmp	.+16     	; 0x272 <_Z13mode_joystickv+0x8e>
     262:	10 92 6f 04 	sts	0x046F, r1	; 0x80046f <driving_dv>
     266:	10 92 70 04 	sts	0x0470, r1	; 0x800470 <driving_dv+0x1>
     26a:	10 92 71 04 	sts	0x0471, r1	; 0x800471 <driving_dv+0x2>
     26e:	10 92 72 04 	sts	0x0472, r1	; 0x800472 <driving_dv+0x3>
     272:	10 92 5e 04 	sts	0x045E, r1	; 0x80045e <engine_dv>
     276:	10 92 5f 04 	sts	0x045F, r1	; 0x80045f <engine_dv+0x1>
     27a:	10 92 60 04 	sts	0x0460, r1	; 0x800460 <engine_dv+0x2>
     27e:	10 92 61 04 	sts	0x0461, r1	; 0x800461 <engine_dv+0x3>
     282:	10 92 51 04 	sts	0x0451, r1	; 0x800451 <braking_dv>
     286:	10 92 52 04 	sts	0x0452, r1	; 0x800452 <braking_dv+0x1>
     28a:	10 92 53 04 	sts	0x0453, r1	; 0x800453 <braking_dv+0x2>
     28e:	10 92 54 04 	sts	0x0454, r1	; 0x800454 <braking_dv+0x3>
     292:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__data_start>
     296:	88 23       	and	r24, r24
     298:	51 f1       	breq	.+84     	; 0x2ee <_Z13mode_joystickv+0x10a>
     29a:	80 91 6f 04 	lds	r24, 0x046F	; 0x80046f <driving_dv>
     29e:	90 91 70 04 	lds	r25, 0x0470	; 0x800470 <driving_dv+0x1>
     2a2:	a0 91 71 04 	lds	r26, 0x0471	; 0x800471 <driving_dv+0x2>
     2a6:	b0 91 72 04 	lds	r27, 0x0472	; 0x800472 <driving_dv+0x3>
     2aa:	18 16       	cp	r1, r24
     2ac:	19 06       	cpc	r1, r25
     2ae:	1a 06       	cpc	r1, r26
     2b0:	1b 06       	cpc	r1, r27
     2b2:	4c f4       	brge	.+18     	; 0x2c6 <_Z13mode_joystickv+0xe2>
     2b4:	80 93 5e 04 	sts	0x045E, r24	; 0x80045e <engine_dv>
     2b8:	90 93 5f 04 	sts	0x045F, r25	; 0x80045f <engine_dv+0x1>
     2bc:	a0 93 60 04 	sts	0x0460, r26	; 0x800460 <engine_dv+0x2>
     2c0:	b0 93 61 04 	sts	0x0461, r27	; 0x800461 <engine_dv+0x3>
     2c4:	08 95       	ret
     2c6:	9c 01       	movw	r18, r24
     2c8:	99 23       	and	r25, r25
     2ca:	24 f4       	brge	.+8      	; 0x2d4 <_Z13mode_joystickv+0xf0>
     2cc:	22 27       	eor	r18, r18
     2ce:	33 27       	eor	r19, r19
     2d0:	28 1b       	sub	r18, r24
     2d2:	39 0b       	sbc	r19, r25
     2d4:	c9 01       	movw	r24, r18
     2d6:	33 0f       	add	r19, r19
     2d8:	aa 0b       	sbc	r26, r26
     2da:	bb 0b       	sbc	r27, r27
     2dc:	80 93 51 04 	sts	0x0451, r24	; 0x800451 <braking_dv>
     2e0:	90 93 52 04 	sts	0x0452, r25	; 0x800452 <braking_dv+0x1>
     2e4:	a0 93 53 04 	sts	0x0453, r26	; 0x800453 <braking_dv+0x2>
     2e8:	b0 93 54 04 	sts	0x0454, r27	; 0x800454 <braking_dv+0x3>
     2ec:	08 95       	ret
     2ee:	80 91 6f 04 	lds	r24, 0x046F	; 0x80046f <driving_dv>
     2f2:	90 91 70 04 	lds	r25, 0x0470	; 0x800470 <driving_dv+0x1>
     2f6:	a0 91 71 04 	lds	r26, 0x0471	; 0x800471 <driving_dv+0x2>
     2fa:	b0 91 72 04 	lds	r27, 0x0472	; 0x800472 <driving_dv+0x3>
     2fe:	18 16       	cp	r1, r24
     300:	19 06       	cpc	r1, r25
     302:	1a 06       	cpc	r1, r26
     304:	1b 06       	cpc	r1, r27
     306:	4c f4       	brge	.+18     	; 0x31a <_Z13mode_joystickv+0x136>
     308:	80 93 51 04 	sts	0x0451, r24	; 0x800451 <braking_dv>
     30c:	90 93 52 04 	sts	0x0452, r25	; 0x800452 <braking_dv+0x1>
     310:	a0 93 53 04 	sts	0x0453, r26	; 0x800453 <braking_dv+0x2>
     314:	b0 93 54 04 	sts	0x0454, r27	; 0x800454 <braking_dv+0x3>
     318:	08 95       	ret
     31a:	9c 01       	movw	r18, r24
     31c:	99 23       	and	r25, r25
     31e:	24 f4       	brge	.+8      	; 0x328 <_Z13mode_joystickv+0x144>
     320:	22 27       	eor	r18, r18
     322:	33 27       	eor	r19, r19
     324:	28 1b       	sub	r18, r24
     326:	39 0b       	sbc	r19, r25
     328:	c9 01       	movw	r24, r18
     32a:	33 0f       	add	r19, r19
     32c:	aa 0b       	sbc	r26, r26
     32e:	bb 0b       	sbc	r27, r27
     330:	80 93 5e 04 	sts	0x045E, r24	; 0x80045e <engine_dv>
     334:	90 93 5f 04 	sts	0x045F, r25	; 0x80045f <engine_dv+0x1>
     338:	a0 93 60 04 	sts	0x0460, r26	; 0x800460 <engine_dv+0x2>
     33c:	b0 93 61 04 	sts	0x0461, r27	; 0x800461 <engine_dv+0x3>
     340:	08 95       	ret

00000342 <_Z9mode_idlev>:
     342:	10 92 5e 04 	sts	0x045E, r1	; 0x80045e <engine_dv>
     346:	10 92 5f 04 	sts	0x045F, r1	; 0x80045f <engine_dv+0x1>
     34a:	10 92 60 04 	sts	0x0460, r1	; 0x800460 <engine_dv+0x2>
     34e:	10 92 61 04 	sts	0x0461, r1	; 0x800461 <engine_dv+0x3>
     352:	10 92 6b 04 	sts	0x046B, r1	; 0x80046b <steering_dv>
     356:	10 92 6c 04 	sts	0x046C, r1	; 0x80046c <steering_dv+0x1>
     35a:	10 92 6d 04 	sts	0x046D, r1	; 0x80046d <steering_dv+0x2>
     35e:	10 92 6e 04 	sts	0x046E, r1	; 0x80046e <steering_dv+0x3>
     362:	10 92 51 04 	sts	0x0451, r1	; 0x800451 <braking_dv>
     366:	10 92 52 04 	sts	0x0452, r1	; 0x800452 <braking_dv+0x1>
     36a:	10 92 53 04 	sts	0x0453, r1	; 0x800453 <braking_dv+0x2>
     36e:	10 92 54 04 	sts	0x0454, r1	; 0x800454 <braking_dv+0x3>
     372:	80 91 44 04 	lds	r24, 0x0444	; 0x800444 <engine_rpm>
     376:	90 91 45 04 	lds	r25, 0x0445	; 0x800445 <engine_rpm+0x1>
     37a:	89 2b       	or	r24, r25
     37c:	21 f4       	brne	.+8      	; 0x386 <_Z9mode_idlev+0x44>
     37e:	60 e0       	ldi	r22, 0x00	; 0
     380:	81 e2       	ldi	r24, 0x21	; 33
     382:	90 e0       	ldi	r25, 0x00	; 0
     384:	62 c2       	rjmp	.+1220   	; 0x84a <_Z12digitalWriteib>
     386:	08 95       	ret

00000388 <_Z9run_brakev>:
	//digitalWrite(do_hv_relais,HIGH);
	//not (yet) implemented
}

void run_brake(){
	braking_cv = (long(analogRead(ai_brake_pressure) - braking_sensor_offset) * (250 / 1023));				//retrieve the current value of the brake pressure sensor
     388:	81 e0       	ldi	r24, 0x01	; 1
     38a:	90 e0       	ldi	r25, 0x00	; 0
     38c:	a9 d3       	rcall	.+1874   	; 0xae0 <_Z10analogReadi>
     38e:	10 92 49 04 	sts	0x0449, r1	; 0x800449 <braking_cv>
     392:	10 92 4a 04 	sts	0x044A, r1	; 0x80044a <braking_cv+0x1>
     396:	10 92 4b 04 	sts	0x044B, r1	; 0x80044b <braking_cv+0x2>
     39a:	10 92 4c 04 	sts	0x044C, r1	; 0x80044c <braking_cv+0x3>
	braking_delta = braking_dv - braking_cv;
     39e:	40 91 51 04 	lds	r20, 0x0451	; 0x800451 <braking_dv>
     3a2:	50 91 52 04 	lds	r21, 0x0452	; 0x800452 <braking_dv+0x1>
     3a6:	60 91 53 04 	lds	r22, 0x0453	; 0x800453 <braking_dv+0x2>
     3aa:	70 91 54 04 	lds	r23, 0x0454	; 0x800454 <braking_dv+0x3>
	if(abs(braking_delta)<10)
     3ae:	ca 01       	movw	r24, r20
     3b0:	09 96       	adiw	r24, 0x09	; 9
     3b2:	43 97       	sbiw	r24, 0x13	; 19
     3b4:	48 f0       	brcs	.+18     	; 0x3c8 <_Z9run_brakev+0x40>
	//not (yet) implemented
}

void run_brake(){
	braking_cv = (long(analogRead(ai_brake_pressure) - braking_sensor_offset) * (250 / 1023));				//retrieve the current value of the brake pressure sensor
	braking_delta = braking_dv - braking_cv;
     3b6:	40 93 4d 04 	sts	0x044D, r20	; 0x80044d <braking_delta>
     3ba:	50 93 4e 04 	sts	0x044E, r21	; 0x80044e <braking_delta+0x1>
     3be:	60 93 4f 04 	sts	0x044F, r22	; 0x80044f <braking_delta+0x2>
     3c2:	70 93 50 04 	sts	0x0450, r23	; 0x800450 <braking_delta+0x3>
     3c6:	08 c0       	rjmp	.+16     	; 0x3d8 <_Z9run_brakev+0x50>
	if(abs(braking_delta)<10)
		braking_delta = 0;
     3c8:	10 92 4d 04 	sts	0x044D, r1	; 0x80044d <braking_delta>
     3cc:	10 92 4e 04 	sts	0x044E, r1	; 0x80044e <braking_delta+0x1>
     3d0:	10 92 4f 04 	sts	0x044F, r1	; 0x80044f <braking_delta+0x2>
     3d4:	10 92 50 04 	sts	0x0450, r1	; 0x800450 <braking_delta+0x3>
	braking_ov =  constrain(braking_dv * braking_kp, 0, 255);
     3d8:	db 01       	movw	r26, r22
     3da:	ca 01       	movw	r24, r20
     3dc:	88 0f       	add	r24, r24
     3de:	99 1f       	adc	r25, r25
     3e0:	aa 1f       	adc	r26, r26
     3e2:	bb 1f       	adc	r27, r27
     3e4:	84 0f       	add	r24, r20
     3e6:	95 1f       	adc	r25, r21
     3e8:	a6 1f       	adc	r26, r22
     3ea:	b7 1f       	adc	r27, r23
     3ec:	bb 23       	and	r27, r27
     3ee:	5c f0       	brlt	.+22     	; 0x406 <__LOCK_REGION_LENGTH__+0x6>
     3f0:	8f 3f       	cpi	r24, 0xFF	; 255
     3f2:	91 05       	cpc	r25, r1
     3f4:	a1 05       	cpc	r26, r1
     3f6:	b1 05       	cpc	r27, r1
     3f8:	39 f0       	breq	.+14     	; 0x408 <__LOCK_REGION_LENGTH__+0x8>
     3fa:	34 f0       	brlt	.+12     	; 0x408 <__LOCK_REGION_LENGTH__+0x8>
     3fc:	8f ef       	ldi	r24, 0xFF	; 255
     3fe:	90 e0       	ldi	r25, 0x00	; 0
     400:	a0 e0       	ldi	r26, 0x00	; 0
     402:	b0 e0       	ldi	r27, 0x00	; 0
     404:	01 c0       	rjmp	.+2      	; 0x408 <__LOCK_REGION_LENGTH__+0x8>
     406:	80 e0       	ldi	r24, 0x00	; 0
     408:	80 93 48 04 	sts	0x0448, r24	; 0x800448 <braking_ov>
	analogWrite(pwm_brake_pump, braking_dv);															//Write op to brake pump
     40c:	ba 01       	movw	r22, r20
     40e:	87 e0       	ldi	r24, 0x07	; 7
     410:	90 e0       	ldi	r25, 0x00	; 0
     412:	d4 c1       	rjmp	.+936    	; 0x7bc <_Z11analogWriteii>
     414:	08 95       	ret

00000416 <_Z9run_steerv>:
}

void run_steer(){
     416:	0f 93       	push	r16
     418:	1f 93       	push	r17
	steering_cv = -(long(analogRead(ai_steer_pot)- steering_sensor_offset) * 1000/1023);				//retrieve the current value of the steering potentiometer and convert it to 10th of degrees
     41a:	80 e0       	ldi	r24, 0x00	; 0
     41c:	90 e0       	ldi	r25, 0x00	; 0
     41e:	60 d3       	rcall	.+1728   	; 0xae0 <_Z10analogReadi>
     420:	dc 01       	movw	r26, r24
     422:	b2 50       	subi	r27, 0x02	; 2
     424:	28 ee       	ldi	r18, 0xE8	; 232
     426:	33 e0       	ldi	r19, 0x03	; 3
     428:	0e 94 9c 0c 	call	0x1938	; 0x1938 <__usmulhisi3>
     42c:	2f ef       	ldi	r18, 0xFF	; 255
     42e:	33 e0       	ldi	r19, 0x03	; 3
     430:	40 e0       	ldi	r20, 0x00	; 0
     432:	50 e0       	ldi	r21, 0x00	; 0
     434:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <__divmodsi4>
     438:	88 27       	eor	r24, r24
     43a:	99 27       	eor	r25, r25
     43c:	dc 01       	movw	r26, r24
     43e:	82 1b       	sub	r24, r18
     440:	93 0b       	sbc	r25, r19
     442:	a4 0b       	sbc	r26, r20
     444:	b5 0b       	sbc	r27, r21
     446:	80 93 63 04 	sts	0x0463, r24	; 0x800463 <steering_cv>
     44a:	90 93 64 04 	sts	0x0464, r25	; 0x800464 <steering_cv+0x1>
     44e:	a0 93 65 04 	sts	0x0465, r26	; 0x800465 <steering_cv+0x2>
     452:	b0 93 66 04 	sts	0x0466, r27	; 0x800466 <steering_cv+0x3>
	if(abs(steering_dv)<steering_deadzone)																//create a dead zone around default joystick position, desired value must at least be bigger then dead zone value (makes going straight easier
     456:	80 91 6b 04 	lds	r24, 0x046B	; 0x80046b <steering_dv>
     45a:	90 91 6c 04 	lds	r25, 0x046C	; 0x80046c <steering_dv+0x1>
     45e:	c1 96       	adiw	r24, 0x31	; 49
     460:	83 36       	cpi	r24, 0x63	; 99
     462:	91 05       	cpc	r25, r1
     464:	40 f4       	brcc	.+16     	; 0x476 <_Z9run_steerv+0x60>
		steering_dv = 0;
     466:	10 92 6b 04 	sts	0x046B, r1	; 0x80046b <steering_dv>
     46a:	10 92 6c 04 	sts	0x046C, r1	; 0x80046c <steering_dv+0x1>
     46e:	10 92 6d 04 	sts	0x046D, r1	; 0x80046d <steering_dv+0x2>
     472:	10 92 6e 04 	sts	0x046E, r1	; 0x80046e <steering_dv+0x3>
	steering_delta = steering_dv - steering_cv;															//difference between desired value and current value
     476:	80 91 6b 04 	lds	r24, 0x046B	; 0x80046b <steering_dv>
     47a:	90 91 6c 04 	lds	r25, 0x046C	; 0x80046c <steering_dv+0x1>
     47e:	a0 91 6d 04 	lds	r26, 0x046D	; 0x80046d <steering_dv+0x2>
     482:	b0 91 6e 04 	lds	r27, 0x046E	; 0x80046e <steering_dv+0x3>
     486:	89 01       	movw	r16, r18
     488:	9a 01       	movw	r18, r20
     48a:	08 0f       	add	r16, r24
     48c:	19 1f       	adc	r17, r25
     48e:	2a 1f       	adc	r18, r26
     490:	3b 1f       	adc	r19, r27
     492:	00 93 67 04 	sts	0x0467, r16	; 0x800467 <steering_delta>
     496:	10 93 68 04 	sts	0x0468, r17	; 0x800468 <steering_delta+0x1>
     49a:	20 93 69 04 	sts	0x0469, r18	; 0x800469 <steering_delta+0x2>
     49e:	30 93 6a 04 	sts	0x046A, r19	; 0x80046a <steering_delta+0x3>
	if(abs(steering_delta)<10)																			//if the two are too close together, don't steer, this to prevent the motor from constantly trying to make small movements which it is not capable of, so it starts skreeching
     4a2:	c8 01       	movw	r24, r16
     4a4:	09 96       	adiw	r24, 0x09	; 9
     4a6:	43 97       	sbiw	r24, 0x13	; 19
     4a8:	70 f4       	brcc	.+28     	; 0x4c6 <_Z9run_steerv+0xb0>
		steering_delta=0;
     4aa:	10 92 67 04 	sts	0x0467, r1	; 0x800467 <steering_delta>
     4ae:	10 92 68 04 	sts	0x0468, r1	; 0x800468 <steering_delta+0x1>
     4b2:	10 92 69 04 	sts	0x0469, r1	; 0x800469 <steering_delta+0x2>
     4b6:	10 92 6a 04 	sts	0x046A, r1	; 0x80046a <steering_delta+0x3>
	steering_ov = constrain((abs(steering_delta) * steering_kp), 0, 255);								//determine the output PMW value in such a way that the smaller the delta, the slower it goes to smooth out steering
     4ba:	60 e0       	ldi	r22, 0x00	; 0
     4bc:	70 e0       	ldi	r23, 0x00	; 0
     4be:	00 e0       	ldi	r16, 0x00	; 0
     4c0:	10 e0       	ldi	r17, 0x00	; 0
     4c2:	98 01       	movw	r18, r16
     4c4:	11 c0       	rjmp	.+34     	; 0x4e8 <_Z9run_steerv+0xd2>
     4c6:	c8 01       	movw	r24, r16
     4c8:	99 23       	and	r25, r25
     4ca:	24 f4       	brge	.+8      	; 0x4d4 <_Z9run_steerv+0xbe>
     4cc:	88 27       	eor	r24, r24
     4ce:	99 27       	eor	r25, r25
     4d0:	80 1b       	sub	r24, r16
     4d2:	91 0b       	sbc	r25, r17
     4d4:	bc 01       	movw	r22, r24
     4d6:	66 0f       	add	r22, r22
     4d8:	77 1f       	adc	r23, r23
     4da:	66 0f       	add	r22, r22
     4dc:	77 1f       	adc	r23, r23
     4de:	66 0f       	add	r22, r22
     4e0:	77 1f       	adc	r23, r23
     4e2:	68 1b       	sub	r22, r24
     4e4:	79 0b       	sbc	r23, r25
     4e6:	3a f0       	brmi	.+14     	; 0x4f6 <_Z9run_steerv+0xe0>
     4e8:	6f 3f       	cpi	r22, 0xFF	; 255
     4ea:	71 05       	cpc	r23, r1
     4ec:	29 f0       	breq	.+10     	; 0x4f8 <_Z9run_steerv+0xe2>
     4ee:	24 f0       	brlt	.+8      	; 0x4f8 <_Z9run_steerv+0xe2>
     4f0:	6f ef       	ldi	r22, 0xFF	; 255
     4f2:	70 e0       	ldi	r23, 0x00	; 0
     4f4:	01 c0       	rjmp	.+2      	; 0x4f8 <_Z9run_steerv+0xe2>
     4f6:	60 e0       	ldi	r22, 0x00	; 0
     4f8:	60 93 62 04 	sts	0x0462, r22	; 0x800462 <steering_ov>
	if (steering_delta < 0) {																			//H bridge settings, let the engine turn the correct way
     4fc:	33 23       	and	r19, r19
     4fe:	54 f4       	brge	.+20     	; 0x514 <_Z9run_steerv+0xfe>
		analogWrite(pwm_steer_rpwm, steering_ov);														
     500:	70 e0       	ldi	r23, 0x00	; 0
     502:	83 e0       	ldi	r24, 0x03	; 3
     504:	90 e0       	ldi	r25, 0x00	; 0
     506:	5a d1       	rcall	.+692    	; 0x7bc <_Z11analogWriteii>
		analogWrite(pwm_steer_lpwm, 0);
     508:	60 e0       	ldi	r22, 0x00	; 0
     50a:	70 e0       	ldi	r23, 0x00	; 0
     50c:	82 e0       	ldi	r24, 0x02	; 2
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	55 d1       	rcall	.+682    	; 0x7bc <_Z11analogWriteii>
     512:	1b c0       	rjmp	.+54     	; 0x54a <_Z9run_steerv+0x134>
	}
	else if (steering_delta > 0) {
     514:	10 16       	cp	r1, r16
     516:	11 06       	cpc	r1, r17
     518:	12 06       	cpc	r1, r18
     51a:	13 06       	cpc	r1, r19
     51c:	64 f4       	brge	.+24     	; 0x536 <_Z9run_steerv+0x120>
		analogWrite(pwm_steer_rpwm, 0);
     51e:	60 e0       	ldi	r22, 0x00	; 0
     520:	70 e0       	ldi	r23, 0x00	; 0
     522:	83 e0       	ldi	r24, 0x03	; 3
     524:	90 e0       	ldi	r25, 0x00	; 0
     526:	4a d1       	rcall	.+660    	; 0x7bc <_Z11analogWriteii>
		analogWrite(pwm_steer_lpwm, steering_ov);
     528:	60 91 62 04 	lds	r22, 0x0462	; 0x800462 <steering_ov>
     52c:	70 e0       	ldi	r23, 0x00	; 0
     52e:	82 e0       	ldi	r24, 0x02	; 2
     530:	90 e0       	ldi	r25, 0x00	; 0
     532:	44 d1       	rcall	.+648    	; 0x7bc <_Z11analogWriteii>
     534:	0a c0       	rjmp	.+20     	; 0x54a <_Z9run_steerv+0x134>
	}
	else {
		analogWrite(pwm_steer_rpwm, 0);
     536:	60 e0       	ldi	r22, 0x00	; 0
     538:	70 e0       	ldi	r23, 0x00	; 0
     53a:	83 e0       	ldi	r24, 0x03	; 3
     53c:	90 e0       	ldi	r25, 0x00	; 0
     53e:	3e d1       	rcall	.+636    	; 0x7bc <_Z11analogWriteii>
		analogWrite(pwm_steer_lpwm, 0);
     540:	60 e0       	ldi	r22, 0x00	; 0
     542:	70 e0       	ldi	r23, 0x00	; 0
     544:	82 e0       	ldi	r24, 0x02	; 2
     546:	90 e0       	ldi	r25, 0x00	; 0
     548:	39 d1       	rcall	.+626    	; 0x7bc <_Z11analogWriteii>
     54a:	1f 91       	pop	r17
	}	
}
     54c:	0f 91       	pop	r16
     54e:	08 95       	ret

00000550 <_Z10run_curtisv>:
     550:	60 91 44 04 	lds	r22, 0x0444	; 0x800444 <engine_rpm>

void run_curtis(){
	engine_cv = (engine_rpm * float(100 / 1023));												//the proces value of the engine system is the rpm which we read from the CAN-bus of the curtis
     554:	70 91 45 04 	lds	r23, 0x0445	; 0x800445 <engine_rpm+0x1>
     558:	80 e0       	ldi	r24, 0x00	; 0
     55a:	90 e0       	ldi	r25, 0x00	; 0
     55c:	0e 94 87 0b 	call	0x170e	; 0x170e <__floatunsisf>
     560:	20 e0       	ldi	r18, 0x00	; 0
     562:	30 e0       	ldi	r19, 0x00	; 0
     564:	a9 01       	movw	r20, r18
     566:	0e 94 ed 0b 	call	0x17da	; 0x17da <__mulsf3>
     56a:	0e 94 56 0b 	call	0x16ac	; 0x16ac <__fixsfsi>
     56e:	60 93 56 04 	sts	0x0456, r22	; 0x800456 <engine_cv>
     572:	70 93 57 04 	sts	0x0457, r23	; 0x800457 <engine_cv+0x1>
     576:	80 93 58 04 	sts	0x0458, r24	; 0x800458 <engine_cv+0x2>
     57a:	90 93 59 04 	sts	0x0459, r25	; 0x800459 <engine_cv+0x3>
	digitalWrite(do_drive_forward,  driving_direction);											//give the curtiss the correct driving direction
     57e:	60 91 00 02 	lds	r22, 0x0200	; 0x800200 <__data_start>
     582:	8b e1       	ldi	r24, 0x1B	; 27
     584:	90 e0       	ldi	r25, 0x00	; 0
     586:	61 d1       	rcall	.+706    	; 0x84a <_Z12digitalWriteib>
	digitalWrite(do_drive_reverse,  !driving_direction);
     588:	60 91 00 02 	lds	r22, 0x0200	; 0x800200 <__data_start>
     58c:	81 e0       	ldi	r24, 0x01	; 1
     58e:	68 27       	eor	r22, r24
     590:	8c e1       	ldi	r24, 0x1C	; 28
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	5a d1       	rcall	.+692    	; 0x84a <_Z12digitalWriteib>
	
	//Set the curtis in the right mode for braking, driving or neutral																		//if we want to brake
		digitalWrite(do_drive_throttleswitch, engine_dv);				//if there is an engine signal, enable listening to the throttle
     596:	61 e0       	ldi	r22, 0x01	; 1
     598:	80 91 5e 04 	lds	r24, 0x045E	; 0x80045e <engine_dv>
     59c:	90 91 5f 04 	lds	r25, 0x045F	; 0x80045f <engine_dv+0x1>
     5a0:	a0 91 60 04 	lds	r26, 0x0460	; 0x800460 <engine_dv+0x2>
     5a4:	b0 91 61 04 	lds	r27, 0x0461	; 0x800461 <engine_dv+0x3>
     5a8:	89 2b       	or	r24, r25
     5aa:	8a 2b       	or	r24, r26
     5ac:	8b 2b       	or	r24, r27
     5ae:	09 f4       	brne	.+2      	; 0x5b2 <_Z10run_curtisv+0x62>
     5b0:	60 e0       	ldi	r22, 0x00	; 0
     5b2:	8e e1       	ldi	r24, 0x1E	; 30
     5b4:	90 e0       	ldi	r25, 0x00	; 0
     5b6:	49 d1       	rcall	.+658    	; 0x84a <_Z12digitalWriteib>
		digitalWrite(do_drive_brake, braking_dv);						//if there is an braking signal, turn on the braking 
     5b8:	61 e0       	ldi	r22, 0x01	; 1
     5ba:	80 91 51 04 	lds	r24, 0x0451	; 0x800451 <braking_dv>
     5be:	90 91 52 04 	lds	r25, 0x0452	; 0x800452 <braking_dv+0x1>
     5c2:	a0 91 53 04 	lds	r26, 0x0453	; 0x800453 <braking_dv+0x2>
     5c6:	b0 91 54 04 	lds	r27, 0x0454	; 0x800454 <braking_dv+0x3>
     5ca:	89 2b       	or	r24, r25
     5cc:	8a 2b       	or	r24, r26
     5ce:	8b 2b       	or	r24, r27
     5d0:	09 f4       	brne	.+2      	; 0x5d4 <_Z10run_curtisv+0x84>
     5d2:	60 e0       	ldi	r22, 0x00	; 0
     5d4:	8d e1       	ldi	r24, 0x1D	; 29
     5d6:	90 e0       	ldi	r25, 0x00	; 0
     5d8:	38 d1       	rcall	.+624    	; 0x84a <_Z12digitalWriteib>

	engine_delta = engine_dv - engine_cv;									//calculate delta
     5da:	40 91 5e 04 	lds	r20, 0x045E	; 0x80045e <engine_dv>
     5de:	50 91 5f 04 	lds	r21, 0x045F	; 0x80045f <engine_dv+0x1>
     5e2:	60 91 60 04 	lds	r22, 0x0460	; 0x800460 <engine_dv+0x2>
     5e6:	70 91 61 04 	lds	r23, 0x0461	; 0x800461 <engine_dv+0x3>
     5ea:	80 91 56 04 	lds	r24, 0x0456	; 0x800456 <engine_cv>
     5ee:	90 91 57 04 	lds	r25, 0x0457	; 0x800457 <engine_cv+0x1>
     5f2:	a0 91 58 04 	lds	r26, 0x0458	; 0x800458 <engine_cv+0x2>
     5f6:	b0 91 59 04 	lds	r27, 0x0459	; 0x800459 <engine_cv+0x3>
     5fa:	9a 01       	movw	r18, r20
     5fc:	ab 01       	movw	r20, r22
     5fe:	28 1b       	sub	r18, r24
     600:	39 0b       	sbc	r19, r25
     602:	4a 0b       	sbc	r20, r26
     604:	5b 0b       	sbc	r21, r27
     606:	20 93 5a 04 	sts	0x045A, r18	; 0x80045a <engine_delta>
     60a:	30 93 5b 04 	sts	0x045B, r19	; 0x80045b <engine_delta+0x1>
     60e:	40 93 5c 04 	sts	0x045C, r20	; 0x80045c <engine_delta+0x2>
     612:	50 93 5d 04 	sts	0x045D, r21	; 0x80045d <engine_delta+0x3>
	engine_ov = constrain(engine_delta * engine_kp * 255 / 100, 0, 255);	//calculate output value
     616:	ad ef       	ldi	r26, 0xFD	; 253
     618:	b2 e0       	ldi	r27, 0x02	; 2
     61a:	0e 94 a2 0c 	call	0x1944	; 0x1944 <__muluhisi3>
     61e:	6d 39       	cpi	r22, 0x9D	; 157
     620:	2f ef       	ldi	r18, 0xFF	; 255
     622:	72 07       	cpc	r23, r18
     624:	82 07       	cpc	r24, r18
     626:	92 07       	cpc	r25, r18
     628:	6c f0       	brlt	.+26     	; 0x644 <_Z10run_curtisv+0xf4>
     62a:	61 15       	cp	r22, r1
     62c:	24 e6       	ldi	r18, 0x64	; 100
     62e:	72 07       	cpc	r23, r18
     630:	81 05       	cpc	r24, r1
     632:	91 05       	cpc	r25, r1
     634:	4c f4       	brge	.+18     	; 0x648 <_Z10run_curtisv+0xf8>
     636:	24 e6       	ldi	r18, 0x64	; 100
     638:	30 e0       	ldi	r19, 0x00	; 0
     63a:	40 e0       	ldi	r20, 0x00	; 0
     63c:	50 e0       	ldi	r21, 0x00	; 0
     63e:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <__divmodsi4>
     642:	03 c0       	rjmp	.+6      	; 0x64a <_Z10run_curtisv+0xfa>
     644:	20 e0       	ldi	r18, 0x00	; 0
     646:	01 c0       	rjmp	.+2      	; 0x64a <_Z10run_curtisv+0xfa>
     648:	2f ef       	ldi	r18, 0xFF	; 255
     64a:	20 93 55 04 	sts	0x0455, r18	; 0x800455 <engine_ov>
	analogWrite(pwm_drive_throttle, engine_ov);								//Write op to throttle signal of curtis
     64e:	62 2f       	mov	r22, r18
     650:	70 e0       	ldi	r23, 0x00	; 0
     652:	88 e0       	ldi	r24, 0x08	; 8
     654:	90 e0       	ldi	r25, 0x00	; 0
     656:	b2 c0       	rjmp	.+356    	; 0x7bc <_Z11analogWriteii>
     658:	08 95       	ret

0000065a <_Z5drivev>:
	}
}

void drive(){
	//get correct driving input parameters from selected source (remote and auto not implemented, thus being interpreted as idle)
	mode_select();
     65a:	81 dd       	rcall	.-1278   	; 0x15e <_Z11mode_selectv>
	switch(drivemode){
     65c:	80 91 73 04 	lds	r24, 0x0473	; 0x800473 <drivemode>
     660:	90 91 74 04 	lds	r25, 0x0474	; 0x800474 <drivemode+0x1>
     664:	81 30       	cpi	r24, 0x01	; 1
     666:	91 05       	cpc	r25, r1
     668:	51 f0       	breq	.+20     	; 0x67e <_Z5drivev+0x24>
     66a:	1c f4       	brge	.+6      	; 0x672 <_Z5drivev+0x18>
     66c:	89 2b       	or	r24, r25
     66e:	49 f0       	breq	.+18     	; 0x682 <_Z5drivev+0x28>
     670:	0d c0       	rjmp	.+26     	; 0x68c <_Z5drivev+0x32>
     672:	82 30       	cpi	r24, 0x02	; 2
     674:	91 05       	cpc	r25, r1
     676:	49 f0       	breq	.+18     	; 0x68a <_Z5drivev+0x30>
     678:	03 97       	sbiw	r24, 0x03	; 3
     67a:	29 f0       	breq	.+10     	; 0x686 <_Z5drivev+0x2c>
		case drivemode_joystick:
			mode_joystick();
     67c:	07 c0       	rjmp	.+14     	; 0x68c <_Z5drivev+0x32>
			break;
     67e:	b2 dd       	rcall	.-1180   	; 0x1e4 <_Z13mode_joystickv>
		case drivemode_idle:
			mode_idle();		
     680:	05 c0       	rjmp	.+10     	; 0x68c <_Z5drivev+0x32>
			break;
		case drivemode_auto:
			mode_idle();		//not yet implemented
     682:	5f de       	rcall	.-834    	; 0x342 <_Z9mode_idlev>
			break;
		case drivemode_remote:
			mode_idle();		//not yet implemented
     684:	03 c0       	rjmp	.+6      	; 0x68c <_Z5drivev+0x32>
     686:	5d de       	rcall	.-838    	; 0x342 <_Z9mode_idlev>
			break;	
	}
	run_steer();				//update the steering system
     688:	01 c0       	rjmp	.+2      	; 0x68c <_Z5drivev+0x32>
     68a:	5b de       	rcall	.-842    	; 0x342 <_Z9mode_idlev>
	run_brake();				//update the braking system
     68c:	c4 de       	rcall	.-632    	; 0x416 <_Z9run_steerv>
     68e:	7c de       	rcall	.-776    	; 0x388 <_Z9run_brakev>
	run_curtis();				//update the curtiss
     690:	5f cf       	rjmp	.-322    	; 0x550 <_Z10run_curtisv>
     692:	08 95       	ret

00000694 <_Z6initIOv>:
     694:	cf 93       	push	r28
#include "IOPins.h"

//this funcion should be called when initializng the program. It writes the correct settings to the registry, allowing the use of analog and digital reading and writing of pins.
void initIO(){
     696:	df 93       	push	r29
	Serial.println("Applying IO settings...");
     698:	61 e0       	ldi	r22, 0x01	; 1
     69a:	72 e0       	ldi	r23, 0x02	; 2
     69c:	84 e9       	ldi	r24, 0x94	; 148
     69e:	94 e0       	ldi	r25, 0x04	; 4
     6a0:	cc d7       	rcall	.+3992   	; 0x163a <_ZN5USART7printlnEPKc>
	//Read/Write pins
	//////////////////////////////////////
	//Disable the pullup resistor in these pins, making them output by writing a 1 to their respective registry entries. Pins not written to default to input pins.
	//when adding/altering pins, alter them in the respective switch case as well.
	//digitalwrite
	DDRA |= 0b11111111;
     6a2:	81 b1       	in	r24, 0x01	; 1
     6a4:	8f ef       	ldi	r24, 0xFF	; 255
     6a6:	81 b9       	out	0x01, r24	; 1
	//B pins are reserved for SPI, don't touch those
	DDRC |= 0b11111111;
     6a8:	97 b1       	in	r25, 0x07	; 7
     6aa:	87 b9       	out	0x07, r24	; 7
	DDRD |= 0b10000000;
     6ac:	57 9a       	sbi	0x0a, 7	; 10
	DDRG |= 0b00000111;
     6ae:	83 b3       	in	r24, 0x13	; 19
     6b0:	87 60       	ori	r24, 0x07	; 7
     6b2:	83 bb       	out	0x13, r24	; 19
	//DDRL |= 0b11111111;
	
	//analogwrite, Not all pins support PWM signals, please consult datasheets before altering.
	DDRB |= 0b11110000;
     6b4:	84 b1       	in	r24, 0x04	; 4
     6b6:	80 6f       	ori	r24, 0xF0	; 240
     6b8:	84 b9       	out	0x04, r24	; 4
	DDRE |= 0b00111000;
     6ba:	8d b1       	in	r24, 0x0d	; 13
     6bc:	88 63       	ori	r24, 0x38	; 56
     6be:	8d b9       	out	0x0d, r24	; 13
	DDRG |= 0b00100000;
     6c0:	9d 9a       	sbi	0x13, 5	; 19
	DDRH |= 0b01111000;
     6c2:	e1 e0       	ldi	r30, 0x01	; 1
     6c4:	f1 e0       	ldi	r31, 0x01	; 1
     6c6:	80 81       	ld	r24, Z
     6c8:	88 67       	ori	r24, 0x78	; 120
     6ca:	80 83       	st	Z, r24
	DDRL |= 0b00111000;
     6cc:	ea e0       	ldi	r30, 0x0A	; 10
     6ce:	f1 e0       	ldi	r31, 0x01	; 1
     6d0:	80 81       	ld	r24, Z
     6d2:	88 63       	ori	r24, 0x38	; 56
     6d4:	80 83       	st	Z, r24
	//when something is unclear or you want to change some setting, please consult the datasheet first.
	
	//Compare output mode
	//determines how the PWN behaves, now it Clears OCxx on compare match. This makes it so that low value OCRxx will result in short pulses, while higher result in longer ones
	//COM0xx0 will make OCxx toggle on compare match, both will set om compare match. Neither will disable the pmw by disconnecting OCxx.
	TCCR0A |= (( 1 << COM0A1) | (1 << COM0B1));
     6d6:	84 b5       	in	r24, 0x24	; 36
     6d8:	80 6a       	ori	r24, 0xA0	; 160
     6da:	84 bd       	out	0x24, r24	; 36
	TCCR1A |= (( 1 << COM1A1) | (1 << COM1B1));
     6dc:	c0 e8       	ldi	r28, 0x80	; 128
     6de:	d0 e0       	ldi	r29, 0x00	; 0
     6e0:	88 81       	ld	r24, Y
     6e2:	80 6a       	ori	r24, 0xA0	; 160
     6e4:	88 83       	st	Y, r24
	TCCR2A |= (( 1 << COM2A1) | (1 << COM2B1));
     6e6:	a0 eb       	ldi	r26, 0xB0	; 176
     6e8:	b0 e0       	ldi	r27, 0x00	; 0
     6ea:	8c 91       	ld	r24, X
     6ec:	80 6a       	ori	r24, 0xA0	; 160
     6ee:	8c 93       	st	X, r24
	TCCR3A |= (( 1 << COM3A1) | (1 << COM3B1));
     6f0:	e0 e9       	ldi	r30, 0x90	; 144
     6f2:	f0 e0       	ldi	r31, 0x00	; 0
     6f4:	80 81       	ld	r24, Z
     6f6:	80 6a       	ori	r24, 0xA0	; 160
     6f8:	80 83       	st	Z, r24
	//TCCR4A |= (( 1 << COM4A1) | (1 << COM4B1));
	
	//Waveform Generation
	//note that here OCRxA and OCRxB use the same registry and thus also use the same waveform.
	//the current PWM is Fast PMW, but in this case the PWM mode isn't really important.
	TCCR0A |= ((1 << WGM01) | (1 << WGM00));
     6fa:	84 b5       	in	r24, 0x24	; 36
     6fc:	83 60       	ori	r24, 0x03	; 3
     6fe:	84 bd       	out	0x24, r24	; 36
	TCCR1A |= ((1 << WGM12) | (1 << WGM10));		//16 bit timer, scaled back to 8 bit. (TCCR0x and TCCR2x are 8 bit already)
     700:	88 81       	ld	r24, Y
     702:	89 60       	ori	r24, 0x09	; 9
     704:	88 83       	st	Y, r24
	TCCR2A |= ((1 << WGM21) | (1 << WGM20));
     706:	8c 91       	ld	r24, X
     708:	83 60       	ori	r24, 0x03	; 3
     70a:	8c 93       	st	X, r24
	TCCR3A |= ((1 << WGM32) | (1 << WGM30));		//16 bit
     70c:	80 81       	ld	r24, Z
     70e:	89 60       	ori	r24, 0x09	; 9
     710:	80 83       	st	Z, r24
	
	//clock Select
	//currently selected, Internal clock, /8 prescaler. this starts the PWM as well
	//F_CPU=16000000 / 256 / 8 ~= 7812Hz wave
	//again as with the OCRxx, these use the same registry as well and are thus linked
	TCCR0B |= (1 << CS01);
     712:	85 b5       	in	r24, 0x25	; 37
     714:	82 60       	ori	r24, 0x02	; 2
     716:	85 bd       	out	0x25, r24	; 37
	TCCR1B |= (1 << CS11);
     718:	e1 e8       	ldi	r30, 0x81	; 129
     71a:	f0 e0       	ldi	r31, 0x00	; 0
     71c:	80 81       	ld	r24, Z
     71e:	82 60       	ori	r24, 0x02	; 2
     720:	80 83       	st	Z, r24
	TCCR2B |= (1 << CS21);
     722:	e1 eb       	ldi	r30, 0xB1	; 177
     724:	f0 e0       	ldi	r31, 0x00	; 0
     726:	80 81       	ld	r24, Z
     728:	82 60       	ori	r24, 0x02	; 2
     72a:	80 83       	st	Z, r24
	TCCR3B |= (1 << CS31);
     72c:	e1 e9       	ldi	r30, 0x91	; 145
     72e:	f0 e0       	ldi	r31, 0x00	; 0
     730:	80 81       	ld	r24, Z
     732:	82 60       	ori	r24, 0x02	; 2
     734:	80 83       	st	Z, r24
	TCCR4B |= (1 << CS41);
     736:	e1 ea       	ldi	r30, 0xA1	; 161
     738:	f0 e0       	ldi	r31, 0x00	; 0
     73a:	80 81       	ld	r24, Z
     73c:	82 60       	ori	r24, 0x02	; 2
     73e:	80 83       	st	Z, r24
	
	//initialize each pwm as 0
	OCR3B=0;	//pin 2
     740:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <__TEXT_REGION_LENGTH__+0x70009b>
     744:	10 92 9a 00 	sts	0x009A, r1	; 0x80009a <__TEXT_REGION_LENGTH__+0x70009a>
	OCR3C=0;	//pin 3
     748:	10 92 9d 00 	sts	0x009D, r1	; 0x80009d <__TEXT_REGION_LENGTH__+0x70009d>
     74c:	10 92 9c 00 	sts	0x009C, r1	; 0x80009c <__TEXT_REGION_LENGTH__+0x70009c>
	OCR0B=0;	//pin 4
     750:	18 bc       	out	0x28, r1	; 40
	OCR3A=0;	//pin 5
     752:	10 92 99 00 	sts	0x0099, r1	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
     756:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
	OCR4A=0;	//pin 6
     75a:	10 92 a9 00 	sts	0x00A9, r1	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
     75e:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
	OCR4B=0;	//pin 7
     762:	10 92 ab 00 	sts	0x00AB, r1	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
     766:	10 92 aa 00 	sts	0x00AA, r1	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
	OCR4C=0;	//pin 8
     76a:	10 92 ad 00 	sts	0x00AD, r1	; 0x8000ad <__TEXT_REGION_LENGTH__+0x7000ad>
     76e:	10 92 ac 00 	sts	0x00AC, r1	; 0x8000ac <__TEXT_REGION_LENGTH__+0x7000ac>
	OCR2B=0;	//pin 9
     772:	10 92 b4 00 	sts	0x00B4, r1	; 0x8000b4 <__TEXT_REGION_LENGTH__+0x7000b4>
	OCR2A=0;	//pin 10
     776:	10 92 b3 00 	sts	0x00B3, r1	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
	OCR1A=0;	//pin 11
     77a:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     77e:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
	OCR1B=0;	//pin 12
     782:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     786:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
	OCR1C=0;	//pin 13
     78a:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
     78e:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
	//Analog Digital Converter, analogread
	//////////////////////////////////////
	
	//Analog Digital Multiplexer Selection Register, voltage reference selection
	//Current setting: AVcc with external capacitor at AREF pin (internal 5v)
	ADMUX |= (1 << REFS0);
     792:	ec e7       	ldi	r30, 0x7C	; 124
     794:	f0 e0       	ldi	r31, 0x00	; 0
     796:	80 81       	ld	r24, Z
     798:	80 64       	ori	r24, 0x40	; 64
     79a:	80 83       	st	Z, r24
	
	// 1/128 prescaler
	ADCSRA |= (1 << ADPS0) | (1 << ADPS1) | (1 << ADPS2);
     79c:	ea e7       	ldi	r30, 0x7A	; 122
     79e:	f0 e0       	ldi	r31, 0x00	; 0
     7a0:	80 81       	ld	r24, Z
     7a2:	87 60       	ori	r24, 0x07	; 7
     7a4:	80 83       	st	Z, r24
	
	//enable the ADC convector, and disable GPIO functionality on the ADC pins
	ADCSRA |= (1 << ADEN);
     7a6:	80 81       	ld	r24, Z
     7a8:	80 68       	ori	r24, 0x80	; 128
     7aa:	80 83       	st	Z, r24
	Serial.println("IO setting generated");
     7ac:	69 e1       	ldi	r22, 0x19	; 25
     7ae:	72 e0       	ldi	r23, 0x02	; 2
     7b0:	84 e9       	ldi	r24, 0x94	; 148
     7b2:	94 e0       	ldi	r25, 0x04	; 4
     7b4:	42 d7       	rcall	.+3716   	; 0x163a <_ZN5USART7printlnEPKc>
	return;
}
     7b6:	df 91       	pop	r29
     7b8:	cf 91       	pop	r28
     7ba:	08 95       	ret

000007bc <_Z11analogWriteii>:


//writes a value between 0 and 255 to the correct output compare register
//analogWrite(pin numer, value it should receive).
void analogWrite(int pin,int val){
     7bc:	6f 3f       	cpi	r22, 0xFF	; 255
     7be:	71 05       	cpc	r23, r1
     7c0:	19 f0       	breq	.+6      	; 0x7c8 <_Z11analogWriteii+0xc>
     7c2:	14 f0       	brlt	.+4      	; 0x7c8 <_Z11analogWriteii+0xc>
     7c4:	6f ef       	ldi	r22, 0xFF	; 255
     7c6:	70 e0       	ldi	r23, 0x00	; 0
	if(val>255)			//if the given value exeeds 255, make it 255
	val=255;
	switch(pin){
     7c8:	fc 01       	movw	r30, r24
     7ca:	32 97       	sbiw	r30, 0x02	; 2
     7cc:	eb 30       	cpi	r30, 0x0B	; 11
     7ce:	f1 05       	cpc	r31, r1
     7d0:	b0 f5       	brcc	.+108    	; 0x83e <_Z11analogWriteii+0x82>
     7d2:	88 27       	eor	r24, r24
     7d4:	ee 58       	subi	r30, 0x8E	; 142
     7d6:	ff 4f       	sbci	r31, 0xFF	; 255
     7d8:	8f 4f       	sbci	r24, 0xFF	; 255
     7da:	0c 94 94 0c 	jmp	0x1928	; 0x1928 <__tablejump2__>
		case 2:
		OCR3B=val;
     7de:	70 93 9b 00 	sts	0x009B, r23	; 0x80009b <__TEXT_REGION_LENGTH__+0x70009b>
     7e2:	60 93 9a 00 	sts	0x009A, r22	; 0x80009a <__TEXT_REGION_LENGTH__+0x70009a>
		return;
     7e6:	08 95       	ret
		case 3:
		OCR3C=val;
     7e8:	70 93 9d 00 	sts	0x009D, r23	; 0x80009d <__TEXT_REGION_LENGTH__+0x70009d>
     7ec:	60 93 9c 00 	sts	0x009C, r22	; 0x80009c <__TEXT_REGION_LENGTH__+0x70009c>
		return;
     7f0:	08 95       	ret
		case 4:
		OCR0B=val;
     7f2:	68 bd       	out	0x28, r22	; 40
		return;
     7f4:	08 95       	ret
		case 5:
		OCR3A=val;
     7f6:	70 93 99 00 	sts	0x0099, r23	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
     7fa:	60 93 98 00 	sts	0x0098, r22	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
		return;
     7fe:	08 95       	ret
		case 6:
		OCR4A=val;
     800:	70 93 a9 00 	sts	0x00A9, r23	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
     804:	60 93 a8 00 	sts	0x00A8, r22	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
		return;
     808:	08 95       	ret
		case 7:
		OCR4B=val;
     80a:	70 93 ab 00 	sts	0x00AB, r23	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
     80e:	60 93 aa 00 	sts	0x00AA, r22	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
		return;
     812:	08 95       	ret
		case 8:
		OCR4C=val;
     814:	70 93 ad 00 	sts	0x00AD, r23	; 0x8000ad <__TEXT_REGION_LENGTH__+0x7000ad>
     818:	60 93 ac 00 	sts	0x00AC, r22	; 0x8000ac <__TEXT_REGION_LENGTH__+0x7000ac>
		return;
     81c:	08 95       	ret
		case 9:
		OCR2B=val;
     81e:	60 93 b4 00 	sts	0x00B4, r22	; 0x8000b4 <__TEXT_REGION_LENGTH__+0x7000b4>
		return;
     822:	08 95       	ret
		case 10:
		OCR2A=val;
     824:	60 93 b3 00 	sts	0x00B3, r22	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
		return;
     828:	08 95       	ret
		case 11:
		OCR1A=val;
     82a:	70 93 89 00 	sts	0x0089, r23	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     82e:	60 93 88 00 	sts	0x0088, r22	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
		return;
     832:	08 95       	ret
		case 12:
		OCR1B=val;
     834:	70 93 8b 00 	sts	0x008B, r23	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     838:	60 93 8a 00 	sts	0x008A, r22	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
		return;
     83c:	08 95       	ret
		}
	Serial.println("ERROR: tried to write analog value to unsupported pin");
     83e:	6e e2       	ldi	r22, 0x2E	; 46
     840:	72 e0       	ldi	r23, 0x02	; 2
     842:	84 e9       	ldi	r24, 0x94	; 148
     844:	94 e0       	ldi	r25, 0x04	; 4
     846:	f9 c6       	rjmp	.+3570   	; 0x163a <_ZN5USART7printlnEPKc>
     848:	08 95       	ret

0000084a <_Z12digitalWriteib>:
	return;
}

//writes a digital value to a pin.
void digitalWrite(int pin,bool val){
     84a:	cf 93       	push	r28
     84c:	df 93       	push	r29
	if(pin<22||pin>53){					//check if the pin is a digital IO pin
     84e:	9c 01       	movw	r18, r24
     850:	26 51       	subi	r18, 0x16	; 22
     852:	31 09       	sbc	r19, r1
     854:	20 32       	cpi	r18, 0x20	; 32
     856:	31 05       	cpc	r19, r1
     858:	58 f0       	brcs	.+22     	; 0x870 <_Z12digitalWriteib+0x26>
     85a:	ec 01       	movw	r28, r24
		Serial.print("ERROR: tried to write digital value to unsupported digital pin");
     85c:	64 e6       	ldi	r22, 0x64	; 100
     85e:	72 e0       	ldi	r23, 0x02	; 2
     860:	84 e9       	ldi	r24, 0x94	; 148
     862:	94 e0       	ldi	r25, 0x04	; 4
     864:	d1 d6       	rcall	.+3490   	; 0x1608 <_ZN5USART5printEPKc>
		Serial.println(pin);
     866:	be 01       	movw	r22, r28
     868:	84 e9       	ldi	r24, 0x94	; 148
     86a:	94 e0       	ldi	r25, 0x04	; 4
     86c:	14 d7       	rcall	.+3624   	; 0x1696 <_ZN5USART7printlnEi>
     86e:	b9 c0       	rjmp	.+370    	; 0x9e2 <_Z12digitalWriteib+0x198>
	}
	else if(pin<30){					//check if pin is in the A register
     870:	8e 31       	cpi	r24, 0x1E	; 30
     872:	91 05       	cpc	r25, r1
     874:	f4 f4       	brge	.+60     	; 0x8b2 <_Z12digitalWriteib+0x68>
		pin-=22;						//make pinrange 0-7
     876:	46 97       	sbiw	r24, 0x16	; 22
		if(val) PORTA |= (1<<pin);		//set correct bit in A register is val==true
     878:	66 23       	and	r22, r22
     87a:	69 f0       	breq	.+26     	; 0x896 <_Z12digitalWriteib+0x4c>
     87c:	42 b1       	in	r20, 0x02	; 2
     87e:	21 e0       	ldi	r18, 0x01	; 1
     880:	30 e0       	ldi	r19, 0x00	; 0
     882:	b9 01       	movw	r22, r18
     884:	02 c0       	rjmp	.+4      	; 0x88a <_Z12digitalWriteib+0x40>
     886:	66 0f       	add	r22, r22
     888:	77 1f       	adc	r23, r23
     88a:	8a 95       	dec	r24
     88c:	e2 f7       	brpl	.-8      	; 0x886 <_Z12digitalWriteib+0x3c>
     88e:	cb 01       	movw	r24, r22
     890:	84 2b       	or	r24, r20
     892:	82 b9       	out	0x02, r24	; 2
     894:	a6 c0       	rjmp	.+332    	; 0x9e2 <_Z12digitalWriteib+0x198>
		else PORTA &= ~(1<<pin);		//unset bit if false
     896:	42 b1       	in	r20, 0x02	; 2
     898:	21 e0       	ldi	r18, 0x01	; 1
     89a:	30 e0       	ldi	r19, 0x00	; 0
     89c:	b9 01       	movw	r22, r18
     89e:	02 c0       	rjmp	.+4      	; 0x8a4 <_Z12digitalWriteib+0x5a>
     8a0:	66 0f       	add	r22, r22
     8a2:	77 1f       	adc	r23, r23
     8a4:	8a 95       	dec	r24
     8a6:	e2 f7       	brpl	.-8      	; 0x8a0 <_Z12digitalWriteib+0x56>
     8a8:	cb 01       	movw	r24, r22
     8aa:	80 95       	com	r24
     8ac:	84 23       	and	r24, r20
     8ae:	82 b9       	out	0x02, r24	; 2
     8b0:	98 c0       	rjmp	.+304    	; 0x9e2 <_Z12digitalWriteib+0x198>
	}
	else if(pin<38){
     8b2:	86 32       	cpi	r24, 0x26	; 38
     8b4:	91 05       	cpc	r25, r1
     8b6:	1c f5       	brge	.+70     	; 0x8fe <_Z12digitalWriteib+0xb4>
		pin=(37-pin);
     8b8:	25 e2       	ldi	r18, 0x25	; 37
     8ba:	30 e0       	ldi	r19, 0x00	; 0
     8bc:	a9 01       	movw	r20, r18
     8be:	48 1b       	sub	r20, r24
     8c0:	59 0b       	sbc	r21, r25
     8c2:	ca 01       	movw	r24, r20
		if(val) PORTC |= (1<<pin);
     8c4:	66 23       	and	r22, r22
     8c6:	69 f0       	breq	.+26     	; 0x8e2 <_Z12digitalWriteib+0x98>
     8c8:	48 b1       	in	r20, 0x08	; 8
     8ca:	21 e0       	ldi	r18, 0x01	; 1
     8cc:	30 e0       	ldi	r19, 0x00	; 0
     8ce:	b9 01       	movw	r22, r18
     8d0:	02 c0       	rjmp	.+4      	; 0x8d6 <_Z12digitalWriteib+0x8c>
     8d2:	66 0f       	add	r22, r22
     8d4:	77 1f       	adc	r23, r23
     8d6:	8a 95       	dec	r24
     8d8:	e2 f7       	brpl	.-8      	; 0x8d2 <_Z12digitalWriteib+0x88>
     8da:	cb 01       	movw	r24, r22
     8dc:	84 2b       	or	r24, r20
     8de:	88 b9       	out	0x08, r24	; 8
     8e0:	80 c0       	rjmp	.+256    	; 0x9e2 <_Z12digitalWriteib+0x198>
		else PORTC &= ~(1<<pin);
     8e2:	48 b1       	in	r20, 0x08	; 8
     8e4:	21 e0       	ldi	r18, 0x01	; 1
     8e6:	30 e0       	ldi	r19, 0x00	; 0
     8e8:	b9 01       	movw	r22, r18
     8ea:	02 c0       	rjmp	.+4      	; 0x8f0 <_Z12digitalWriteib+0xa6>
     8ec:	66 0f       	add	r22, r22
     8ee:	77 1f       	adc	r23, r23
     8f0:	8a 95       	dec	r24
     8f2:	e2 f7       	brpl	.-8      	; 0x8ec <_Z12digitalWriteib+0xa2>
     8f4:	cb 01       	movw	r24, r22
     8f6:	80 95       	com	r24
     8f8:	84 23       	and	r24, r20
     8fa:	88 b9       	out	0x08, r24	; 8
     8fc:	72 c0       	rjmp	.+228    	; 0x9e2 <_Z12digitalWriteib+0x198>
	}
	else if(pin==38){
     8fe:	86 32       	cpi	r24, 0x26	; 38
     900:	91 05       	cpc	r25, r1
     902:	31 f4       	brne	.+12     	; 0x910 <_Z12digitalWriteib+0xc6>
		if(val) PORTD |= (1<<PIND7);
     904:	66 23       	and	r22, r22
     906:	11 f0       	breq	.+4      	; 0x90c <_Z12digitalWriteib+0xc2>
     908:	5f 9a       	sbi	0x0b, 7	; 11
     90a:	6b c0       	rjmp	.+214    	; 0x9e2 <_Z12digitalWriteib+0x198>
		else PORTD &= ~(1<<PIND7);
     90c:	5f 98       	cbi	0x0b, 7	; 11
     90e:	69 c0       	rjmp	.+210    	; 0x9e2 <_Z12digitalWriteib+0x198>
	}
	else if(pin<42){
     910:	8a 32       	cpi	r24, 0x2A	; 42
     912:	91 05       	cpc	r25, r1
     914:	ec f4       	brge	.+58     	; 0x950 <_Z12digitalWriteib+0x106>
		pin=(41-pin);
     916:	29 e2       	ldi	r18, 0x29	; 41
     918:	30 e0       	ldi	r19, 0x00	; 0
     91a:	28 1b       	sub	r18, r24
     91c:	39 0b       	sbc	r19, r25
		if(val) PORTG |= (1<<pin);
     91e:	66 23       	and	r22, r22
     920:	59 f0       	breq	.+22     	; 0x938 <_Z12digitalWriteib+0xee>
     922:	34 b3       	in	r19, 0x14	; 20
     924:	81 e0       	ldi	r24, 0x01	; 1
     926:	90 e0       	ldi	r25, 0x00	; 0
     928:	02 c0       	rjmp	.+4      	; 0x92e <_Z12digitalWriteib+0xe4>
     92a:	88 0f       	add	r24, r24
     92c:	99 1f       	adc	r25, r25
     92e:	2a 95       	dec	r18
     930:	e2 f7       	brpl	.-8      	; 0x92a <_Z12digitalWriteib+0xe0>
     932:	83 2b       	or	r24, r19
     934:	84 bb       	out	0x14, r24	; 20
     936:	55 c0       	rjmp	.+170    	; 0x9e2 <_Z12digitalWriteib+0x198>
		else PORTG &= ~(1<<pin);
     938:	34 b3       	in	r19, 0x14	; 20
     93a:	81 e0       	ldi	r24, 0x01	; 1
     93c:	90 e0       	ldi	r25, 0x00	; 0
     93e:	02 c0       	rjmp	.+4      	; 0x944 <_Z12digitalWriteib+0xfa>
     940:	88 0f       	add	r24, r24
     942:	99 1f       	adc	r25, r25
     944:	2a 95       	dec	r18
     946:	e2 f7       	brpl	.-8      	; 0x940 <_Z12digitalWriteib+0xf6>
     948:	80 95       	com	r24
     94a:	83 23       	and	r24, r19
     94c:	84 bb       	out	0x14, r24	; 20
     94e:	49 c0       	rjmp	.+146    	; 0x9e2 <_Z12digitalWriteib+0x198>
	}
	else if(pin<50){
     950:	82 33       	cpi	r24, 0x32	; 50
     952:	91 05       	cpc	r25, r1
     954:	0c f5       	brge	.+66     	; 0x998 <_Z12digitalWriteib+0x14e>
		pin=(49-pin);
     956:	21 e3       	ldi	r18, 0x31	; 49
     958:	30 e0       	ldi	r19, 0x00	; 0
     95a:	28 1b       	sub	r18, r24
     95c:	39 0b       	sbc	r19, r25
		if(val) PORTL |= (1<<pin);
     95e:	66 23       	and	r22, r22
     960:	69 f0       	breq	.+26     	; 0x97c <_Z12digitalWriteib+0x132>
     962:	eb e0       	ldi	r30, 0x0B	; 11
     964:	f1 e0       	ldi	r31, 0x01	; 1
     966:	30 81       	ld	r19, Z
     968:	81 e0       	ldi	r24, 0x01	; 1
     96a:	90 e0       	ldi	r25, 0x00	; 0
     96c:	02 c0       	rjmp	.+4      	; 0x972 <_Z12digitalWriteib+0x128>
     96e:	88 0f       	add	r24, r24
     970:	99 1f       	adc	r25, r25
     972:	2a 95       	dec	r18
     974:	e2 f7       	brpl	.-8      	; 0x96e <_Z12digitalWriteib+0x124>
     976:	83 2b       	or	r24, r19
     978:	80 83       	st	Z, r24
     97a:	33 c0       	rjmp	.+102    	; 0x9e2 <_Z12digitalWriteib+0x198>
		else PORTL &= ~(1<<pin);
     97c:	eb e0       	ldi	r30, 0x0B	; 11
     97e:	f1 e0       	ldi	r31, 0x01	; 1
     980:	30 81       	ld	r19, Z
     982:	81 e0       	ldi	r24, 0x01	; 1
     984:	90 e0       	ldi	r25, 0x00	; 0
     986:	02 c0       	rjmp	.+4      	; 0x98c <_Z12digitalWriteib+0x142>
     988:	88 0f       	add	r24, r24
     98a:	99 1f       	adc	r25, r25
     98c:	2a 95       	dec	r18
     98e:	e2 f7       	brpl	.-8      	; 0x988 <_Z12digitalWriteib+0x13e>
     990:	80 95       	com	r24
     992:	83 23       	and	r24, r19
     994:	80 83       	st	Z, r24
     996:	25 c0       	rjmp	.+74     	; 0x9e2 <_Z12digitalWriteib+0x198>
	}
	else if(pin<54){
     998:	86 33       	cpi	r24, 0x36	; 54
     99a:	91 05       	cpc	r25, r1
     99c:	14 f5       	brge	.+68     	; 0x9e2 <_Z12digitalWriteib+0x198>
		pin=(53-pin);
     99e:	25 e3       	ldi	r18, 0x35	; 53
     9a0:	30 e0       	ldi	r19, 0x00	; 0
     9a2:	a9 01       	movw	r20, r18
     9a4:	48 1b       	sub	r20, r24
     9a6:	59 0b       	sbc	r21, r25
     9a8:	ca 01       	movw	r24, r20
		if(val) PORTB |= (1<<pin);
     9aa:	66 23       	and	r22, r22
     9ac:	69 f0       	breq	.+26     	; 0x9c8 <_Z12digitalWriteib+0x17e>
     9ae:	45 b1       	in	r20, 0x05	; 5
     9b0:	21 e0       	ldi	r18, 0x01	; 1
     9b2:	30 e0       	ldi	r19, 0x00	; 0
     9b4:	b9 01       	movw	r22, r18
     9b6:	02 c0       	rjmp	.+4      	; 0x9bc <_Z12digitalWriteib+0x172>
     9b8:	66 0f       	add	r22, r22
     9ba:	77 1f       	adc	r23, r23
     9bc:	8a 95       	dec	r24
     9be:	e2 f7       	brpl	.-8      	; 0x9b8 <_Z12digitalWriteib+0x16e>
     9c0:	cb 01       	movw	r24, r22
     9c2:	84 2b       	or	r24, r20
     9c4:	85 b9       	out	0x05, r24	; 5
     9c6:	0d c0       	rjmp	.+26     	; 0x9e2 <_Z12digitalWriteib+0x198>
		else PORTB &= ~(1<<pin);
     9c8:	45 b1       	in	r20, 0x05	; 5
     9ca:	21 e0       	ldi	r18, 0x01	; 1
     9cc:	30 e0       	ldi	r19, 0x00	; 0
     9ce:	b9 01       	movw	r22, r18
     9d0:	02 c0       	rjmp	.+4      	; 0x9d6 <_Z12digitalWriteib+0x18c>
     9d2:	66 0f       	add	r22, r22
     9d4:	77 1f       	adc	r23, r23
     9d6:	8a 95       	dec	r24
     9d8:	e2 f7       	brpl	.-8      	; 0x9d2 <_Z12digitalWriteib+0x188>
     9da:	cb 01       	movw	r24, r22
     9dc:	80 95       	com	r24
     9de:	84 23       	and	r24, r20
     9e0:	85 b9       	out	0x05, r24	; 5
	}
	return;
}
     9e2:	df 91       	pop	r29
     9e4:	cf 91       	pop	r28
     9e6:	08 95       	ret

000009e8 <_Z11digitalReadi>:

bool digitalRead(int pin){
     9e8:	cf 93       	push	r28
     9ea:	df 93       	push	r29
	if(pin==4){
     9ec:	84 30       	cpi	r24, 0x04	; 4
     9ee:	91 05       	cpc	r25, r1
     9f0:	29 f4       	brne	.+10     	; 0x9fc <_Z11digitalReadi+0x14>
		if(PING&(1<<PING5))	return true;
     9f2:	82 b3       	in	r24, 0x12	; 18
     9f4:	85 fb       	bst	r24, 5
     9f6:	88 27       	eor	r24, r24
     9f8:	80 f9       	bld	r24, 0
     9fa:	6f c0       	rjmp	.+222    	; 0xada <_Z11digitalReadi+0xf2>
	}
	else if(pin<30){					//check if pin is in the A register
     9fc:	8e 31       	cpi	r24, 0x1E	; 30
     9fe:	91 05       	cpc	r25, r1
     a00:	64 f4       	brge	.+24     	; 0xa1a <_Z11digitalReadi+0x32>
		pin-=22;						//make pinrange 0-7
		if(PINA&(1<<pin))	return true;							//break function
     a02:	20 b1       	in	r18, 0x00	; 0
     a04:	30 e0       	ldi	r19, 0x00	; 0
     a06:	46 97       	sbiw	r24, 0x16	; 22
     a08:	a9 01       	movw	r20, r18
     a0a:	02 c0       	rjmp	.+4      	; 0xa10 <_Z11digitalReadi+0x28>
     a0c:	55 95       	asr	r21
     a0e:	47 95       	ror	r20
     a10:	8a 95       	dec	r24
     a12:	e2 f7       	brpl	.-8      	; 0xa0c <_Z11digitalReadi+0x24>
     a14:	ca 01       	movw	r24, r20
     a16:	81 70       	andi	r24, 0x01	; 1
     a18:	60 c0       	rjmp	.+192    	; 0xada <_Z11digitalReadi+0xf2>
	}
	else if(pin<38){
     a1a:	86 32       	cpi	r24, 0x26	; 38
     a1c:	91 05       	cpc	r25, r1
     a1e:	84 f4       	brge	.+32     	; 0xa40 <_Z11digitalReadi+0x58>
		pin=37-pin;
		if(PINC&(1<<pin))	return true;							//break function
     a20:	26 b1       	in	r18, 0x06	; 6
     a22:	30 e0       	ldi	r19, 0x00	; 0
     a24:	45 e2       	ldi	r20, 0x25	; 37
     a26:	50 e0       	ldi	r21, 0x00	; 0
     a28:	ba 01       	movw	r22, r20
     a2a:	68 1b       	sub	r22, r24
     a2c:	79 0b       	sbc	r23, r25
     a2e:	a9 01       	movw	r20, r18
     a30:	02 c0       	rjmp	.+4      	; 0xa36 <_Z11digitalReadi+0x4e>
     a32:	55 95       	asr	r21
     a34:	47 95       	ror	r20
     a36:	6a 95       	dec	r22
     a38:	e2 f7       	brpl	.-8      	; 0xa32 <_Z11digitalReadi+0x4a>
     a3a:	ca 01       	movw	r24, r20
     a3c:	81 70       	andi	r24, 0x01	; 1
     a3e:	4d c0       	rjmp	.+154    	; 0xada <_Z11digitalReadi+0xf2>
	}
	else if(pin==38){
     a40:	86 32       	cpi	r24, 0x26	; 38
     a42:	91 05       	cpc	r25, r1
     a44:	29 f4       	brne	.+10     	; 0xa50 <_Z11digitalReadi+0x68>
		if(PIND&(1<<PIND7))	return true;							//break function
     a46:	89 b1       	in	r24, 0x09	; 9
     a48:	88 1f       	adc	r24, r24
     a4a:	88 27       	eor	r24, r24
     a4c:	88 1f       	adc	r24, r24
     a4e:	45 c0       	rjmp	.+138    	; 0xada <_Z11digitalReadi+0xf2>
	}
	else if(pin<42){
     a50:	8a 32       	cpi	r24, 0x2A	; 42
     a52:	91 05       	cpc	r25, r1
     a54:	84 f4       	brge	.+32     	; 0xa76 <_Z11digitalReadi+0x8e>
		pin=41-pin;
		if(PING&(1<<pin))	return true;							//break function
     a56:	22 b3       	in	r18, 0x12	; 18
     a58:	30 e0       	ldi	r19, 0x00	; 0
     a5a:	49 e2       	ldi	r20, 0x29	; 41
     a5c:	50 e0       	ldi	r21, 0x00	; 0
     a5e:	ba 01       	movw	r22, r20
     a60:	68 1b       	sub	r22, r24
     a62:	79 0b       	sbc	r23, r25
     a64:	a9 01       	movw	r20, r18
     a66:	02 c0       	rjmp	.+4      	; 0xa6c <_Z11digitalReadi+0x84>
     a68:	55 95       	asr	r21
     a6a:	47 95       	ror	r20
     a6c:	6a 95       	dec	r22
     a6e:	e2 f7       	brpl	.-8      	; 0xa68 <_Z11digitalReadi+0x80>
     a70:	ca 01       	movw	r24, r20
     a72:	81 70       	andi	r24, 0x01	; 1
     a74:	32 c0       	rjmp	.+100    	; 0xada <_Z11digitalReadi+0xf2>
	}
	else if(pin<50){
     a76:	82 33       	cpi	r24, 0x32	; 50
     a78:	91 05       	cpc	r25, r1
     a7a:	8c f4       	brge	.+34     	; 0xa9e <_Z11digitalReadi+0xb6>
		pin=49-pin;
		if(PINL&(1<<pin))	return true;							//break function
     a7c:	20 91 09 01 	lds	r18, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
     a80:	30 e0       	ldi	r19, 0x00	; 0
     a82:	41 e3       	ldi	r20, 0x31	; 49
     a84:	50 e0       	ldi	r21, 0x00	; 0
     a86:	ba 01       	movw	r22, r20
     a88:	68 1b       	sub	r22, r24
     a8a:	79 0b       	sbc	r23, r25
     a8c:	a9 01       	movw	r20, r18
     a8e:	02 c0       	rjmp	.+4      	; 0xa94 <_Z11digitalReadi+0xac>
     a90:	55 95       	asr	r21
     a92:	47 95       	ror	r20
     a94:	6a 95       	dec	r22
     a96:	e2 f7       	brpl	.-8      	; 0xa90 <_Z11digitalReadi+0xa8>
     a98:	ca 01       	movw	r24, r20
     a9a:	81 70       	andi	r24, 0x01	; 1
     a9c:	1e c0       	rjmp	.+60     	; 0xada <_Z11digitalReadi+0xf2>
	}
	else if(pin<54){
     a9e:	86 33       	cpi	r24, 0x36	; 54
     aa0:	91 05       	cpc	r25, r1
     aa2:	84 f4       	brge	.+32     	; 0xac4 <_Z11digitalReadi+0xdc>
		pin=(53-pin);
		if(PINB&(1<<pin))	return true;							//break function
     aa4:	23 b1       	in	r18, 0x03	; 3
     aa6:	30 e0       	ldi	r19, 0x00	; 0
     aa8:	45 e3       	ldi	r20, 0x35	; 53
     aaa:	50 e0       	ldi	r21, 0x00	; 0
     aac:	ba 01       	movw	r22, r20
     aae:	68 1b       	sub	r22, r24
     ab0:	79 0b       	sbc	r23, r25
     ab2:	a9 01       	movw	r20, r18
     ab4:	02 c0       	rjmp	.+4      	; 0xaba <_Z11digitalReadi+0xd2>
     ab6:	55 95       	asr	r21
     ab8:	47 95       	ror	r20
     aba:	6a 95       	dec	r22
     abc:	e2 f7       	brpl	.-8      	; 0xab6 <_Z11digitalReadi+0xce>
     abe:	ca 01       	movw	r24, r20
     ac0:	81 70       	andi	r24, 0x01	; 1
     ac2:	0b c0       	rjmp	.+22     	; 0xada <_Z11digitalReadi+0xf2>
     ac4:	ec 01       	movw	r28, r24
	}
	else{					//pin unsupported
		Serial.print("ERROR: tried to read digital value from unsupported digital pin: ");
     ac6:	63 ea       	ldi	r22, 0xA3	; 163
     ac8:	72 e0       	ldi	r23, 0x02	; 2
     aca:	84 e9       	ldi	r24, 0x94	; 148
     acc:	94 e0       	ldi	r25, 0x04	; 4
     ace:	9c d5       	rcall	.+2872   	; 0x1608 <_ZN5USART5printEPKc>
		Serial.println(pin);
     ad0:	be 01       	movw	r22, r28
     ad2:	84 e9       	ldi	r24, 0x94	; 148
     ad4:	94 e0       	ldi	r25, 0x04	; 4
     ad6:	df d5       	rcall	.+3006   	; 0x1696 <_ZN5USART7printlnEi>
		return false;
     ad8:	80 e0       	ldi	r24, 0x00	; 0
	}
	return false;	
}
     ada:	df 91       	pop	r29
     adc:	cf 91       	pop	r28
     ade:	08 95       	ret

00000ae0 <_Z10analogReadi>:

int analogRead(int pin){
     ae0:	cf 93       	push	r28
     ae2:	df 93       	push	r29
	//set correct MUX registers, these determine on which pin the ADC should read it's value
	//first the MUXx bits are cleared, then filled to prevent old setting leaking though
	
	ADMUX &=(0b11100000);							//clear the bottom 4 bit
     ae4:	ec e7       	ldi	r30, 0x7C	; 124
     ae6:	f0 e0       	ldi	r31, 0x00	; 0
     ae8:	20 81       	ld	r18, Z
     aea:	20 7e       	andi	r18, 0xE0	; 224
     aec:	20 83       	st	Z, r18
	ADCSRB &=(0b11110111);							//clear the top one bit
     aee:	eb e7       	ldi	r30, 0x7B	; 123
     af0:	f0 e0       	ldi	r31, 0x00	; 0
     af2:	20 81       	ld	r18, Z
     af4:	27 7f       	andi	r18, 0xF7	; 247
     af6:	20 83       	st	Z, r18
	if(pin<8)										//if adc #0-7
     af8:	88 30       	cpi	r24, 0x08	; 8
     afa:	91 05       	cpc	r25, r1
     afc:	34 f4       	brge	.+12     	; 0xb0a <_Z10analogReadi+0x2a>
	ADMUX |= pin;								//write the full pin to the ADMUX registry
     afe:	ec e7       	ldi	r30, 0x7C	; 124
     b00:	f0 e0       	ldi	r31, 0x00	; 0
     b02:	90 81       	ld	r25, Z
     b04:	89 2b       	or	r24, r25
     b06:	80 83       	st	Z, r24
     b08:	1c c0       	rjmp	.+56     	; 0xb42 <_Z10analogReadi+0x62>
	else if(pin<16){									//if adc #8-15
     b0a:	80 31       	cpi	r24, 0x10	; 16
     b0c:	91 05       	cpc	r25, r1
     b0e:	64 f4       	brge	.+24     	; 0xb28 <_Z10analogReadi+0x48>
		ADCSRB |= (1<<3);							//write upper bit to ADCSRB register
     b10:	eb e7       	ldi	r30, 0x7B	; 123
     b12:	f0 e0       	ldi	r31, 0x00	; 0
     b14:	90 81       	ld	r25, Z
     b16:	98 60       	ori	r25, 0x08	; 8
     b18:	90 83       	st	Z, r25
		ADMUX |= (pin-8);							//write lower bits to ADMUX registry
     b1a:	ec e7       	ldi	r30, 0x7C	; 124
     b1c:	f0 e0       	ldi	r31, 0x00	; 0
     b1e:	90 81       	ld	r25, Z
     b20:	88 50       	subi	r24, 0x08	; 8
     b22:	89 2b       	or	r24, r25
     b24:	80 83       	st	Z, r24
     b26:	0d c0       	rjmp	.+26     	; 0xb42 <_Z10analogReadi+0x62>
     b28:	ec 01       	movw	r28, r24
	}
	else{
		Serial.print("ERROR: tried to read digital value from unsupported analog pin ");
     b2a:	65 ee       	ldi	r22, 0xE5	; 229
     b2c:	72 e0       	ldi	r23, 0x02	; 2
     b2e:	84 e9       	ldi	r24, 0x94	; 148
     b30:	94 e0       	ldi	r25, 0x04	; 4
     b32:	6a d5       	rcall	.+2772   	; 0x1608 <_ZN5USART5printEPKc>
		Serial.println(pin);
     b34:	be 01       	movw	r22, r28
     b36:	84 e9       	ldi	r24, 0x94	; 148
     b38:	94 e0       	ldi	r25, 0x04	; 4
     b3a:	ad d5       	rcall	.+2906   	; 0x1696 <_ZN5USART7printlnEi>
		return 0;
     b3c:	80 e0       	ldi	r24, 0x00	; 0
     b3e:	90 e0       	ldi	r25, 0x00	; 0
     b40:	0c c0       	rjmp	.+24     	; 0xb5a <_Z10analogReadi+0x7a>
	}
	ADCSRA |= (1<<ADSC);							//start ADC conversion
     b42:	ea e7       	ldi	r30, 0x7A	; 122
     b44:	f0 e0       	ldi	r31, 0x00	; 0
     b46:	80 81       	ld	r24, Z
     b48:	80 64       	ori	r24, 0x40	; 64
     b4a:	80 83       	st	Z, r24
	while(ADCSRA & (1<<ADSC));						//wait until the ADSC is 0 again and the conversion is done
     b4c:	80 81       	ld	r24, Z
     b4e:	86 fd       	sbrc	r24, 6
     b50:	fd cf       	rjmp	.-6      	; 0xb4c <_Z10analogReadi+0x6c>
	return ADC;										//return the byte in ADLAR, the result of the ADC conversion
     b52:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
     b56:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
}
     b5a:	df 91       	pop	r29
     b5c:	cf 91       	pop	r28
     b5e:	08 95       	ret

00000b60 <_Z9printinfov>:
		printinfo();			//print info in the terminal
	}
}

void printinfo(){
	Serial.print("DM: ");
     b60:	65 e2       	ldi	r22, 0x25	; 37
     b62:	73 e0       	ldi	r23, 0x03	; 3
     b64:	84 e9       	ldi	r24, 0x94	; 148
     b66:	94 e0       	ldi	r25, 0x04	; 4
     b68:	4f d5       	rcall	.+2718   	; 0x1608 <_ZN5USART5printEPKc>
	Serial.print(drivemode);
     b6a:	60 91 73 04 	lds	r22, 0x0473	; 0x800473 <drivemode>
     b6e:	70 91 74 04 	lds	r23, 0x0474	; 0x800474 <drivemode+0x1>
     b72:	84 e9       	ldi	r24, 0x94	; 148
     b74:	94 e0       	ldi	r25, 0x04	; 4
     b76:	6c d5       	rcall	.+2776   	; 0x1650 <_ZN5USART5printEi>
	Serial.print(" drive dir: ");
     b78:	6a e2       	ldi	r22, 0x2A	; 42
     b7a:	73 e0       	ldi	r23, 0x03	; 3
     b7c:	84 e9       	ldi	r24, 0x94	; 148
     b7e:	94 e0       	ldi	r25, 0x04	; 4
     b80:	43 d5       	rcall	.+2694   	; 0x1608 <_ZN5USART5printEPKc>
	Serial.print(driving_direction);
     b82:	60 91 00 02 	lds	r22, 0x0200	; 0x800200 <__data_start>
     b86:	70 e0       	ldi	r23, 0x00	; 0
     b88:	84 e9       	ldi	r24, 0x94	; 148
     b8a:	94 e0       	ldi	r25, 0x04	; 4
     b8c:	61 d5       	rcall	.+2754   	; 0x1650 <_ZN5USART5printEi>
	Serial.print(" engine_dv =  ");
     b8e:	67 e3       	ldi	r22, 0x37	; 55
     b90:	73 e0       	ldi	r23, 0x03	; 3
     b92:	84 e9       	ldi	r24, 0x94	; 148
     b94:	94 e0       	ldi	r25, 0x04	; 4
     b96:	38 d5       	rcall	.+2672   	; 0x1608 <_ZN5USART5printEPKc>
	Serial.print(engine_dv);
     b98:	60 91 5e 04 	lds	r22, 0x045E	; 0x80045e <engine_dv>
     b9c:	70 91 5f 04 	lds	r23, 0x045F	; 0x80045f <engine_dv+0x1>
     ba0:	84 e9       	ldi	r24, 0x94	; 148
     ba2:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" speed. =  ");
     ba4:	55 d5       	rcall	.+2730   	; 0x1650 <_ZN5USART5printEi>
     ba6:	66 e4       	ldi	r22, 0x46	; 70
     ba8:	73 e0       	ldi	r23, 0x03	; 3
     baa:	84 e9       	ldi	r24, 0x94	; 148
     bac:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(engine_cv);
     bae:	2c d5       	rcall	.+2648   	; 0x1608 <_ZN5USART5printEPKc>
     bb0:	60 91 56 04 	lds	r22, 0x0456	; 0x800456 <engine_cv>
     bb4:	70 91 57 04 	lds	r23, 0x0457	; 0x800457 <engine_cv+0x1>
     bb8:	84 e9       	ldi	r24, 0x94	; 148
     bba:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" engine_ov =  ");
     bbc:	49 d5       	rcall	.+2706   	; 0x1650 <_ZN5USART5printEi>
     bbe:	62 e5       	ldi	r22, 0x52	; 82
     bc0:	73 e0       	ldi	r23, 0x03	; 3
     bc2:	84 e9       	ldi	r24, 0x94	; 148
     bc4:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(engine_ov);
     bc6:	20 d5       	rcall	.+2624   	; 0x1608 <_ZN5USART5printEPKc>
     bc8:	60 91 55 04 	lds	r22, 0x0455	; 0x800455 <engine_ov>
     bcc:	70 e0       	ldi	r23, 0x00	; 0
     bce:	84 e9       	ldi	r24, 0x94	; 148
     bd0:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" brake_dv = ");
     bd2:	3e d5       	rcall	.+2684   	; 0x1650 <_ZN5USART5printEi>
     bd4:	61 e6       	ldi	r22, 0x61	; 97
     bd6:	73 e0       	ldi	r23, 0x03	; 3
     bd8:	84 e9       	ldi	r24, 0x94	; 148
     bda:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(braking_dv);
     bdc:	15 d5       	rcall	.+2602   	; 0x1608 <_ZN5USART5printEPKc>
     bde:	60 91 51 04 	lds	r22, 0x0451	; 0x800451 <braking_dv>
     be2:	70 91 52 04 	lds	r23, 0x0452	; 0x800452 <braking_dv+0x1>
     be6:	84 e9       	ldi	r24, 0x94	; 148
	Serial.print(" braking_ov = ");
     be8:	94 e0       	ldi	r25, 0x04	; 4
     bea:	32 d5       	rcall	.+2660   	; 0x1650 <_ZN5USART5printEi>
     bec:	6e e6       	ldi	r22, 0x6E	; 110
     bee:	73 e0       	ldi	r23, 0x03	; 3
     bf0:	84 e9       	ldi	r24, 0x94	; 148
	Serial.print(braking_ov);
     bf2:	94 e0       	ldi	r25, 0x04	; 4
     bf4:	09 d5       	rcall	.+2578   	; 0x1608 <_ZN5USART5printEPKc>
     bf6:	60 91 48 04 	lds	r22, 0x0448	; 0x800448 <braking_ov>
     bfa:	70 e0       	ldi	r23, 0x00	; 0
     bfc:	84 e9       	ldi	r24, 0x94	; 148

	Serial.print(" steering_dv =  ");
     bfe:	94 e0       	ldi	r25, 0x04	; 4
     c00:	27 d5       	rcall	.+2638   	; 0x1650 <_ZN5USART5printEi>
     c02:	6d e7       	ldi	r22, 0x7D	; 125
     c04:	73 e0       	ldi	r23, 0x03	; 3
     c06:	84 e9       	ldi	r24, 0x94	; 148
	Serial.print(steering_dv);
     c08:	94 e0       	ldi	r25, 0x04	; 4
     c0a:	fe d4       	rcall	.+2556   	; 0x1608 <_ZN5USART5printEPKc>
     c0c:	60 91 6b 04 	lds	r22, 0x046B	; 0x80046b <steering_dv>
     c10:	70 91 6c 04 	lds	r23, 0x046C	; 0x80046c <steering_dv+0x1>
     c14:	84 e9       	ldi	r24, 0x94	; 148
	Serial.print(" steering_cv =  ");
     c16:	94 e0       	ldi	r25, 0x04	; 4
     c18:	1b d5       	rcall	.+2614   	; 0x1650 <_ZN5USART5printEi>
     c1a:	6e e8       	ldi	r22, 0x8E	; 142
     c1c:	73 e0       	ldi	r23, 0x03	; 3
     c1e:	84 e9       	ldi	r24, 0x94	; 148
	Serial.print(steering_cv);
     c20:	94 e0       	ldi	r25, 0x04	; 4
     c22:	f2 d4       	rcall	.+2532   	; 0x1608 <_ZN5USART5printEPKc>
     c24:	60 91 63 04 	lds	r22, 0x0463	; 0x800463 <steering_cv>
     c28:	70 91 64 04 	lds	r23, 0x0464	; 0x800464 <steering_cv+0x1>
	Serial.print(" steering_ov =  ");
     c2c:	84 e9       	ldi	r24, 0x94	; 148
     c2e:	94 e0       	ldi	r25, 0x04	; 4
     c30:	0f d5       	rcall	.+2590   	; 0x1650 <_ZN5USART5printEi>
     c32:	6f e9       	ldi	r22, 0x9F	; 159
     c34:	73 e0       	ldi	r23, 0x03	; 3
	Serial.print(steering_ov);
     c36:	84 e9       	ldi	r24, 0x94	; 148
     c38:	94 e0       	ldi	r25, 0x04	; 4
     c3a:	e6 d4       	rcall	.+2508   	; 0x1608 <_ZN5USART5printEPKc>
     c3c:	60 91 62 04 	lds	r22, 0x0462	; 0x800462 <steering_ov>
     c40:	70 e0       	ldi	r23, 0x00	; 0
	Serial.print(" delta =  ");
     c42:	84 e9       	ldi	r24, 0x94	; 148
     c44:	94 e0       	ldi	r25, 0x04	; 4
     c46:	04 d5       	rcall	.+2568   	; 0x1650 <_ZN5USART5printEi>
     c48:	60 eb       	ldi	r22, 0xB0	; 176
     c4a:	73 e0       	ldi	r23, 0x03	; 3
	Serial.print(steering_delta);
     c4c:	84 e9       	ldi	r24, 0x94	; 148
     c4e:	94 e0       	ldi	r25, 0x04	; 4
     c50:	db d4       	rcall	.+2486   	; 0x1608 <_ZN5USART5printEPKc>
     c52:	60 91 67 04 	lds	r22, 0x0467	; 0x800467 <steering_delta>
     c56:	70 91 68 04 	lds	r23, 0x0468	; 0x800468 <steering_delta+0x1>
	Serial.print(" low volt =  ");
     c5a:	84 e9       	ldi	r24, 0x94	; 148
     c5c:	94 e0       	ldi	r25, 0x04	; 4
     c5e:	f8 d4       	rcall	.+2544   	; 0x1650 <_ZN5USART5printEi>
     c60:	6b eb       	ldi	r22, 0xBB	; 187
     c62:	73 e0       	ldi	r23, 0x03	; 3
	Serial.print(low_voltage);
     c64:	84 e9       	ldi	r24, 0x94	; 148
     c66:	94 e0       	ldi	r25, 0x04	; 4
     c68:	cf d4       	rcall	.+2462   	; 0x1608 <_ZN5USART5printEPKc>
     c6a:	60 91 46 04 	lds	r22, 0x0446	; 0x800446 <low_voltage>
     c6e:	70 91 47 04 	lds	r23, 0x0447	; 0x800447 <low_voltage+0x1>
	Serial.print(" high volt =  ");
     c72:	84 e9       	ldi	r24, 0x94	; 148
     c74:	94 e0       	ldi	r25, 0x04	; 4
     c76:	ec d4       	rcall	.+2520   	; 0x1650 <_ZN5USART5printEi>
     c78:	69 ec       	ldi	r22, 0xC9	; 201
     c7a:	73 e0       	ldi	r23, 0x03	; 3
	Serial.print(high_voltage);
     c7c:	84 e9       	ldi	r24, 0x94	; 148
     c7e:	94 e0       	ldi	r25, 0x04	; 4
     c80:	c3 d4       	rcall	.+2438   	; 0x1608 <_ZN5USART5printEPKc>
     c82:	60 91 3e 04 	lds	r22, 0x043E	; 0x80043e <__data_end>
     c86:	70 91 3f 04 	lds	r23, 0x043F	; 0x80043f <__data_end+0x1>
	Serial.print(" rpm =  ");
     c8a:	84 e9       	ldi	r24, 0x94	; 148
     c8c:	94 e0       	ldi	r25, 0x04	; 4
     c8e:	e0 d4       	rcall	.+2496   	; 0x1650 <_ZN5USART5printEi>
     c90:	68 ed       	ldi	r22, 0xD8	; 216
     c92:	73 e0       	ldi	r23, 0x03	; 3
     c94:	84 e9       	ldi	r24, 0x94	; 148
	Serial.print(engine_rpm);
     c96:	94 e0       	ldi	r25, 0x04	; 4
     c98:	b7 d4       	rcall	.+2414   	; 0x1608 <_ZN5USART5printEPKc>
     c9a:	60 91 44 04 	lds	r22, 0x0444	; 0x800444 <engine_rpm>
     c9e:	70 91 45 04 	lds	r23, 0x0445	; 0x800445 <engine_rpm+0x1>
     ca2:	84 e9       	ldi	r24, 0x94	; 148
     ca4:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" temp =  ");
     ca6:	d4 d4       	rcall	.+2472   	; 0x1650 <_ZN5USART5printEi>
     ca8:	61 ee       	ldi	r22, 0xE1	; 225
     caa:	73 e0       	ldi	r23, 0x03	; 3
     cac:	84 e9       	ldi	r24, 0x94	; 148
     cae:	94 e0       	ldi	r25, 0x04	; 4
     cb0:	ab d4       	rcall	.+2390   	; 0x1608 <_ZN5USART5printEPKc>
	Serial.println(engine_temp);
     cb2:	60 91 42 04 	lds	r22, 0x0442	; 0x800442 <engine_temp>
     cb6:	70 91 43 04 	lds	r23, 0x0443	; 0x800443 <engine_temp+0x1>
     cba:	84 e9       	ldi	r24, 0x94	; 148
     cbc:	94 e0       	ldi	r25, 0x04	; 4
     cbe:	eb c4       	rjmp	.+2518   	; 0x1696 <_ZN5USART7printlnEi>
     cc0:	08 95       	ret

00000cc2 <_Z13updateCurtissv>:
     cc2:	25 e7       	ldi	r18, 0x75	; 117
}

void updateCurtiss(){
	CAN_Curt.readMsgBuf(&rxId_Curt, &len_Curt, rxBuf_Curt);      // Read data: len = data length, buf = data byte(s)
     cc4:	34 e0       	ldi	r19, 0x04	; 4
     cc6:	4d e7       	ldi	r20, 0x7D	; 125
     cc8:	54 e0       	ldi	r21, 0x04	; 4
     cca:	6e e7       	ldi	r22, 0x7E	; 126
     ccc:	74 e0       	ldi	r23, 0x04	; 4
     cce:	82 e8       	ldi	r24, 0x82	; 130
     cd0:	94 e0       	ldi	r25, 0x04	; 4
     cd2:	0d d4       	rcall	.+2074   	; 0x14ee <_ZN7MCP_CAN10readMsgBufEPmPhS1_>
	if((rxId_Curt & 0x40000000) == 0x40000000)    // Determine if message is a remote request frame.
     cd4:	80 91 7e 04 	lds	r24, 0x047E	; 0x80047e <rxId_Curt>
     cd8:	90 91 7f 04 	lds	r25, 0x047F	; 0x80047f <rxId_Curt+0x1>
     cdc:	a0 91 80 04 	lds	r26, 0x0480	; 0x800480 <rxId_Curt+0x2>
     ce0:	b0 91 81 04 	lds	r27, 0x0481	; 0x800481 <rxId_Curt+0x3>
     ce4:	b6 fd       	sbrc	r27, 6
     ce6:	36 c0       	rjmp	.+108    	; 0xd54 <_Z13updateCurtissv+0x92>
		return;	
	low_voltage = rxBuf_Curt[0] + (rxBuf_Curt[1] * 256);
     ce8:	e5 e7       	ldi	r30, 0x75	; 117
     cea:	f4 e0       	ldi	r31, 0x04	; 4
     cec:	81 81       	ldd	r24, Z+1	; 0x01
     cee:	90 e0       	ldi	r25, 0x00	; 0
     cf0:	98 2f       	mov	r25, r24
     cf2:	88 27       	eor	r24, r24
     cf4:	20 81       	ld	r18, Z
     cf6:	82 0f       	add	r24, r18
     cf8:	91 1d       	adc	r25, r1
     cfa:	90 93 47 04 	sts	0x0447, r25	; 0x800447 <low_voltage+0x1>
     cfe:	80 93 46 04 	sts	0x0446, r24	; 0x800446 <low_voltage>
	engine_rpm = rxBuf_Curt[2] + (rxBuf_Curt[3] * 256);
     d02:	83 81       	ldd	r24, Z+3	; 0x03
     d04:	90 e0       	ldi	r25, 0x00	; 0
     d06:	98 2f       	mov	r25, r24
     d08:	88 27       	eor	r24, r24
     d0a:	22 81       	ldd	r18, Z+2	; 0x02
     d0c:	82 0f       	add	r24, r18
     d0e:	91 1d       	adc	r25, r1
     d10:	90 93 45 04 	sts	0x0445, r25	; 0x800445 <engine_rpm+0x1>
     d14:	80 93 44 04 	sts	0x0444, r24	; 0x800444 <engine_rpm>
	engine_temp = rxBuf_Curt[4] + (rxBuf_Curt[5] * 256);
     d18:	85 81       	ldd	r24, Z+5	; 0x05
     d1a:	90 e0       	ldi	r25, 0x00	; 0
     d1c:	98 2f       	mov	r25, r24
     d1e:	88 27       	eor	r24, r24
     d20:	24 81       	ldd	r18, Z+4	; 0x04
     d22:	82 0f       	add	r24, r18
     d24:	91 1d       	adc	r25, r1
     d26:	90 93 43 04 	sts	0x0443, r25	; 0x800443 <engine_temp+0x1>
     d2a:	80 93 42 04 	sts	0x0442, r24	; 0x800442 <engine_temp>
	control_temp = rxBuf_Curt[6] + (rxBuf_Curt[7] * 256);
     d2e:	87 81       	ldd	r24, Z+7	; 0x07
     d30:	90 e0       	ldi	r25, 0x00	; 0
     d32:	98 2f       	mov	r25, r24
     d34:	88 27       	eor	r24, r24
     d36:	26 81       	ldd	r18, Z+6	; 0x06
     d38:	ac 01       	movw	r20, r24
     d3a:	42 0f       	add	r20, r18
     d3c:	51 1d       	adc	r21, r1
     d3e:	50 93 41 04 	sts	0x0441, r21	; 0x800441 <control_temp+0x1>
     d42:	40 93 40 04 	sts	0x0440, r20	; 0x800440 <control_temp>
	high_voltage = rxBuf_Curt[8] + (rxBuf_Curt[7] * 256);	
     d46:	20 85       	ldd	r18, Z+8	; 0x08
     d48:	82 0f       	add	r24, r18
     d4a:	91 1d       	adc	r25, r1
     d4c:	90 93 3f 04 	sts	0x043F, r25	; 0x80043f <__data_end+0x1>
     d50:	80 93 3e 04 	sts	0x043E, r24	; 0x80043e <__data_end>
     d54:	08 95       	ret

00000d56 <main>:
unsigned char len_Curt;
unsigned char rxBuf_Curt[8];
char msgString_Curt[128];                        // Array to store Serial string

int main(void){
	Serial.println("Alley Hoop V2.1");
     d56:	6b ee       	ldi	r22, 0xEB	; 235
     d58:	73 e0       	ldi	r23, 0x03	; 3
     d5a:	84 e9       	ldi	r24, 0x94	; 148
     d5c:	94 e0       	ldi	r25, 0x04	; 4
     d5e:	6d d4       	rcall	.+2266   	; 0x163a <_ZN5USART7printlnEPKc>
	//setup canbus
	initIO();				//initializes the IO pins
     d60:	99 dc       	rcall	.-1742   	; 0x694 <_Z6initIOv>
	initDrive();	
     d62:	26 da       	rcall	.-2996   	; 0x1b0 <_Z9initDrivev>
     d64:	21 e0       	ldi	r18, 0x01	; 1
	//detect steering modus

	if(CAN_Curt.begin(MCP_ANY, CAN_500KBPS, MCP_16MHZ) == CAN_OK)
     d66:	4d e0       	ldi	r20, 0x0D	; 13
     d68:	63 e0       	ldi	r22, 0x03	; 3
     d6a:	82 e8       	ldi	r24, 0x82	; 130
     d6c:	94 e0       	ldi	r25, 0x04	; 4
     d6e:	85 d3       	rcall	.+1802   	; 0x147a <_ZN7MCP_CAN5beginEhhh>
     d70:	81 11       	cpse	r24, r1
     d72:	06 c0       	rjmp	.+12     	; 0xd80 <main+0x2a>
     d74:	6b ef       	ldi	r22, 0xFB	; 251
		Serial.println("MCP2515 Initialized Successfully!");
     d76:	73 e0       	ldi	r23, 0x03	; 3
     d78:	84 e9       	ldi	r24, 0x94	; 148
     d7a:	94 e0       	ldi	r25, 0x04	; 4
     d7c:	5e d4       	rcall	.+2236   	; 0x163a <_ZN5USART7printlnEPKc>
     d7e:	05 c0       	rjmp	.+10     	; 0xd8a <main+0x34>
     d80:	6d e1       	ldi	r22, 0x1D	; 29
	else
		Serial.println("Error Initializing MCP2515...");
     d82:	74 e0       	ldi	r23, 0x04	; 4
     d84:	84 e9       	ldi	r24, 0x94	; 148
     d86:	94 e0       	ldi	r25, 0x04	; 4
     d88:	58 d4       	rcall	.+2224   	; 0x163a <_ZN5USART7printlnEPKc>
	CAN_Curt.setMode(MCP_NORMAL);                     // Set operation mode to normal so the MCP2515 sends acks to received data.
     d8a:	60 e0       	ldi	r22, 0x00	; 0
     d8c:	82 e8       	ldi	r24, 0x82	; 130
     d8e:	94 e0       	ldi	r25, 0x04	; 4
     d90:	d5 d1       	rcall	.+938    	; 0x113c <_ZN7MCP_CAN7setModeEh>

	while (1){				//main program loop	
		updateCurtiss();		//update the values retrieved from the Curtis
     d92:	97 df       	rcall	.-210    	; 0xcc2 <_Z13updateCurtissv>
     d94:	62 dc       	rcall	.-1852   	; 0x65a <_Z5drivev>
		drive();				//update the values send to various components
     d96:	e4 de       	rcall	.-568    	; 0xb60 <_Z9printinfov>
     d98:	fc cf       	rjmp	.-8      	; 0xd92 <main+0x3c>

00000d9a <_GLOBAL__sub_I_Serial>:
		printinfo();			//print info in the terminal
     d9a:	84 e9       	ldi	r24, 0x94	; 148
     d9c:	94 e0       	ldi	r25, 0x04	; 4
     d9e:	29 d4       	rcall	.+2130   	; 0x15f2 <_ZN5USARTC1Ev>
#include <util/delay.h>		//allows usage of _delay_ms()
#include "overhead.h"		//defines and standard includes
#include "Drive.h"			//takes care of driving the car

USART Serial;				//global Serial
MCP_CAN CAN_Curt(47);
     da0:	6f e2       	ldi	r22, 0x2F	; 47
     da2:	82 e8       	ldi	r24, 0x82	; 130
     da4:	94 e0       	ldi	r25, 0x04	; 4
     da6:	5c c3       	rjmp	.+1720   	; 0x1460 <_ZN7MCP_CANC1Eh>
     da8:	08 95       	ret

00000daa <_ZN7MCP_CAN13mcp2515_resetEv>:
		tbufdata[MCP_EID0] = 0;
		tbufdata[MCP_EID8] = 0;
	}

	mcp2515_setRegisterS( mcp_addr, tbufdata, 4 );
}
     daa:	0f 93       	push	r16
     dac:	1f 93       	push	r17
     dae:	cf 93       	push	r28
     db0:	df 93       	push	r29
     db2:	1f 92       	push	r1
     db4:	1f 92       	push	r1
     db6:	cd b7       	in	r28, 0x3d	; 61
     db8:	de b7       	in	r29, 0x3e	; 62
     dba:	00 e0       	ldi	r16, 0x00	; 0
     dbc:	21 e0       	ldi	r18, 0x01	; 1
     dbe:	40 e8       	ldi	r20, 0x80	; 128
     dc0:	56 e9       	ldi	r21, 0x96	; 150
     dc2:	68 e9       	ldi	r22, 0x98	; 152
     dc4:	70 e0       	ldi	r23, 0x00	; 0
     dc6:	ce 01       	movw	r24, r28
     dc8:	01 96       	adiw	r24, 0x01	; 1
     dca:	e3 d3       	rcall	.+1990   	; 0x1592 <_ZN11SPISettingsC1Emhh>
     dcc:	be 01       	movw	r22, r28
     dce:	6f 5f       	subi	r22, 0xFF	; 255
     dd0:	7f 4f       	sbci	r23, 0xFF	; 255
     dd2:	86 e9       	ldi	r24, 0x96	; 150
     dd4:	94 e0       	ldi	r25, 0x04	; 4
     dd6:	01 d4       	rcall	.+2050   	; 0x15da <_ZN8SPIClass16beginTransactionE11SPISettings>
     dd8:	0b e0       	ldi	r16, 0x0B	; 11
     dda:	11 e0       	ldi	r17, 0x01	; 1
     ddc:	f8 01       	movw	r30, r16
     dde:	80 81       	ld	r24, Z
     de0:	8b 7f       	andi	r24, 0xFB	; 251
     de2:	80 83       	st	Z, r24
     de4:	60 ec       	ldi	r22, 0xC0	; 192
     de6:	86 e9       	ldi	r24, 0x96	; 150
     de8:	94 e0       	ldi	r25, 0x04	; 4
     dea:	fd d3       	rcall	.+2042   	; 0x15e6 <_ZN8SPIClass8transferEh>
     dec:	f8 01       	movw	r30, r16
     dee:	80 81       	ld	r24, Z
     df0:	84 60       	ori	r24, 0x04	; 4
     df2:	80 83       	st	Z, r24
     df4:	83 ec       	ldi	r24, 0xC3	; 195
     df6:	99 e0       	ldi	r25, 0x09	; 9
     df8:	01 97       	sbiw	r24, 0x01	; 1
     dfa:	f1 f7       	brne	.-4      	; 0xdf8 <_ZN7MCP_CAN13mcp2515_resetEv+0x4e>
     dfc:	00 c0       	rjmp	.+0      	; 0xdfe <_ZN7MCP_CAN13mcp2515_resetEv+0x54>
     dfe:	00 00       	nop
     e00:	0f 90       	pop	r0
     e02:	0f 90       	pop	r0
     e04:	df 91       	pop	r29
     e06:	cf 91       	pop	r28
     e08:	1f 91       	pop	r17
     e0a:	0f 91       	pop	r16
     e0c:	08 95       	ret

00000e0e <_ZN7MCP_CAN20mcp2515_readRegisterEh>:
     e0e:	ff 92       	push	r15
     e10:	0f 93       	push	r16
     e12:	1f 93       	push	r17
     e14:	cf 93       	push	r28
     e16:	df 93       	push	r29
     e18:	1f 92       	push	r1
     e1a:	1f 92       	push	r1
     e1c:	cd b7       	in	r28, 0x3d	; 61
     e1e:	de b7       	in	r29, 0x3e	; 62
     e20:	f6 2e       	mov	r15, r22
     e22:	00 e0       	ldi	r16, 0x00	; 0
     e24:	21 e0       	ldi	r18, 0x01	; 1
     e26:	40 e8       	ldi	r20, 0x80	; 128
     e28:	56 e9       	ldi	r21, 0x96	; 150
     e2a:	68 e9       	ldi	r22, 0x98	; 152
     e2c:	70 e0       	ldi	r23, 0x00	; 0
     e2e:	ce 01       	movw	r24, r28
     e30:	01 96       	adiw	r24, 0x01	; 1
     e32:	af d3       	rcall	.+1886   	; 0x1592 <_ZN11SPISettingsC1Emhh>
     e34:	be 01       	movw	r22, r28
     e36:	6f 5f       	subi	r22, 0xFF	; 255
     e38:	7f 4f       	sbci	r23, 0xFF	; 255
     e3a:	86 e9       	ldi	r24, 0x96	; 150
     e3c:	94 e0       	ldi	r25, 0x04	; 4
     e3e:	cd d3       	rcall	.+1946   	; 0x15da <_ZN8SPIClass16beginTransactionE11SPISettings>
     e40:	0b e0       	ldi	r16, 0x0B	; 11
     e42:	11 e0       	ldi	r17, 0x01	; 1
     e44:	f8 01       	movw	r30, r16
     e46:	80 81       	ld	r24, Z
     e48:	8b 7f       	andi	r24, 0xFB	; 251
     e4a:	80 83       	st	Z, r24
     e4c:	63 e0       	ldi	r22, 0x03	; 3
     e4e:	86 e9       	ldi	r24, 0x96	; 150
     e50:	94 e0       	ldi	r25, 0x04	; 4
     e52:	c9 d3       	rcall	.+1938   	; 0x15e6 <_ZN8SPIClass8transferEh>
     e54:	6f 2d       	mov	r22, r15
     e56:	86 e9       	ldi	r24, 0x96	; 150
     e58:	94 e0       	ldi	r25, 0x04	; 4
     e5a:	c5 d3       	rcall	.+1930   	; 0x15e6 <_ZN8SPIClass8transferEh>
     e5c:	60 e0       	ldi	r22, 0x00	; 0
     e5e:	86 e9       	ldi	r24, 0x96	; 150
     e60:	94 e0       	ldi	r25, 0x04	; 4
     e62:	c1 d3       	rcall	.+1922   	; 0x15e6 <_ZN8SPIClass8transferEh>
     e64:	f8 01       	movw	r30, r16
     e66:	90 81       	ld	r25, Z
     e68:	94 60       	ori	r25, 0x04	; 4
     e6a:	90 83       	st	Z, r25
     e6c:	0f 90       	pop	r0
     e6e:	0f 90       	pop	r0
     e70:	df 91       	pop	r29
     e72:	cf 91       	pop	r28
     e74:	1f 91       	pop	r17
     e76:	0f 91       	pop	r16
     e78:	ff 90       	pop	r15
     e7a:	08 95       	ret

00000e7c <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh>:
     e7c:	cf 92       	push	r12
     e7e:	df 92       	push	r13
     e80:	ef 92       	push	r14
     e82:	ff 92       	push	r15
     e84:	0f 93       	push	r16
     e86:	1f 93       	push	r17
     e88:	cf 93       	push	r28
     e8a:	df 93       	push	r29
     e8c:	1f 92       	push	r1
     e8e:	1f 92       	push	r1
     e90:	cd b7       	in	r28, 0x3d	; 61
     e92:	de b7       	in	r29, 0x3e	; 62
     e94:	16 2f       	mov	r17, r22
     e96:	6a 01       	movw	r12, r20
     e98:	f2 2e       	mov	r15, r18
     e9a:	00 e0       	ldi	r16, 0x00	; 0
     e9c:	21 e0       	ldi	r18, 0x01	; 1
     e9e:	40 e8       	ldi	r20, 0x80	; 128
     ea0:	56 e9       	ldi	r21, 0x96	; 150
     ea2:	68 e9       	ldi	r22, 0x98	; 152
     ea4:	70 e0       	ldi	r23, 0x00	; 0
     ea6:	ce 01       	movw	r24, r28
     ea8:	01 96       	adiw	r24, 0x01	; 1
     eaa:	73 d3       	rcall	.+1766   	; 0x1592 <_ZN11SPISettingsC1Emhh>
     eac:	be 01       	movw	r22, r28
     eae:	6f 5f       	subi	r22, 0xFF	; 255
     eb0:	7f 4f       	sbci	r23, 0xFF	; 255
     eb2:	86 e9       	ldi	r24, 0x96	; 150
     eb4:	94 e0       	ldi	r25, 0x04	; 4
     eb6:	91 d3       	rcall	.+1826   	; 0x15da <_ZN8SPIClass16beginTransactionE11SPISettings>
     eb8:	eb e0       	ldi	r30, 0x0B	; 11
     eba:	f1 e0       	ldi	r31, 0x01	; 1
     ebc:	80 81       	ld	r24, Z
     ebe:	8b 7f       	andi	r24, 0xFB	; 251
     ec0:	80 83       	st	Z, r24
     ec2:	63 e0       	ldi	r22, 0x03	; 3
     ec4:	86 e9       	ldi	r24, 0x96	; 150
     ec6:	94 e0       	ldi	r25, 0x04	; 4
     ec8:	8e d3       	rcall	.+1820   	; 0x15e6 <_ZN8SPIClass8transferEh>
     eca:	61 2f       	mov	r22, r17
     ecc:	86 e9       	ldi	r24, 0x96	; 150
     ece:	94 e0       	ldi	r25, 0x04	; 4
     ed0:	8a d3       	rcall	.+1812   	; 0x15e6 <_ZN8SPIClass8transferEh>
     ed2:	ff 20       	and	r15, r15
     ed4:	99 f0       	breq	.+38     	; 0xefc <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh+0x80>
     ed6:	86 01       	movw	r16, r12
     ed8:	fa 94       	dec	r15
     eda:	ef 2c       	mov	r14, r15
     edc:	f1 2c       	mov	r15, r1
     ede:	8f ef       	ldi	r24, 0xFF	; 255
     ee0:	e8 1a       	sub	r14, r24
     ee2:	f8 0a       	sbc	r15, r24
     ee4:	ec 0c       	add	r14, r12
     ee6:	fd 1c       	adc	r15, r13
     ee8:	60 e0       	ldi	r22, 0x00	; 0
     eea:	86 e9       	ldi	r24, 0x96	; 150
     eec:	94 e0       	ldi	r25, 0x04	; 4
     eee:	7b d3       	rcall	.+1782   	; 0x15e6 <_ZN8SPIClass8transferEh>
     ef0:	f8 01       	movw	r30, r16
     ef2:	81 93       	st	Z+, r24
     ef4:	8f 01       	movw	r16, r30
     ef6:	ee 15       	cp	r30, r14
     ef8:	ff 05       	cpc	r31, r15
     efa:	b1 f7       	brne	.-20     	; 0xee8 <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh+0x6c>
     efc:	eb e0       	ldi	r30, 0x0B	; 11
     efe:	f1 e0       	ldi	r31, 0x01	; 1
     f00:	80 81       	ld	r24, Z
     f02:	84 60       	ori	r24, 0x04	; 4
     f04:	80 83       	st	Z, r24
     f06:	0f 90       	pop	r0
     f08:	0f 90       	pop	r0
     f0a:	df 91       	pop	r29
     f0c:	cf 91       	pop	r28
     f0e:	1f 91       	pop	r17
     f10:	0f 91       	pop	r16
     f12:	ff 90       	pop	r15
     f14:	ef 90       	pop	r14
     f16:	df 90       	pop	r13
     f18:	cf 90       	pop	r12
     f1a:	08 95       	ret

00000f1c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>:
     f1c:	ef 92       	push	r14
     f1e:	ff 92       	push	r15
     f20:	0f 93       	push	r16
     f22:	1f 93       	push	r17
     f24:	cf 93       	push	r28
     f26:	df 93       	push	r29
     f28:	1f 92       	push	r1
     f2a:	1f 92       	push	r1
     f2c:	cd b7       	in	r28, 0x3d	; 61
     f2e:	de b7       	in	r29, 0x3e	; 62
     f30:	e6 2e       	mov	r14, r22
     f32:	f4 2e       	mov	r15, r20
     f34:	00 e0       	ldi	r16, 0x00	; 0
     f36:	21 e0       	ldi	r18, 0x01	; 1
     f38:	40 e8       	ldi	r20, 0x80	; 128
     f3a:	56 e9       	ldi	r21, 0x96	; 150
     f3c:	68 e9       	ldi	r22, 0x98	; 152
     f3e:	70 e0       	ldi	r23, 0x00	; 0
     f40:	ce 01       	movw	r24, r28
     f42:	01 96       	adiw	r24, 0x01	; 1
     f44:	26 d3       	rcall	.+1612   	; 0x1592 <_ZN11SPISettingsC1Emhh>
     f46:	be 01       	movw	r22, r28
     f48:	6f 5f       	subi	r22, 0xFF	; 255
     f4a:	7f 4f       	sbci	r23, 0xFF	; 255
     f4c:	86 e9       	ldi	r24, 0x96	; 150
     f4e:	94 e0       	ldi	r25, 0x04	; 4
     f50:	44 d3       	rcall	.+1672   	; 0x15da <_ZN8SPIClass16beginTransactionE11SPISettings>
     f52:	0b e0       	ldi	r16, 0x0B	; 11
     f54:	11 e0       	ldi	r17, 0x01	; 1
     f56:	f8 01       	movw	r30, r16
     f58:	80 81       	ld	r24, Z
     f5a:	8b 7f       	andi	r24, 0xFB	; 251
     f5c:	80 83       	st	Z, r24
     f5e:	62 e0       	ldi	r22, 0x02	; 2
     f60:	86 e9       	ldi	r24, 0x96	; 150
     f62:	94 e0       	ldi	r25, 0x04	; 4
     f64:	40 d3       	rcall	.+1664   	; 0x15e6 <_ZN8SPIClass8transferEh>
     f66:	6e 2d       	mov	r22, r14
     f68:	86 e9       	ldi	r24, 0x96	; 150
     f6a:	94 e0       	ldi	r25, 0x04	; 4
     f6c:	3c d3       	rcall	.+1656   	; 0x15e6 <_ZN8SPIClass8transferEh>
     f6e:	6f 2d       	mov	r22, r15
     f70:	86 e9       	ldi	r24, 0x96	; 150
     f72:	94 e0       	ldi	r25, 0x04	; 4
     f74:	38 d3       	rcall	.+1648   	; 0x15e6 <_ZN8SPIClass8transferEh>
     f76:	f8 01       	movw	r30, r16
     f78:	80 81       	ld	r24, Z
     f7a:	84 60       	ori	r24, 0x04	; 4
     f7c:	80 83       	st	Z, r24
     f7e:	0f 90       	pop	r0
     f80:	0f 90       	pop	r0
     f82:	df 91       	pop	r29
     f84:	cf 91       	pop	r28
     f86:	1f 91       	pop	r17
     f88:	0f 91       	pop	r16
     f8a:	ff 90       	pop	r15
     f8c:	ef 90       	pop	r14
     f8e:	08 95       	ret

00000f90 <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh>:
     f90:	cf 92       	push	r12
     f92:	df 92       	push	r13
     f94:	ef 92       	push	r14
     f96:	ff 92       	push	r15
     f98:	0f 93       	push	r16
     f9a:	1f 93       	push	r17
     f9c:	cf 93       	push	r28
     f9e:	df 93       	push	r29
     fa0:	1f 92       	push	r1
     fa2:	1f 92       	push	r1
     fa4:	cd b7       	in	r28, 0x3d	; 61
     fa6:	de b7       	in	r29, 0x3e	; 62
     fa8:	16 2f       	mov	r17, r22
     faa:	6a 01       	movw	r12, r20
     fac:	f2 2e       	mov	r15, r18
     fae:	00 e0       	ldi	r16, 0x00	; 0
     fb0:	21 e0       	ldi	r18, 0x01	; 1
     fb2:	40 e8       	ldi	r20, 0x80	; 128
     fb4:	56 e9       	ldi	r21, 0x96	; 150
     fb6:	68 e9       	ldi	r22, 0x98	; 152
     fb8:	70 e0       	ldi	r23, 0x00	; 0
     fba:	ce 01       	movw	r24, r28
     fbc:	01 96       	adiw	r24, 0x01	; 1
     fbe:	e9 d2       	rcall	.+1490   	; 0x1592 <_ZN11SPISettingsC1Emhh>
     fc0:	be 01       	movw	r22, r28
     fc2:	6f 5f       	subi	r22, 0xFF	; 255
     fc4:	7f 4f       	sbci	r23, 0xFF	; 255
     fc6:	86 e9       	ldi	r24, 0x96	; 150
     fc8:	94 e0       	ldi	r25, 0x04	; 4
     fca:	07 d3       	rcall	.+1550   	; 0x15da <_ZN8SPIClass16beginTransactionE11SPISettings>
     fcc:	eb e0       	ldi	r30, 0x0B	; 11
     fce:	f1 e0       	ldi	r31, 0x01	; 1
     fd0:	80 81       	ld	r24, Z
     fd2:	8b 7f       	andi	r24, 0xFB	; 251
     fd4:	80 83       	st	Z, r24
     fd6:	62 e0       	ldi	r22, 0x02	; 2
     fd8:	86 e9       	ldi	r24, 0x96	; 150
     fda:	94 e0       	ldi	r25, 0x04	; 4
     fdc:	04 d3       	rcall	.+1544   	; 0x15e6 <_ZN8SPIClass8transferEh>
     fde:	61 2f       	mov	r22, r17
     fe0:	86 e9       	ldi	r24, 0x96	; 150
     fe2:	94 e0       	ldi	r25, 0x04	; 4
     fe4:	00 d3       	rcall	.+1536   	; 0x15e6 <_ZN8SPIClass8transferEh>
     fe6:	ff 20       	and	r15, r15
     fe8:	91 f0       	breq	.+36     	; 0x100e <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh+0x7e>
     fea:	86 01       	movw	r16, r12
     fec:	fa 94       	dec	r15
     fee:	ef 2c       	mov	r14, r15
     ff0:	f1 2c       	mov	r15, r1
     ff2:	8f ef       	ldi	r24, 0xFF	; 255
     ff4:	e8 1a       	sub	r14, r24
     ff6:	f8 0a       	sbc	r15, r24
     ff8:	ec 0c       	add	r14, r12
     ffa:	fd 1c       	adc	r15, r13
     ffc:	f8 01       	movw	r30, r16
     ffe:	61 91       	ld	r22, Z+
    1000:	8f 01       	movw	r16, r30
    1002:	86 e9       	ldi	r24, 0x96	; 150
    1004:	94 e0       	ldi	r25, 0x04	; 4
    1006:	ef d2       	rcall	.+1502   	; 0x15e6 <_ZN8SPIClass8transferEh>
    1008:	0e 15       	cp	r16, r14
    100a:	1f 05       	cpc	r17, r15
    100c:	b9 f7       	brne	.-18     	; 0xffc <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh+0x6c>
    100e:	eb e0       	ldi	r30, 0x0B	; 11
    1010:	f1 e0       	ldi	r31, 0x01	; 1
    1012:	80 81       	ld	r24, Z
    1014:	84 60       	ori	r24, 0x04	; 4
    1016:	80 83       	st	Z, r24
    1018:	0f 90       	pop	r0
    101a:	0f 90       	pop	r0
    101c:	df 91       	pop	r29
    101e:	cf 91       	pop	r28
    1020:	1f 91       	pop	r17
    1022:	0f 91       	pop	r16
    1024:	ff 90       	pop	r15
    1026:	ef 90       	pop	r14
    1028:	df 90       	pop	r13
    102a:	cf 90       	pop	r12
    102c:	08 95       	ret

0000102e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>:
    102e:	df 92       	push	r13
    1030:	ef 92       	push	r14
    1032:	ff 92       	push	r15
    1034:	0f 93       	push	r16
    1036:	1f 93       	push	r17
    1038:	cf 93       	push	r28
    103a:	df 93       	push	r29
    103c:	1f 92       	push	r1
    103e:	1f 92       	push	r1
    1040:	cd b7       	in	r28, 0x3d	; 61
    1042:	de b7       	in	r29, 0x3e	; 62
    1044:	d6 2e       	mov	r13, r22
    1046:	e4 2e       	mov	r14, r20
    1048:	f2 2e       	mov	r15, r18
    104a:	00 e0       	ldi	r16, 0x00	; 0
    104c:	21 e0       	ldi	r18, 0x01	; 1
    104e:	40 e8       	ldi	r20, 0x80	; 128
    1050:	56 e9       	ldi	r21, 0x96	; 150
    1052:	68 e9       	ldi	r22, 0x98	; 152
    1054:	70 e0       	ldi	r23, 0x00	; 0
    1056:	ce 01       	movw	r24, r28
    1058:	01 96       	adiw	r24, 0x01	; 1
    105a:	9b d2       	rcall	.+1334   	; 0x1592 <_ZN11SPISettingsC1Emhh>
    105c:	be 01       	movw	r22, r28
    105e:	6f 5f       	subi	r22, 0xFF	; 255
    1060:	7f 4f       	sbci	r23, 0xFF	; 255
    1062:	86 e9       	ldi	r24, 0x96	; 150
    1064:	94 e0       	ldi	r25, 0x04	; 4
    1066:	b9 d2       	rcall	.+1394   	; 0x15da <_ZN8SPIClass16beginTransactionE11SPISettings>
    1068:	0b e0       	ldi	r16, 0x0B	; 11
    106a:	11 e0       	ldi	r17, 0x01	; 1
    106c:	f8 01       	movw	r30, r16
    106e:	80 81       	ld	r24, Z
    1070:	8b 7f       	andi	r24, 0xFB	; 251
    1072:	80 83       	st	Z, r24
    1074:	65 e0       	ldi	r22, 0x05	; 5
    1076:	86 e9       	ldi	r24, 0x96	; 150
    1078:	94 e0       	ldi	r25, 0x04	; 4
    107a:	b5 d2       	rcall	.+1386   	; 0x15e6 <_ZN8SPIClass8transferEh>
    107c:	6d 2d       	mov	r22, r13
    107e:	86 e9       	ldi	r24, 0x96	; 150
    1080:	94 e0       	ldi	r25, 0x04	; 4
    1082:	b1 d2       	rcall	.+1378   	; 0x15e6 <_ZN8SPIClass8transferEh>
    1084:	6e 2d       	mov	r22, r14
    1086:	86 e9       	ldi	r24, 0x96	; 150
    1088:	94 e0       	ldi	r25, 0x04	; 4
    108a:	ad d2       	rcall	.+1370   	; 0x15e6 <_ZN8SPIClass8transferEh>
    108c:	6f 2d       	mov	r22, r15
    108e:	86 e9       	ldi	r24, 0x96	; 150
    1090:	94 e0       	ldi	r25, 0x04	; 4
    1092:	a9 d2       	rcall	.+1362   	; 0x15e6 <_ZN8SPIClass8transferEh>
    1094:	f8 01       	movw	r30, r16
    1096:	80 81       	ld	r24, Z
    1098:	84 60       	ori	r24, 0x04	; 4
    109a:	80 83       	st	Z, r24
    109c:	0f 90       	pop	r0
    109e:	0f 90       	pop	r0
    10a0:	df 91       	pop	r29
    10a2:	cf 91       	pop	r28
    10a4:	1f 91       	pop	r17
    10a6:	0f 91       	pop	r16
    10a8:	ff 90       	pop	r15
    10aa:	ef 90       	pop	r14
    10ac:	df 90       	pop	r13
    10ae:	08 95       	ret

000010b0 <_ZN7MCP_CAN18mcp2515_readStatusEv>:
    10b0:	0f 93       	push	r16
    10b2:	1f 93       	push	r17
    10b4:	cf 93       	push	r28
    10b6:	df 93       	push	r29
    10b8:	1f 92       	push	r1
    10ba:	1f 92       	push	r1
    10bc:	cd b7       	in	r28, 0x3d	; 61
    10be:	de b7       	in	r29, 0x3e	; 62
    10c0:	00 e0       	ldi	r16, 0x00	; 0
    10c2:	21 e0       	ldi	r18, 0x01	; 1
    10c4:	40 e8       	ldi	r20, 0x80	; 128
    10c6:	56 e9       	ldi	r21, 0x96	; 150
    10c8:	68 e9       	ldi	r22, 0x98	; 152
    10ca:	70 e0       	ldi	r23, 0x00	; 0
    10cc:	ce 01       	movw	r24, r28
    10ce:	01 96       	adiw	r24, 0x01	; 1
    10d0:	60 d2       	rcall	.+1216   	; 0x1592 <_ZN11SPISettingsC1Emhh>
    10d2:	be 01       	movw	r22, r28
    10d4:	6f 5f       	subi	r22, 0xFF	; 255
    10d6:	7f 4f       	sbci	r23, 0xFF	; 255
    10d8:	86 e9       	ldi	r24, 0x96	; 150
    10da:	94 e0       	ldi	r25, 0x04	; 4
    10dc:	7e d2       	rcall	.+1276   	; 0x15da <_ZN8SPIClass16beginTransactionE11SPISettings>
    10de:	0b e0       	ldi	r16, 0x0B	; 11
    10e0:	11 e0       	ldi	r17, 0x01	; 1
    10e2:	f8 01       	movw	r30, r16
    10e4:	80 81       	ld	r24, Z
    10e6:	8b 7f       	andi	r24, 0xFB	; 251
    10e8:	80 83       	st	Z, r24
    10ea:	60 ea       	ldi	r22, 0xA0	; 160
    10ec:	86 e9       	ldi	r24, 0x96	; 150
    10ee:	94 e0       	ldi	r25, 0x04	; 4
    10f0:	7a d2       	rcall	.+1268   	; 0x15e6 <_ZN8SPIClass8transferEh>
    10f2:	60 e0       	ldi	r22, 0x00	; 0
    10f4:	86 e9       	ldi	r24, 0x96	; 150
    10f6:	94 e0       	ldi	r25, 0x04	; 4
    10f8:	76 d2       	rcall	.+1260   	; 0x15e6 <_ZN8SPIClass8transferEh>
    10fa:	f8 01       	movw	r30, r16
    10fc:	90 81       	ld	r25, Z
    10fe:	94 60       	ori	r25, 0x04	; 4
    1100:	90 83       	st	Z, r25
    1102:	0f 90       	pop	r0
    1104:	0f 90       	pop	r0
    1106:	df 91       	pop	r29
    1108:	cf 91       	pop	r28
    110a:	1f 91       	pop	r17
    110c:	0f 91       	pop	r16
    110e:	08 95       	ret

00001110 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>:
    1110:	0f 93       	push	r16
    1112:	1f 93       	push	r17
    1114:	cf 93       	push	r28
    1116:	8c 01       	movw	r16, r24
    1118:	c6 2f       	mov	r28, r22
    111a:	26 2f       	mov	r18, r22
    111c:	40 ee       	ldi	r20, 0xE0	; 224
    111e:	6f e0       	ldi	r22, 0x0F	; 15
    1120:	86 df       	rcall	.-244    	; 0x102e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    1122:	6f e0       	ldi	r22, 0x0F	; 15
    1124:	c8 01       	movw	r24, r16
    1126:	73 de       	rcall	.-794    	; 0xe0e <_ZN7MCP_CAN20mcp2515_readRegisterEh>
    1128:	98 2f       	mov	r25, r24
    112a:	90 7e       	andi	r25, 0xE0	; 224
    112c:	81 e0       	ldi	r24, 0x01	; 1
    112e:	9c 13       	cpse	r25, r28
    1130:	01 c0       	rjmp	.+2      	; 0x1134 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh+0x24>
    1132:	80 e0       	ldi	r24, 0x00	; 0
    1134:	cf 91       	pop	r28
    1136:	1f 91       	pop	r17
    1138:	0f 91       	pop	r16
    113a:	08 95       	ret

0000113c <_ZN7MCP_CAN7setModeEh>:
    113c:	fc 01       	movw	r30, r24
    113e:	61 8b       	std	Z+17, r22	; 0x11
    1140:	e7 cf       	rjmp	.-50     	; 0x1110 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>
    1142:	08 95       	ret

00001144 <_ZN7MCP_CAN18mcp2515_configRateEhh>:
    1144:	cf 93       	push	r28
    1146:	df 93       	push	r29
    1148:	ec 01       	movw	r28, r24
    114a:	40 e4       	ldi	r20, 0x40	; 64
    114c:	6a e2       	ldi	r22, 0x2A	; 42
    114e:	e6 de       	rcall	.-564    	; 0xf1c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1150:	45 ee       	ldi	r20, 0xE5	; 229
    1152:	69 e2       	ldi	r22, 0x29	; 41
    1154:	ce 01       	movw	r24, r28
    1156:	e2 de       	rcall	.-572    	; 0xf1c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1158:	43 e8       	ldi	r20, 0x83	; 131
    115a:	68 e2       	ldi	r22, 0x28	; 40
    115c:	ce 01       	movw	r24, r28
    115e:	de de       	rcall	.-580    	; 0xf1c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1160:	80 e0       	ldi	r24, 0x00	; 0
    1162:	df 91       	pop	r29
    1164:	cf 91       	pop	r28
    1166:	08 95       	ret

00001168 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>:

/*********************************************************************************************************
** Function name:           mcp2515_write_mf
** Descriptions:            Write Masks and Filters
*********************************************************************************************************/
void MCP_CAN::mcp2515_write_mf( const uint8_t mcp_addr, const uint8_t ext, const uint32_t id ){
    1168:	0f 93       	push	r16
    116a:	1f 93       	push	r17
    116c:	cf 93       	push	r28
    116e:	df 93       	push	r29
    1170:	00 d0       	rcall	.+0      	; 0x1172 <_ZN7MCP_CAN16mcp2515_write_mfEhhm+0xa>
    1172:	1f 92       	push	r1
    1174:	cd b7       	in	r28, 0x3d	; 61
    1176:	de b7       	in	r29, 0x3e	; 62
	uint16_t canid;
	uint8_t tbufdata[4];
	canid = (uint16_t)(id & 0x0FFFF);
	if ( ext == 1){
    1178:	41 30       	cpi	r20, 0x01	; 1
    117a:	c9 f4       	brne	.+50     	; 0x11ae <_ZN7MCP_CAN16mcp2515_write_mfEhhm+0x46>
		tbufdata[MCP_EID0] = (uint8_t) (canid & 0xFF);
    117c:	0c 83       	std	Y+4, r16	; 0x04
		tbufdata[MCP_EID8] = (uint8_t) (canid >> 8);
    117e:	1b 83       	std	Y+3, r17	; 0x03
		canid = (uint16_t)(id >> 16);
    1180:	89 01       	movw	r16, r18
    1182:	22 27       	eor	r18, r18
    1184:	33 27       	eor	r19, r19
		tbufdata[MCP_SIDL] = (uint8_t) (canid & 0x03);
		tbufdata[MCP_SIDL] += (uint8_t) ((canid & 0x1C) << 3);
		tbufdata[MCP_SIDL] |= MCP_TXB_EXIDE_M;
    1186:	40 2f       	mov	r20, r16
    1188:	4c 71       	andi	r20, 0x1C	; 28
    118a:	44 0f       	add	r20, r20
    118c:	44 0f       	add	r20, r20
    118e:	44 0f       	add	r20, r20
    1190:	50 2f       	mov	r21, r16
    1192:	53 70       	andi	r21, 0x03	; 3
    1194:	45 0f       	add	r20, r21
    1196:	48 60       	ori	r20, 0x08	; 8
    1198:	4a 83       	std	Y+2, r20	; 0x02
		tbufdata[MCP_SIDH] = (uint8_t) (canid >> 5 );
    119a:	16 95       	lsr	r17
    119c:	07 95       	ror	r16
    119e:	12 95       	swap	r17
    11a0:	02 95       	swap	r16
    11a2:	0f 70       	andi	r16, 0x0F	; 15
    11a4:	01 27       	eor	r16, r17
    11a6:	1f 70       	andi	r17, 0x0F	; 15
    11a8:	01 27       	eor	r16, r17
    11aa:	09 83       	std	Y+1, r16	; 0x01
    11ac:	11 c0       	rjmp	.+34     	; 0x11d0 <_ZN7MCP_CAN16mcp2515_write_mfEhhm+0x68>
	} else {
		tbufdata[MCP_EID0] = (uint8_t) (canid & 0xFF);
    11ae:	0c 83       	std	Y+4, r16	; 0x04
		tbufdata[MCP_EID8] = (uint8_t) (canid >> 8);
    11b0:	1b 83       	std	Y+3, r17	; 0x03
		canid = (uint16_t)(id >> 16);
    11b2:	89 01       	movw	r16, r18
    11b4:	22 27       	eor	r18, r18
    11b6:	33 27       	eor	r19, r19
		tbufdata[MCP_SIDL] = (uint8_t) ((canid & 0x07) << 5);
    11b8:	40 2f       	mov	r20, r16
    11ba:	42 95       	swap	r20
    11bc:	44 0f       	add	r20, r20
    11be:	40 7e       	andi	r20, 0xE0	; 224
    11c0:	4a 83       	std	Y+2, r20	; 0x02
		tbufdata[MCP_SIDH] = (uint8_t) (canid >> 3 );
    11c2:	16 95       	lsr	r17
    11c4:	07 95       	ror	r16
    11c6:	16 95       	lsr	r17
    11c8:	07 95       	ror	r16
    11ca:	16 95       	lsr	r17
    11cc:	07 95       	ror	r16
    11ce:	09 83       	std	Y+1, r16	; 0x01
	}
	mcp2515_setRegisterS( mcp_addr, tbufdata, 4 );
    11d0:	24 e0       	ldi	r18, 0x04	; 4
    11d2:	ae 01       	movw	r20, r28
    11d4:	4f 5f       	subi	r20, 0xFF	; 255
    11d6:	5f 4f       	sbci	r21, 0xFF	; 255
    11d8:	db de       	rcall	.-586    	; 0xf90 <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh>
}
    11da:	0f 90       	pop	r0
    11dc:	0f 90       	pop	r0
    11de:	0f 90       	pop	r0
    11e0:	0f 90       	pop	r0
    11e2:	df 91       	pop	r29
    11e4:	cf 91       	pop	r28
    11e6:	1f 91       	pop	r17
    11e8:	0f 91       	pop	r16
    11ea:	08 95       	ret

000011ec <_ZN7MCP_CAN22mcp2515_initCANBuffersEv>:

/*********************************************************************************************************
** Function name:           mcp2515_initCANBuffers
** Descriptions:            Initialize Buffers, Masks, and Filters
*********************************************************************************************************/
void MCP_CAN::mcp2515_initCANBuffers(void){
    11ec:	ef 92       	push	r14
    11ee:	ff 92       	push	r15
    11f0:	0f 93       	push	r16
    11f2:	1f 93       	push	r17
    11f4:	cf 93       	push	r28
    11f6:	7c 01       	movw	r14, r24
	uint8_t std = 0;
	uint8_t ext = 1;
	uint32_t ulMask = 0x00, ulFilt = 0x00;


	mcp2515_write_mf(MCP_RXM0SIDH, ext, ulMask);			/*Set both masks to 0           */
    11f8:	00 e0       	ldi	r16, 0x00	; 0
    11fa:	10 e0       	ldi	r17, 0x00	; 0
    11fc:	98 01       	movw	r18, r16
    11fe:	41 e0       	ldi	r20, 0x01	; 1
    1200:	60 e2       	ldi	r22, 0x20	; 32
    1202:	b2 df       	rcall	.-156    	; 0x1168 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXM1SIDH, ext, ulMask);			/*Mask register ignores ext bit */
    1204:	00 e0       	ldi	r16, 0x00	; 0
    1206:	10 e0       	ldi	r17, 0x00	; 0
    1208:	98 01       	movw	r18, r16
    120a:	41 e0       	ldi	r20, 0x01	; 1
    120c:	64 e2       	ldi	r22, 0x24	; 36
    120e:	c7 01       	movw	r24, r14
    1210:	ab df       	rcall	.-170    	; 0x1168 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	
	/* Set all filters to 0         */
	mcp2515_write_mf(MCP_RXF0SIDH, ext, ulFilt);			/* RXB0: extended               */
    1212:	00 e0       	ldi	r16, 0x00	; 0
    1214:	10 e0       	ldi	r17, 0x00	; 0
    1216:	98 01       	movw	r18, r16
    1218:	41 e0       	ldi	r20, 0x01	; 1
    121a:	60 e0       	ldi	r22, 0x00	; 0
    121c:	c7 01       	movw	r24, r14
    121e:	a4 df       	rcall	.-184    	; 0x1168 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF1SIDH, std, ulFilt);			/* RXB1: standard               */
    1220:	00 e0       	ldi	r16, 0x00	; 0
    1222:	10 e0       	ldi	r17, 0x00	; 0
    1224:	98 01       	movw	r18, r16
    1226:	40 e0       	ldi	r20, 0x00	; 0
    1228:	64 e0       	ldi	r22, 0x04	; 4
    122a:	c7 01       	movw	r24, r14
    122c:	9d df       	rcall	.-198    	; 0x1168 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF2SIDH, ext, ulFilt);			/* RXB2: extended               */
    122e:	00 e0       	ldi	r16, 0x00	; 0
    1230:	10 e0       	ldi	r17, 0x00	; 0
    1232:	98 01       	movw	r18, r16
    1234:	41 e0       	ldi	r20, 0x01	; 1
    1236:	68 e0       	ldi	r22, 0x08	; 8
    1238:	c7 01       	movw	r24, r14
    123a:	96 df       	rcall	.-212    	; 0x1168 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF3SIDH, std, ulFilt);			/* RXB3: standard               */
    123c:	00 e0       	ldi	r16, 0x00	; 0
    123e:	10 e0       	ldi	r17, 0x00	; 0
    1240:	98 01       	movw	r18, r16
    1242:	40 e0       	ldi	r20, 0x00	; 0
    1244:	60 e1       	ldi	r22, 0x10	; 16
    1246:	c7 01       	movw	r24, r14
    1248:	8f df       	rcall	.-226    	; 0x1168 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF4SIDH, ext, ulFilt);
    124a:	00 e0       	ldi	r16, 0x00	; 0
    124c:	10 e0       	ldi	r17, 0x00	; 0
    124e:	98 01       	movw	r18, r16
    1250:	41 e0       	ldi	r20, 0x01	; 1
    1252:	64 e1       	ldi	r22, 0x14	; 20
    1254:	c7 01       	movw	r24, r14
    1256:	88 df       	rcall	.-240    	; 0x1168 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF5SIDH, std, ulFilt);
    1258:	00 e0       	ldi	r16, 0x00	; 0
    125a:	10 e0       	ldi	r17, 0x00	; 0
    125c:	98 01       	movw	r18, r16
    125e:	40 e0       	ldi	r20, 0x00	; 0
    1260:	68 e1       	ldi	r22, 0x18	; 24
    1262:	c7 01       	movw	r24, r14
    1264:	81 df       	rcall	.-254    	; 0x1168 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>

	/* Clear, deactivate the three  */
	/* transmit buffers             */
	/* TXBnCTRL -> TXBnD7           */
	a1 = MCP_TXB0CTRL;
    1266:	c0 e3       	ldi	r28, 0x30	; 48
	a2 = MCP_TXB1CTRL;
	a3 = MCP_TXB2CTRL;
	for (i = 0; i < 14; i++) {                                          /* in-buffer loop               */
		mcp2515_setRegister(a1, 0);
    1268:	40 e0       	ldi	r20, 0x00	; 0
    126a:	6c 2f       	mov	r22, r28
    126c:	c7 01       	movw	r24, r14
    126e:	56 de       	rcall	.-852    	; 0xf1c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		mcp2515_setRegister(a2, 0);
    1270:	60 e1       	ldi	r22, 0x10	; 16
    1272:	6c 0f       	add	r22, r28
    1274:	40 e0       	ldi	r20, 0x00	; 0
    1276:	c7 01       	movw	r24, r14
    1278:	51 de       	rcall	.-862    	; 0xf1c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		mcp2515_setRegister(a3, 0);
    127a:	60 e2       	ldi	r22, 0x20	; 32
    127c:	6c 0f       	add	r22, r28
    127e:	40 e0       	ldi	r20, 0x00	; 0
    1280:	c7 01       	movw	r24, r14
    1282:	4c de       	rcall	.-872    	; 0xf1c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		a1++;
    1284:	cf 5f       	subi	r28, 0xFF	; 255
	/* transmit buffers             */
	/* TXBnCTRL -> TXBnD7           */
	a1 = MCP_TXB0CTRL;
	a2 = MCP_TXB1CTRL;
	a3 = MCP_TXB2CTRL;
	for (i = 0; i < 14; i++) {                                          /* in-buffer loop               */
    1286:	ce 33       	cpi	r28, 0x3E	; 62
    1288:	79 f7       	brne	.-34     	; 0x1268 <_ZN7MCP_CAN22mcp2515_initCANBuffersEv+0x7c>
		mcp2515_setRegister(a3, 0);
		a1++;
		a2++;
		a3++;
	}
	mcp2515_setRegister(MCP_RXB0CTRL, 0);
    128a:	40 e0       	ldi	r20, 0x00	; 0
    128c:	60 e6       	ldi	r22, 0x60	; 96
    128e:	c7 01       	movw	r24, r14
    1290:	45 de       	rcall	.-886    	; 0xf1c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1292:	40 e0       	ldi	r20, 0x00	; 0
	mcp2515_setRegister(MCP_RXB1CTRL, 0);
    1294:	60 e7       	ldi	r22, 0x70	; 112
    1296:	c7 01       	movw	r24, r14
    1298:	41 de       	rcall	.-894    	; 0xf1c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    129a:	cf 91       	pop	r28
    129c:	1f 91       	pop	r17
}
    129e:	0f 91       	pop	r16
    12a0:	ff 90       	pop	r15
    12a2:	ef 90       	pop	r14
    12a4:	08 95       	ret

000012a6 <_ZN7MCP_CAN12mcp2515_initEhhh>:
    12a6:	ff 92       	push	r15
    12a8:	0f 93       	push	r16

/*********************************************************************************************************
** Function name:           mcp2515_init
** Descriptions:            Initialize the controller
*********************************************************************************************************/
uint8_t MCP_CAN::mcp2515_init(const uint8_t canIDMode, const uint8_t canSpeed, const uint8_t canClock){
    12aa:	1f 93       	push	r17
    12ac:	cf 93       	push	r28
    12ae:	df 93       	push	r29
    12b0:	ec 01       	movw	r28, r24
    12b2:	f6 2e       	mov	r15, r22
    12b4:	14 2f       	mov	r17, r20
    12b6:	02 2f       	mov	r16, r18
	uint8_t res;
	mcp2515_reset();
    12b8:	78 dd       	rcall	.-1296   	; 0xdaa <_ZN7MCP_CAN13mcp2515_resetEv>
	mcpMode = MCP_LOOPBACK;
    12ba:	80 e4       	ldi	r24, 0x40	; 64
    12bc:	89 8b       	std	Y+17, r24	; 0x11
	res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
    12be:	60 e8       	ldi	r22, 0x80	; 128
    12c0:	ce 01       	movw	r24, r28
    12c2:	26 df       	rcall	.-436    	; 0x1110 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>
	if(res > 0)
    12c4:	81 11       	cpse	r24, r1
    12c6:	35 c0       	rjmp	.+106    	; 0x1332 <_ZN7MCP_CAN12mcp2515_initEhhh+0x8c>
	return res;
	// Set Baudrate
	if(mcp2515_configRate(canSpeed, canClock))
    12c8:	40 2f       	mov	r20, r16
    12ca:	61 2f       	mov	r22, r17
    12cc:	ce 01       	movw	r24, r28
    12ce:	3a df       	rcall	.-396    	; 0x1144 <_ZN7MCP_CAN18mcp2515_configRateEhh>
    12d0:	81 11       	cpse	r24, r1
	return res;
	if ( res == MCP2515_OK ) {
		mcp2515_initCANBuffers();											//init canbuffers
    12d2:	2c c0       	rjmp	.+88     	; 0x132c <_ZN7MCP_CAN12mcp2515_initEhhh+0x86>
    12d4:	ce 01       	movw	r24, r28
		mcp2515_setRegister(MCP_CANINTE, MCP_RX0IF | MCP_RX1IF);			//interrupt mode
    12d6:	8a df       	rcall	.-236    	; 0x11ec <_ZN7MCP_CAN22mcp2515_initCANBuffersEv>
    12d8:	43 e0       	ldi	r20, 0x03	; 3
    12da:	6b e2       	ldi	r22, 0x2B	; 43
    12dc:	ce 01       	movw	r24, r28
		mcp2515_setRegister(MCP_BFPCTRL,MCP_BxBFS_MASK | MCP_BxBFE_MASK);	//Sets BF pins as GPO
    12de:	1e de       	rcall	.-964    	; 0xf1c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    12e0:	4c e3       	ldi	r20, 0x3C	; 60
    12e2:	6c e0       	ldi	r22, 0x0C	; 12
    12e4:	ce 01       	movw	r24, r28
		mcp2515_setRegister(MCP_TXRTSCTRL,0x00);							//Sets RTS pins as GPI
    12e6:	1a de       	rcall	.-972    	; 0xf1c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    12e8:	40 e0       	ldi	r20, 0x00	; 0
    12ea:	6d e0       	ldi	r22, 0x0D	; 13
    12ec:	ce 01       	movw	r24, r28
    12ee:	16 de       	rcall	.-980    	; 0xf1c <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		switch(canIDMode){
    12f0:	ff 20       	and	r15, r15
    12f2:	71 f0       	breq	.+28     	; 0x1310 <_ZN7MCP_CAN12mcp2515_initEhhh+0x6a>
    12f4:	83 e0       	ldi	r24, 0x03	; 3
    12f6:	f8 12       	cpse	r15, r24
			case (MCP_ANY):
			mcp2515_modifyRegister(MCP_RXB0CTRL,
			MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
			MCP_RXB_RX_ANY | MCP_RXB_BUKT_MASK);
    12f8:	1b c0       	rjmp	.+54     	; 0x1330 <_ZN7MCP_CAN12mcp2515_initEhhh+0x8a>
    12fa:	24 e6       	ldi	r18, 0x64	; 100
    12fc:	44 e6       	ldi	r20, 0x64	; 100
    12fe:	60 e6       	ldi	r22, 0x60	; 96
    1300:	ce 01       	movw	r24, r28
			mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
			MCP_RXB_RX_ANY);
    1302:	95 de       	rcall	.-726    	; 0x102e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    1304:	20 e6       	ldi	r18, 0x60	; 96
    1306:	40 e6       	ldi	r20, 0x60	; 96
    1308:	60 e7       	ldi	r22, 0x70	; 112
    130a:	ce 01       	movw	r24, r28
			break;
    130c:	90 de       	rcall	.-736    	; 0x102e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
			case (MCP_STDEXT):
			mcp2515_modifyRegister(MCP_RXB0CTRL,
			MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
			MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK );
    130e:	0a c0       	rjmp	.+20     	; 0x1324 <_ZN7MCP_CAN12mcp2515_initEhhh+0x7e>
    1310:	24 e0       	ldi	r18, 0x04	; 4
    1312:	44 e6       	ldi	r20, 0x64	; 100
    1314:	60 e6       	ldi	r22, 0x60	; 96
			mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
			MCP_RXB_RX_STDEXT);
    1316:	ce 01       	movw	r24, r28
    1318:	8a de       	rcall	.-748    	; 0x102e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    131a:	20 e0       	ldi	r18, 0x00	; 0
    131c:	40 e6       	ldi	r20, 0x60	; 96
    131e:	60 e7       	ldi	r22, 0x70	; 112
    1320:	ce 01       	movw	r24, r28
			break;
			default:
			return MCP2515_FAIL;
			break;
		}
		res = mcp2515_setCANCTRL_Mode(mcpMode);
    1322:	85 de       	rcall	.-758    	; 0x102e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    1324:	69 89       	ldd	r22, Y+17	; 0x11
    1326:	ce 01       	movw	r24, r28
    1328:	f3 de       	rcall	.-538    	; 0x1110 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>
    132a:	03 c0       	rjmp	.+6      	; 0x1332 <_ZN7MCP_CAN12mcp2515_initEhhh+0x8c>
	res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
	if(res > 0)
	return res;
	// Set Baudrate
	if(mcp2515_configRate(canSpeed, canClock))
	return res;
    132c:	80 e0       	ldi	r24, 0x00	; 0
    132e:	01 c0       	rjmp	.+2      	; 0x1332 <_ZN7MCP_CAN12mcp2515_initEhhh+0x8c>
			MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK );
			mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
			MCP_RXB_RX_STDEXT);
			break;
			default:
			return MCP2515_FAIL;
    1330:	81 e0       	ldi	r24, 0x01	; 1
		res = mcp2515_setCANCTRL_Mode(mcpMode);
		if(res)
		return res;
	}
	return res;
}
    1332:	df 91       	pop	r29
    1334:	cf 91       	pop	r28
    1336:	1f 91       	pop	r17
    1338:	0f 91       	pop	r16
    133a:	ff 90       	pop	r15
    133c:	08 95       	ret

0000133e <_ZN7MCP_CAN15mcp2515_read_idEhPhPm>:

/*********************************************************************************************************
** Function name:           mcp2515_read_id
** Descriptions:            Read CAN ID
*********************************************************************************************************/
void MCP_CAN::mcp2515_read_id( const uint8_t mcp_addr, uint8_t* ext, uint32_t* id ){
    133e:	ef 92       	push	r14
    1340:	ff 92       	push	r15
    1342:	0f 93       	push	r16
    1344:	1f 93       	push	r17
    1346:	cf 93       	push	r28
    1348:	df 93       	push	r29
    134a:	00 d0       	rcall	.+0      	; 0x134c <_ZN7MCP_CAN15mcp2515_read_idEhPhPm+0xe>
    134c:	1f 92       	push	r1
    134e:	cd b7       	in	r28, 0x3d	; 61
    1350:	de b7       	in	r29, 0x3e	; 62
    1352:	7a 01       	movw	r14, r20
    1354:	89 01       	movw	r16, r18
	uint8_t tbufdata[4];
	*ext = 0;
    1356:	fa 01       	movw	r30, r20
    1358:	10 82       	st	Z, r1
	*id = 0;
    135a:	f9 01       	movw	r30, r18
    135c:	10 82       	st	Z, r1
    135e:	11 82       	std	Z+1, r1	; 0x01
    1360:	12 82       	std	Z+2, r1	; 0x02
    1362:	13 82       	std	Z+3, r1	; 0x03
	mcp2515_readRegisterS( mcp_addr, tbufdata, 4 );
    1364:	24 e0       	ldi	r18, 0x04	; 4
    1366:	ae 01       	movw	r20, r28
    1368:	4f 5f       	subi	r20, 0xFF	; 255
    136a:	5f 4f       	sbci	r21, 0xFF	; 255
    136c:	87 dd       	rcall	.-1266   	; 0xe7c <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh>
	*id = (tbufdata[MCP_SIDH]<<3) + (tbufdata[MCP_SIDL]>>5);
    136e:	2a 81       	ldd	r18, Y+2	; 0x02
    1370:	39 81       	ldd	r19, Y+1	; 0x01
    1372:	82 2f       	mov	r24, r18
    1374:	90 e0       	ldi	r25, 0x00	; 0
    1376:	95 95       	asr	r25
    1378:	87 95       	ror	r24
    137a:	95 95       	asr	r25
    137c:	87 95       	ror	r24
    137e:	95 95       	asr	r25
    1380:	87 95       	ror	r24
    1382:	95 95       	asr	r25
    1384:	87 95       	ror	r24
    1386:	95 95       	asr	r25
    1388:	87 95       	ror	r24
    138a:	f8 e0       	ldi	r31, 0x08	; 8
    138c:	3f 9f       	mul	r19, r31
    138e:	80 0d       	add	r24, r0
    1390:	91 1d       	adc	r25, r1
    1392:	11 24       	eor	r1, r1
    1394:	09 2e       	mov	r0, r25
    1396:	00 0c       	add	r0, r0
    1398:	aa 0b       	sbc	r26, r26
    139a:	bb 0b       	sbc	r27, r27
    139c:	f8 01       	movw	r30, r16
    139e:	80 83       	st	Z, r24
    13a0:	91 83       	std	Z+1, r25	; 0x01
    13a2:	a2 83       	std	Z+2, r26	; 0x02
    13a4:	b3 83       	std	Z+3, r27	; 0x03
	if ( (tbufdata[MCP_SIDL] & MCP_TXB_EXIDE_M) ==  MCP_TXB_EXIDE_M ){
    13a6:	23 ff       	sbrs	r18, 3
    13a8:	26 c0       	rjmp	.+76     	; 0x13f6 <_ZN7MCP_CAN15mcp2515_read_idEhPhPm+0xb8>
		/* extended id                  */
		*id = (*id<<2) + (tbufdata[MCP_SIDL] & 0x03);
		*id = (*id<<8) + tbufdata[MCP_EID8];
		*id = (*id<<8) + tbufdata[MCP_EID0];
    13aa:	88 0f       	add	r24, r24
    13ac:	99 1f       	adc	r25, r25
    13ae:	aa 1f       	adc	r26, r26
    13b0:	bb 1f       	adc	r27, r27
    13b2:	88 0f       	add	r24, r24
    13b4:	99 1f       	adc	r25, r25
    13b6:	aa 1f       	adc	r26, r26
    13b8:	bb 1f       	adc	r27, r27
    13ba:	23 70       	andi	r18, 0x03	; 3
    13bc:	82 0f       	add	r24, r18
    13be:	91 1d       	adc	r25, r1
    13c0:	a1 1d       	adc	r26, r1
    13c2:	b1 1d       	adc	r27, r1
    13c4:	ba 2f       	mov	r27, r26
    13c6:	a9 2f       	mov	r26, r25
    13c8:	98 2f       	mov	r25, r24
    13ca:	88 27       	eor	r24, r24
    13cc:	2b 81       	ldd	r18, Y+3	; 0x03
    13ce:	82 0f       	add	r24, r18
    13d0:	91 1d       	adc	r25, r1
    13d2:	a1 1d       	adc	r26, r1
    13d4:	b1 1d       	adc	r27, r1
    13d6:	ba 2f       	mov	r27, r26
    13d8:	a9 2f       	mov	r26, r25
    13da:	98 2f       	mov	r25, r24
    13dc:	88 27       	eor	r24, r24
    13de:	2c 81       	ldd	r18, Y+4	; 0x04
    13e0:	82 0f       	add	r24, r18
    13e2:	91 1d       	adc	r25, r1
    13e4:	a1 1d       	adc	r26, r1
    13e6:	b1 1d       	adc	r27, r1
    13e8:	80 83       	st	Z, r24
    13ea:	91 83       	std	Z+1, r25	; 0x01
    13ec:	a2 83       	std	Z+2, r26	; 0x02
    13ee:	b3 83       	std	Z+3, r27	; 0x03
		*ext = 1;
    13f0:	81 e0       	ldi	r24, 0x01	; 1
    13f2:	f7 01       	movw	r30, r14
    13f4:	80 83       	st	Z, r24
	}
}
    13f6:	0f 90       	pop	r0
    13f8:	0f 90       	pop	r0
    13fa:	0f 90       	pop	r0
    13fc:	0f 90       	pop	r0
    13fe:	df 91       	pop	r29
    1400:	cf 91       	pop	r28
    1402:	1f 91       	pop	r17
    1404:	0f 91       	pop	r16
    1406:	ff 90       	pop	r15
    1408:	ef 90       	pop	r14
    140a:	08 95       	ret

0000140c <_ZN7MCP_CAN19mcp2515_read_canMsgEh>:

/*********************************************************************************************************
** Function name:           mcp2515_read_canMsg
** Descriptions:            Read message
*********************************************************************************************************/
void MCP_CAN::mcp2515_read_canMsg( const uint8_t buffer_sidh_addr){        /* read can msg                 */
    140c:	0f 93       	push	r16
    140e:	1f 93       	push	r17
    1410:	cf 93       	push	r28
    1412:	df 93       	push	r29
    1414:	ec 01       	movw	r28, r24
    1416:	16 2f       	mov	r17, r22
	uint8_t mcp_addr, ctrl;
	mcp_addr = buffer_sidh_addr;
	mcp2515_read_id( mcp_addr, &m_nExtFlg,&m_nID );
    1418:	9c 01       	movw	r18, r24
    141a:	2f 5f       	subi	r18, 0xFF	; 255
    141c:	3f 4f       	sbci	r19, 0xFF	; 255
    141e:	ac 01       	movw	r20, r24
    1420:	8e df       	rcall	.-228    	; 0x133e <_ZN7MCP_CAN15mcp2515_read_idEhPhPm>
	ctrl = mcp2515_readRegister( mcp_addr-1 );
    1422:	6f ef       	ldi	r22, 0xFF	; 255
    1424:	61 0f       	add	r22, r17
    1426:	ce 01       	movw	r24, r28
    1428:	f2 dc       	rcall	.-1564   	; 0xe0e <_ZN7MCP_CAN20mcp2515_readRegisterEh>
    142a:	08 2f       	mov	r16, r24
	m_nDlc = mcp2515_readRegister( mcp_addr+4 );
    142c:	64 e0       	ldi	r22, 0x04	; 4
    142e:	61 0f       	add	r22, r17
    1430:	ce 01       	movw	r24, r28
    1432:	ed dc       	rcall	.-1574   	; 0xe0e <_ZN7MCP_CAN20mcp2515_readRegisterEh>
    1434:	8d 83       	std	Y+5, r24	; 0x05
	if (ctrl & 0x08)
    1436:	03 ff       	sbrs	r16, 3
    1438:	03 c0       	rjmp	.+6      	; 0x1440 <_ZN7MCP_CAN19mcp2515_read_canMsgEh+0x34>
		m_nRtr = 1;
    143a:	91 e0       	ldi	r25, 0x01	; 1
    143c:	9e 87       	std	Y+14, r25	; 0x0e
    143e:	01 c0       	rjmp	.+2      	; 0x1442 <_ZN7MCP_CAN19mcp2515_read_canMsgEh+0x36>
	else
		m_nRtr = 0;
    1440:	1e 86       	std	Y+14, r1	; 0x0e
	m_nDlc &= MCP_DLC_MASK;
    1442:	28 2f       	mov	r18, r24
    1444:	2f 70       	andi	r18, 0x0F	; 15
    1446:	2d 83       	std	Y+5, r18	; 0x05
	mcp2515_readRegisterS( mcp_addr+5, &(m_nDta[0]), m_nDlc );
    1448:	ae 01       	movw	r20, r28
    144a:	4a 5f       	subi	r20, 0xFA	; 250
    144c:	5f 4f       	sbci	r21, 0xFF	; 255
    144e:	65 e0       	ldi	r22, 0x05	; 5
    1450:	61 0f       	add	r22, r17
    1452:	ce 01       	movw	r24, r28
    1454:	13 dd       	rcall	.-1498   	; 0xe7c <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh>
}
    1456:	df 91       	pop	r29
    1458:	cf 91       	pop	r28
    145a:	1f 91       	pop	r17
    145c:	0f 91       	pop	r16
    145e:	08 95       	ret

00001460 <_ZN7MCP_CANC1Eh>:
** Function name:           MCP_CAN
** Descriptions:            Public function to declare CAN class and the /CS pin.
*********************************************************************************************************/
MCP_CAN::MCP_CAN(uint8_t _CS)
{
	MCPCS = _CS;
    1460:	fc 01       	movw	r30, r24
    1462:	60 8b       	std	Z+16, r22	; 0x10
	MCP2515_UNSELECT();
    1464:	eb e0       	ldi	r30, 0x0B	; 11
    1466:	f1 e0       	ldi	r31, 0x01	; 1
    1468:	80 81       	ld	r24, Z
    146a:	84 60       	ori	r24, 0x04	; 4
    146c:	80 83       	st	Z, r24
	DDRL |= (1 << PL2);		//????
    146e:	ea e0       	ldi	r30, 0x0A	; 10
    1470:	f1 e0       	ldi	r31, 0x01	; 1
    1472:	80 81       	ld	r24, Z
    1474:	84 60       	ori	r24, 0x04	; 4
    1476:	80 83       	st	Z, r24
    1478:	08 95       	ret

0000147a <_ZN7MCP_CAN5beginEhhh>:
/*********************************************************************************************************
** Function name:           begin
** Descriptions:            Public function to declare controller initialization parameters.
*********************************************************************************************************/
uint8_t MCP_CAN::begin(uint8_t idmodeset, uint8_t speedset, uint8_t clockset)
{
    147a:	ff 92       	push	r15
    147c:	0f 93       	push	r16
    147e:	1f 93       	push	r17
    1480:	cf 93       	push	r28
    1482:	df 93       	push	r29
    1484:	ec 01       	movw	r28, r24
    1486:	16 2f       	mov	r17, r22
    1488:	04 2f       	mov	r16, r20
    148a:	f2 2e       	mov	r15, r18
	uint8_t res;

	SPI.begin();
    148c:	90 d0       	rcall	.+288    	; 0x15ae <_ZN8SPIClass5beginEv>
	res = mcp2515_init(idmodeset, speedset, clockset);
    148e:	2f 2d       	mov	r18, r15
    1490:	40 2f       	mov	r20, r16
    1492:	61 2f       	mov	r22, r17
    1494:	ce 01       	movw	r24, r28
    1496:	07 df       	rcall	.-498    	; 0x12a6 <_ZN7MCP_CAN12mcp2515_initEhhh>
    1498:	91 e0       	ldi	r25, 0x01	; 1
    149a:	81 11       	cpse	r24, r1
    149c:	01 c0       	rjmp	.+2      	; 0x14a0 <_ZN7MCP_CAN5beginEhhh+0x26>
    149e:	90 e0       	ldi	r25, 0x00	; 0
	if (res == MCP2515_OK)
	return CAN_OK;
	
	return CAN_FAILINIT;
}
    14a0:	89 2f       	mov	r24, r25
    14a2:	df 91       	pop	r29
    14a4:	cf 91       	pop	r28
    14a6:	1f 91       	pop	r17
    14a8:	0f 91       	pop	r16
    14aa:	ff 90       	pop	r15
    14ac:	08 95       	ret

000014ae <_ZN7MCP_CAN7readMsgEv>:

/*********************************************************************************************************
** Function name:           readMsg
** Descriptions:            Read message
*********************************************************************************************************/
uint8_t MCP_CAN::readMsg(){
    14ae:	cf 93       	push	r28
    14b0:	df 93       	push	r29
    14b2:	ec 01       	movw	r28, r24
	uint8_t stat, res;
	stat = mcp2515_readStatus();
    14b4:	fd dd       	rcall	.-1030   	; 0x10b0 <_ZN7MCP_CAN18mcp2515_readStatusEv>

	if ( stat & MCP_STAT_RX0IF )                                        /* Msg in Buffer 0              */
    14b6:	80 ff       	sbrs	r24, 0
    14b8:	0a c0       	rjmp	.+20     	; 0x14ce <_ZN7MCP_CAN7readMsgEv+0x20>
	{
		mcp2515_read_canMsg( MCP_RXBUF_0);
    14ba:	61 e6       	ldi	r22, 0x61	; 97
    14bc:	ce 01       	movw	r24, r28
    14be:	a6 df       	rcall	.-180    	; 0x140c <_ZN7MCP_CAN19mcp2515_read_canMsgEh>
		mcp2515_modifyRegister(MCP_CANINTF, MCP_RX0IF, 0);
    14c0:	20 e0       	ldi	r18, 0x00	; 0
    14c2:	41 e0       	ldi	r20, 0x01	; 1
    14c4:	6c e2       	ldi	r22, 0x2C	; 44
    14c6:	ce 01       	movw	r24, r28
    14c8:	b2 dd       	rcall	.-1180   	; 0x102e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
		res = CAN_OK;
    14ca:	80 e0       	ldi	r24, 0x00	; 0
    14cc:	0d c0       	rjmp	.+26     	; 0x14e8 <_ZN7MCP_CAN7readMsgEv+0x3a>
	}
	else if ( stat & MCP_STAT_RX1IF )                                   /* Msg in Buffer 1              */
    14ce:	81 ff       	sbrs	r24, 1
	{
		mcp2515_read_canMsg( MCP_RXBUF_1);
    14d0:	0a c0       	rjmp	.+20     	; 0x14e6 <_ZN7MCP_CAN7readMsgEv+0x38>
    14d2:	61 e7       	ldi	r22, 0x71	; 113
    14d4:	ce 01       	movw	r24, r28
    14d6:	9a df       	rcall	.-204    	; 0x140c <_ZN7MCP_CAN19mcp2515_read_canMsgEh>
		mcp2515_modifyRegister(MCP_CANINTF, MCP_RX1IF, 0);
    14d8:	20 e0       	ldi	r18, 0x00	; 0
    14da:	42 e0       	ldi	r20, 0x02	; 2
    14dc:	6c e2       	ldi	r22, 0x2C	; 44
    14de:	ce 01       	movw	r24, r28
    14e0:	a6 dd       	rcall	.-1204   	; 0x102e <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
		res = CAN_OK;
    14e2:	80 e0       	ldi	r24, 0x00	; 0
    14e4:	01 c0       	rjmp	.+2      	; 0x14e8 <_ZN7MCP_CAN7readMsgEv+0x3a>
	}
	else
	res = CAN_NOMSG;
    14e6:	84 e0       	ldi	r24, 0x04	; 4
	
	return res;
}
    14e8:	df 91       	pop	r29
    14ea:	cf 91       	pop	r28
    14ec:	08 95       	ret

000014ee <_ZN7MCP_CAN10readMsgBufEPmPhS1_>:

/*********************************************************************************************************
** Function name:           readMsgBuf
** Descriptions:            Public function, Reads message from receive buffer.
*********************************************************************************************************/
uint8_t MCP_CAN::readMsgBuf(uint32_t *id, uint8_t *len, uint8_t buf[]){
    14ee:	cf 92       	push	r12
    14f0:	df 92       	push	r13
    14f2:	ef 92       	push	r14
    14f4:	ff 92       	push	r15
    14f6:	0f 93       	push	r16
    14f8:	1f 93       	push	r17
    14fa:	cf 93       	push	r28
    14fc:	df 93       	push	r29
    14fe:	ec 01       	movw	r28, r24
    1500:	7b 01       	movw	r14, r22
    1502:	8a 01       	movw	r16, r20
    1504:	c2 2e       	mov	r12, r18
    1506:	d3 2e       	mov	r13, r19
	if(readMsg() == CAN_NOMSG)
    1508:	d2 df       	rcall	.-92     	; 0x14ae <_ZN7MCP_CAN7readMsgEv>
    150a:	84 30       	cpi	r24, 0x04	; 4
    150c:	c9 f1       	breq	.+114    	; 0x1580 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x92>
	return CAN_NOMSG;

	if (m_nExtFlg)
    150e:	88 81       	ld	r24, Y
    1510:	88 23       	and	r24, r24
    1512:	49 f0       	breq	.+18     	; 0x1526 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x38>
	m_nID |= 0x80000000;
    1514:	89 81       	ldd	r24, Y+1	; 0x01
    1516:	9a 81       	ldd	r25, Y+2	; 0x02
    1518:	ab 81       	ldd	r26, Y+3	; 0x03
    151a:	bc 81       	ldd	r27, Y+4	; 0x04
    151c:	b0 68       	ori	r27, 0x80	; 128
    151e:	89 83       	std	Y+1, r24	; 0x01
    1520:	9a 83       	std	Y+2, r25	; 0x02
    1522:	ab 83       	std	Y+3, r26	; 0x03
    1524:	bc 83       	std	Y+4, r27	; 0x04

	if (m_nRtr)
    1526:	8e 85       	ldd	r24, Y+14	; 0x0e
    1528:	88 23       	and	r24, r24
    152a:	49 f0       	breq	.+18     	; 0x153e <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x50>
	m_nID |= 0x40000000;
    152c:	89 81       	ldd	r24, Y+1	; 0x01
    152e:	9a 81       	ldd	r25, Y+2	; 0x02
    1530:	ab 81       	ldd	r26, Y+3	; 0x03
    1532:	bc 81       	ldd	r27, Y+4	; 0x04
    1534:	b0 64       	ori	r27, 0x40	; 64
    1536:	89 83       	std	Y+1, r24	; 0x01
    1538:	9a 83       	std	Y+2, r25	; 0x02
    153a:	ab 83       	std	Y+3, r26	; 0x03
    153c:	bc 83       	std	Y+4, r27	; 0x04
	*id  = m_nID;
    153e:	89 81       	ldd	r24, Y+1	; 0x01
    1540:	9a 81       	ldd	r25, Y+2	; 0x02
    1542:	ab 81       	ldd	r26, Y+3	; 0x03
    1544:	bc 81       	ldd	r27, Y+4	; 0x04
    1546:	f7 01       	movw	r30, r14
    1548:	80 83       	st	Z, r24
    154a:	91 83       	std	Z+1, r25	; 0x01
    154c:	a2 83       	std	Z+2, r26	; 0x02
    154e:	b3 83       	std	Z+3, r27	; 0x03
	*len = m_nDlc;
    1550:	8d 81       	ldd	r24, Y+5	; 0x05
    1552:	f8 01       	movw	r30, r16
    1554:	80 83       	st	Z, r24
	for(int i = 0; i<m_nDlc; i++)
    1556:	8d 81       	ldd	r24, Y+5	; 0x05
    1558:	88 23       	and	r24, r24
    155a:	89 f0       	breq	.+34     	; 0x157e <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x90>
    155c:	de 01       	movw	r26, r28
    155e:	16 96       	adiw	r26, 0x06	; 6
    1560:	ec 2d       	mov	r30, r12
    1562:	fd 2d       	mov	r31, r13
    1564:	20 e0       	ldi	r18, 0x00	; 0
    1566:	30 e0       	ldi	r19, 0x00	; 0
	buf[i] = m_nDta[i];
    1568:	8d 91       	ld	r24, X+
    156a:	81 93       	st	Z+, r24

	if (m_nRtr)
	m_nID |= 0x40000000;
	*id  = m_nID;
	*len = m_nDlc;
	for(int i = 0; i<m_nDlc; i++)
    156c:	2f 5f       	subi	r18, 0xFF	; 255
    156e:	3f 4f       	sbci	r19, 0xFF	; 255
    1570:	8d 81       	ldd	r24, Y+5	; 0x05
    1572:	90 e0       	ldi	r25, 0x00	; 0
    1574:	28 17       	cp	r18, r24
    1576:	39 07       	cpc	r19, r25
    1578:	bc f3       	brlt	.-18     	; 0x1568 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x7a>
	buf[i] = m_nDta[i];
	return CAN_OK;
    157a:	80 e0       	ldi	r24, 0x00	; 0
    157c:	01 c0       	rjmp	.+2      	; 0x1580 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x92>
    157e:	80 e0       	ldi	r24, 0x00	; 0
}
    1580:	df 91       	pop	r29
    1582:	cf 91       	pop	r28
    1584:	1f 91       	pop	r17
    1586:	0f 91       	pop	r16
    1588:	ff 90       	pop	r15
    158a:	ef 90       	pop	r14
    158c:	df 90       	pop	r13
    158e:	cf 90       	pop	r12
    1590:	08 95       	ret

00001592 <_ZN11SPISettingsC1Emhh>:
void SPIClass::end() {
	cli();							// Protect from a scheduler and prevent transactionBegin
	if (initialized)					// Decrease the reference counter
		initialized--;
	if (!initialized)				
		SPCR &= ~(1 << SPE);
    1592:	0f 93       	push	r16
    1594:	fc 01       	movw	r30, r24
    1596:	22 23       	and	r18, r18
    1598:	11 f0       	breq	.+4      	; 0x159e <_ZN11SPISettingsC1Emhh+0xc>
    159a:	90 e5       	ldi	r25, 0x50	; 80
    159c:	01 c0       	rjmp	.+2      	; 0x15a0 <_ZN11SPISettingsC1Emhh+0xe>
    159e:	90 e7       	ldi	r25, 0x70	; 112
    15a0:	0c 70       	andi	r16, 0x0C	; 12
    15a2:	09 2b       	or	r16, r25
    15a4:	00 83       	st	Z, r16
    15a6:	81 e0       	ldi	r24, 0x01	; 1
    15a8:	81 83       	std	Z+1, r24	; 0x01
    15aa:	0f 91       	pop	r16
    15ac:	08 95       	ret

000015ae <_ZN8SPIClass5beginEv>:
    15ae:	f8 94       	cli
    15b0:	80 91 95 04 	lds	r24, 0x0495	; 0x800495 <_ZN8SPIClass11initializedE>
    15b4:	81 11       	cpse	r24, r1
    15b6:	0b c0       	rjmp	.+22     	; 0x15ce <_ZN8SPIClass5beginEv+0x20>
    15b8:	58 9a       	sbi	0x0b, 0	; 11
    15ba:	20 9a       	sbi	0x04, 0	; 4
    15bc:	84 b1       	in	r24, 0x04	; 4
    15be:	86 60       	ori	r24, 0x06	; 6
    15c0:	84 b9       	out	0x04, r24	; 4
    15c2:	8c b5       	in	r24, 0x2c	; 44
    15c4:	80 61       	ori	r24, 0x10	; 16
    15c6:	8c bd       	out	0x2c, r24	; 44
    15c8:	8c b5       	in	r24, 0x2c	; 44
    15ca:	80 64       	ori	r24, 0x40	; 64
    15cc:	8c bd       	out	0x2c, r24	; 44
    15ce:	80 91 95 04 	lds	r24, 0x0495	; 0x800495 <_ZN8SPIClass11initializedE>
    15d2:	8f 5f       	subi	r24, 0xFF	; 255
    15d4:	80 93 95 04 	sts	0x0495, r24	; 0x800495 <_ZN8SPIClass11initializedE>
    15d8:	08 95       	ret

000015da <_ZN8SPIClass16beginTransactionE11SPISettings>:
}

void SPIClass::beginTransaction(SPISettings settings) {
	SPCR = settings.spcr;
    15da:	fb 01       	movw	r30, r22
    15dc:	80 81       	ld	r24, Z
    15de:	8c bd       	out	0x2c, r24	; 44
	SPSR = settings.spsr;
    15e0:	81 81       	ldd	r24, Z+1	; 0x01
    15e2:	8d bd       	out	0x2d, r24	; 45
    15e4:	08 95       	ret

000015e6 <_ZN8SPIClass8transferEh>:
}

uint8_t SPIClass::transfer(uint8_t data) {
SPDR = data;
    15e6:	6e bd       	out	0x2e, r22	; 46
while (!(SPSR & (1 << SPIF))) ; // wait
    15e8:	0d b4       	in	r0, 0x2d	; 45
    15ea:	07 fe       	sbrs	r0, 7
    15ec:	fd cf       	rjmp	.-6      	; 0x15e8 <_ZN8SPIClass8transferEh+0x2>
return SPDR;
    15ee:	8e b5       	in	r24, 0x2e	; 46
}
    15f0:	08 95       	ret

000015f2 <_ZN5USARTC1Ev>:
#include "USART.h"

//constructor with setup

USART::USART(){
	UCSR0B = (1 << TXEN0);						// Enable de USART Transmitter
    15f2:	88 e0       	ldi	r24, 0x08	; 8
    15f4:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);		// 8 data bits, 1 stop bit
    15f8:	96 e0       	ldi	r25, 0x06	; 6
    15fa:	90 93 c2 00 	sts	0x00C2, r25	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
	UBRR0H=0;									//write the baudrate (76800)
    15fe:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
	UBRR0L=8;									// "
    1602:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    1606:	08 95       	ret

00001608 <_ZN5USART5printEPKc>:
}



//write a string in the Serial
void USART::print(const char st[]) {
    1608:	cf 93       	push	r28
    160a:	df 93       	push	r29
	for(uint8_t i = 0 ; st[i] != 0 ; i++) {		//iterate over every char in the string
    160c:	fb 01       	movw	r30, r22
    160e:	90 81       	ld	r25, Z
    1610:	99 23       	and	r25, r25
    1612:	81 f0       	breq	.+32     	; 0x1634 <_ZN5USART5printEPKc+0x2c>
    1614:	20 e0       	ldi	r18, 0x00	; 0
		while(~UCSR0A & (1 << UDRE0));			//wait till the transmit buffer is empty
    1616:	e0 ec       	ldi	r30, 0xC0	; 192
    1618:	f0 e0       	ldi	r31, 0x00	; 0
		UDR0 = (int)st[i];						//write the char in the transmit buffer
    161a:	c6 ec       	ldi	r28, 0xC6	; 198
    161c:	d0 e0       	ldi	r29, 0x00	; 0


//write a string in the Serial
void USART::print(const char st[]) {
	for(uint8_t i = 0 ; st[i] != 0 ; i++) {		//iterate over every char in the string
		while(~UCSR0A & (1 << UDRE0));			//wait till the transmit buffer is empty
    161e:	80 81       	ld	r24, Z
    1620:	85 ff       	sbrs	r24, 5
    1622:	fd cf       	rjmp	.-6      	; 0x161e <_ZN5USART5printEPKc+0x16>
		UDR0 = (int)st[i];						//write the char in the transmit buffer
    1624:	98 83       	st	Y, r25



//write a string in the Serial
void USART::print(const char st[]) {
	for(uint8_t i = 0 ; st[i] != 0 ; i++) {		//iterate over every char in the string
    1626:	2f 5f       	subi	r18, 0xFF	; 255
    1628:	db 01       	movw	r26, r22
    162a:	a2 0f       	add	r26, r18
    162c:	b1 1d       	adc	r27, r1
    162e:	9c 91       	ld	r25, X
    1630:	91 11       	cpse	r25, r1
    1632:	f5 cf       	rjmp	.-22     	; 0x161e <_ZN5USART5printEPKc+0x16>
		while(~UCSR0A & (1 << UDRE0));			//wait till the transmit buffer is empty
		UDR0 = (int)st[i];						//write the char in the transmit buffer
	}
}
    1634:	df 91       	pop	r29
    1636:	cf 91       	pop	r28
    1638:	08 95       	ret

0000163a <_ZN5USART7printlnEPKc>:

void USART::println(const char st[]){
    163a:	cf 93       	push	r28
    163c:	df 93       	push	r29
    163e:	ec 01       	movw	r28, r24
	this->print(st);
    1640:	e3 df       	rcall	.-58     	; 0x1608 <_ZN5USART5printEPKc>
	this->print("\n\r");
    1642:	6b e3       	ldi	r22, 0x3B	; 59
    1644:	74 e0       	ldi	r23, 0x04	; 4
    1646:	ce 01       	movw	r24, r28
    1648:	df df       	rcall	.-66     	; 0x1608 <_ZN5USART5printEPKc>
}
    164a:	df 91       	pop	r29
    164c:	cf 91       	pop	r28
    164e:	08 95       	ret

00001650 <_ZN5USART5printEi>:

//write an integer in the Serial
void USART::print(int i) {
    1650:	0f 93       	push	r16
    1652:	1f 93       	push	r17
    1654:	cf 93       	push	r28
    1656:	df 93       	push	r29
    1658:	cd b7       	in	r28, 0x3d	; 61
    165a:	de b7       	in	r29, 0x3e	; 62
    165c:	60 97       	sbiw	r28, 0x10	; 16
    165e:	0f b6       	in	r0, 0x3f	; 63
    1660:	f8 94       	cli
    1662:	de bf       	out	0x3e, r29	; 62
    1664:	0f be       	out	0x3f, r0	; 63
    1666:	cd bf       	out	0x3d, r28	; 61
    1668:	8c 01       	movw	r16, r24
    166a:	cb 01       	movw	r24, r22
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    166c:	4a e0       	ldi	r20, 0x0A	; 10
    166e:	be 01       	movw	r22, r28
    1670:	6f 5f       	subi	r22, 0xFF	; 255
    1672:	7f 4f       	sbci	r23, 0xFF	; 255
    1674:	a2 d1       	rcall	.+836    	; 0x19ba <__itoa_ncheck>
	char buffer[16];							//create a string
	itoa(i,buffer,10);							//parse the integer into the string
	print(buffer);						//print the string
    1676:	be 01       	movw	r22, r28
    1678:	6f 5f       	subi	r22, 0xFF	; 255
    167a:	7f 4f       	sbci	r23, 0xFF	; 255
    167c:	c8 01       	movw	r24, r16
    167e:	c4 df       	rcall	.-120    	; 0x1608 <_ZN5USART5printEPKc>
}
    1680:	60 96       	adiw	r28, 0x10	; 16
    1682:	0f b6       	in	r0, 0x3f	; 63
    1684:	f8 94       	cli
    1686:	de bf       	out	0x3e, r29	; 62
    1688:	0f be       	out	0x3f, r0	; 63
    168a:	cd bf       	out	0x3d, r28	; 61
    168c:	df 91       	pop	r29
    168e:	cf 91       	pop	r28
    1690:	1f 91       	pop	r17
    1692:	0f 91       	pop	r16
    1694:	08 95       	ret

00001696 <_ZN5USART7printlnEi>:

void USART::println(int i){
    1696:	cf 93       	push	r28
    1698:	df 93       	push	r29
    169a:	ec 01       	movw	r28, r24
	this->print(i);
    169c:	d9 df       	rcall	.-78     	; 0x1650 <_ZN5USART5printEi>
	this->print("\n\r");
    169e:	6b e3       	ldi	r22, 0x3B	; 59
    16a0:	74 e0       	ldi	r23, 0x04	; 4
    16a2:	ce 01       	movw	r24, r28
    16a4:	b1 df       	rcall	.-158    	; 0x1608 <_ZN5USART5printEPKc>
}
    16a6:	df 91       	pop	r29
    16a8:	cf 91       	pop	r28
    16aa:	08 95       	ret

000016ac <__fixsfsi>:
    16ac:	04 d0       	rcall	.+8      	; 0x16b6 <__fixunssfsi>
    16ae:	68 94       	set
    16b0:	b1 11       	cpse	r27, r1
    16b2:	8d c0       	rjmp	.+282    	; 0x17ce <__fp_szero>
    16b4:	08 95       	ret

000016b6 <__fixunssfsi>:
    16b6:	70 d0       	rcall	.+224    	; 0x1798 <__fp_splitA>
    16b8:	88 f0       	brcs	.+34     	; 0x16dc <__fixunssfsi+0x26>
    16ba:	9f 57       	subi	r25, 0x7F	; 127
    16bc:	90 f0       	brcs	.+36     	; 0x16e2 <__fixunssfsi+0x2c>
    16be:	b9 2f       	mov	r27, r25
    16c0:	99 27       	eor	r25, r25
    16c2:	b7 51       	subi	r27, 0x17	; 23
    16c4:	a0 f0       	brcs	.+40     	; 0x16ee <__fixunssfsi+0x38>
    16c6:	d1 f0       	breq	.+52     	; 0x16fc <__fixunssfsi+0x46>
    16c8:	66 0f       	add	r22, r22
    16ca:	77 1f       	adc	r23, r23
    16cc:	88 1f       	adc	r24, r24
    16ce:	99 1f       	adc	r25, r25
    16d0:	1a f0       	brmi	.+6      	; 0x16d8 <__fixunssfsi+0x22>
    16d2:	ba 95       	dec	r27
    16d4:	c9 f7       	brne	.-14     	; 0x16c8 <__fixunssfsi+0x12>
    16d6:	12 c0       	rjmp	.+36     	; 0x16fc <__fixunssfsi+0x46>
    16d8:	b1 30       	cpi	r27, 0x01	; 1
    16da:	81 f0       	breq	.+32     	; 0x16fc <__fixunssfsi+0x46>
    16dc:	77 d0       	rcall	.+238    	; 0x17cc <__fp_zero>
    16de:	b1 e0       	ldi	r27, 0x01	; 1
    16e0:	08 95       	ret
    16e2:	74 c0       	rjmp	.+232    	; 0x17cc <__fp_zero>
    16e4:	67 2f       	mov	r22, r23
    16e6:	78 2f       	mov	r23, r24
    16e8:	88 27       	eor	r24, r24
    16ea:	b8 5f       	subi	r27, 0xF8	; 248
    16ec:	39 f0       	breq	.+14     	; 0x16fc <__fixunssfsi+0x46>
    16ee:	b9 3f       	cpi	r27, 0xF9	; 249
    16f0:	cc f3       	brlt	.-14     	; 0x16e4 <__fixunssfsi+0x2e>
    16f2:	86 95       	lsr	r24
    16f4:	77 95       	ror	r23
    16f6:	67 95       	ror	r22
    16f8:	b3 95       	inc	r27
    16fa:	d9 f7       	brne	.-10     	; 0x16f2 <__fixunssfsi+0x3c>
    16fc:	3e f4       	brtc	.+14     	; 0x170c <__fixunssfsi+0x56>
    16fe:	90 95       	com	r25
    1700:	80 95       	com	r24
    1702:	70 95       	com	r23
    1704:	61 95       	neg	r22
    1706:	7f 4f       	sbci	r23, 0xFF	; 255
    1708:	8f 4f       	sbci	r24, 0xFF	; 255
    170a:	9f 4f       	sbci	r25, 0xFF	; 255
    170c:	08 95       	ret

0000170e <__floatunsisf>:
    170e:	e8 94       	clt
    1710:	09 c0       	rjmp	.+18     	; 0x1724 <__floatsisf+0x12>

00001712 <__floatsisf>:
    1712:	97 fb       	bst	r25, 7
    1714:	3e f4       	brtc	.+14     	; 0x1724 <__floatsisf+0x12>
    1716:	90 95       	com	r25
    1718:	80 95       	com	r24
    171a:	70 95       	com	r23
    171c:	61 95       	neg	r22
    171e:	7f 4f       	sbci	r23, 0xFF	; 255
    1720:	8f 4f       	sbci	r24, 0xFF	; 255
    1722:	9f 4f       	sbci	r25, 0xFF	; 255
    1724:	99 23       	and	r25, r25
    1726:	a9 f0       	breq	.+42     	; 0x1752 <__floatsisf+0x40>
    1728:	f9 2f       	mov	r31, r25
    172a:	96 e9       	ldi	r25, 0x96	; 150
    172c:	bb 27       	eor	r27, r27
    172e:	93 95       	inc	r25
    1730:	f6 95       	lsr	r31
    1732:	87 95       	ror	r24
    1734:	77 95       	ror	r23
    1736:	67 95       	ror	r22
    1738:	b7 95       	ror	r27
    173a:	f1 11       	cpse	r31, r1
    173c:	f8 cf       	rjmp	.-16     	; 0x172e <__floatsisf+0x1c>
    173e:	fa f4       	brpl	.+62     	; 0x177e <__floatsisf+0x6c>
    1740:	bb 0f       	add	r27, r27
    1742:	11 f4       	brne	.+4      	; 0x1748 <__floatsisf+0x36>
    1744:	60 ff       	sbrs	r22, 0
    1746:	1b c0       	rjmp	.+54     	; 0x177e <__floatsisf+0x6c>
    1748:	6f 5f       	subi	r22, 0xFF	; 255
    174a:	7f 4f       	sbci	r23, 0xFF	; 255
    174c:	8f 4f       	sbci	r24, 0xFF	; 255
    174e:	9f 4f       	sbci	r25, 0xFF	; 255
    1750:	16 c0       	rjmp	.+44     	; 0x177e <__floatsisf+0x6c>
    1752:	88 23       	and	r24, r24
    1754:	11 f0       	breq	.+4      	; 0x175a <__floatsisf+0x48>
    1756:	96 e9       	ldi	r25, 0x96	; 150
    1758:	11 c0       	rjmp	.+34     	; 0x177c <__floatsisf+0x6a>
    175a:	77 23       	and	r23, r23
    175c:	21 f0       	breq	.+8      	; 0x1766 <__floatsisf+0x54>
    175e:	9e e8       	ldi	r25, 0x8E	; 142
    1760:	87 2f       	mov	r24, r23
    1762:	76 2f       	mov	r23, r22
    1764:	05 c0       	rjmp	.+10     	; 0x1770 <__floatsisf+0x5e>
    1766:	66 23       	and	r22, r22
    1768:	71 f0       	breq	.+28     	; 0x1786 <__floatsisf+0x74>
    176a:	96 e8       	ldi	r25, 0x86	; 134
    176c:	86 2f       	mov	r24, r22
    176e:	70 e0       	ldi	r23, 0x00	; 0
    1770:	60 e0       	ldi	r22, 0x00	; 0
    1772:	2a f0       	brmi	.+10     	; 0x177e <__floatsisf+0x6c>
    1774:	9a 95       	dec	r25
    1776:	66 0f       	add	r22, r22
    1778:	77 1f       	adc	r23, r23
    177a:	88 1f       	adc	r24, r24
    177c:	da f7       	brpl	.-10     	; 0x1774 <__floatsisf+0x62>
    177e:	88 0f       	add	r24, r24
    1780:	96 95       	lsr	r25
    1782:	87 95       	ror	r24
    1784:	97 f9       	bld	r25, 7
    1786:	08 95       	ret

00001788 <__fp_split3>:
    1788:	57 fd       	sbrc	r21, 7
    178a:	90 58       	subi	r25, 0x80	; 128
    178c:	44 0f       	add	r20, r20
    178e:	55 1f       	adc	r21, r21
    1790:	59 f0       	breq	.+22     	; 0x17a8 <__fp_splitA+0x10>
    1792:	5f 3f       	cpi	r21, 0xFF	; 255
    1794:	71 f0       	breq	.+28     	; 0x17b2 <__fp_splitA+0x1a>
    1796:	47 95       	ror	r20

00001798 <__fp_splitA>:
    1798:	88 0f       	add	r24, r24
    179a:	97 fb       	bst	r25, 7
    179c:	99 1f       	adc	r25, r25
    179e:	61 f0       	breq	.+24     	; 0x17b8 <__fp_splitA+0x20>
    17a0:	9f 3f       	cpi	r25, 0xFF	; 255
    17a2:	79 f0       	breq	.+30     	; 0x17c2 <__fp_splitA+0x2a>
    17a4:	87 95       	ror	r24
    17a6:	08 95       	ret
    17a8:	12 16       	cp	r1, r18
    17aa:	13 06       	cpc	r1, r19
    17ac:	14 06       	cpc	r1, r20
    17ae:	55 1f       	adc	r21, r21
    17b0:	f2 cf       	rjmp	.-28     	; 0x1796 <__fp_split3+0xe>
    17b2:	46 95       	lsr	r20
    17b4:	f1 df       	rcall	.-30     	; 0x1798 <__fp_splitA>
    17b6:	08 c0       	rjmp	.+16     	; 0x17c8 <__fp_splitA+0x30>
    17b8:	16 16       	cp	r1, r22
    17ba:	17 06       	cpc	r1, r23
    17bc:	18 06       	cpc	r1, r24
    17be:	99 1f       	adc	r25, r25
    17c0:	f1 cf       	rjmp	.-30     	; 0x17a4 <__fp_splitA+0xc>
    17c2:	86 95       	lsr	r24
    17c4:	71 05       	cpc	r23, r1
    17c6:	61 05       	cpc	r22, r1
    17c8:	08 94       	sec
    17ca:	08 95       	ret

000017cc <__fp_zero>:
    17cc:	e8 94       	clt

000017ce <__fp_szero>:
    17ce:	bb 27       	eor	r27, r27
    17d0:	66 27       	eor	r22, r22
    17d2:	77 27       	eor	r23, r23
    17d4:	cb 01       	movw	r24, r22
    17d6:	97 f9       	bld	r25, 7
    17d8:	08 95       	ret

000017da <__mulsf3>:
    17da:	0b d0       	rcall	.+22     	; 0x17f2 <__mulsf3x>
    17dc:	78 c0       	rjmp	.+240    	; 0x18ce <__fp_round>
    17de:	69 d0       	rcall	.+210    	; 0x18b2 <__fp_pscA>
    17e0:	28 f0       	brcs	.+10     	; 0x17ec <__mulsf3+0x12>
    17e2:	6e d0       	rcall	.+220    	; 0x18c0 <__fp_pscB>
    17e4:	18 f0       	brcs	.+6      	; 0x17ec <__mulsf3+0x12>
    17e6:	95 23       	and	r25, r21
    17e8:	09 f0       	breq	.+2      	; 0x17ec <__mulsf3+0x12>
    17ea:	5a c0       	rjmp	.+180    	; 0x18a0 <__fp_inf>
    17ec:	5f c0       	rjmp	.+190    	; 0x18ac <__fp_nan>
    17ee:	11 24       	eor	r1, r1
    17f0:	ee cf       	rjmp	.-36     	; 0x17ce <__fp_szero>

000017f2 <__mulsf3x>:
    17f2:	ca df       	rcall	.-108    	; 0x1788 <__fp_split3>
    17f4:	a0 f3       	brcs	.-24     	; 0x17de <__mulsf3+0x4>

000017f6 <__mulsf3_pse>:
    17f6:	95 9f       	mul	r25, r21
    17f8:	d1 f3       	breq	.-12     	; 0x17ee <__mulsf3+0x14>
    17fa:	95 0f       	add	r25, r21
    17fc:	50 e0       	ldi	r21, 0x00	; 0
    17fe:	55 1f       	adc	r21, r21
    1800:	62 9f       	mul	r22, r18
    1802:	f0 01       	movw	r30, r0
    1804:	72 9f       	mul	r23, r18
    1806:	bb 27       	eor	r27, r27
    1808:	f0 0d       	add	r31, r0
    180a:	b1 1d       	adc	r27, r1
    180c:	63 9f       	mul	r22, r19
    180e:	aa 27       	eor	r26, r26
    1810:	f0 0d       	add	r31, r0
    1812:	b1 1d       	adc	r27, r1
    1814:	aa 1f       	adc	r26, r26
    1816:	64 9f       	mul	r22, r20
    1818:	66 27       	eor	r22, r22
    181a:	b0 0d       	add	r27, r0
    181c:	a1 1d       	adc	r26, r1
    181e:	66 1f       	adc	r22, r22
    1820:	82 9f       	mul	r24, r18
    1822:	22 27       	eor	r18, r18
    1824:	b0 0d       	add	r27, r0
    1826:	a1 1d       	adc	r26, r1
    1828:	62 1f       	adc	r22, r18
    182a:	73 9f       	mul	r23, r19
    182c:	b0 0d       	add	r27, r0
    182e:	a1 1d       	adc	r26, r1
    1830:	62 1f       	adc	r22, r18
    1832:	83 9f       	mul	r24, r19
    1834:	a0 0d       	add	r26, r0
    1836:	61 1d       	adc	r22, r1
    1838:	22 1f       	adc	r18, r18
    183a:	74 9f       	mul	r23, r20
    183c:	33 27       	eor	r19, r19
    183e:	a0 0d       	add	r26, r0
    1840:	61 1d       	adc	r22, r1
    1842:	23 1f       	adc	r18, r19
    1844:	84 9f       	mul	r24, r20
    1846:	60 0d       	add	r22, r0
    1848:	21 1d       	adc	r18, r1
    184a:	82 2f       	mov	r24, r18
    184c:	76 2f       	mov	r23, r22
    184e:	6a 2f       	mov	r22, r26
    1850:	11 24       	eor	r1, r1
    1852:	9f 57       	subi	r25, 0x7F	; 127
    1854:	50 40       	sbci	r21, 0x00	; 0
    1856:	8a f0       	brmi	.+34     	; 0x187a <__mulsf3_pse+0x84>
    1858:	e1 f0       	breq	.+56     	; 0x1892 <__mulsf3_pse+0x9c>
    185a:	88 23       	and	r24, r24
    185c:	4a f0       	brmi	.+18     	; 0x1870 <__mulsf3_pse+0x7a>
    185e:	ee 0f       	add	r30, r30
    1860:	ff 1f       	adc	r31, r31
    1862:	bb 1f       	adc	r27, r27
    1864:	66 1f       	adc	r22, r22
    1866:	77 1f       	adc	r23, r23
    1868:	88 1f       	adc	r24, r24
    186a:	91 50       	subi	r25, 0x01	; 1
    186c:	50 40       	sbci	r21, 0x00	; 0
    186e:	a9 f7       	brne	.-22     	; 0x185a <__mulsf3_pse+0x64>
    1870:	9e 3f       	cpi	r25, 0xFE	; 254
    1872:	51 05       	cpc	r21, r1
    1874:	70 f0       	brcs	.+28     	; 0x1892 <__mulsf3_pse+0x9c>
    1876:	14 c0       	rjmp	.+40     	; 0x18a0 <__fp_inf>
    1878:	aa cf       	rjmp	.-172    	; 0x17ce <__fp_szero>
    187a:	5f 3f       	cpi	r21, 0xFF	; 255
    187c:	ec f3       	brlt	.-6      	; 0x1878 <__mulsf3_pse+0x82>
    187e:	98 3e       	cpi	r25, 0xE8	; 232
    1880:	dc f3       	brlt	.-10     	; 0x1878 <__mulsf3_pse+0x82>
    1882:	86 95       	lsr	r24
    1884:	77 95       	ror	r23
    1886:	67 95       	ror	r22
    1888:	b7 95       	ror	r27
    188a:	f7 95       	ror	r31
    188c:	e7 95       	ror	r30
    188e:	9f 5f       	subi	r25, 0xFF	; 255
    1890:	c1 f7       	brne	.-16     	; 0x1882 <__mulsf3_pse+0x8c>
    1892:	fe 2b       	or	r31, r30
    1894:	88 0f       	add	r24, r24
    1896:	91 1d       	adc	r25, r1
    1898:	96 95       	lsr	r25
    189a:	87 95       	ror	r24
    189c:	97 f9       	bld	r25, 7
    189e:	08 95       	ret

000018a0 <__fp_inf>:
    18a0:	97 f9       	bld	r25, 7
    18a2:	9f 67       	ori	r25, 0x7F	; 127
    18a4:	80 e8       	ldi	r24, 0x80	; 128
    18a6:	70 e0       	ldi	r23, 0x00	; 0
    18a8:	60 e0       	ldi	r22, 0x00	; 0
    18aa:	08 95       	ret

000018ac <__fp_nan>:
    18ac:	9f ef       	ldi	r25, 0xFF	; 255
    18ae:	80 ec       	ldi	r24, 0xC0	; 192
    18b0:	08 95       	ret

000018b2 <__fp_pscA>:
    18b2:	00 24       	eor	r0, r0
    18b4:	0a 94       	dec	r0
    18b6:	16 16       	cp	r1, r22
    18b8:	17 06       	cpc	r1, r23
    18ba:	18 06       	cpc	r1, r24
    18bc:	09 06       	cpc	r0, r25
    18be:	08 95       	ret

000018c0 <__fp_pscB>:
    18c0:	00 24       	eor	r0, r0
    18c2:	0a 94       	dec	r0
    18c4:	12 16       	cp	r1, r18
    18c6:	13 06       	cpc	r1, r19
    18c8:	14 06       	cpc	r1, r20
    18ca:	05 06       	cpc	r0, r21
    18cc:	08 95       	ret

000018ce <__fp_round>:
    18ce:	09 2e       	mov	r0, r25
    18d0:	03 94       	inc	r0
    18d2:	00 0c       	add	r0, r0
    18d4:	11 f4       	brne	.+4      	; 0x18da <__fp_round+0xc>
    18d6:	88 23       	and	r24, r24
    18d8:	52 f0       	brmi	.+20     	; 0x18ee <__fp_round+0x20>
    18da:	bb 0f       	add	r27, r27
    18dc:	40 f4       	brcc	.+16     	; 0x18ee <__fp_round+0x20>
    18de:	bf 2b       	or	r27, r31
    18e0:	11 f4       	brne	.+4      	; 0x18e6 <__fp_round+0x18>
    18e2:	60 ff       	sbrs	r22, 0
    18e4:	04 c0       	rjmp	.+8      	; 0x18ee <__fp_round+0x20>
    18e6:	6f 5f       	subi	r22, 0xFF	; 255
    18e8:	7f 4f       	sbci	r23, 0xFF	; 255
    18ea:	8f 4f       	sbci	r24, 0xFF	; 255
    18ec:	9f 4f       	sbci	r25, 0xFF	; 255
    18ee:	08 95       	ret

000018f0 <__divmodsi4>:
    18f0:	05 2e       	mov	r0, r21
    18f2:	97 fb       	bst	r25, 7
    18f4:	16 f4       	brtc	.+4      	; 0x18fa <__divmodsi4+0xa>
    18f6:	00 94       	com	r0
    18f8:	0f d0       	rcall	.+30     	; 0x1918 <__negsi2>
    18fa:	57 fd       	sbrc	r21, 7
    18fc:	05 d0       	rcall	.+10     	; 0x1908 <__divmodsi4_neg2>
    18fe:	2c d0       	rcall	.+88     	; 0x1958 <__udivmodsi4>
    1900:	07 fc       	sbrc	r0, 7
    1902:	02 d0       	rcall	.+4      	; 0x1908 <__divmodsi4_neg2>
    1904:	46 f4       	brtc	.+16     	; 0x1916 <__divmodsi4_exit>
    1906:	08 c0       	rjmp	.+16     	; 0x1918 <__negsi2>

00001908 <__divmodsi4_neg2>:
    1908:	50 95       	com	r21
    190a:	40 95       	com	r20
    190c:	30 95       	com	r19
    190e:	21 95       	neg	r18
    1910:	3f 4f       	sbci	r19, 0xFF	; 255
    1912:	4f 4f       	sbci	r20, 0xFF	; 255
    1914:	5f 4f       	sbci	r21, 0xFF	; 255

00001916 <__divmodsi4_exit>:
    1916:	08 95       	ret

00001918 <__negsi2>:
    1918:	90 95       	com	r25
    191a:	80 95       	com	r24
    191c:	70 95       	com	r23
    191e:	61 95       	neg	r22
    1920:	7f 4f       	sbci	r23, 0xFF	; 255
    1922:	8f 4f       	sbci	r24, 0xFF	; 255
    1924:	9f 4f       	sbci	r25, 0xFF	; 255
    1926:	08 95       	ret

00001928 <__tablejump2__>:
    1928:	ee 0f       	add	r30, r30
    192a:	ff 1f       	adc	r31, r31
    192c:	88 1f       	adc	r24, r24
    192e:	8b bf       	out	0x3b, r24	; 59
    1930:	07 90       	elpm	r0, Z+
    1932:	f6 91       	elpm	r31, Z
    1934:	e0 2d       	mov	r30, r0
    1936:	19 94       	eijmp

00001938 <__usmulhisi3>:
    1938:	31 d0       	rcall	.+98     	; 0x199c <__umulhisi3>

0000193a <__usmulhisi3_tail>:
    193a:	b7 ff       	sbrs	r27, 7
    193c:	08 95       	ret
    193e:	82 1b       	sub	r24, r18
    1940:	93 0b       	sbc	r25, r19
    1942:	08 95       	ret

00001944 <__muluhisi3>:
    1944:	2b d0       	rcall	.+86     	; 0x199c <__umulhisi3>
    1946:	a5 9f       	mul	r26, r21
    1948:	90 0d       	add	r25, r0
    194a:	b4 9f       	mul	r27, r20
    194c:	90 0d       	add	r25, r0
    194e:	a4 9f       	mul	r26, r20
    1950:	80 0d       	add	r24, r0
    1952:	91 1d       	adc	r25, r1
    1954:	11 24       	eor	r1, r1
    1956:	08 95       	ret

00001958 <__udivmodsi4>:
    1958:	a1 e2       	ldi	r26, 0x21	; 33
    195a:	1a 2e       	mov	r1, r26
    195c:	aa 1b       	sub	r26, r26
    195e:	bb 1b       	sub	r27, r27
    1960:	fd 01       	movw	r30, r26
    1962:	0d c0       	rjmp	.+26     	; 0x197e <__udivmodsi4_ep>

00001964 <__udivmodsi4_loop>:
    1964:	aa 1f       	adc	r26, r26
    1966:	bb 1f       	adc	r27, r27
    1968:	ee 1f       	adc	r30, r30
    196a:	ff 1f       	adc	r31, r31
    196c:	a2 17       	cp	r26, r18
    196e:	b3 07       	cpc	r27, r19
    1970:	e4 07       	cpc	r30, r20
    1972:	f5 07       	cpc	r31, r21
    1974:	20 f0       	brcs	.+8      	; 0x197e <__udivmodsi4_ep>
    1976:	a2 1b       	sub	r26, r18
    1978:	b3 0b       	sbc	r27, r19
    197a:	e4 0b       	sbc	r30, r20
    197c:	f5 0b       	sbc	r31, r21

0000197e <__udivmodsi4_ep>:
    197e:	66 1f       	adc	r22, r22
    1980:	77 1f       	adc	r23, r23
    1982:	88 1f       	adc	r24, r24
    1984:	99 1f       	adc	r25, r25
    1986:	1a 94       	dec	r1
    1988:	69 f7       	brne	.-38     	; 0x1964 <__udivmodsi4_loop>
    198a:	60 95       	com	r22
    198c:	70 95       	com	r23
    198e:	80 95       	com	r24
    1990:	90 95       	com	r25
    1992:	9b 01       	movw	r18, r22
    1994:	ac 01       	movw	r20, r24
    1996:	bd 01       	movw	r22, r26
    1998:	cf 01       	movw	r24, r30
    199a:	08 95       	ret

0000199c <__umulhisi3>:
    199c:	a2 9f       	mul	r26, r18
    199e:	b0 01       	movw	r22, r0
    19a0:	b3 9f       	mul	r27, r19
    19a2:	c0 01       	movw	r24, r0
    19a4:	a3 9f       	mul	r26, r19
    19a6:	70 0d       	add	r23, r0
    19a8:	81 1d       	adc	r24, r1
    19aa:	11 24       	eor	r1, r1
    19ac:	91 1d       	adc	r25, r1
    19ae:	b2 9f       	mul	r27, r18
    19b0:	70 0d       	add	r23, r0
    19b2:	81 1d       	adc	r24, r1
    19b4:	11 24       	eor	r1, r1
    19b6:	91 1d       	adc	r25, r1
    19b8:	08 95       	ret

000019ba <__itoa_ncheck>:
    19ba:	bb 27       	eor	r27, r27
    19bc:	4a 30       	cpi	r20, 0x0A	; 10
    19be:	31 f4       	brne	.+12     	; 0x19cc <__itoa_ncheck+0x12>
    19c0:	99 23       	and	r25, r25
    19c2:	22 f4       	brpl	.+8      	; 0x19cc <__itoa_ncheck+0x12>
    19c4:	bd e2       	ldi	r27, 0x2D	; 45
    19c6:	90 95       	com	r25
    19c8:	81 95       	neg	r24
    19ca:	9f 4f       	sbci	r25, 0xFF	; 255
    19cc:	01 c0       	rjmp	.+2      	; 0x19d0 <__utoa_common>

000019ce <__utoa_ncheck>:
    19ce:	bb 27       	eor	r27, r27

000019d0 <__utoa_common>:
    19d0:	fb 01       	movw	r30, r22
    19d2:	55 27       	eor	r21, r21
    19d4:	aa 27       	eor	r26, r26
    19d6:	88 0f       	add	r24, r24
    19d8:	99 1f       	adc	r25, r25
    19da:	aa 1f       	adc	r26, r26
    19dc:	a4 17       	cp	r26, r20
    19de:	10 f0       	brcs	.+4      	; 0x19e4 <__utoa_common+0x14>
    19e0:	a4 1b       	sub	r26, r20
    19e2:	83 95       	inc	r24
    19e4:	50 51       	subi	r21, 0x10	; 16
    19e6:	b9 f7       	brne	.-18     	; 0x19d6 <__utoa_common+0x6>
    19e8:	a0 5d       	subi	r26, 0xD0	; 208
    19ea:	aa 33       	cpi	r26, 0x3A	; 58
    19ec:	08 f0       	brcs	.+2      	; 0x19f0 <__utoa_common+0x20>
    19ee:	a9 5d       	subi	r26, 0xD9	; 217
    19f0:	a1 93       	st	Z+, r26
    19f2:	00 97       	sbiw	r24, 0x00	; 0
    19f4:	79 f7       	brne	.-34     	; 0x19d4 <__utoa_common+0x4>
    19f6:	b1 11       	cpse	r27, r1
    19f8:	b1 93       	st	Z+, r27
    19fa:	11 92       	st	Z+, r1
    19fc:	cb 01       	movw	r24, r22
    19fe:	00 c0       	rjmp	.+0      	; 0x1a00 <strrev>

00001a00 <strrev>:
    1a00:	dc 01       	movw	r26, r24
    1a02:	fc 01       	movw	r30, r24
    1a04:	67 2f       	mov	r22, r23
    1a06:	71 91       	ld	r23, Z+
    1a08:	77 23       	and	r23, r23
    1a0a:	e1 f7       	brne	.-8      	; 0x1a04 <strrev+0x4>
    1a0c:	32 97       	sbiw	r30, 0x02	; 2
    1a0e:	04 c0       	rjmp	.+8      	; 0x1a18 <strrev+0x18>
    1a10:	7c 91       	ld	r23, X
    1a12:	6d 93       	st	X+, r22
    1a14:	70 83       	st	Z, r23
    1a16:	62 91       	ld	r22, -Z
    1a18:	ae 17       	cp	r26, r30
    1a1a:	bf 07       	cpc	r27, r31
    1a1c:	c8 f3       	brcs	.-14     	; 0x1a10 <strrev+0x10>
    1a1e:	08 95       	ret

00001a20 <_exit>:
    1a20:	f8 94       	cli

00001a22 <__stop_program>:
    1a22:	ff cf       	rjmp	.-2      	; 0x1a22 <__stop_program>
