
Alley Hoop V2.1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000224  00800200  00001b40  00001bd4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001b40  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000052  00800424  00800424  00001df8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001df8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001e28  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000238  00000000  00000000  00001e68  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000046b4  00000000  00000000  000020a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001807  00000000  00000000  00006754  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001767  00000000  00000000  00007f5b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000006ac  00000000  00000000  000096c4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000112f  00000000  00000000  00009d70  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001fa9  00000000  00000000  0000ae9f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001f0  00000000  00000000  0000ce48  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	7d c0       	rjmp	.+250    	; 0xfc <__ctors_end>
       2:	00 00       	nop
       4:	ab c0       	rjmp	.+342    	; 0x15c <__bad_interrupt>
       6:	00 00       	nop
       8:	a9 c0       	rjmp	.+338    	; 0x15c <__bad_interrupt>
       a:	00 00       	nop
       c:	a7 c0       	rjmp	.+334    	; 0x15c <__bad_interrupt>
       e:	00 00       	nop
      10:	a5 c0       	rjmp	.+330    	; 0x15c <__bad_interrupt>
      12:	00 00       	nop
      14:	a3 c0       	rjmp	.+326    	; 0x15c <__bad_interrupt>
      16:	00 00       	nop
      18:	a1 c0       	rjmp	.+322    	; 0x15c <__bad_interrupt>
      1a:	00 00       	nop
      1c:	9f c0       	rjmp	.+318    	; 0x15c <__bad_interrupt>
      1e:	00 00       	nop
      20:	9d c0       	rjmp	.+314    	; 0x15c <__bad_interrupt>
      22:	00 00       	nop
      24:	9b c0       	rjmp	.+310    	; 0x15c <__bad_interrupt>
      26:	00 00       	nop
      28:	99 c0       	rjmp	.+306    	; 0x15c <__bad_interrupt>
      2a:	00 00       	nop
      2c:	97 c0       	rjmp	.+302    	; 0x15c <__bad_interrupt>
      2e:	00 00       	nop
      30:	95 c0       	rjmp	.+298    	; 0x15c <__bad_interrupt>
      32:	00 00       	nop
      34:	93 c0       	rjmp	.+294    	; 0x15c <__bad_interrupt>
      36:	00 00       	nop
      38:	91 c0       	rjmp	.+290    	; 0x15c <__bad_interrupt>
      3a:	00 00       	nop
      3c:	8f c0       	rjmp	.+286    	; 0x15c <__bad_interrupt>
      3e:	00 00       	nop
      40:	8d c0       	rjmp	.+282    	; 0x15c <__bad_interrupt>
      42:	00 00       	nop
      44:	8b c0       	rjmp	.+278    	; 0x15c <__bad_interrupt>
      46:	00 00       	nop
      48:	89 c0       	rjmp	.+274    	; 0x15c <__bad_interrupt>
      4a:	00 00       	nop
      4c:	87 c0       	rjmp	.+270    	; 0x15c <__bad_interrupt>
      4e:	00 00       	nop
      50:	85 c0       	rjmp	.+266    	; 0x15c <__bad_interrupt>
      52:	00 00       	nop
      54:	83 c0       	rjmp	.+262    	; 0x15c <__bad_interrupt>
      56:	00 00       	nop
      58:	81 c0       	rjmp	.+258    	; 0x15c <__bad_interrupt>
      5a:	00 00       	nop
      5c:	7f c0       	rjmp	.+254    	; 0x15c <__bad_interrupt>
      5e:	00 00       	nop
      60:	7d c0       	rjmp	.+250    	; 0x15c <__bad_interrupt>
      62:	00 00       	nop
      64:	7b c0       	rjmp	.+246    	; 0x15c <__bad_interrupt>
      66:	00 00       	nop
      68:	79 c0       	rjmp	.+242    	; 0x15c <__bad_interrupt>
      6a:	00 00       	nop
      6c:	77 c0       	rjmp	.+238    	; 0x15c <__bad_interrupt>
      6e:	00 00       	nop
      70:	75 c0       	rjmp	.+234    	; 0x15c <__bad_interrupt>
      72:	00 00       	nop
      74:	73 c0       	rjmp	.+230    	; 0x15c <__bad_interrupt>
      76:	00 00       	nop
      78:	71 c0       	rjmp	.+226    	; 0x15c <__bad_interrupt>
      7a:	00 00       	nop
      7c:	6f c0       	rjmp	.+222    	; 0x15c <__bad_interrupt>
      7e:	00 00       	nop
      80:	6d c0       	rjmp	.+218    	; 0x15c <__bad_interrupt>
      82:	00 00       	nop
      84:	6b c0       	rjmp	.+214    	; 0x15c <__bad_interrupt>
      86:	00 00       	nop
      88:	69 c0       	rjmp	.+210    	; 0x15c <__bad_interrupt>
      8a:	00 00       	nop
      8c:	67 c0       	rjmp	.+206    	; 0x15c <__bad_interrupt>
      8e:	00 00       	nop
      90:	65 c0       	rjmp	.+202    	; 0x15c <__bad_interrupt>
      92:	00 00       	nop
      94:	63 c0       	rjmp	.+198    	; 0x15c <__bad_interrupt>
      96:	00 00       	nop
      98:	61 c0       	rjmp	.+194    	; 0x15c <__bad_interrupt>
      9a:	00 00       	nop
      9c:	5f c0       	rjmp	.+190    	; 0x15c <__bad_interrupt>
      9e:	00 00       	nop
      a0:	5d c0       	rjmp	.+186    	; 0x15c <__bad_interrupt>
      a2:	00 00       	nop
      a4:	5b c0       	rjmp	.+182    	; 0x15c <__bad_interrupt>
      a6:	00 00       	nop
      a8:	59 c0       	rjmp	.+178    	; 0x15c <__bad_interrupt>
      aa:	00 00       	nop
      ac:	57 c0       	rjmp	.+174    	; 0x15c <__bad_interrupt>
      ae:	00 00       	nop
      b0:	55 c0       	rjmp	.+170    	; 0x15c <__bad_interrupt>
      b2:	00 00       	nop
      b4:	53 c0       	rjmp	.+166    	; 0x15c <__bad_interrupt>
      b6:	00 00       	nop
      b8:	51 c0       	rjmp	.+162    	; 0x15c <__bad_interrupt>
      ba:	00 00       	nop
      bc:	4f c0       	rjmp	.+158    	; 0x15c <__bad_interrupt>
      be:	00 00       	nop
      c0:	4d c0       	rjmp	.+154    	; 0x15c <__bad_interrupt>
      c2:	00 00       	nop
      c4:	4b c0       	rjmp	.+150    	; 0x15c <__bad_interrupt>
      c6:	00 00       	nop
      c8:	49 c0       	rjmp	.+146    	; 0x15c <__bad_interrupt>
      ca:	00 00       	nop
      cc:	47 c0       	rjmp	.+142    	; 0x15c <__bad_interrupt>
      ce:	00 00       	nop
      d0:	45 c0       	rjmp	.+138    	; 0x15c <__bad_interrupt>
      d2:	00 00       	nop
      d4:	43 c0       	rjmp	.+134    	; 0x15c <__bad_interrupt>
      d6:	00 00       	nop
      d8:	41 c0       	rjmp	.+130    	; 0x15c <__bad_interrupt>
      da:	00 00       	nop
      dc:	3f c0       	rjmp	.+126    	; 0x15c <__bad_interrupt>
      de:	00 00       	nop
      e0:	3d c0       	rjmp	.+122    	; 0x15c <__bad_interrupt>
      e2:	00 00       	nop
      e4:	c1 04       	cpc	r12, r1
      e6:	c6 04       	cpc	r12, r6
      e8:	cb 04       	cpc	r12, r11
      ea:	cd 04       	cpc	r12, r13
      ec:	d2 04       	cpc	r13, r2
      ee:	d7 04       	cpc	r13, r7
      f0:	dc 04       	cpc	r13, r12
      f2:	e1 04       	cpc	r14, r1
      f4:	e4 04       	cpc	r14, r4
      f6:	e7 04       	cpc	r14, r7
      f8:	ec 04       	cpc	r14, r12

000000fa <__ctors_start>:
      fa:	8c 07       	cpc	r24, r28

000000fc <__ctors_end>:
      fc:	11 24       	eor	r1, r1
      fe:	1f be       	out	0x3f, r1	; 63
     100:	cf ef       	ldi	r28, 0xFF	; 255
     102:	d1 e2       	ldi	r29, 0x21	; 33
     104:	de bf       	out	0x3e, r29	; 62
     106:	cd bf       	out	0x3d, r28	; 61
     108:	00 e0       	ldi	r16, 0x00	; 0
     10a:	0c bf       	out	0x3c, r16	; 60

0000010c <__do_copy_data>:
     10c:	14 e0       	ldi	r17, 0x04	; 4
     10e:	a0 e0       	ldi	r26, 0x00	; 0
     110:	b2 e0       	ldi	r27, 0x02	; 2
     112:	e0 e4       	ldi	r30, 0x40	; 64
     114:	fb e1       	ldi	r31, 0x1B	; 27
     116:	00 e0       	ldi	r16, 0x00	; 0
     118:	0b bf       	out	0x3b, r16	; 59
     11a:	02 c0       	rjmp	.+4      	; 0x120 <__do_copy_data+0x14>
     11c:	07 90       	elpm	r0, Z+
     11e:	0d 92       	st	X+, r0
     120:	a4 32       	cpi	r26, 0x24	; 36
     122:	b1 07       	cpc	r27, r17
     124:	d9 f7       	brne	.-10     	; 0x11c <__do_copy_data+0x10>

00000126 <__do_clear_bss>:
     126:	24 e0       	ldi	r18, 0x04	; 4
     128:	a4 e2       	ldi	r26, 0x24	; 36
     12a:	b4 e0       	ldi	r27, 0x04	; 4
     12c:	01 c0       	rjmp	.+2      	; 0x130 <.do_clear_bss_start>

0000012e <.do_clear_bss_loop>:
     12e:	1d 92       	st	X+, r1

00000130 <.do_clear_bss_start>:
     130:	a6 37       	cpi	r26, 0x76	; 118
     132:	b2 07       	cpc	r27, r18
     134:	e1 f7       	brne	.-8      	; 0x12e <.do_clear_bss_loop>

00000136 <__do_global_ctors>:
     136:	10 e0       	ldi	r17, 0x00	; 0
     138:	ce e7       	ldi	r28, 0x7E	; 126
     13a:	d0 e0       	ldi	r29, 0x00	; 0
     13c:	00 e0       	ldi	r16, 0x00	; 0
     13e:	06 c0       	rjmp	.+12     	; 0x14c <__do_global_ctors+0x16>
     140:	21 97       	sbiw	r28, 0x01	; 1
     142:	01 09       	sbc	r16, r1
     144:	80 2f       	mov	r24, r16
     146:	fe 01       	movw	r30, r28
     148:	0e 94 31 0c 	call	0x1862	; 0x1862 <__tablejump2__>
     14c:	cd 37       	cpi	r28, 0x7D	; 125
     14e:	d1 07       	cpc	r29, r17
     150:	80 e0       	ldi	r24, 0x00	; 0
     152:	08 07       	cpc	r16, r24
     154:	a9 f7       	brne	.-22     	; 0x140 <__do_global_ctors+0xa>
     156:	ba d6       	rcall	.+3444   	; 0xecc <main>
     158:	0c 94 9e 0d 	jmp	0x1b3c	; 0x1b3c <_exit>

0000015c <__bad_interrupt>:
     15c:	51 cf       	rjmp	.-350    	; 0x0 <__vectors>

0000015e <_Z11mode_selectv>:
		digitalWrite(do_hv_relay,LOW);			//disengage engine relay
		braking_dv=0;							//stop braking
	}
}

void mode_remote(){
     15e:	8b e2       	ldi	r24, 0x2B	; 43
     160:	90 e0       	ldi	r25, 0x00	; 0
     162:	14 d5       	rcall	.+2600   	; 0xb8c <_Z11digitalReadi>
     164:	88 23       	and	r24, r24
     166:	39 f0       	breq	.+14     	; 0x176 <_Z11mode_selectv+0x18>
     168:	81 e0       	ldi	r24, 0x01	; 1
     16a:	90 e0       	ldi	r25, 0x00	; 0
     16c:	90 93 53 04 	sts	0x0453, r25	; 0x800453 <drivemode+0x1>
     170:	80 93 52 04 	sts	0x0452, r24	; 0x800452 <drivemode>
     174:	08 95       	ret
     176:	88 e2       	ldi	r24, 0x28	; 40
     178:	90 e0       	ldi	r25, 0x00	; 0
     17a:	08 d5       	rcall	.+2576   	; 0xb8c <_Z11digitalReadi>
     17c:	88 23       	and	r24, r24
     17e:	39 f0       	breq	.+14     	; 0x18e <_Z11mode_selectv+0x30>
     180:	82 e0       	ldi	r24, 0x02	; 2
     182:	90 e0       	ldi	r25, 0x00	; 0
     184:	90 93 53 04 	sts	0x0453, r25	; 0x800453 <drivemode+0x1>
     188:	80 93 52 04 	sts	0x0452, r24	; 0x800452 <drivemode>
     18c:	08 95       	ret
     18e:	89 e2       	ldi	r24, 0x29	; 41
     190:	90 e0       	ldi	r25, 0x00	; 0
     192:	fc d4       	rcall	.+2552   	; 0xb8c <_Z11digitalReadi>
     194:	88 23       	and	r24, r24
     196:	39 f0       	breq	.+14     	; 0x1a6 <_Z11mode_selectv+0x48>
     198:	83 e0       	ldi	r24, 0x03	; 3
     19a:	90 e0       	ldi	r25, 0x00	; 0
     19c:	90 93 53 04 	sts	0x0453, r25	; 0x800453 <drivemode+0x1>
     1a0:	80 93 52 04 	sts	0x0452, r24	; 0x800452 <drivemode>
     1a4:	08 95       	ret
     1a6:	10 92 53 04 	sts	0x0453, r1	; 0x800453 <drivemode+0x1>
     1aa:	10 92 52 04 	sts	0x0452, r1	; 0x800452 <drivemode>
     1ae:	08 95       	ret

000001b0 <_Z9initDrivev>:
     1b0:	61 e0       	ldi	r22, 0x01	; 1
     1b2:	8a e1       	ldi	r24, 0x1A	; 26
     1b4:	90 e0       	ldi	r25, 0x00	; 0
     1b6:	1b d4       	rcall	.+2102   	; 0x9ee <_Z12digitalWriteib>
     1b8:	61 e0       	ldi	r22, 0x01	; 1
     1ba:	88 e1       	ldi	r24, 0x18	; 24
     1bc:	90 e0       	ldi	r25, 0x00	; 0
     1be:	17 d4       	rcall	.+2094   	; 0x9ee <_Z12digitalWriteib>
     1c0:	61 e0       	ldi	r22, 0x01	; 1
     1c2:	89 e1       	ldi	r24, 0x19	; 25
     1c4:	90 e0       	ldi	r25, 0x00	; 0
     1c6:	13 d4       	rcall	.+2086   	; 0x9ee <_Z12digitalWriteib>
     1c8:	61 e0       	ldi	r22, 0x01	; 1
     1ca:	86 e1       	ldi	r24, 0x16	; 22
     1cc:	90 e0       	ldi	r25, 0x00	; 0
     1ce:	0f d4       	rcall	.+2078   	; 0x9ee <_Z12digitalWriteib>
     1d0:	61 e0       	ldi	r22, 0x01	; 1
     1d2:	87 e1       	ldi	r24, 0x17	; 23
     1d4:	90 e0       	ldi	r25, 0x00	; 0
     1d6:	0b d4       	rcall	.+2070   	; 0x9ee <_Z12digitalWriteib>
     1d8:	c2 cf       	rjmp	.-124    	; 0x15e <_Z11mode_selectv>
     1da:	08 95       	ret

000001dc <_Z13mode_joystickv>:
     1dc:	0f 93       	push	r16
     1de:	1f 93       	push	r17
     1e0:	61 e0       	ldi	r22, 0x01	; 1
     1e2:	82 e2       	ldi	r24, 0x22	; 34
     1e4:	90 e0       	ldi	r25, 0x00	; 0
     1e6:	03 d4       	rcall	.+2054   	; 0x9ee <_Z12digitalWriteib>
     1e8:	61 e0       	ldi	r22, 0x01	; 1
     1ea:	8f e1       	ldi	r24, 0x1F	; 31
     1ec:	90 e0       	ldi	r25, 0x00	; 0
     1ee:	ff d3       	rcall	.+2046   	; 0x9ee <_Z12digitalWriteib>
     1f0:	80 91 2a 04 	lds	r24, 0x042A	; 0x80042a <engine_rpm>
     1f4:	90 91 2b 04 	lds	r25, 0x042B	; 0x80042b <engine_rpm+0x1>
     1f8:	89 2b       	or	r24, r25
     1fa:	29 f4       	brne	.+10     	; 0x206 <_Z13mode_joystickv+0x2a>
     1fc:	8a e2       	ldi	r24, 0x2A	; 42
     1fe:	90 e0       	ldi	r25, 0x00	; 0
     200:	c5 d4       	rcall	.+2442   	; 0xb8c <_Z11digitalReadi>
     202:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
     206:	84 e0       	ldi	r24, 0x04	; 4
     208:	90 e0       	ldi	r25, 0x00	; 0
     20a:	3c d5       	rcall	.+2680   	; 0xc84 <_Z10analogReadi>
     20c:	dc 01       	movw	r26, r24
     20e:	ad 5f       	subi	r26, 0xFD	; 253
     210:	b1 40       	sbci	r27, 0x01	; 1
     212:	2e e0       	ldi	r18, 0x0E	; 14
     214:	31 e0       	ldi	r19, 0x01	; 1
     216:	0e 94 39 0c 	call	0x1872	; 0x1872 <__usmulhisi3>
     21a:	99 23       	and	r25, r25
     21c:	7c f0       	brlt	.+30     	; 0x23c <_Z13mode_joystickv+0x60>
     21e:	27 e8       	ldi	r18, 0x87	; 135
     220:	30 e0       	ldi	r19, 0x00	; 0
     222:	40 e0       	ldi	r20, 0x00	; 0
     224:	50 e0       	ldi	r21, 0x00	; 0
     226:	0e 94 15 0c 	call	0x182a	; 0x182a <__divmodsi4>
     22a:	20 93 4a 04 	sts	0x044A, r18	; 0x80044a <steering_dv>
     22e:	30 93 4b 04 	sts	0x044B, r19	; 0x80044b <steering_dv+0x1>
     232:	40 93 4c 04 	sts	0x044C, r20	; 0x80044c <steering_dv+0x2>
     236:	50 93 4d 04 	sts	0x044D, r21	; 0x80044d <steering_dv+0x3>
     23a:	0e c0       	rjmp	.+28     	; 0x258 <_Z13mode_joystickv+0x7c>
     23c:	28 e7       	ldi	r18, 0x78	; 120
     23e:	30 e0       	ldi	r19, 0x00	; 0
     240:	40 e0       	ldi	r20, 0x00	; 0
     242:	50 e0       	ldi	r21, 0x00	; 0
     244:	0e 94 15 0c 	call	0x182a	; 0x182a <__divmodsi4>
     248:	20 93 4a 04 	sts	0x044A, r18	; 0x80044a <steering_dv>
     24c:	30 93 4b 04 	sts	0x044B, r19	; 0x80044b <steering_dv+0x1>
     250:	40 93 4c 04 	sts	0x044C, r20	; 0x80044c <steering_dv+0x2>
     254:	50 93 4d 04 	sts	0x044D, r21	; 0x80044d <steering_dv+0x3>
     258:	82 e0       	ldi	r24, 0x02	; 2
     25a:	90 e0       	ldi	r25, 0x00	; 0
     25c:	13 d5       	rcall	.+2598   	; 0xc84 <_Z10analogReadi>
     25e:	dc 01       	movw	r26, r24
     260:	ae 5f       	subi	r26, 0xFE	; 254
     262:	b1 40       	sbci	r27, 0x01	; 1
     264:	2f ef       	ldi	r18, 0xFF	; 255
     266:	30 e0       	ldi	r19, 0x00	; 0
     268:	0e 94 39 0c 	call	0x1872	; 0x1872 <__usmulhisi3>
     26c:	60 93 4e 04 	sts	0x044E, r22	; 0x80044e <driving_dv>
     270:	70 93 4f 04 	sts	0x044F, r23	; 0x80044f <driving_dv+0x1>
     274:	80 93 50 04 	sts	0x0450, r24	; 0x800450 <driving_dv+0x2>
     278:	90 93 51 04 	sts	0x0451, r25	; 0x800451 <driving_dv+0x3>
     27c:	10 92 3b 04 	sts	0x043B, r1	; 0x80043b <engine_dv>
     280:	10 92 3c 04 	sts	0x043C, r1	; 0x80043c <engine_dv+0x1>
     284:	10 92 3d 04 	sts	0x043D, r1	; 0x80043d <engine_dv+0x2>
     288:	10 92 3e 04 	sts	0x043E, r1	; 0x80043e <engine_dv+0x3>
     28c:	10 92 37 04 	sts	0x0437, r1	; 0x800437 <braking_dv>
     290:	10 92 38 04 	sts	0x0438, r1	; 0x800438 <braking_dv+0x1>
     294:	10 92 39 04 	sts	0x0439, r1	; 0x800439 <braking_dv+0x2>
     298:	10 92 3a 04 	sts	0x043A, r1	; 0x80043a <braking_dv+0x3>
     29c:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
     2a0:	22 23       	and	r18, r18
     2a2:	c1 f1       	breq	.+112    	; 0x314 <_Z13mode_joystickv+0x138>
     2a4:	16 16       	cp	r1, r22
     2a6:	17 06       	cpc	r1, r23
     2a8:	18 06       	cpc	r1, r24
     2aa:	19 06       	cpc	r1, r25
     2ac:	7c f4       	brge	.+30     	; 0x2cc <_Z13mode_joystickv+0xf0>
     2ae:	2e e7       	ldi	r18, 0x7E	; 126
     2b0:	30 e0       	ldi	r19, 0x00	; 0
     2b2:	40 e0       	ldi	r20, 0x00	; 0
     2b4:	50 e0       	ldi	r21, 0x00	; 0
     2b6:	0e 94 15 0c 	call	0x182a	; 0x182a <__divmodsi4>
     2ba:	20 93 3b 04 	sts	0x043B, r18	; 0x80043b <engine_dv>
     2be:	30 93 3c 04 	sts	0x043C, r19	; 0x80043c <engine_dv+0x1>
     2c2:	40 93 3d 04 	sts	0x043D, r20	; 0x80043d <engine_dv+0x2>
     2c6:	50 93 3e 04 	sts	0x043E, r21	; 0x80043e <engine_dv+0x3>
     2ca:	5b c0       	rjmp	.+182    	; 0x382 <_Z13mode_joystickv+0x1a6>
     2cc:	8b 01       	movw	r16, r22
     2ce:	9c 01       	movw	r18, r24
     2d0:	99 23       	and	r25, r25
     2d2:	24 f4       	brge	.+8      	; 0x2dc <_Z13mode_joystickv+0x100>
     2d4:	01 58       	subi	r16, 0x81	; 129
     2d6:	1f 4f       	sbci	r17, 0xFF	; 255
     2d8:	2f 4f       	sbci	r18, 0xFF	; 255
     2da:	3f 4f       	sbci	r19, 0xFF	; 255
     2dc:	68 94       	set
     2de:	16 f8       	bld	r1, 6
     2e0:	35 95       	asr	r19
     2e2:	27 95       	ror	r18
     2e4:	17 95       	ror	r17
     2e6:	07 95       	ror	r16
     2e8:	16 94       	lsr	r1
     2ea:	d1 f7       	brne	.-12     	; 0x2e0 <_Z13mode_joystickv+0x104>
     2ec:	c8 01       	movw	r24, r16
     2ee:	99 23       	and	r25, r25
     2f0:	24 f4       	brge	.+8      	; 0x2fa <_Z13mode_joystickv+0x11e>
     2f2:	88 27       	eor	r24, r24
     2f4:	99 27       	eor	r25, r25
     2f6:	80 1b       	sub	r24, r16
     2f8:	91 0b       	sbc	r25, r17
     2fa:	09 2e       	mov	r0, r25
     2fc:	00 0c       	add	r0, r0
     2fe:	aa 0b       	sbc	r26, r26
     300:	bb 0b       	sbc	r27, r27
     302:	80 93 37 04 	sts	0x0437, r24	; 0x800437 <braking_dv>
     306:	90 93 38 04 	sts	0x0438, r25	; 0x800438 <braking_dv+0x1>
     30a:	a0 93 39 04 	sts	0x0439, r26	; 0x800439 <braking_dv+0x2>
     30e:	b0 93 3a 04 	sts	0x043A, r27	; 0x80043a <braking_dv+0x3>
     312:	37 c0       	rjmp	.+110    	; 0x382 <_Z13mode_joystickv+0x1a6>
     314:	16 16       	cp	r1, r22
     316:	17 06       	cpc	r1, r23
     318:	18 06       	cpc	r1, r24
     31a:	19 06       	cpc	r1, r25
     31c:	cc f4       	brge	.+50     	; 0x350 <_Z13mode_joystickv+0x174>
     31e:	8b 01       	movw	r16, r22
     320:	9c 01       	movw	r18, r24
     322:	99 23       	and	r25, r25
     324:	24 f4       	brge	.+8      	; 0x32e <_Z13mode_joystickv+0x152>
     326:	01 58       	subi	r16, 0x81	; 129
     328:	1f 4f       	sbci	r17, 0xFF	; 255
     32a:	2f 4f       	sbci	r18, 0xFF	; 255
     32c:	3f 4f       	sbci	r19, 0xFF	; 255
     32e:	68 94       	set
     330:	16 f8       	bld	r1, 6
     332:	35 95       	asr	r19
     334:	27 95       	ror	r18
     336:	17 95       	ror	r17
     338:	07 95       	ror	r16
     33a:	16 94       	lsr	r1
     33c:	d1 f7       	brne	.-12     	; 0x332 <_Z13mode_joystickv+0x156>
     33e:	00 93 37 04 	sts	0x0437, r16	; 0x800437 <braking_dv>
     342:	10 93 38 04 	sts	0x0438, r17	; 0x800438 <braking_dv+0x1>
     346:	20 93 39 04 	sts	0x0439, r18	; 0x800439 <braking_dv+0x2>
     34a:	30 93 3a 04 	sts	0x043A, r19	; 0x80043a <braking_dv+0x3>
     34e:	19 c0       	rjmp	.+50     	; 0x382 <_Z13mode_joystickv+0x1a6>
     350:	2e e7       	ldi	r18, 0x7E	; 126
     352:	30 e0       	ldi	r19, 0x00	; 0
     354:	40 e0       	ldi	r20, 0x00	; 0
     356:	50 e0       	ldi	r21, 0x00	; 0
     358:	0e 94 15 0c 	call	0x182a	; 0x182a <__divmodsi4>
     35c:	c9 01       	movw	r24, r18
     35e:	99 23       	and	r25, r25
     360:	24 f4       	brge	.+8      	; 0x36a <_Z13mode_joystickv+0x18e>
     362:	88 27       	eor	r24, r24
     364:	99 27       	eor	r25, r25
     366:	82 1b       	sub	r24, r18
     368:	93 0b       	sbc	r25, r19
     36a:	09 2e       	mov	r0, r25
     36c:	00 0c       	add	r0, r0
     36e:	aa 0b       	sbc	r26, r26
     370:	bb 0b       	sbc	r27, r27
     372:	80 93 3b 04 	sts	0x043B, r24	; 0x80043b <engine_dv>
     376:	90 93 3c 04 	sts	0x043C, r25	; 0x80043c <engine_dv+0x1>
     37a:	a0 93 3d 04 	sts	0x043D, r26	; 0x80043d <engine_dv+0x2>
     37e:	b0 93 3e 04 	sts	0x043E, r27	; 0x80043e <engine_dv+0x3>
     382:	80 91 37 04 	lds	r24, 0x0437	; 0x800437 <braking_dv>
     386:	90 91 38 04 	lds	r25, 0x0438	; 0x800438 <braking_dv+0x1>
     38a:	a0 91 39 04 	lds	r26, 0x0439	; 0x800439 <braking_dv+0x2>
     38e:	b0 91 3a 04 	lds	r27, 0x043A	; 0x80043a <braking_dv+0x3>
     392:	8f 3f       	cpi	r24, 0xFF	; 255
     394:	91 05       	cpc	r25, r1
     396:	a1 05       	cpc	r26, r1
     398:	b1 05       	cpc	r27, r1
     39a:	29 f0       	breq	.+10     	; 0x3a6 <_Z13mode_joystickv+0x1ca>
     39c:	24 f0       	brlt	.+8      	; 0x3a6 <_Z13mode_joystickv+0x1ca>
     39e:	8f ef       	ldi	r24, 0xFF	; 255
     3a0:	90 e0       	ldi	r25, 0x00	; 0
     3a2:	a0 e0       	ldi	r26, 0x00	; 0
     3a4:	b0 e0       	ldi	r27, 0x00	; 0
     3a6:	bb 23       	and	r27, r27
     3a8:	1c f4       	brge	.+6      	; 0x3b0 <_Z13mode_joystickv+0x1d4>
     3aa:	80 e0       	ldi	r24, 0x00	; 0
     3ac:	90 e0       	ldi	r25, 0x00	; 0
     3ae:	dc 01       	movw	r26, r24
     3b0:	80 93 37 04 	sts	0x0437, r24	; 0x800437 <braking_dv>
     3b4:	90 93 38 04 	sts	0x0438, r25	; 0x800438 <braking_dv+0x1>
     3b8:	a0 93 39 04 	sts	0x0439, r26	; 0x800439 <braking_dv+0x2>
     3bc:	b0 93 3a 04 	sts	0x043A, r27	; 0x80043a <braking_dv+0x3>
     3c0:	1f 91       	pop	r17
     3c2:	0f 91       	pop	r16
     3c4:	08 95       	ret

000003c6 <_Z9mode_idlev>:
     3c6:	10 92 3b 04 	sts	0x043B, r1	; 0x80043b <engine_dv>
     3ca:	10 92 3c 04 	sts	0x043C, r1	; 0x80043c <engine_dv+0x1>
     3ce:	10 92 3d 04 	sts	0x043D, r1	; 0x80043d <engine_dv+0x2>
     3d2:	10 92 3e 04 	sts	0x043E, r1	; 0x80043e <engine_dv+0x3>
     3d6:	10 92 4a 04 	sts	0x044A, r1	; 0x80044a <steering_dv>
     3da:	10 92 4b 04 	sts	0x044B, r1	; 0x80044b <steering_dv+0x1>
     3de:	10 92 4c 04 	sts	0x044C, r1	; 0x80044c <steering_dv+0x2>
     3e2:	10 92 4d 04 	sts	0x044D, r1	; 0x80044d <steering_dv+0x3>
     3e6:	84 e6       	ldi	r24, 0x64	; 100
     3e8:	90 e0       	ldi	r25, 0x00	; 0
     3ea:	a0 e0       	ldi	r26, 0x00	; 0
     3ec:	b0 e0       	ldi	r27, 0x00	; 0
     3ee:	80 93 37 04 	sts	0x0437, r24	; 0x800437 <braking_dv>
     3f2:	90 93 38 04 	sts	0x0438, r25	; 0x800438 <braking_dv+0x1>
     3f6:	a0 93 39 04 	sts	0x0439, r26	; 0x800439 <braking_dv+0x2>
     3fa:	b0 93 3a 04 	sts	0x043A, r27	; 0x80043a <braking_dv+0x3>
     3fe:	80 91 2a 04 	lds	r24, 0x042A	; 0x80042a <engine_rpm>
     402:	90 91 2b 04 	lds	r25, 0x042B	; 0x80042b <engine_rpm+0x1>
     406:	89 2b       	or	r24, r25
     408:	61 f4       	brne	.+24     	; 0x422 <__LOCK_REGION_LENGTH__+0x22>
     40a:	60 e0       	ldi	r22, 0x00	; 0
     40c:	8f e1       	ldi	r24, 0x1F	; 31
     40e:	90 e0       	ldi	r25, 0x00	; 0
     410:	ee d2       	rcall	.+1500   	; 0x9ee <_Z12digitalWriteib>
     412:	10 92 37 04 	sts	0x0437, r1	; 0x800437 <braking_dv>
     416:	10 92 38 04 	sts	0x0438, r1	; 0x800438 <braking_dv+0x1>
     41a:	10 92 39 04 	sts	0x0439, r1	; 0x800439 <braking_dv+0x2>
     41e:	10 92 3a 04 	sts	0x043A, r1	; 0x80043a <braking_dv+0x3>
     422:	08 95       	ret

00000424 <_Z9run_brakev>:
	//digitalWrite(do_hv_relay,HIGH);
	//not (yet) implemented
}

void run_brake(){
	braking_cv = (long(analogRead(ai_brake_pressure) - braking_sensor_offset) * (250 / 1023));				//retrieve the current value of the brake pressure sensor
     424:	81 e0       	ldi	r24, 0x01	; 1
     426:	90 e0       	ldi	r25, 0x00	; 0
     428:	2d d4       	rcall	.+2138   	; 0xc84 <_Z10analogReadi>
     42a:	10 92 2f 04 	sts	0x042F, r1	; 0x80042f <braking_cv>
     42e:	10 92 30 04 	sts	0x0430, r1	; 0x800430 <braking_cv+0x1>
     432:	10 92 31 04 	sts	0x0431, r1	; 0x800431 <braking_cv+0x2>
     436:	10 92 32 04 	sts	0x0432, r1	; 0x800432 <braking_cv+0x3>
	braking_delta = braking_dv - braking_cv;
     43a:	40 91 37 04 	lds	r20, 0x0437	; 0x800437 <braking_dv>
     43e:	50 91 38 04 	lds	r21, 0x0438	; 0x800438 <braking_dv+0x1>
     442:	60 91 39 04 	lds	r22, 0x0439	; 0x800439 <braking_dv+0x2>
     446:	70 91 3a 04 	lds	r23, 0x043A	; 0x80043a <braking_dv+0x3>
	if(abs(braking_delta)<10)
     44a:	ca 01       	movw	r24, r20
     44c:	09 96       	adiw	r24, 0x09	; 9
     44e:	43 97       	sbiw	r24, 0x13	; 19
     450:	48 f0       	brcs	.+18     	; 0x464 <_Z9run_brakev+0x40>
	//not (yet) implemented
}

void run_brake(){
	braking_cv = (long(analogRead(ai_brake_pressure) - braking_sensor_offset) * (250 / 1023));				//retrieve the current value of the brake pressure sensor
	braking_delta = braking_dv - braking_cv;
     452:	40 93 33 04 	sts	0x0433, r20	; 0x800433 <braking_delta>
     456:	50 93 34 04 	sts	0x0434, r21	; 0x800434 <braking_delta+0x1>
     45a:	60 93 35 04 	sts	0x0435, r22	; 0x800435 <braking_delta+0x2>
     45e:	70 93 36 04 	sts	0x0436, r23	; 0x800436 <braking_delta+0x3>
     462:	08 c0       	rjmp	.+16     	; 0x474 <_Z9run_brakev+0x50>
	if(abs(braking_delta)<10)
		braking_delta = 0;
     464:	10 92 33 04 	sts	0x0433, r1	; 0x800433 <braking_delta>
     468:	10 92 34 04 	sts	0x0434, r1	; 0x800434 <braking_delta+0x1>
     46c:	10 92 35 04 	sts	0x0435, r1	; 0x800435 <braking_delta+0x2>
     470:	10 92 36 04 	sts	0x0436, r1	; 0x800436 <braking_delta+0x3>
	braking_ov = constrain(braking_dv * braking_kp, 0, 255);
     474:	db 01       	movw	r26, r22
     476:	ca 01       	movw	r24, r20
     478:	88 0f       	add	r24, r24
     47a:	99 1f       	adc	r25, r25
     47c:	aa 1f       	adc	r26, r26
     47e:	bb 1f       	adc	r27, r27
     480:	84 0f       	add	r24, r20
     482:	95 1f       	adc	r25, r21
     484:	a6 1f       	adc	r26, r22
     486:	b7 1f       	adc	r27, r23
     488:	bb 23       	and	r27, r27
     48a:	5c f0       	brlt	.+22     	; 0x4a2 <_Z9run_brakev+0x7e>
     48c:	8f 3f       	cpi	r24, 0xFF	; 255
     48e:	91 05       	cpc	r25, r1
     490:	a1 05       	cpc	r26, r1
     492:	b1 05       	cpc	r27, r1
     494:	39 f0       	breq	.+14     	; 0x4a4 <_Z9run_brakev+0x80>
     496:	34 f0       	brlt	.+12     	; 0x4a4 <_Z9run_brakev+0x80>
     498:	8f ef       	ldi	r24, 0xFF	; 255
     49a:	90 e0       	ldi	r25, 0x00	; 0
     49c:	a0 e0       	ldi	r26, 0x00	; 0
     49e:	b0 e0       	ldi	r27, 0x00	; 0
     4a0:	01 c0       	rjmp	.+2      	; 0x4a4 <_Z9run_brakev+0x80>
     4a2:	80 e0       	ldi	r24, 0x00	; 0
     4a4:	80 93 2e 04 	sts	0x042E, r24	; 0x80042e <braking_ov>
	analogWrite(pwm_brake_pump, braking_dv);															//Write op to brake pump
     4a8:	ba 01       	movw	r22, r20
     4aa:	87 e0       	ldi	r24, 0x07	; 7
     4ac:	90 e0       	ldi	r25, 0x00	; 0
     4ae:	59 c2       	rjmp	.+1202   	; 0x962 <_Z11analogWriteii>
     4b0:	08 95       	ret

000004b2 <_Z9run_steerv>:
}

void run_steer(){
     4b2:	8f 92       	push	r8
     4b4:	9f 92       	push	r9
     4b6:	af 92       	push	r10
     4b8:	bf 92       	push	r11
     4ba:	cf 92       	push	r12
     4bc:	df 92       	push	r13
     4be:	ef 92       	push	r14
     4c0:	ff 92       	push	r15
     4c2:	0f 93       	push	r16
     4c4:	1f 93       	push	r17
     4c6:	cf 93       	push	r28
     4c8:	df 93       	push	r29
	steering_cv = (analogRead(ai_steer_pot)-steering_sensor_offset);							//get the offset from the default position by subtracting the offset from the retrieved value
     4ca:	80 e0       	ldi	r24, 0x00	; 0
     4cc:	90 e0       	ldi	r25, 0x00	; 0
     4ce:	da d3       	rcall	.+1972   	; 0xc84 <_Z10analogReadi>
	steering_cv = -steering_cv;																	//because the potentiometer gives it value the other way(left = max, right is minimum), invert this.
     4d0:	ac 01       	movw	r20, r24
     4d2:	44 54       	subi	r20, 0x44	; 68
     4d4:	52 40       	sbci	r21, 0x02	; 2
     4d6:	95 2f       	mov	r25, r21
     4d8:	99 0f       	add	r25, r25
     4da:	99 0b       	sbc	r25, r25
     4dc:	24 2f       	mov	r18, r20
     4de:	35 2f       	mov	r19, r21
     4e0:	49 2f       	mov	r20, r25
     4e2:	59 2f       	mov	r21, r25
     4e4:	69 2f       	mov	r22, r25
     4e6:	79 2f       	mov	r23, r25
     4e8:	89 2f       	mov	r24, r25
     4ea:	0e 94 c8 0c 	call	0x1990	; 0x1990 <__negdi2>
     4ee:	20 93 40 04 	sts	0x0440, r18	; 0x800440 <steering_cv>
     4f2:	30 93 41 04 	sts	0x0441, r19	; 0x800441 <steering_cv+0x1>
     4f6:	40 93 42 04 	sts	0x0442, r20	; 0x800442 <steering_cv+0x2>
     4fa:	50 93 43 04 	sts	0x0443, r21	; 0x800443 <steering_cv+0x3>
     4fe:	60 93 44 04 	sts	0x0444, r22	; 0x800444 <steering_cv+0x4>
     502:	70 93 45 04 	sts	0x0445, r23	; 0x800445 <steering_cv+0x5>
     506:	80 93 46 04 	sts	0x0446, r24	; 0x800446 <steering_cv+0x6>
     50a:	90 93 47 04 	sts	0x0447, r25	; 0x800447 <steering_cv+0x7>
		Serial.println(steering_cv);
     50e:	62 2f       	mov	r22, r18
     510:	73 2f       	mov	r23, r19
     512:	83 e7       	ldi	r24, 0x73	; 115
     514:	94 e0       	ldi	r25, 0x04	; 4
     516:	0e 94 0a 0c 	call	0x1814	; 0x1814 <_ZN5USART7printlnEi>

	steering_cv *= steering_max_deg;															//convert to degrees
	steering_cv /= steering_sensor_maximum;														//divide by the maximum to get the ratio between 0-1
     51a:	20 91 40 04 	lds	r18, 0x0440	; 0x800440 <steering_cv>
     51e:	30 91 41 04 	lds	r19, 0x0441	; 0x800441 <steering_cv+0x1>
     522:	40 91 42 04 	lds	r20, 0x0442	; 0x800442 <steering_cv+0x2>
     526:	50 91 43 04 	lds	r21, 0x0443	; 0x800443 <steering_cv+0x3>
     52a:	60 91 44 04 	lds	r22, 0x0444	; 0x800444 <steering_cv+0x4>
     52e:	70 91 45 04 	lds	r23, 0x0445	; 0x800445 <steering_cv+0x5>
     532:	80 91 46 04 	lds	r24, 0x0446	; 0x800446 <steering_cv+0x6>
     536:	90 91 47 04 	lds	r25, 0x0447	; 0x800447 <steering_cv+0x7>
     53a:	01 e0       	ldi	r16, 0x01	; 1
     53c:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <__ashldi3>
     540:	82 2e       	mov	r8, r18
     542:	93 2e       	mov	r9, r19
     544:	d4 2f       	mov	r29, r20
     546:	c5 2f       	mov	r28, r21
     548:	b6 2f       	mov	r27, r22
     54a:	a7 2f       	mov	r26, r23
     54c:	f8 2f       	mov	r31, r24
     54e:	e9 2f       	mov	r30, r25
     550:	03 e0       	ldi	r16, 0x03	; 3
     552:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <__ashldi3>
     556:	a2 2e       	mov	r10, r18
     558:	b3 2e       	mov	r11, r19
     55a:	c4 2e       	mov	r12, r20
     55c:	d5 2e       	mov	r13, r21
     55e:	e6 2e       	mov	r14, r22
     560:	f7 2e       	mov	r15, r23
     562:	08 2f       	mov	r16, r24
     564:	19 2f       	mov	r17, r25
     566:	28 2d       	mov	r18, r8
     568:	39 2d       	mov	r19, r9
     56a:	4d 2f       	mov	r20, r29
     56c:	5c 2f       	mov	r21, r28
     56e:	6b 2f       	mov	r22, r27
     570:	7a 2f       	mov	r23, r26
     572:	8f 2f       	mov	r24, r31
     574:	9e 2f       	mov	r25, r30
     576:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <__adddi3>
     57a:	a2 2e       	mov	r10, r18
     57c:	b3 2e       	mov	r11, r19
     57e:	c4 2e       	mov	r12, r20
     580:	d5 2e       	mov	r13, r21
     582:	e6 2e       	mov	r14, r22
     584:	f7 2e       	mov	r15, r23
     586:	e8 2f       	mov	r30, r24
     588:	19 2f       	mov	r17, r25
     58a:	04 e0       	ldi	r16, 0x04	; 4
     58c:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <__ashldi3>
     590:	0e 2f       	mov	r16, r30
     592:	0e 94 31 0d 	call	0x1a62	; 0x1a62 <__subdi3>
     596:	0f 2e       	mov	r0, r31
     598:	fe e5       	ldi	r31, 0x5E	; 94
     59a:	af 2e       	mov	r10, r31
     59c:	f0 2d       	mov	r31, r0
     59e:	bb 24       	eor	r11, r11
     5a0:	b3 94       	inc	r11
     5a2:	c1 2c       	mov	r12, r1
     5a4:	d1 2c       	mov	r13, r1
     5a6:	e1 2c       	mov	r14, r1
     5a8:	f1 2c       	mov	r15, r1
     5aa:	00 e0       	ldi	r16, 0x00	; 0
     5ac:	10 e0       	ldi	r17, 0x00	; 0
     5ae:	0e 94 41 0c 	call	0x1882	; 0x1882 <__divdi3>
     5b2:	d2 2f       	mov	r29, r18
     5b4:	c3 2f       	mov	r28, r19
     5b6:	b4 2f       	mov	r27, r20
     5b8:	a5 2f       	mov	r26, r21
     5ba:	f6 2f       	mov	r31, r22
     5bc:	e7 2f       	mov	r30, r23
     5be:	02 2f       	mov	r16, r18
     5c0:	13 2f       	mov	r17, r19
     5c2:	d0 93 40 04 	sts	0x0440, r29	; 0x800440 <steering_cv>
     5c6:	c0 93 41 04 	sts	0x0441, r28	; 0x800441 <steering_cv+0x1>
     5ca:	b0 93 42 04 	sts	0x0442, r27	; 0x800442 <steering_cv+0x2>
     5ce:	a0 93 43 04 	sts	0x0443, r26	; 0x800443 <steering_cv+0x3>
     5d2:	f0 93 44 04 	sts	0x0444, r31	; 0x800444 <steering_cv+0x4>
     5d6:	e0 93 45 04 	sts	0x0445, r30	; 0x800445 <steering_cv+0x5>
     5da:	80 93 46 04 	sts	0x0446, r24	; 0x800446 <steering_cv+0x6>
     5de:	90 93 47 04 	sts	0x0447, r25	; 0x800447 <steering_cv+0x7>
	
	if(abs(steering_dv)<steering_deadzone)														//create a dead zone around default joystick position, desired value must at least be bigger then dead zone value (makes going straight easier
     5e2:	80 91 4a 04 	lds	r24, 0x044A	; 0x80044a <steering_dv>
     5e6:	90 91 4b 04 	lds	r25, 0x044B	; 0x80044b <steering_dv+0x1>
     5ea:	a0 91 4c 04 	lds	r26, 0x044C	; 0x80044c <steering_dv+0x2>
     5ee:	b0 91 4d 04 	lds	r27, 0x044D	; 0x80044d <steering_dv+0x3>
     5f2:	fc 01       	movw	r30, r24
     5f4:	73 96       	adiw	r30, 0x13	; 19
     5f6:	b7 97       	sbiw	r30, 0x27	; 39
     5f8:	80 f4       	brcc	.+32     	; 0x61a <_Z9run_steerv+0x168>
		steering_dv = 0;
     5fa:	10 92 4a 04 	sts	0x044A, r1	; 0x80044a <steering_dv>
     5fe:	10 92 4b 04 	sts	0x044B, r1	; 0x80044b <steering_dv+0x1>
     602:	10 92 4c 04 	sts	0x044C, r1	; 0x80044c <steering_dv+0x2>
     606:	10 92 4d 04 	sts	0x044D, r1	; 0x80044d <steering_dv+0x3>
	steering_delta = steering_dv - steering_cv;													//difference between desired value and current value
     60a:	11 95       	neg	r17
     60c:	01 95       	neg	r16
     60e:	11 09       	sbc	r17, r1
     610:	10 93 49 04 	sts	0x0449, r17	; 0x800449 <steering_delta+0x1>
     614:	00 93 48 04 	sts	0x0448, r16	; 0x800448 <steering_delta>
     618:	19 c0       	rjmp	.+50     	; 0x64c <_Z9run_steerv+0x19a>
     61a:	9c 01       	movw	r18, r24
     61c:	20 1b       	sub	r18, r16
     61e:	31 0b       	sbc	r19, r17
     620:	30 93 49 04 	sts	0x0449, r19	; 0x800449 <steering_delta+0x1>
     624:	20 93 48 04 	sts	0x0448, r18	; 0x800448 <steering_delta>
	if((abs(steering_delta)<10) && (steering_dv!= 0))											//if the two are too close together except the default position, don't steer, this to prevent the motor from constantly trying to make small correcting movements which it is not capable of, so it starts screeching
     628:	27 5f       	subi	r18, 0xF7	; 247
     62a:	3f 4f       	sbci	r19, 0xFF	; 255
     62c:	23 31       	cpi	r18, 0x13	; 19
     62e:	31 05       	cpc	r19, r1
     630:	68 f4       	brcc	.+26     	; 0x64c <_Z9run_steerv+0x19a>
     632:	89 2b       	or	r24, r25
     634:	8a 2b       	or	r24, r26
     636:	8b 2b       	or	r24, r27
     638:	49 f0       	breq	.+18     	; 0x64c <_Z9run_steerv+0x19a>
		steering_delta=0;
     63a:	10 92 49 04 	sts	0x0449, r1	; 0x800449 <steering_delta+0x1>
     63e:	10 92 48 04 	sts	0x0448, r1	; 0x800448 <steering_delta>
	steering_ov = constrain((abs(steering_delta) * steering_kp), 0, 255);						//determine the output PMW value in such a way that the smaller the delta, the slower it goes to smooth out steering
     642:	60 e0       	ldi	r22, 0x00	; 0
     644:	70 e0       	ldi	r23, 0x00	; 0
     646:	80 e0       	ldi	r24, 0x00	; 0
     648:	90 e0       	ldi	r25, 0x00	; 0
     64a:	15 c0       	rjmp	.+42     	; 0x676 <_Z9run_steerv+0x1c4>
     64c:	80 91 48 04 	lds	r24, 0x0448	; 0x800448 <steering_delta>
     650:	90 91 49 04 	lds	r25, 0x0449	; 0x800449 <steering_delta+0x1>
     654:	9c 01       	movw	r18, r24
     656:	99 23       	and	r25, r25
     658:	24 f4       	brge	.+8      	; 0x662 <_Z9run_steerv+0x1b0>
     65a:	22 27       	eor	r18, r18
     65c:	33 27       	eor	r19, r19
     65e:	28 1b       	sub	r18, r24
     660:	39 0b       	sbc	r19, r25
     662:	b9 01       	movw	r22, r18
     664:	66 0f       	add	r22, r22
     666:	77 1f       	adc	r23, r23
     668:	66 0f       	add	r22, r22
     66a:	77 1f       	adc	r23, r23
     66c:	66 0f       	add	r22, r22
     66e:	77 1f       	adc	r23, r23
     670:	62 1b       	sub	r22, r18
     672:	73 0b       	sbc	r23, r19
     674:	3a f0       	brmi	.+14     	; 0x684 <_Z9run_steerv+0x1d2>
     676:	6f 3f       	cpi	r22, 0xFF	; 255
     678:	71 05       	cpc	r23, r1
     67a:	29 f0       	breq	.+10     	; 0x686 <_Z9run_steerv+0x1d4>
     67c:	24 f0       	brlt	.+8      	; 0x686 <_Z9run_steerv+0x1d4>
     67e:	6f ef       	ldi	r22, 0xFF	; 255
     680:	70 e0       	ldi	r23, 0x00	; 0
     682:	01 c0       	rjmp	.+2      	; 0x686 <_Z9run_steerv+0x1d4>
     684:	60 e0       	ldi	r22, 0x00	; 0
     686:	60 93 3f 04 	sts	0x043F, r22	; 0x80043f <steering_ov>

		
	if (steering_delta > 0) {																	//H bridge settings, let the engine turn the correct way
     68a:	18 16       	cp	r1, r24
     68c:	19 06       	cpc	r1, r25
     68e:	54 f4       	brge	.+20     	; 0x6a4 <_Z9run_steerv+0x1f2>
		analogWrite(pwm_steer_rpwm, steering_ov);												//if the delta is smaller than 0, turn to the right		
     690:	70 e0       	ldi	r23, 0x00	; 0
     692:	83 e0       	ldi	r24, 0x03	; 3
     694:	90 e0       	ldi	r25, 0x00	; 0
     696:	65 d1       	rcall	.+714    	; 0x962 <_Z11analogWriteii>
		analogWrite(pwm_steer_lpwm, 0);
     698:	60 e0       	ldi	r22, 0x00	; 0
     69a:	70 e0       	ldi	r23, 0x00	; 0
     69c:	82 e0       	ldi	r24, 0x02	; 2
     69e:	90 e0       	ldi	r25, 0x00	; 0
     6a0:	60 d1       	rcall	.+704    	; 0x962 <_Z11analogWriteii>
     6a2:	18 c0       	rjmp	.+48     	; 0x6d4 <_Z9run_steerv+0x222>
	}
	else if (steering_delta < 0) {
     6a4:	99 23       	and	r25, r25
     6a6:	64 f4       	brge	.+24     	; 0x6c0 <_Z9run_steerv+0x20e>
		analogWrite(pwm_steer_rpwm, 0);															//if the delta is larger than 0
     6a8:	60 e0       	ldi	r22, 0x00	; 0
     6aa:	70 e0       	ldi	r23, 0x00	; 0
     6ac:	83 e0       	ldi	r24, 0x03	; 3
     6ae:	90 e0       	ldi	r25, 0x00	; 0
     6b0:	58 d1       	rcall	.+688    	; 0x962 <_Z11analogWriteii>
		analogWrite(pwm_steer_lpwm, steering_ov);
     6b2:	60 91 3f 04 	lds	r22, 0x043F	; 0x80043f <steering_ov>
     6b6:	70 e0       	ldi	r23, 0x00	; 0
     6b8:	82 e0       	ldi	r24, 0x02	; 2
     6ba:	90 e0       	ldi	r25, 0x00	; 0
     6bc:	52 d1       	rcall	.+676    	; 0x962 <_Z11analogWriteii>
     6be:	0a c0       	rjmp	.+20     	; 0x6d4 <_Z9run_steerv+0x222>
	}
	else {
		analogWrite(pwm_steer_rpwm, 0);															//if neither, do nothing
     6c0:	60 e0       	ldi	r22, 0x00	; 0
     6c2:	70 e0       	ldi	r23, 0x00	; 0
     6c4:	83 e0       	ldi	r24, 0x03	; 3
     6c6:	90 e0       	ldi	r25, 0x00	; 0
     6c8:	4c d1       	rcall	.+664    	; 0x962 <_Z11analogWriteii>
		analogWrite(pwm_steer_lpwm, 0);
     6ca:	60 e0       	ldi	r22, 0x00	; 0
     6cc:	70 e0       	ldi	r23, 0x00	; 0
     6ce:	82 e0       	ldi	r24, 0x02	; 2
     6d0:	90 e0       	ldi	r25, 0x00	; 0
     6d2:	47 d1       	rcall	.+654    	; 0x962 <_Z11analogWriteii>
     6d4:	df 91       	pop	r29
	}	
}
     6d6:	cf 91       	pop	r28
     6d8:	1f 91       	pop	r17
     6da:	0f 91       	pop	r16
     6dc:	ff 90       	pop	r15
     6de:	ef 90       	pop	r14
     6e0:	df 90       	pop	r13
     6e2:	cf 90       	pop	r12
     6e4:	bf 90       	pop	r11
     6e6:	af 90       	pop	r10
     6e8:	9f 90       	pop	r9
     6ea:	8f 90       	pop	r8
     6ec:	08 95       	ret

000006ee <_Z10run_curtisv>:
     6ee:	60 91 00 02 	lds	r22, 0x0200	; 0x800200 <__data_start>

void run_curtis(){
	digitalWrite(do_engine_forward, driving_direction);											//give the Curtis the correct driving direction
     6f2:	8b e1       	ldi	r24, 0x1B	; 27
     6f4:	90 e0       	ldi	r25, 0x00	; 0
     6f6:	7b d1       	rcall	.+758    	; 0x9ee <_Z12digitalWriteib>
	digitalWrite(do_engine_reverse, !driving_direction);
     6f8:	60 91 00 02 	lds	r22, 0x0200	; 0x800200 <__data_start>
     6fc:	81 e0       	ldi	r24, 0x01	; 1
     6fe:	68 27       	eor	r22, r24
     700:	8c e1       	ldi	r24, 0x1C	; 28
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	74 d1       	rcall	.+744    	; 0x9ee <_Z12digitalWriteib>
	
	if(abs(engine_dv)<driving_deadzone)														//create a dead zone around the standing still position, desired value must at least be bigger then dead zone value (makes standing still easier)
     706:	80 91 3b 04 	lds	r24, 0x043B	; 0x80043b <engine_dv>
     70a:	90 91 3c 04 	lds	r25, 0x043C	; 0x80043c <engine_dv+0x1>
     70e:	43 96       	adiw	r24, 0x13	; 19
     710:	87 97       	sbiw	r24, 0x27	; 39
     712:	40 f4       	brcc	.+16     	; 0x724 <_Z10run_curtisv+0x36>
		engine_dv = 0;
     714:	10 92 3b 04 	sts	0x043B, r1	; 0x80043b <engine_dv>
     718:	10 92 3c 04 	sts	0x043C, r1	; 0x80043c <engine_dv+0x1>
     71c:	10 92 3d 04 	sts	0x043D, r1	; 0x80043d <engine_dv+0x2>
     720:	10 92 3e 04 	sts	0x043E, r1	; 0x80043e <engine_dv+0x3>
     724:	80 91 3b 04 	lds	r24, 0x043B	; 0x80043b <engine_dv>
     728:	90 91 3c 04 	lds	r25, 0x043C	; 0x80043c <engine_dv+0x1>
     72c:	a0 91 3d 04 	lds	r26, 0x043D	; 0x80043d <engine_dv+0x2>
     730:	b0 91 3e 04 	lds	r27, 0x043E	; 0x80043e <engine_dv+0x3>
     734:	8f 3f       	cpi	r24, 0xFF	; 255
     736:	91 05       	cpc	r25, r1
     738:	a1 05       	cpc	r26, r1
     73a:	b1 05       	cpc	r27, r1
     73c:	29 f0       	breq	.+10     	; 0x748 <_Z10run_curtisv+0x5a>
     73e:	24 f0       	brlt	.+8      	; 0x748 <_Z10run_curtisv+0x5a>
     740:	8f ef       	ldi	r24, 0xFF	; 255
     742:	90 e0       	ldi	r25, 0x00	; 0
     744:	a0 e0       	ldi	r26, 0x00	; 0
     746:	b0 e0       	ldi	r27, 0x00	; 0
     748:	bb 23       	and	r27, r27
     74a:	1c f4       	brge	.+6      	; 0x752 <_Z10run_curtisv+0x64>
     74c:	80 e0       	ldi	r24, 0x00	; 0
     74e:	90 e0       	ldi	r25, 0x00	; 0
     750:	dc 01       	movw	r26, r24
		engine_dv = constrain(engine_dv, 0, drive_max_PWM);	//constrain the value, preventing an integer overflow if a too high of a value was supplied
     752:	80 93 3b 04 	sts	0x043B, r24	; 0x80043b <engine_dv>
     756:	90 93 3c 04 	sts	0x043C, r25	; 0x80043c <engine_dv+0x1>
     75a:	a0 93 3d 04 	sts	0x043D, r26	; 0x80043d <engine_dv+0x2>
     75e:	b0 93 3e 04 	sts	0x043E, r27	; 0x80043e <engine_dv+0x3>

			
	//Set the Curtis in the right mode for braking, driving or neutral																		//if we want to brake
		digitalWrite(do_engine_throttleswitch, engine_dv);				//if there is an engine signal, enable listening to the throttle
     762:	61 e0       	ldi	r22, 0x01	; 1
     764:	89 2b       	or	r24, r25
     766:	8a 2b       	or	r24, r26
     768:	8b 2b       	or	r24, r27
     76a:	09 f4       	brne	.+2      	; 0x76e <_Z10run_curtisv+0x80>
     76c:	60 e0       	ldi	r22, 0x00	; 0
     76e:	8e e1       	ldi	r24, 0x1E	; 30
     770:	90 e0       	ldi	r25, 0x00	; 0
     772:	3d d1       	rcall	.+634    	; 0x9ee <_Z12digitalWriteib>
		digitalWrite(do_engine_brake, braking_dv);						//if there is an braking signal, turn on the braking 
     774:	61 e0       	ldi	r22, 0x01	; 1
     776:	80 91 37 04 	lds	r24, 0x0437	; 0x800437 <braking_dv>
     77a:	90 91 38 04 	lds	r25, 0x0438	; 0x800438 <braking_dv+0x1>
     77e:	a0 91 39 04 	lds	r26, 0x0439	; 0x800439 <braking_dv+0x2>
     782:	b0 91 3a 04 	lds	r27, 0x043A	; 0x80043a <braking_dv+0x3>
     786:	89 2b       	or	r24, r25
     788:	8a 2b       	or	r24, r26
     78a:	8b 2b       	or	r24, r27
     78c:	09 f4       	brne	.+2      	; 0x790 <_Z10run_curtisv+0xa2>
     78e:	60 e0       	ldi	r22, 0x00	; 0
     790:	8d e1       	ldi	r24, 0x1D	; 29
     792:	90 e0       	ldi	r25, 0x00	; 0
     794:	2c d1       	rcall	.+600    	; 0x9ee <_Z12digitalWriteib>

	analogWrite(pwm_drive_throttle, engine_dv);								//Write op to throttle signal of Curtis
     796:	60 91 3b 04 	lds	r22, 0x043B	; 0x80043b <engine_dv>
     79a:	70 91 3c 04 	lds	r23, 0x043C	; 0x80043c <engine_dv+0x1>
     79e:	88 e0       	ldi	r24, 0x08	; 8
     7a0:	90 e0       	ldi	r25, 0x00	; 0
     7a2:	df c0       	rjmp	.+446    	; 0x962 <_Z11analogWriteii>
     7a4:	08 95       	ret

000007a6 <_Z5drivev>:
	}
}

void drive(){
	//get correct driving input parameters from selected source (remote and auto not implemented, thus being interpreted as idle)
	mode_select();
     7a6:	db dc       	rcall	.-1610   	; 0x15e <_Z11mode_selectv>
	switch(drivemode){
     7a8:	80 91 52 04 	lds	r24, 0x0452	; 0x800452 <drivemode>
     7ac:	90 91 53 04 	lds	r25, 0x0453	; 0x800453 <drivemode+0x1>
     7b0:	81 30       	cpi	r24, 0x01	; 1
     7b2:	91 05       	cpc	r25, r1
     7b4:	51 f0       	breq	.+20     	; 0x7ca <_Z5drivev+0x24>
     7b6:	1c f4       	brge	.+6      	; 0x7be <_Z5drivev+0x18>
     7b8:	89 2b       	or	r24, r25
     7ba:	49 f0       	breq	.+18     	; 0x7ce <_Z5drivev+0x28>
     7bc:	0d c0       	rjmp	.+26     	; 0x7d8 <_Z5drivev+0x32>
     7be:	82 30       	cpi	r24, 0x02	; 2
     7c0:	91 05       	cpc	r25, r1
     7c2:	49 f0       	breq	.+18     	; 0x7d6 <_Z5drivev+0x30>
     7c4:	03 97       	sbiw	r24, 0x03	; 3
     7c6:	29 f0       	breq	.+10     	; 0x7d2 <_Z5drivev+0x2c>
		case drivemode_joystick:
			mode_joystick();
     7c8:	07 c0       	rjmp	.+14     	; 0x7d8 <_Z5drivev+0x32>
			break;
     7ca:	08 dd       	rcall	.-1520   	; 0x1dc <_Z13mode_joystickv>
		case drivemode_idle:
			mode_idle();		
     7cc:	05 c0       	rjmp	.+10     	; 0x7d8 <_Z5drivev+0x32>
			break;
		case drivemode_auto:
			mode_idle();		//not yet implemented
     7ce:	fb dd       	rcall	.-1034   	; 0x3c6 <_Z9mode_idlev>
     7d0:	03 c0       	rjmp	.+6      	; 0x7d8 <_Z5drivev+0x32>
			break;
     7d2:	f9 dd       	rcall	.-1038   	; 0x3c6 <_Z9mode_idlev>
		case drivemode_remote:
			mode_idle();		//not yet implemented
     7d4:	01 c0       	rjmp	.+2      	; 0x7d8 <_Z5drivev+0x32>
     7d6:	f7 dd       	rcall	.-1042   	; 0x3c6 <_Z9mode_idlev>
			break;	
	}
	//prevent any value of the maximum value being send
	if(steering_dv>steering_max_deg)
     7d8:	80 91 4a 04 	lds	r24, 0x044A	; 0x80044a <steering_dv>
     7dc:	90 91 4b 04 	lds	r25, 0x044B	; 0x80044b <steering_dv+0x1>
     7e0:	a0 91 4c 04 	lds	r26, 0x044C	; 0x80044c <steering_dv+0x2>
     7e4:	b0 91 4d 04 	lds	r27, 0x044D	; 0x80044d <steering_dv+0x3>
     7e8:	8f 30       	cpi	r24, 0x0F	; 15
     7ea:	21 e0       	ldi	r18, 0x01	; 1
     7ec:	92 07       	cpc	r25, r18
     7ee:	a1 05       	cpc	r26, r1
     7f0:	b1 05       	cpc	r27, r1
     7f2:	6c f0       	brlt	.+26     	; 0x80e <_Z5drivev+0x68>
		steering_dv=steering_max_deg;
     7f4:	8e e0       	ldi	r24, 0x0E	; 14
     7f6:	91 e0       	ldi	r25, 0x01	; 1
     7f8:	a0 e0       	ldi	r26, 0x00	; 0
     7fa:	b0 e0       	ldi	r27, 0x00	; 0
     7fc:	80 93 4a 04 	sts	0x044A, r24	; 0x80044a <steering_dv>
     800:	90 93 4b 04 	sts	0x044B, r25	; 0x80044b <steering_dv+0x1>
     804:	a0 93 4c 04 	sts	0x044C, r26	; 0x80044c <steering_dv+0x2>
     808:	b0 93 4d 04 	sts	0x044D, r27	; 0x80044d <steering_dv+0x3>
     80c:	11 c0       	rjmp	.+34     	; 0x830 <_Z5drivev+0x8a>
	if(steering_dv<-steering_max_deg)
     80e:	82 3f       	cpi	r24, 0xF2	; 242
     810:	9e 4f       	sbci	r25, 0xFE	; 254
     812:	af 4f       	sbci	r26, 0xFF	; 255
     814:	bf 4f       	sbci	r27, 0xFF	; 255
     816:	64 f4       	brge	.+24     	; 0x830 <_Z5drivev+0x8a>
		steering_dv=-steering_max_deg;
     818:	82 ef       	ldi	r24, 0xF2	; 242
     81a:	9e ef       	ldi	r25, 0xFE	; 254
     81c:	af ef       	ldi	r26, 0xFF	; 255
     81e:	bf ef       	ldi	r27, 0xFF	; 255
     820:	80 93 4a 04 	sts	0x044A, r24	; 0x80044a <steering_dv>
     824:	90 93 4b 04 	sts	0x044B, r25	; 0x80044b <steering_dv+0x1>
     828:	a0 93 4c 04 	sts	0x044C, r26	; 0x80044c <steering_dv+0x2>
	
	run_steer();				//update the steering system
     82c:	b0 93 4d 04 	sts	0x044D, r27	; 0x80044d <steering_dv+0x3>
	run_brake();				//update the braking system
     830:	40 de       	rcall	.-896    	; 0x4b2 <_Z9run_steerv>
	run_curtis();				//update the Curtis
     832:	f8 dd       	rcall	.-1040   	; 0x424 <_Z9run_brakev>
     834:	5c cf       	rjmp	.-328    	; 0x6ee <_Z10run_curtisv>
     836:	08 95       	ret

00000838 <_Z6initIOv>:
#include "IOPins.h"

//this funcion should be called when initializng the program. It writes the correct settings to the registry, allowing the use of analog and digital reading and writing of pins.
void initIO(){
     838:	cf 93       	push	r28
     83a:	df 93       	push	r29
	Serial.println("Applying IO settings...");
     83c:	61 e0       	ldi	r22, 0x01	; 1
     83e:	72 e0       	ldi	r23, 0x02	; 2
     840:	83 e7       	ldi	r24, 0x73	; 115
     842:	94 e0       	ldi	r25, 0x04	; 4
     844:	b9 d7       	rcall	.+3954   	; 0x17b8 <_ZN5USART7printlnEPKc>
	//Read/Write pins
	//////////////////////////////////////
	//Disable the pullup resistor in these pins, making them output by writing a 1 to their respective registry entries. Pins not written to default to input pins.
	//when adding/altering pins, alter them in the respective switch case as well.
	//digitalwrite
	DDRA |= 0b11111111;
     846:	81 b1       	in	r24, 0x01	; 1
     848:	8f ef       	ldi	r24, 0xFF	; 255
     84a:	81 b9       	out	0x01, r24	; 1
	//B pins are reserved for SPI, don't touch those
	DDRC |= 0b10110111;
     84c:	87 b1       	in	r24, 0x07	; 7
     84e:	87 6b       	ori	r24, 0xB7	; 183
     850:	87 b9       	out	0x07, r24	; 7
	DDRD |= 0b10000000;
     852:	57 9a       	sbi	0x0a, 7	; 10
	DDRG |= 0b00000111;
     854:	83 b3       	in	r24, 0x13	; 19
     856:	87 60       	ori	r24, 0x07	; 7
     858:	83 bb       	out	0x13, r24	; 19
	//DDRL |= 0b11111111;
	
	//analogwrite, Not all pins support PWM signals, please consult datasheets before altering.
	DDRB |= 0b11110000;
     85a:	84 b1       	in	r24, 0x04	; 4
     85c:	80 6f       	ori	r24, 0xF0	; 240
     85e:	84 b9       	out	0x04, r24	; 4
	DDRE |= 0b00111000;
     860:	8d b1       	in	r24, 0x0d	; 13
     862:	88 63       	ori	r24, 0x38	; 56
     864:	8d b9       	out	0x0d, r24	; 13
	DDRG |= 0b00100000;
     866:	9d 9a       	sbi	0x13, 5	; 19
	DDRH |= 0b01111000;
     868:	e1 e0       	ldi	r30, 0x01	; 1
     86a:	f1 e0       	ldi	r31, 0x01	; 1
     86c:	80 81       	ld	r24, Z
     86e:	88 67       	ori	r24, 0x78	; 120
     870:	80 83       	st	Z, r24
	DDRL |= 0b00111000;
     872:	ea e0       	ldi	r30, 0x0A	; 10
     874:	f1 e0       	ldi	r31, 0x01	; 1
     876:	80 81       	ld	r24, Z
     878:	88 63       	ori	r24, 0x38	; 56
     87a:	80 83       	st	Z, r24
	//when something is unclear or you want to change some setting, please consult the datasheet first.
	
	//Compare output mode
	//determines how the PWN behaves, now it Clears OCxx on compare match. This makes it so that low value OCRxx will result in short pulses, while higher result in longer ones
	//COM0xx0 will make OCxx toggle on compare match, both will set om compare match. Neither will disable the pmw by disconnecting OCxx.
	TCCR0A |= (( 1 << COM0A1) | (1 << COM0B1));
     87c:	84 b5       	in	r24, 0x24	; 36
     87e:	80 6a       	ori	r24, 0xA0	; 160
     880:	84 bd       	out	0x24, r24	; 36
	TCCR1A |= (( 1 << COM1A1) | (1 << COM1B1));
     882:	c0 e8       	ldi	r28, 0x80	; 128
     884:	d0 e0       	ldi	r29, 0x00	; 0
     886:	88 81       	ld	r24, Y
     888:	80 6a       	ori	r24, 0xA0	; 160
     88a:	88 83       	st	Y, r24
	TCCR2A |= (( 1 << COM2A1) | (1 << COM2B1));
     88c:	a0 eb       	ldi	r26, 0xB0	; 176
     88e:	b0 e0       	ldi	r27, 0x00	; 0
     890:	8c 91       	ld	r24, X
     892:	80 6a       	ori	r24, 0xA0	; 160
     894:	8c 93       	st	X, r24
	TCCR3A |= (( 1 << COM3A1) | (1 << COM3B1));
     896:	e0 e9       	ldi	r30, 0x90	; 144
     898:	f0 e0       	ldi	r31, 0x00	; 0
     89a:	80 81       	ld	r24, Z
     89c:	80 6a       	ori	r24, 0xA0	; 160
     89e:	80 83       	st	Z, r24
	//TCCR4A |= (( 1 << COM4A1) | (1 << COM4B1));
	
	//Waveform Generation
	//note that here OCRxA and OCRxB use the same registry and thus also use the same waveform.
	//the current PWM is Fast PMW, but in this case the PWM mode isn't really important.
	TCCR0A |= ((1 << WGM01) | (1 << WGM00));
     8a0:	84 b5       	in	r24, 0x24	; 36
     8a2:	83 60       	ori	r24, 0x03	; 3
     8a4:	84 bd       	out	0x24, r24	; 36
	TCCR1A |= ((1 << WGM12) | (1 << WGM10));		//16 bit timer, scaled back to 8 bit. (TCCR0x and TCCR2x are 8 bit already)
     8a6:	88 81       	ld	r24, Y
     8a8:	89 60       	ori	r24, 0x09	; 9
     8aa:	88 83       	st	Y, r24
	TCCR2A |= ((1 << WGM21) | (1 << WGM20));
     8ac:	8c 91       	ld	r24, X
     8ae:	83 60       	ori	r24, 0x03	; 3
     8b0:	8c 93       	st	X, r24
	TCCR3A |= ((1 << WGM32) | (1 << WGM30));		//16 bit
     8b2:	80 81       	ld	r24, Z
     8b4:	89 60       	ori	r24, 0x09	; 9
     8b6:	80 83       	st	Z, r24
	
	//clock Select
	//currently selected, Internal clock, /8 prescaler. this starts the PWM as well
	//F_CPU=16000000 / 256 / 8 ~= 7812Hz wave
	//again as with the OCRxx, these use the same registry as well and are thus linked
	TCCR0B |= (1 << CS01);
     8b8:	85 b5       	in	r24, 0x25	; 37
     8ba:	82 60       	ori	r24, 0x02	; 2
     8bc:	85 bd       	out	0x25, r24	; 37
	TCCR1B |= (1 << CS11);
     8be:	e1 e8       	ldi	r30, 0x81	; 129
     8c0:	f0 e0       	ldi	r31, 0x00	; 0
     8c2:	80 81       	ld	r24, Z
     8c4:	82 60       	ori	r24, 0x02	; 2
     8c6:	80 83       	st	Z, r24
	TCCR2B |= (1 << CS21);
     8c8:	e1 eb       	ldi	r30, 0xB1	; 177
     8ca:	f0 e0       	ldi	r31, 0x00	; 0
     8cc:	80 81       	ld	r24, Z
     8ce:	82 60       	ori	r24, 0x02	; 2
     8d0:	80 83       	st	Z, r24
	TCCR3B |= (1 << CS31);
     8d2:	e1 e9       	ldi	r30, 0x91	; 145
     8d4:	f0 e0       	ldi	r31, 0x00	; 0
     8d6:	80 81       	ld	r24, Z
     8d8:	82 60       	ori	r24, 0x02	; 2
     8da:	80 83       	st	Z, r24
	TCCR4B |= (1 << CS41);
     8dc:	e1 ea       	ldi	r30, 0xA1	; 161
     8de:	f0 e0       	ldi	r31, 0x00	; 0
     8e0:	80 81       	ld	r24, Z
     8e2:	82 60       	ori	r24, 0x02	; 2
     8e4:	80 83       	st	Z, r24
	
	//initialize each pwm as 0
	OCR3B=0;	//pin 2
     8e6:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <__TEXT_REGION_LENGTH__+0x70009b>
     8ea:	10 92 9a 00 	sts	0x009A, r1	; 0x80009a <__TEXT_REGION_LENGTH__+0x70009a>
	OCR3C=0;	//pin 3
     8ee:	10 92 9d 00 	sts	0x009D, r1	; 0x80009d <__TEXT_REGION_LENGTH__+0x70009d>
     8f2:	10 92 9c 00 	sts	0x009C, r1	; 0x80009c <__TEXT_REGION_LENGTH__+0x70009c>
	OCR0B=0;	//pin 4
     8f6:	18 bc       	out	0x28, r1	; 40
	OCR3A=0;	//pin 5
     8f8:	10 92 99 00 	sts	0x0099, r1	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
     8fc:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
	OCR4A=0;	//pin 6
     900:	10 92 a9 00 	sts	0x00A9, r1	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
     904:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
	OCR4B=0;	//pin 7
     908:	10 92 ab 00 	sts	0x00AB, r1	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
     90c:	10 92 aa 00 	sts	0x00AA, r1	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
	OCR4C=0;	//pin 8
     910:	10 92 ad 00 	sts	0x00AD, r1	; 0x8000ad <__TEXT_REGION_LENGTH__+0x7000ad>
     914:	10 92 ac 00 	sts	0x00AC, r1	; 0x8000ac <__TEXT_REGION_LENGTH__+0x7000ac>
	OCR2B=0;	//pin 9
     918:	10 92 b4 00 	sts	0x00B4, r1	; 0x8000b4 <__TEXT_REGION_LENGTH__+0x7000b4>
	OCR2A=0;	//pin 10
     91c:	10 92 b3 00 	sts	0x00B3, r1	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
	OCR1A=0;	//pin 11
     920:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     924:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
	OCR1B=0;	//pin 12
     928:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     92c:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
	OCR1C=0;	//pin 13
     930:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
     934:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
	//Analog Digital Converter, analogread
	//////////////////////////////////////
	
	//Analog Digital Multiplexer Selection Register, voltage reference selection
	//Current setting: AVcc with external capacitor at AREF pin (internal 5v)
	ADMUX |= (1 << REFS0);
     938:	ec e7       	ldi	r30, 0x7C	; 124
     93a:	f0 e0       	ldi	r31, 0x00	; 0
     93c:	80 81       	ld	r24, Z
     93e:	80 64       	ori	r24, 0x40	; 64
     940:	80 83       	st	Z, r24
	
	// 1/128 prescaler
	ADCSRA |= (1 << ADPS0) | (1 << ADPS1) | (1 << ADPS2);
     942:	ea e7       	ldi	r30, 0x7A	; 122
     944:	f0 e0       	ldi	r31, 0x00	; 0
     946:	80 81       	ld	r24, Z
     948:	87 60       	ori	r24, 0x07	; 7
     94a:	80 83       	st	Z, r24
	
	//enable the ADC convector, and disable GPIO functionality on the ADC pins
	ADCSRA |= (1 << ADEN);
     94c:	80 81       	ld	r24, Z
     94e:	80 68       	ori	r24, 0x80	; 128
     950:	80 83       	st	Z, r24
	Serial.println("IO setting generated");
     952:	69 e1       	ldi	r22, 0x19	; 25
     954:	72 e0       	ldi	r23, 0x02	; 2
     956:	83 e7       	ldi	r24, 0x73	; 115
     958:	94 e0       	ldi	r25, 0x04	; 4
     95a:	2e d7       	rcall	.+3676   	; 0x17b8 <_ZN5USART7printlnEPKc>
	return;
}
     95c:	df 91       	pop	r29
     95e:	cf 91       	pop	r28
     960:	08 95       	ret

00000962 <_Z11analogWriteii>:


//writes a value between 0 and 255 to the correct output compare register
//analogWrite(pin numer, value it should receive).
void analogWrite(int pin,int val){
     962:	6f 3f       	cpi	r22, 0xFF	; 255
     964:	71 05       	cpc	r23, r1
     966:	19 f0       	breq	.+6      	; 0x96e <_Z11analogWriteii+0xc>
     968:	14 f0       	brlt	.+4      	; 0x96e <_Z11analogWriteii+0xc>
     96a:	6f ef       	ldi	r22, 0xFF	; 255
     96c:	70 e0       	ldi	r23, 0x00	; 0
	if(val>255)			//if the given value exeeds 255, make it 255
	val=255;
	switch(pin){
     96e:	fc 01       	movw	r30, r24
     970:	32 97       	sbiw	r30, 0x02	; 2
     972:	eb 30       	cpi	r30, 0x0B	; 11
     974:	f1 05       	cpc	r31, r1
     976:	a8 f5       	brcc	.+106    	; 0x9e2 <_Z11analogWriteii+0x80>
     978:	88 27       	eor	r24, r24
     97a:	ee 58       	subi	r30, 0x8E	; 142
     97c:	ff 4f       	sbci	r31, 0xFF	; 255
     97e:	8f 4f       	sbci	r24, 0xFF	; 255
     980:	70 c7       	rjmp	.+3808   	; 0x1862 <__tablejump2__>
		case 2:
		OCR3B=val;
     982:	70 93 9b 00 	sts	0x009B, r23	; 0x80009b <__TEXT_REGION_LENGTH__+0x70009b>
     986:	60 93 9a 00 	sts	0x009A, r22	; 0x80009a <__TEXT_REGION_LENGTH__+0x70009a>
		return;
     98a:	08 95       	ret
		case 3:
		OCR3C=val;
     98c:	70 93 9d 00 	sts	0x009D, r23	; 0x80009d <__TEXT_REGION_LENGTH__+0x70009d>
     990:	60 93 9c 00 	sts	0x009C, r22	; 0x80009c <__TEXT_REGION_LENGTH__+0x70009c>
		return;
     994:	08 95       	ret
		case 4:
		OCR0B=val;
     996:	68 bd       	out	0x28, r22	; 40
		return;
     998:	08 95       	ret
		case 5:
		OCR3A=val;
     99a:	70 93 99 00 	sts	0x0099, r23	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
     99e:	60 93 98 00 	sts	0x0098, r22	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
		return;
     9a2:	08 95       	ret
		case 6:
		OCR4A=val;
     9a4:	70 93 a9 00 	sts	0x00A9, r23	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
     9a8:	60 93 a8 00 	sts	0x00A8, r22	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
		return;
     9ac:	08 95       	ret
		case 7:
		OCR4B=val;
     9ae:	70 93 ab 00 	sts	0x00AB, r23	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
     9b2:	60 93 aa 00 	sts	0x00AA, r22	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
		return;
     9b6:	08 95       	ret
		case 8:
		OCR4C=val;
     9b8:	70 93 ad 00 	sts	0x00AD, r23	; 0x8000ad <__TEXT_REGION_LENGTH__+0x7000ad>
     9bc:	60 93 ac 00 	sts	0x00AC, r22	; 0x8000ac <__TEXT_REGION_LENGTH__+0x7000ac>
		return;
     9c0:	08 95       	ret
		case 9:
		OCR2B=val;
     9c2:	60 93 b4 00 	sts	0x00B4, r22	; 0x8000b4 <__TEXT_REGION_LENGTH__+0x7000b4>
		return;
     9c6:	08 95       	ret
		case 10:
		OCR2A=val;
     9c8:	60 93 b3 00 	sts	0x00B3, r22	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
		return;
     9cc:	08 95       	ret
		case 11:
		OCR1A=val;
     9ce:	70 93 89 00 	sts	0x0089, r23	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     9d2:	60 93 88 00 	sts	0x0088, r22	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
		return;
     9d6:	08 95       	ret
		case 12:
		OCR1B=val;
     9d8:	70 93 8b 00 	sts	0x008B, r23	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     9dc:	60 93 8a 00 	sts	0x008A, r22	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
		return;
     9e0:	08 95       	ret
		}
	Serial.println("ERROR: tried to write analog value to unsupported pin");
     9e2:	6e e2       	ldi	r22, 0x2E	; 46
     9e4:	72 e0       	ldi	r23, 0x02	; 2
     9e6:	83 e7       	ldi	r24, 0x73	; 115
     9e8:	94 e0       	ldi	r25, 0x04	; 4
     9ea:	e6 c6       	rjmp	.+3532   	; 0x17b8 <_ZN5USART7printlnEPKc>
     9ec:	08 95       	ret

000009ee <_Z12digitalWriteib>:
	return;
}

//writes a digital value to a pin.
void digitalWrite(int pin,bool val){
     9ee:	cf 93       	push	r28
     9f0:	df 93       	push	r29
	if(pin<22||pin>53){					//check if the pin is a digital IO pin
     9f2:	9c 01       	movw	r18, r24
     9f4:	26 51       	subi	r18, 0x16	; 22
     9f6:	31 09       	sbc	r19, r1
     9f8:	20 32       	cpi	r18, 0x20	; 32
     9fa:	31 05       	cpc	r19, r1
     9fc:	58 f0       	brcs	.+22     	; 0xa14 <_Z12digitalWriteib+0x26>
     9fe:	ec 01       	movw	r28, r24
		Serial.print("ERROR: tried to write digital value to unsupported digital pin");
     a00:	64 e6       	ldi	r22, 0x64	; 100
     a02:	72 e0       	ldi	r23, 0x02	; 2
     a04:	83 e7       	ldi	r24, 0x73	; 115
     a06:	94 e0       	ldi	r25, 0x04	; 4
     a08:	be d6       	rcall	.+3452   	; 0x1786 <_ZN5USART5printEPKc>
		Serial.println(pin);
     a0a:	be 01       	movw	r22, r28
     a0c:	83 e7       	ldi	r24, 0x73	; 115
     a0e:	94 e0       	ldi	r25, 0x04	; 4
     a10:	01 d7       	rcall	.+3586   	; 0x1814 <_ZN5USART7printlnEi>
     a12:	b9 c0       	rjmp	.+370    	; 0xb86 <_Z12digitalWriteib+0x198>
	}
	else if(pin<30){					//check if pin is in the A register
     a14:	8e 31       	cpi	r24, 0x1E	; 30
     a16:	91 05       	cpc	r25, r1
     a18:	f4 f4       	brge	.+60     	; 0xa56 <_Z12digitalWriteib+0x68>
		pin-=22;						//make pinrange 0-7
     a1a:	46 97       	sbiw	r24, 0x16	; 22
		if(val) PORTA |= (1<<pin);		//set correct bit in A register is val==true
     a1c:	66 23       	and	r22, r22
     a1e:	69 f0       	breq	.+26     	; 0xa3a <_Z12digitalWriteib+0x4c>
     a20:	42 b1       	in	r20, 0x02	; 2
     a22:	21 e0       	ldi	r18, 0x01	; 1
     a24:	30 e0       	ldi	r19, 0x00	; 0
     a26:	b9 01       	movw	r22, r18
     a28:	02 c0       	rjmp	.+4      	; 0xa2e <_Z12digitalWriteib+0x40>
     a2a:	66 0f       	add	r22, r22
     a2c:	77 1f       	adc	r23, r23
     a2e:	8a 95       	dec	r24
     a30:	e2 f7       	brpl	.-8      	; 0xa2a <_Z12digitalWriteib+0x3c>
     a32:	cb 01       	movw	r24, r22
     a34:	84 2b       	or	r24, r20
     a36:	82 b9       	out	0x02, r24	; 2
     a38:	a6 c0       	rjmp	.+332    	; 0xb86 <_Z12digitalWriteib+0x198>
		else PORTA &= ~(1<<pin);		//unset bit if false
     a3a:	42 b1       	in	r20, 0x02	; 2
     a3c:	21 e0       	ldi	r18, 0x01	; 1
     a3e:	30 e0       	ldi	r19, 0x00	; 0
     a40:	b9 01       	movw	r22, r18
     a42:	02 c0       	rjmp	.+4      	; 0xa48 <_Z12digitalWriteib+0x5a>
     a44:	66 0f       	add	r22, r22
     a46:	77 1f       	adc	r23, r23
     a48:	8a 95       	dec	r24
     a4a:	e2 f7       	brpl	.-8      	; 0xa44 <_Z12digitalWriteib+0x56>
     a4c:	cb 01       	movw	r24, r22
     a4e:	80 95       	com	r24
     a50:	84 23       	and	r24, r20
     a52:	82 b9       	out	0x02, r24	; 2
     a54:	98 c0       	rjmp	.+304    	; 0xb86 <_Z12digitalWriteib+0x198>
	}
	else if(pin<38){
     a56:	86 32       	cpi	r24, 0x26	; 38
     a58:	91 05       	cpc	r25, r1
     a5a:	1c f5       	brge	.+70     	; 0xaa2 <_Z12digitalWriteib+0xb4>
		pin=(37-pin);
     a5c:	25 e2       	ldi	r18, 0x25	; 37
     a5e:	30 e0       	ldi	r19, 0x00	; 0
     a60:	a9 01       	movw	r20, r18
     a62:	48 1b       	sub	r20, r24
     a64:	59 0b       	sbc	r21, r25
     a66:	ca 01       	movw	r24, r20
		if(val) PORTC |= (1<<pin);
     a68:	66 23       	and	r22, r22
     a6a:	69 f0       	breq	.+26     	; 0xa86 <_Z12digitalWriteib+0x98>
     a6c:	48 b1       	in	r20, 0x08	; 8
     a6e:	21 e0       	ldi	r18, 0x01	; 1
     a70:	30 e0       	ldi	r19, 0x00	; 0
     a72:	b9 01       	movw	r22, r18
     a74:	02 c0       	rjmp	.+4      	; 0xa7a <_Z12digitalWriteib+0x8c>
     a76:	66 0f       	add	r22, r22
     a78:	77 1f       	adc	r23, r23
     a7a:	8a 95       	dec	r24
     a7c:	e2 f7       	brpl	.-8      	; 0xa76 <_Z12digitalWriteib+0x88>
     a7e:	cb 01       	movw	r24, r22
     a80:	84 2b       	or	r24, r20
     a82:	88 b9       	out	0x08, r24	; 8
     a84:	80 c0       	rjmp	.+256    	; 0xb86 <_Z12digitalWriteib+0x198>
		else PORTC &= ~(1<<pin);
     a86:	48 b1       	in	r20, 0x08	; 8
     a88:	21 e0       	ldi	r18, 0x01	; 1
     a8a:	30 e0       	ldi	r19, 0x00	; 0
     a8c:	b9 01       	movw	r22, r18
     a8e:	02 c0       	rjmp	.+4      	; 0xa94 <_Z12digitalWriteib+0xa6>
     a90:	66 0f       	add	r22, r22
     a92:	77 1f       	adc	r23, r23
     a94:	8a 95       	dec	r24
     a96:	e2 f7       	brpl	.-8      	; 0xa90 <_Z12digitalWriteib+0xa2>
     a98:	cb 01       	movw	r24, r22
     a9a:	80 95       	com	r24
     a9c:	84 23       	and	r24, r20
     a9e:	88 b9       	out	0x08, r24	; 8
     aa0:	72 c0       	rjmp	.+228    	; 0xb86 <_Z12digitalWriteib+0x198>
	}
	else if(pin==38){
     aa2:	86 32       	cpi	r24, 0x26	; 38
     aa4:	91 05       	cpc	r25, r1
     aa6:	31 f4       	brne	.+12     	; 0xab4 <_Z12digitalWriteib+0xc6>
		if(val) PORTD |= (1<<PIND7);
     aa8:	66 23       	and	r22, r22
     aaa:	11 f0       	breq	.+4      	; 0xab0 <_Z12digitalWriteib+0xc2>
     aac:	5f 9a       	sbi	0x0b, 7	; 11
     aae:	6b c0       	rjmp	.+214    	; 0xb86 <_Z12digitalWriteib+0x198>
		else PORTD &= ~(1<<PIND7);
     ab0:	5f 98       	cbi	0x0b, 7	; 11
     ab2:	69 c0       	rjmp	.+210    	; 0xb86 <_Z12digitalWriteib+0x198>
	}
	else if(pin<42){
     ab4:	8a 32       	cpi	r24, 0x2A	; 42
     ab6:	91 05       	cpc	r25, r1
     ab8:	ec f4       	brge	.+58     	; 0xaf4 <_Z12digitalWriteib+0x106>
		pin=(41-pin);
     aba:	29 e2       	ldi	r18, 0x29	; 41
     abc:	30 e0       	ldi	r19, 0x00	; 0
     abe:	28 1b       	sub	r18, r24
     ac0:	39 0b       	sbc	r19, r25
		if(val) PORTG |= (1<<pin);
     ac2:	66 23       	and	r22, r22
     ac4:	59 f0       	breq	.+22     	; 0xadc <_Z12digitalWriteib+0xee>
     ac6:	34 b3       	in	r19, 0x14	; 20
     ac8:	81 e0       	ldi	r24, 0x01	; 1
     aca:	90 e0       	ldi	r25, 0x00	; 0
     acc:	02 c0       	rjmp	.+4      	; 0xad2 <_Z12digitalWriteib+0xe4>
     ace:	88 0f       	add	r24, r24
     ad0:	99 1f       	adc	r25, r25
     ad2:	2a 95       	dec	r18
     ad4:	e2 f7       	brpl	.-8      	; 0xace <_Z12digitalWriteib+0xe0>
     ad6:	83 2b       	or	r24, r19
     ad8:	84 bb       	out	0x14, r24	; 20
     ada:	55 c0       	rjmp	.+170    	; 0xb86 <_Z12digitalWriteib+0x198>
		else PORTG &= ~(1<<pin);
     adc:	34 b3       	in	r19, 0x14	; 20
     ade:	81 e0       	ldi	r24, 0x01	; 1
     ae0:	90 e0       	ldi	r25, 0x00	; 0
     ae2:	02 c0       	rjmp	.+4      	; 0xae8 <_Z12digitalWriteib+0xfa>
     ae4:	88 0f       	add	r24, r24
     ae6:	99 1f       	adc	r25, r25
     ae8:	2a 95       	dec	r18
     aea:	e2 f7       	brpl	.-8      	; 0xae4 <_Z12digitalWriteib+0xf6>
     aec:	80 95       	com	r24
     aee:	83 23       	and	r24, r19
     af0:	84 bb       	out	0x14, r24	; 20
     af2:	49 c0       	rjmp	.+146    	; 0xb86 <_Z12digitalWriteib+0x198>
	}
	else if(pin<50){
     af4:	82 33       	cpi	r24, 0x32	; 50
     af6:	91 05       	cpc	r25, r1
     af8:	0c f5       	brge	.+66     	; 0xb3c <_Z12digitalWriteib+0x14e>
		pin=(49-pin);
     afa:	21 e3       	ldi	r18, 0x31	; 49
     afc:	30 e0       	ldi	r19, 0x00	; 0
     afe:	28 1b       	sub	r18, r24
     b00:	39 0b       	sbc	r19, r25
		if(val) PORTL |= (1<<pin);
     b02:	66 23       	and	r22, r22
     b04:	69 f0       	breq	.+26     	; 0xb20 <_Z12digitalWriteib+0x132>
     b06:	eb e0       	ldi	r30, 0x0B	; 11
     b08:	f1 e0       	ldi	r31, 0x01	; 1
     b0a:	30 81       	ld	r19, Z
     b0c:	81 e0       	ldi	r24, 0x01	; 1
     b0e:	90 e0       	ldi	r25, 0x00	; 0
     b10:	02 c0       	rjmp	.+4      	; 0xb16 <_Z12digitalWriteib+0x128>
     b12:	88 0f       	add	r24, r24
     b14:	99 1f       	adc	r25, r25
     b16:	2a 95       	dec	r18
     b18:	e2 f7       	brpl	.-8      	; 0xb12 <_Z12digitalWriteib+0x124>
     b1a:	83 2b       	or	r24, r19
     b1c:	80 83       	st	Z, r24
     b1e:	33 c0       	rjmp	.+102    	; 0xb86 <_Z12digitalWriteib+0x198>
		else PORTL &= ~(1<<pin);
     b20:	eb e0       	ldi	r30, 0x0B	; 11
     b22:	f1 e0       	ldi	r31, 0x01	; 1
     b24:	30 81       	ld	r19, Z
     b26:	81 e0       	ldi	r24, 0x01	; 1
     b28:	90 e0       	ldi	r25, 0x00	; 0
     b2a:	02 c0       	rjmp	.+4      	; 0xb30 <_Z12digitalWriteib+0x142>
     b2c:	88 0f       	add	r24, r24
     b2e:	99 1f       	adc	r25, r25
     b30:	2a 95       	dec	r18
     b32:	e2 f7       	brpl	.-8      	; 0xb2c <_Z12digitalWriteib+0x13e>
     b34:	80 95       	com	r24
     b36:	83 23       	and	r24, r19
     b38:	80 83       	st	Z, r24
     b3a:	25 c0       	rjmp	.+74     	; 0xb86 <_Z12digitalWriteib+0x198>
	}
	else if(pin<54){
     b3c:	86 33       	cpi	r24, 0x36	; 54
     b3e:	91 05       	cpc	r25, r1
     b40:	14 f5       	brge	.+68     	; 0xb86 <_Z12digitalWriteib+0x198>
		pin=(53-pin);
     b42:	25 e3       	ldi	r18, 0x35	; 53
     b44:	30 e0       	ldi	r19, 0x00	; 0
     b46:	a9 01       	movw	r20, r18
     b48:	48 1b       	sub	r20, r24
     b4a:	59 0b       	sbc	r21, r25
     b4c:	ca 01       	movw	r24, r20
		if(val) PORTB |= (1<<pin);
     b4e:	66 23       	and	r22, r22
     b50:	69 f0       	breq	.+26     	; 0xb6c <_Z12digitalWriteib+0x17e>
     b52:	45 b1       	in	r20, 0x05	; 5
     b54:	21 e0       	ldi	r18, 0x01	; 1
     b56:	30 e0       	ldi	r19, 0x00	; 0
     b58:	b9 01       	movw	r22, r18
     b5a:	02 c0       	rjmp	.+4      	; 0xb60 <_Z12digitalWriteib+0x172>
     b5c:	66 0f       	add	r22, r22
     b5e:	77 1f       	adc	r23, r23
     b60:	8a 95       	dec	r24
     b62:	e2 f7       	brpl	.-8      	; 0xb5c <_Z12digitalWriteib+0x16e>
     b64:	cb 01       	movw	r24, r22
     b66:	84 2b       	or	r24, r20
     b68:	85 b9       	out	0x05, r24	; 5
     b6a:	0d c0       	rjmp	.+26     	; 0xb86 <_Z12digitalWriteib+0x198>
		else PORTB &= ~(1<<pin);
     b6c:	45 b1       	in	r20, 0x05	; 5
     b6e:	21 e0       	ldi	r18, 0x01	; 1
     b70:	30 e0       	ldi	r19, 0x00	; 0
     b72:	b9 01       	movw	r22, r18
     b74:	02 c0       	rjmp	.+4      	; 0xb7a <_Z12digitalWriteib+0x18c>
     b76:	66 0f       	add	r22, r22
     b78:	77 1f       	adc	r23, r23
     b7a:	8a 95       	dec	r24
     b7c:	e2 f7       	brpl	.-8      	; 0xb76 <_Z12digitalWriteib+0x188>
     b7e:	cb 01       	movw	r24, r22
     b80:	80 95       	com	r24
     b82:	84 23       	and	r24, r20
     b84:	85 b9       	out	0x05, r24	; 5
	}
	return;
}
     b86:	df 91       	pop	r29
     b88:	cf 91       	pop	r28
     b8a:	08 95       	ret

00000b8c <_Z11digitalReadi>:

bool digitalRead(int pin){
     b8c:	cf 93       	push	r28
     b8e:	df 93       	push	r29
	if(pin==4){
     b90:	84 30       	cpi	r24, 0x04	; 4
     b92:	91 05       	cpc	r25, r1
     b94:	29 f4       	brne	.+10     	; 0xba0 <_Z11digitalReadi+0x14>
		if(PING&(1<<PING5))	return true;
     b96:	82 b3       	in	r24, 0x12	; 18
     b98:	85 fb       	bst	r24, 5
     b9a:	88 27       	eor	r24, r24
     b9c:	80 f9       	bld	r24, 0
     b9e:	6f c0       	rjmp	.+222    	; 0xc7e <_Z11digitalReadi+0xf2>
	}
	else if(pin<30){					//check if pin is in the A register
     ba0:	8e 31       	cpi	r24, 0x1E	; 30
     ba2:	91 05       	cpc	r25, r1
     ba4:	64 f4       	brge	.+24     	; 0xbbe <_Z11digitalReadi+0x32>
		pin-=22;						//make pinrange 0-7
		if(PINA&(1<<pin))	return true;							//break function
     ba6:	20 b1       	in	r18, 0x00	; 0
     ba8:	30 e0       	ldi	r19, 0x00	; 0
     baa:	46 97       	sbiw	r24, 0x16	; 22
     bac:	a9 01       	movw	r20, r18
     bae:	02 c0       	rjmp	.+4      	; 0xbb4 <_Z11digitalReadi+0x28>
     bb0:	55 95       	asr	r21
     bb2:	47 95       	ror	r20
     bb4:	8a 95       	dec	r24
     bb6:	e2 f7       	brpl	.-8      	; 0xbb0 <_Z11digitalReadi+0x24>
     bb8:	ca 01       	movw	r24, r20
     bba:	81 70       	andi	r24, 0x01	; 1
     bbc:	60 c0       	rjmp	.+192    	; 0xc7e <_Z11digitalReadi+0xf2>
	}
	else if(pin<38){
     bbe:	86 32       	cpi	r24, 0x26	; 38
     bc0:	91 05       	cpc	r25, r1
     bc2:	84 f4       	brge	.+32     	; 0xbe4 <_Z11digitalReadi+0x58>
		pin=37-pin;
		if(PINC&(1<<pin))	return true;							//break function
     bc4:	26 b1       	in	r18, 0x06	; 6
     bc6:	30 e0       	ldi	r19, 0x00	; 0
     bc8:	45 e2       	ldi	r20, 0x25	; 37
     bca:	50 e0       	ldi	r21, 0x00	; 0
     bcc:	ba 01       	movw	r22, r20
     bce:	68 1b       	sub	r22, r24
     bd0:	79 0b       	sbc	r23, r25
     bd2:	a9 01       	movw	r20, r18
     bd4:	02 c0       	rjmp	.+4      	; 0xbda <_Z11digitalReadi+0x4e>
     bd6:	55 95       	asr	r21
     bd8:	47 95       	ror	r20
     bda:	6a 95       	dec	r22
     bdc:	e2 f7       	brpl	.-8      	; 0xbd6 <_Z11digitalReadi+0x4a>
     bde:	ca 01       	movw	r24, r20
     be0:	81 70       	andi	r24, 0x01	; 1
     be2:	4d c0       	rjmp	.+154    	; 0xc7e <_Z11digitalReadi+0xf2>
	}
	else if(pin==38){
     be4:	86 32       	cpi	r24, 0x26	; 38
     be6:	91 05       	cpc	r25, r1
     be8:	29 f4       	brne	.+10     	; 0xbf4 <_Z11digitalReadi+0x68>
		if(PIND&(1<<PIND7))	return true;							//break function
     bea:	89 b1       	in	r24, 0x09	; 9
     bec:	88 1f       	adc	r24, r24
     bee:	88 27       	eor	r24, r24
     bf0:	88 1f       	adc	r24, r24
     bf2:	45 c0       	rjmp	.+138    	; 0xc7e <_Z11digitalReadi+0xf2>
	}
	else if(pin<42){
     bf4:	8a 32       	cpi	r24, 0x2A	; 42
     bf6:	91 05       	cpc	r25, r1
     bf8:	84 f4       	brge	.+32     	; 0xc1a <_Z11digitalReadi+0x8e>
		pin=41-pin;
		if(PING&(1<<pin))	return true;							//break function
     bfa:	22 b3       	in	r18, 0x12	; 18
     bfc:	30 e0       	ldi	r19, 0x00	; 0
     bfe:	49 e2       	ldi	r20, 0x29	; 41
     c00:	50 e0       	ldi	r21, 0x00	; 0
     c02:	ba 01       	movw	r22, r20
     c04:	68 1b       	sub	r22, r24
     c06:	79 0b       	sbc	r23, r25
     c08:	a9 01       	movw	r20, r18
     c0a:	02 c0       	rjmp	.+4      	; 0xc10 <_Z11digitalReadi+0x84>
     c0c:	55 95       	asr	r21
     c0e:	47 95       	ror	r20
     c10:	6a 95       	dec	r22
     c12:	e2 f7       	brpl	.-8      	; 0xc0c <_Z11digitalReadi+0x80>
     c14:	ca 01       	movw	r24, r20
     c16:	81 70       	andi	r24, 0x01	; 1
     c18:	32 c0       	rjmp	.+100    	; 0xc7e <_Z11digitalReadi+0xf2>
	}
	else if(pin<50){
     c1a:	82 33       	cpi	r24, 0x32	; 50
     c1c:	91 05       	cpc	r25, r1
     c1e:	8c f4       	brge	.+34     	; 0xc42 <_Z11digitalReadi+0xb6>
		pin=49-pin;
		if(PINL&(1<<pin))	return true;							//break function
     c20:	20 91 09 01 	lds	r18, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
     c24:	30 e0       	ldi	r19, 0x00	; 0
     c26:	41 e3       	ldi	r20, 0x31	; 49
     c28:	50 e0       	ldi	r21, 0x00	; 0
     c2a:	ba 01       	movw	r22, r20
     c2c:	68 1b       	sub	r22, r24
     c2e:	79 0b       	sbc	r23, r25
     c30:	a9 01       	movw	r20, r18
     c32:	02 c0       	rjmp	.+4      	; 0xc38 <_Z11digitalReadi+0xac>
     c34:	55 95       	asr	r21
     c36:	47 95       	ror	r20
     c38:	6a 95       	dec	r22
     c3a:	e2 f7       	brpl	.-8      	; 0xc34 <_Z11digitalReadi+0xa8>
     c3c:	ca 01       	movw	r24, r20
     c3e:	81 70       	andi	r24, 0x01	; 1
     c40:	1e c0       	rjmp	.+60     	; 0xc7e <_Z11digitalReadi+0xf2>
	}
	else if(pin<54){
     c42:	86 33       	cpi	r24, 0x36	; 54
     c44:	91 05       	cpc	r25, r1
     c46:	84 f4       	brge	.+32     	; 0xc68 <_Z11digitalReadi+0xdc>
		pin=(53-pin);
		if(PINB&(1<<pin))	return true;							//break function
     c48:	23 b1       	in	r18, 0x03	; 3
     c4a:	30 e0       	ldi	r19, 0x00	; 0
     c4c:	45 e3       	ldi	r20, 0x35	; 53
     c4e:	50 e0       	ldi	r21, 0x00	; 0
     c50:	ba 01       	movw	r22, r20
     c52:	68 1b       	sub	r22, r24
     c54:	79 0b       	sbc	r23, r25
     c56:	a9 01       	movw	r20, r18
     c58:	02 c0       	rjmp	.+4      	; 0xc5e <_Z11digitalReadi+0xd2>
     c5a:	55 95       	asr	r21
     c5c:	47 95       	ror	r20
     c5e:	6a 95       	dec	r22
     c60:	e2 f7       	brpl	.-8      	; 0xc5a <_Z11digitalReadi+0xce>
     c62:	ca 01       	movw	r24, r20
     c64:	81 70       	andi	r24, 0x01	; 1
     c66:	0b c0       	rjmp	.+22     	; 0xc7e <_Z11digitalReadi+0xf2>
     c68:	ec 01       	movw	r28, r24
	}
	else{					//pin unsupported
		Serial.print("ERROR: tried to read digital value from unsupported digital pin: ");
     c6a:	63 ea       	ldi	r22, 0xA3	; 163
     c6c:	72 e0       	ldi	r23, 0x02	; 2
     c6e:	83 e7       	ldi	r24, 0x73	; 115
     c70:	94 e0       	ldi	r25, 0x04	; 4
     c72:	89 d5       	rcall	.+2834   	; 0x1786 <_ZN5USART5printEPKc>
		Serial.println(pin);
     c74:	be 01       	movw	r22, r28
     c76:	83 e7       	ldi	r24, 0x73	; 115
     c78:	94 e0       	ldi	r25, 0x04	; 4
     c7a:	cc d5       	rcall	.+2968   	; 0x1814 <_ZN5USART7printlnEi>
		return false;
     c7c:	80 e0       	ldi	r24, 0x00	; 0
	}
	return false;	
}
     c7e:	df 91       	pop	r29
     c80:	cf 91       	pop	r28
     c82:	08 95       	ret

00000c84 <_Z10analogReadi>:

int analogRead(int pin){
     c84:	cf 93       	push	r28
     c86:	df 93       	push	r29
	//set correct MUX registers, these determine on which pin the ADC should read it's value
	//first the MUXx bits are cleared, then filled to prevent old setting leaking though
	
	ADMUX &=(0b11100000);							//clear the bottom 4 bit
     c88:	ec e7       	ldi	r30, 0x7C	; 124
     c8a:	f0 e0       	ldi	r31, 0x00	; 0
     c8c:	20 81       	ld	r18, Z
     c8e:	20 7e       	andi	r18, 0xE0	; 224
     c90:	20 83       	st	Z, r18
	ADCSRB &=(0b11110111);							//clear the top one bit
     c92:	eb e7       	ldi	r30, 0x7B	; 123
     c94:	f0 e0       	ldi	r31, 0x00	; 0
     c96:	20 81       	ld	r18, Z
     c98:	27 7f       	andi	r18, 0xF7	; 247
     c9a:	20 83       	st	Z, r18
	if(pin<8)										//if adc #0-7
     c9c:	88 30       	cpi	r24, 0x08	; 8
     c9e:	91 05       	cpc	r25, r1
     ca0:	34 f4       	brge	.+12     	; 0xcae <_Z10analogReadi+0x2a>
	ADMUX |= pin;								//write the full pin to the ADMUX registry
     ca2:	ec e7       	ldi	r30, 0x7C	; 124
     ca4:	f0 e0       	ldi	r31, 0x00	; 0
     ca6:	90 81       	ld	r25, Z
     ca8:	89 2b       	or	r24, r25
     caa:	80 83       	st	Z, r24
     cac:	1c c0       	rjmp	.+56     	; 0xce6 <_Z10analogReadi+0x62>
	else if(pin<16){									//if adc #8-15
     cae:	80 31       	cpi	r24, 0x10	; 16
     cb0:	91 05       	cpc	r25, r1
     cb2:	64 f4       	brge	.+24     	; 0xccc <_Z10analogReadi+0x48>
		ADCSRB |= (1<<3);							//write upper bit to ADCSRB register
     cb4:	eb e7       	ldi	r30, 0x7B	; 123
     cb6:	f0 e0       	ldi	r31, 0x00	; 0
     cb8:	90 81       	ld	r25, Z
     cba:	98 60       	ori	r25, 0x08	; 8
     cbc:	90 83       	st	Z, r25
		ADMUX |= (pin-8);							//write lower bits to ADMUX registry
     cbe:	ec e7       	ldi	r30, 0x7C	; 124
     cc0:	f0 e0       	ldi	r31, 0x00	; 0
     cc2:	90 81       	ld	r25, Z
     cc4:	88 50       	subi	r24, 0x08	; 8
     cc6:	89 2b       	or	r24, r25
     cc8:	80 83       	st	Z, r24
     cca:	0d c0       	rjmp	.+26     	; 0xce6 <_Z10analogReadi+0x62>
     ccc:	ec 01       	movw	r28, r24
	}
	else{
		Serial.print("ERROR: tried to read digital value from unsupported analog pin ");
     cce:	65 ee       	ldi	r22, 0xE5	; 229
     cd0:	72 e0       	ldi	r23, 0x02	; 2
     cd2:	83 e7       	ldi	r24, 0x73	; 115
     cd4:	94 e0       	ldi	r25, 0x04	; 4
     cd6:	57 d5       	rcall	.+2734   	; 0x1786 <_ZN5USART5printEPKc>
		Serial.println(pin);
     cd8:	be 01       	movw	r22, r28
     cda:	83 e7       	ldi	r24, 0x73	; 115
     cdc:	94 e0       	ldi	r25, 0x04	; 4
     cde:	9a d5       	rcall	.+2868   	; 0x1814 <_ZN5USART7printlnEi>
		return 0;
     ce0:	80 e0       	ldi	r24, 0x00	; 0
     ce2:	90 e0       	ldi	r25, 0x00	; 0
     ce4:	0c c0       	rjmp	.+24     	; 0xcfe <_Z10analogReadi+0x7a>
	}
	ADCSRA |= (1<<ADSC);							//start ADC conversion
     ce6:	ea e7       	ldi	r30, 0x7A	; 122
     ce8:	f0 e0       	ldi	r31, 0x00	; 0
     cea:	80 81       	ld	r24, Z
     cec:	80 64       	ori	r24, 0x40	; 64
     cee:	80 83       	st	Z, r24
	while(ADCSRA & (1<<ADSC));						//wait until the ADSC is 0 again and the conversion is done
     cf0:	80 81       	ld	r24, Z
     cf2:	86 fd       	sbrc	r24, 6
     cf4:	fd cf       	rjmp	.-6      	; 0xcf0 <_Z10analogReadi+0x6c>
	return ADC;										//return the byte in ADLAR, the result of the ADC conversion
     cf6:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
     cfa:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
}
     cfe:	df 91       	pop	r29
     d00:	cf 91       	pop	r28
     d02:	08 95       	ret

00000d04 <_Z9printinfov>:
}

#ifdef DEBUG_MODE									//only spam terminal when in debug mode
void printinfo(){

	Serial.print("DM: ");
     d04:	65 e2       	ldi	r22, 0x25	; 37
     d06:	73 e0       	ldi	r23, 0x03	; 3
     d08:	83 e7       	ldi	r24, 0x73	; 115
     d0a:	94 e0       	ldi	r25, 0x04	; 4
     d0c:	3c d5       	rcall	.+2680   	; 0x1786 <_ZN5USART5printEPKc>
	Serial.print(drivemode);
     d0e:	60 91 52 04 	lds	r22, 0x0452	; 0x800452 <drivemode>
     d12:	70 91 53 04 	lds	r23, 0x0453	; 0x800453 <drivemode+0x1>
     d16:	83 e7       	ldi	r24, 0x73	; 115
     d18:	94 e0       	ldi	r25, 0x04	; 4
     d1a:	59 d5       	rcall	.+2738   	; 0x17ce <_ZN5USART5printEi>
	Serial.print(" drive dir: ");
     d1c:	6a e2       	ldi	r22, 0x2A	; 42
     d1e:	73 e0       	ldi	r23, 0x03	; 3
     d20:	83 e7       	ldi	r24, 0x73	; 115
     d22:	94 e0       	ldi	r25, 0x04	; 4
     d24:	30 d5       	rcall	.+2656   	; 0x1786 <_ZN5USART5printEPKc>
	Serial.print(driving_direction);
     d26:	60 91 00 02 	lds	r22, 0x0200	; 0x800200 <__data_start>
     d2a:	70 e0       	ldi	r23, 0x00	; 0
     d2c:	83 e7       	ldi	r24, 0x73	; 115
     d2e:	94 e0       	ldi	r25, 0x04	; 4
     d30:	4e d5       	rcall	.+2716   	; 0x17ce <_ZN5USART5printEi>
	Serial.print(" engine_dv = ");
     d32:	67 e3       	ldi	r22, 0x37	; 55
     d34:	73 e0       	ldi	r23, 0x03	; 3
     d36:	83 e7       	ldi	r24, 0x73	; 115
     d38:	94 e0       	ldi	r25, 0x04	; 4
     d3a:	25 d5       	rcall	.+2634   	; 0x1786 <_ZN5USART5printEPKc>
	Serial.print(engine_dv);
     d3c:	60 91 3b 04 	lds	r22, 0x043B	; 0x80043b <engine_dv>
     d40:	70 91 3c 04 	lds	r23, 0x043C	; 0x80043c <engine_dv+0x1>
     d44:	83 e7       	ldi	r24, 0x73	; 115
     d46:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" brake_dv = ");
     d48:	42 d5       	rcall	.+2692   	; 0x17ce <_ZN5USART5printEi>
     d4a:	65 e4       	ldi	r22, 0x45	; 69
     d4c:	73 e0       	ldi	r23, 0x03	; 3
     d4e:	83 e7       	ldi	r24, 0x73	; 115
     d50:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(braking_dv);
     d52:	19 d5       	rcall	.+2610   	; 0x1786 <_ZN5USART5printEPKc>
     d54:	60 91 37 04 	lds	r22, 0x0437	; 0x800437 <braking_dv>
     d58:	70 91 38 04 	lds	r23, 0x0438	; 0x800438 <braking_dv+0x1>
     d5c:	83 e7       	ldi	r24, 0x73	; 115
     d5e:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" braking_ov = ");
     d60:	36 d5       	rcall	.+2668   	; 0x17ce <_ZN5USART5printEi>
     d62:	62 e5       	ldi	r22, 0x52	; 82
     d64:	73 e0       	ldi	r23, 0x03	; 3
     d66:	83 e7       	ldi	r24, 0x73	; 115
     d68:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(braking_ov);
     d6a:	0d d5       	rcall	.+2586   	; 0x1786 <_ZN5USART5printEPKc>
     d6c:	60 91 2e 04 	lds	r22, 0x042E	; 0x80042e <braking_ov>
     d70:	70 e0       	ldi	r23, 0x00	; 0
     d72:	83 e7       	ldi	r24, 0x73	; 115
     d74:	94 e0       	ldi	r25, 0x04	; 4

	Serial.print(" steering_dv = ");
     d76:	2b d5       	rcall	.+2646   	; 0x17ce <_ZN5USART5printEi>
     d78:	61 e6       	ldi	r22, 0x61	; 97
     d7a:	73 e0       	ldi	r23, 0x03	; 3
     d7c:	83 e7       	ldi	r24, 0x73	; 115
     d7e:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(steering_dv);
     d80:	02 d5       	rcall	.+2564   	; 0x1786 <_ZN5USART5printEPKc>
     d82:	60 91 4a 04 	lds	r22, 0x044A	; 0x80044a <steering_dv>
     d86:	70 91 4b 04 	lds	r23, 0x044B	; 0x80044b <steering_dv+0x1>
     d8a:	83 e7       	ldi	r24, 0x73	; 115
     d8c:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" steering_cv = ");
     d8e:	1f d5       	rcall	.+2622   	; 0x17ce <_ZN5USART5printEi>
     d90:	61 e7       	ldi	r22, 0x71	; 113
     d92:	73 e0       	ldi	r23, 0x03	; 3
     d94:	83 e7       	ldi	r24, 0x73	; 115
     d96:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(steering_cv);
     d98:	f6 d4       	rcall	.+2540   	; 0x1786 <_ZN5USART5printEPKc>
     d9a:	60 91 40 04 	lds	r22, 0x0440	; 0x800440 <steering_cv>
     d9e:	70 91 41 04 	lds	r23, 0x0441	; 0x800441 <steering_cv+0x1>
     da2:	83 e7       	ldi	r24, 0x73	; 115
     da4:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" steering_ov = ");
     da6:	13 d5       	rcall	.+2598   	; 0x17ce <_ZN5USART5printEi>
     da8:	61 e8       	ldi	r22, 0x81	; 129
     daa:	73 e0       	ldi	r23, 0x03	; 3
     dac:	83 e7       	ldi	r24, 0x73	; 115
     dae:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(steering_ov);
     db0:	ea d4       	rcall	.+2516   	; 0x1786 <_ZN5USART5printEPKc>
     db2:	60 91 3f 04 	lds	r22, 0x043F	; 0x80043f <steering_ov>
     db6:	70 e0       	ldi	r23, 0x00	; 0
     db8:	83 e7       	ldi	r24, 0x73	; 115
     dba:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" steering_delta = ");
     dbc:	08 d5       	rcall	.+2576   	; 0x17ce <_ZN5USART5printEi>
     dbe:	61 e9       	ldi	r22, 0x91	; 145
     dc0:	73 e0       	ldi	r23, 0x03	; 3
     dc2:	83 e7       	ldi	r24, 0x73	; 115
     dc4:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(steering_delta);
     dc6:	df d4       	rcall	.+2494   	; 0x1786 <_ZN5USART5printEPKc>
     dc8:	60 91 48 04 	lds	r22, 0x0448	; 0x800448 <steering_delta>
     dcc:	70 91 49 04 	lds	r23, 0x0449	; 0x800449 <steering_delta+0x1>
     dd0:	83 e7       	ldi	r24, 0x73	; 115
	Serial.print(" low volt = ");
     dd2:	94 e0       	ldi	r25, 0x04	; 4
     dd4:	fc d4       	rcall	.+2552   	; 0x17ce <_ZN5USART5printEi>
     dd6:	64 ea       	ldi	r22, 0xA4	; 164
     dd8:	73 e0       	ldi	r23, 0x03	; 3
     dda:	83 e7       	ldi	r24, 0x73	; 115
	Serial.print(low_voltage);
     ddc:	94 e0       	ldi	r25, 0x04	; 4
     dde:	d3 d4       	rcall	.+2470   	; 0x1786 <_ZN5USART5printEPKc>
     de0:	60 91 2c 04 	lds	r22, 0x042C	; 0x80042c <low_voltage>
     de4:	70 91 2d 04 	lds	r23, 0x042D	; 0x80042d <low_voltage+0x1>
     de8:	83 e7       	ldi	r24, 0x73	; 115
	Serial.print(" high volt = ");
     dea:	94 e0       	ldi	r25, 0x04	; 4
     dec:	f0 d4       	rcall	.+2528   	; 0x17ce <_ZN5USART5printEi>
     dee:	61 eb       	ldi	r22, 0xB1	; 177
     df0:	73 e0       	ldi	r23, 0x03	; 3
     df2:	83 e7       	ldi	r24, 0x73	; 115
	Serial.print(high_voltage);
     df4:	94 e0       	ldi	r25, 0x04	; 4
     df6:	c7 d4       	rcall	.+2446   	; 0x1786 <_ZN5USART5printEPKc>
     df8:	60 91 24 04 	lds	r22, 0x0424	; 0x800424 <__data_end>
     dfc:	70 91 25 04 	lds	r23, 0x0425	; 0x800425 <__data_end+0x1>
     e00:	83 e7       	ldi	r24, 0x73	; 115
	Serial.print(" rpm = ");
     e02:	94 e0       	ldi	r25, 0x04	; 4
     e04:	e4 d4       	rcall	.+2504   	; 0x17ce <_ZN5USART5printEi>
     e06:	6f eb       	ldi	r22, 0xBF	; 191
     e08:	73 e0       	ldi	r23, 0x03	; 3
     e0a:	83 e7       	ldi	r24, 0x73	; 115
	Serial.print(engine_rpm);
     e0c:	94 e0       	ldi	r25, 0x04	; 4
     e0e:	bb d4       	rcall	.+2422   	; 0x1786 <_ZN5USART5printEPKc>
     e10:	60 91 2a 04 	lds	r22, 0x042A	; 0x80042a <engine_rpm>
     e14:	70 91 2b 04 	lds	r23, 0x042B	; 0x80042b <engine_rpm+0x1>
     e18:	83 e7       	ldi	r24, 0x73	; 115
     e1a:	94 e0       	ldi	r25, 0x04	; 4
	Serial.print(" temp = ");
     e1c:	d8 d4       	rcall	.+2480   	; 0x17ce <_ZN5USART5printEi>
     e1e:	67 ec       	ldi	r22, 0xC7	; 199
     e20:	73 e0       	ldi	r23, 0x03	; 3
     e22:	83 e7       	ldi	r24, 0x73	; 115
     e24:	94 e0       	ldi	r25, 0x04	; 4
     e26:	af d4       	rcall	.+2398   	; 0x1786 <_ZN5USART5printEPKc>
	Serial.println(engine_temp);
     e28:	60 91 28 04 	lds	r22, 0x0428	; 0x800428 <engine_temp>
     e2c:	70 91 29 04 	lds	r23, 0x0429	; 0x800429 <engine_temp+0x1>
     e30:	83 e7       	ldi	r24, 0x73	; 115
     e32:	94 e0       	ldi	r25, 0x04	; 4
     e34:	ef c4       	rjmp	.+2526   	; 0x1814 <_ZN5USART7printlnEi>
     e36:	08 95       	ret

00000e38 <_Z13updateCurtissv>:
     e38:	24 e5       	ldi	r18, 0x54	; 84
}
#endif

void updateCurtiss(){
	CAN_Curt.readMsgBuf(&rxId_Curt, &len_Curt, rxBuf_Curt);	// Read data: len = data length, buf = data byte(s)
     e3a:	34 e0       	ldi	r19, 0x04	; 4
     e3c:	4c e5       	ldi	r20, 0x5C	; 92
     e3e:	54 e0       	ldi	r21, 0x04	; 4
     e40:	6d e5       	ldi	r22, 0x5D	; 93
     e42:	74 e0       	ldi	r23, 0x04	; 4
     e44:	81 e6       	ldi	r24, 0x61	; 97
     e46:	94 e0       	ldi	r25, 0x04	; 4
     e48:	11 d4       	rcall	.+2082   	; 0x166c <_ZN7MCP_CAN10readMsgBufEPmPhS1_>
	if((rxId_Curt & 0x40000000) == 0x40000000)					//Ignore remote requests
     e4a:	80 91 5d 04 	lds	r24, 0x045D	; 0x80045d <rxId_Curt>
     e4e:	90 91 5e 04 	lds	r25, 0x045E	; 0x80045e <rxId_Curt+0x1>
     e52:	a0 91 5f 04 	lds	r26, 0x045F	; 0x80045f <rxId_Curt+0x2>
     e56:	b0 91 60 04 	lds	r27, 0x0460	; 0x800460 <rxId_Curt+0x3>
     e5a:	b6 fd       	sbrc	r27, 6
     e5c:	36 c0       	rjmp	.+108    	; 0xeca <_Z13updateCurtissv+0x92>
		return;	
	low_voltage = rxBuf_Curt[0] + (rxBuf_Curt[1] * 256);
     e5e:	e4 e5       	ldi	r30, 0x54	; 84
     e60:	f4 e0       	ldi	r31, 0x04	; 4
     e62:	81 81       	ldd	r24, Z+1	; 0x01
     e64:	90 e0       	ldi	r25, 0x00	; 0
     e66:	98 2f       	mov	r25, r24
     e68:	88 27       	eor	r24, r24
     e6a:	20 81       	ld	r18, Z
     e6c:	82 0f       	add	r24, r18
     e6e:	91 1d       	adc	r25, r1
     e70:	90 93 2d 04 	sts	0x042D, r25	; 0x80042d <low_voltage+0x1>
     e74:	80 93 2c 04 	sts	0x042C, r24	; 0x80042c <low_voltage>
	engine_rpm = rxBuf_Curt[2] + (rxBuf_Curt[3] * 256);
     e78:	83 81       	ldd	r24, Z+3	; 0x03
     e7a:	90 e0       	ldi	r25, 0x00	; 0
     e7c:	98 2f       	mov	r25, r24
     e7e:	88 27       	eor	r24, r24
     e80:	22 81       	ldd	r18, Z+2	; 0x02
     e82:	82 0f       	add	r24, r18
     e84:	91 1d       	adc	r25, r1
     e86:	90 93 2b 04 	sts	0x042B, r25	; 0x80042b <engine_rpm+0x1>
     e8a:	80 93 2a 04 	sts	0x042A, r24	; 0x80042a <engine_rpm>
	engine_temp = rxBuf_Curt[4] + (rxBuf_Curt[5] * 256);
     e8e:	85 81       	ldd	r24, Z+5	; 0x05
     e90:	90 e0       	ldi	r25, 0x00	; 0
     e92:	98 2f       	mov	r25, r24
     e94:	88 27       	eor	r24, r24
     e96:	24 81       	ldd	r18, Z+4	; 0x04
     e98:	82 0f       	add	r24, r18
     e9a:	91 1d       	adc	r25, r1
     e9c:	90 93 29 04 	sts	0x0429, r25	; 0x800429 <engine_temp+0x1>
     ea0:	80 93 28 04 	sts	0x0428, r24	; 0x800428 <engine_temp>
	control_temp = rxBuf_Curt[6] + (rxBuf_Curt[7] * 256);
     ea4:	87 81       	ldd	r24, Z+7	; 0x07
     ea6:	90 e0       	ldi	r25, 0x00	; 0
     ea8:	98 2f       	mov	r25, r24
     eaa:	88 27       	eor	r24, r24
     eac:	26 81       	ldd	r18, Z+6	; 0x06
     eae:	ac 01       	movw	r20, r24
     eb0:	42 0f       	add	r20, r18
     eb2:	51 1d       	adc	r21, r1
     eb4:	50 93 27 04 	sts	0x0427, r21	; 0x800427 <control_temp+0x1>
     eb8:	40 93 26 04 	sts	0x0426, r20	; 0x800426 <control_temp>
	high_voltage = rxBuf_Curt[8] + (rxBuf_Curt[7] * 256);	
     ebc:	20 85       	ldd	r18, Z+8	; 0x08
     ebe:	82 0f       	add	r24, r18
     ec0:	91 1d       	adc	r25, r1
     ec2:	90 93 25 04 	sts	0x0425, r25	; 0x800425 <__data_end+0x1>
     ec6:	80 93 24 04 	sts	0x0424, r24	; 0x800424 <__data_end>
     eca:	08 95       	ret

00000ecc <main>:
unsigned char len_Curt;
unsigned char rxBuf_Curt[8];
char msgString_Curt[128]; 

int main(void){
	Serial.println("Alley Hoop V2.1");
     ecc:	60 ed       	ldi	r22, 0xD0	; 208
     ece:	73 e0       	ldi	r23, 0x03	; 3
     ed0:	83 e7       	ldi	r24, 0x73	; 115
     ed2:	94 e0       	ldi	r25, 0x04	; 4
     ed4:	71 d4       	rcall	.+2274   	; 0x17b8 <_ZN5USART7printlnEPKc>
	initIO();															//initializes the IO pins
     ed6:	b0 dc       	rcall	.-1696   	; 0x838 <_Z6initIOv>
	initDrive();														//detect steering modus
     ed8:	6b d9       	rcall	.-3370   	; 0x1b0 <_Z9initDrivev>
     eda:	60 e0       	ldi	r22, 0x00	; 0
	digitalWrite(34,LOW);
     edc:	82 e2       	ldi	r24, 0x22	; 34
     ede:	90 e0       	ldi	r25, 0x00	; 0
     ee0:	86 dd       	rcall	.-1268   	; 0x9ee <_Z12digitalWriteib>
     ee2:	21 e0       	ldi	r18, 0x01	; 1
	if(CAN_Curt.begin(MCP_ANY, CAN_500KBPS, MCP_16MHZ) == CAN_OK)		//initialize the CAN BUS
     ee4:	4d e0       	ldi	r20, 0x0D	; 13
     ee6:	63 e0       	ldi	r22, 0x03	; 3
     ee8:	81 e6       	ldi	r24, 0x61	; 97
     eea:	94 e0       	ldi	r25, 0x04	; 4
     eec:	85 d3       	rcall	.+1802   	; 0x15f8 <_ZN7MCP_CAN5beginEhhh>
     eee:	81 11       	cpse	r24, r1
     ef0:	06 c0       	rjmp	.+12     	; 0xefe <main+0x32>
     ef2:	60 ee       	ldi	r22, 0xE0	; 224
		Serial.println("MCP2515 Initialized Successfully!");
     ef4:	73 e0       	ldi	r23, 0x03	; 3
     ef6:	83 e7       	ldi	r24, 0x73	; 115
     ef8:	94 e0       	ldi	r25, 0x04	; 4
     efa:	5e d4       	rcall	.+2236   	; 0x17b8 <_ZN5USART7printlnEPKc>
     efc:	05 c0       	rjmp	.+10     	; 0xf08 <main+0x3c>
     efe:	62 e0       	ldi	r22, 0x02	; 2
	else
		Serial.println("Error Initializing MCP2515...");
     f00:	74 e0       	ldi	r23, 0x04	; 4
     f02:	83 e7       	ldi	r24, 0x73	; 115
     f04:	94 e0       	ldi	r25, 0x04	; 4
     f06:	58 d4       	rcall	.+2224   	; 0x17b8 <_ZN5USART7printlnEPKc>
	CAN_Curt.setMode(MCP_NORMAL);										// Set operation mode to normal so the MCP2515 sends acks to received data.
     f08:	60 e0       	ldi	r22, 0x00	; 0
     f0a:	81 e6       	ldi	r24, 0x61	; 97
     f0c:	94 e0       	ldi	r25, 0x04	; 4
     f0e:	d5 d1       	rcall	.+938    	; 0x12ba <_ZN7MCP_CAN7setModeEh>
     f10:	93 df       	rcall	.-218    	; 0xe38 <_Z13updateCurtissv>

	while (1){				//main program loop	
		updateCurtiss();		//update the values retrieved from the Curtis
     f12:	49 dc       	rcall	.-1902   	; 0x7a6 <_Z5drivev>
     f14:	f7 de       	rcall	.-530    	; 0xd04 <_Z9printinfov>
		drive();				//update the values send to various components
     f16:	fc cf       	rjmp	.-8      	; 0xf10 <main+0x44>

00000f18 <_GLOBAL__sub_I_Serial>:
     f18:	83 e7       	ldi	r24, 0x73	; 115
		#ifdef DEBUG_MODE
			printinfo();			//print info in the terminal, only when debug mode is enabled
     f1a:	94 e0       	ldi	r25, 0x04	; 4
     f1c:	29 d4       	rcall	.+2130   	; 0x1770 <_ZN5USARTC1Ev>
     f1e:	6f e2       	ldi	r22, 0x2F	; 47
#include <util/delay.h>		//allows usage of _delay_ms()
#include "overhead.h"		//defines and standard includes
#include "Drive.h"			//takes care of driving the car

USART Serial;				//global Serial
MCP_CAN CAN_Curt(47);		//the Curtiss CAN BUS
     f20:	81 e6       	ldi	r24, 0x61	; 97
     f22:	94 e0       	ldi	r25, 0x04	; 4
     f24:	5c c3       	rjmp	.+1720   	; 0x15de <_ZN7MCP_CANC1Eh>
     f26:	08 95       	ret

00000f28 <_ZN7MCP_CAN13mcp2515_resetEv>:
		tbufdata[MCP_EID0] = 0;
		tbufdata[MCP_EID8] = 0;
	}

	mcp2515_setRegisterS( mcp_addr, tbufdata, 4 );
}
     f28:	0f 93       	push	r16
     f2a:	1f 93       	push	r17
     f2c:	cf 93       	push	r28
     f2e:	df 93       	push	r29
     f30:	1f 92       	push	r1
     f32:	1f 92       	push	r1
     f34:	cd b7       	in	r28, 0x3d	; 61
     f36:	de b7       	in	r29, 0x3e	; 62
     f38:	00 e0       	ldi	r16, 0x00	; 0
     f3a:	21 e0       	ldi	r18, 0x01	; 1
     f3c:	40 e8       	ldi	r20, 0x80	; 128
     f3e:	56 e9       	ldi	r21, 0x96	; 150
     f40:	68 e9       	ldi	r22, 0x98	; 152
     f42:	70 e0       	ldi	r23, 0x00	; 0
     f44:	ce 01       	movw	r24, r28
     f46:	01 96       	adiw	r24, 0x01	; 1
     f48:	e3 d3       	rcall	.+1990   	; 0x1710 <_ZN11SPISettingsC1Emhh>
     f4a:	be 01       	movw	r22, r28
     f4c:	6f 5f       	subi	r22, 0xFF	; 255
     f4e:	7f 4f       	sbci	r23, 0xFF	; 255
     f50:	85 e7       	ldi	r24, 0x75	; 117
     f52:	94 e0       	ldi	r25, 0x04	; 4
     f54:	01 d4       	rcall	.+2050   	; 0x1758 <_ZN8SPIClass16beginTransactionE11SPISettings>
     f56:	0b e0       	ldi	r16, 0x0B	; 11
     f58:	11 e0       	ldi	r17, 0x01	; 1
     f5a:	f8 01       	movw	r30, r16
     f5c:	80 81       	ld	r24, Z
     f5e:	8b 7f       	andi	r24, 0xFB	; 251
     f60:	80 83       	st	Z, r24
     f62:	60 ec       	ldi	r22, 0xC0	; 192
     f64:	85 e7       	ldi	r24, 0x75	; 117
     f66:	94 e0       	ldi	r25, 0x04	; 4
     f68:	fd d3       	rcall	.+2042   	; 0x1764 <_ZN8SPIClass8transferEh>
     f6a:	f8 01       	movw	r30, r16
     f6c:	80 81       	ld	r24, Z
     f6e:	84 60       	ori	r24, 0x04	; 4
     f70:	80 83       	st	Z, r24
     f72:	83 ec       	ldi	r24, 0xC3	; 195
     f74:	99 e0       	ldi	r25, 0x09	; 9
     f76:	01 97       	sbiw	r24, 0x01	; 1
     f78:	f1 f7       	brne	.-4      	; 0xf76 <_ZN7MCP_CAN13mcp2515_resetEv+0x4e>
     f7a:	00 c0       	rjmp	.+0      	; 0xf7c <_ZN7MCP_CAN13mcp2515_resetEv+0x54>
     f7c:	00 00       	nop
     f7e:	0f 90       	pop	r0
     f80:	0f 90       	pop	r0
     f82:	df 91       	pop	r29
     f84:	cf 91       	pop	r28
     f86:	1f 91       	pop	r17
     f88:	0f 91       	pop	r16
     f8a:	08 95       	ret

00000f8c <_ZN7MCP_CAN20mcp2515_readRegisterEh>:
     f8c:	ff 92       	push	r15
     f8e:	0f 93       	push	r16
     f90:	1f 93       	push	r17
     f92:	cf 93       	push	r28
     f94:	df 93       	push	r29
     f96:	1f 92       	push	r1
     f98:	1f 92       	push	r1
     f9a:	cd b7       	in	r28, 0x3d	; 61
     f9c:	de b7       	in	r29, 0x3e	; 62
     f9e:	f6 2e       	mov	r15, r22
     fa0:	00 e0       	ldi	r16, 0x00	; 0
     fa2:	21 e0       	ldi	r18, 0x01	; 1
     fa4:	40 e8       	ldi	r20, 0x80	; 128
     fa6:	56 e9       	ldi	r21, 0x96	; 150
     fa8:	68 e9       	ldi	r22, 0x98	; 152
     faa:	70 e0       	ldi	r23, 0x00	; 0
     fac:	ce 01       	movw	r24, r28
     fae:	01 96       	adiw	r24, 0x01	; 1
     fb0:	af d3       	rcall	.+1886   	; 0x1710 <_ZN11SPISettingsC1Emhh>
     fb2:	be 01       	movw	r22, r28
     fb4:	6f 5f       	subi	r22, 0xFF	; 255
     fb6:	7f 4f       	sbci	r23, 0xFF	; 255
     fb8:	85 e7       	ldi	r24, 0x75	; 117
     fba:	94 e0       	ldi	r25, 0x04	; 4
     fbc:	cd d3       	rcall	.+1946   	; 0x1758 <_ZN8SPIClass16beginTransactionE11SPISettings>
     fbe:	0b e0       	ldi	r16, 0x0B	; 11
     fc0:	11 e0       	ldi	r17, 0x01	; 1
     fc2:	f8 01       	movw	r30, r16
     fc4:	80 81       	ld	r24, Z
     fc6:	8b 7f       	andi	r24, 0xFB	; 251
     fc8:	80 83       	st	Z, r24
     fca:	63 e0       	ldi	r22, 0x03	; 3
     fcc:	85 e7       	ldi	r24, 0x75	; 117
     fce:	94 e0       	ldi	r25, 0x04	; 4
     fd0:	c9 d3       	rcall	.+1938   	; 0x1764 <_ZN8SPIClass8transferEh>
     fd2:	6f 2d       	mov	r22, r15
     fd4:	85 e7       	ldi	r24, 0x75	; 117
     fd6:	94 e0       	ldi	r25, 0x04	; 4
     fd8:	c5 d3       	rcall	.+1930   	; 0x1764 <_ZN8SPIClass8transferEh>
     fda:	60 e0       	ldi	r22, 0x00	; 0
     fdc:	85 e7       	ldi	r24, 0x75	; 117
     fde:	94 e0       	ldi	r25, 0x04	; 4
     fe0:	c1 d3       	rcall	.+1922   	; 0x1764 <_ZN8SPIClass8transferEh>
     fe2:	f8 01       	movw	r30, r16
     fe4:	90 81       	ld	r25, Z
     fe6:	94 60       	ori	r25, 0x04	; 4
     fe8:	90 83       	st	Z, r25
     fea:	0f 90       	pop	r0
     fec:	0f 90       	pop	r0
     fee:	df 91       	pop	r29
     ff0:	cf 91       	pop	r28
     ff2:	1f 91       	pop	r17
     ff4:	0f 91       	pop	r16
     ff6:	ff 90       	pop	r15
     ff8:	08 95       	ret

00000ffa <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh>:
     ffa:	cf 92       	push	r12
     ffc:	df 92       	push	r13
     ffe:	ef 92       	push	r14
    1000:	ff 92       	push	r15
    1002:	0f 93       	push	r16
    1004:	1f 93       	push	r17
    1006:	cf 93       	push	r28
    1008:	df 93       	push	r29
    100a:	1f 92       	push	r1
    100c:	1f 92       	push	r1
    100e:	cd b7       	in	r28, 0x3d	; 61
    1010:	de b7       	in	r29, 0x3e	; 62
    1012:	16 2f       	mov	r17, r22
    1014:	6a 01       	movw	r12, r20
    1016:	f2 2e       	mov	r15, r18
    1018:	00 e0       	ldi	r16, 0x00	; 0
    101a:	21 e0       	ldi	r18, 0x01	; 1
    101c:	40 e8       	ldi	r20, 0x80	; 128
    101e:	56 e9       	ldi	r21, 0x96	; 150
    1020:	68 e9       	ldi	r22, 0x98	; 152
    1022:	70 e0       	ldi	r23, 0x00	; 0
    1024:	ce 01       	movw	r24, r28
    1026:	01 96       	adiw	r24, 0x01	; 1
    1028:	73 d3       	rcall	.+1766   	; 0x1710 <_ZN11SPISettingsC1Emhh>
    102a:	be 01       	movw	r22, r28
    102c:	6f 5f       	subi	r22, 0xFF	; 255
    102e:	7f 4f       	sbci	r23, 0xFF	; 255
    1030:	85 e7       	ldi	r24, 0x75	; 117
    1032:	94 e0       	ldi	r25, 0x04	; 4
    1034:	91 d3       	rcall	.+1826   	; 0x1758 <_ZN8SPIClass16beginTransactionE11SPISettings>
    1036:	eb e0       	ldi	r30, 0x0B	; 11
    1038:	f1 e0       	ldi	r31, 0x01	; 1
    103a:	80 81       	ld	r24, Z
    103c:	8b 7f       	andi	r24, 0xFB	; 251
    103e:	80 83       	st	Z, r24
    1040:	63 e0       	ldi	r22, 0x03	; 3
    1042:	85 e7       	ldi	r24, 0x75	; 117
    1044:	94 e0       	ldi	r25, 0x04	; 4
    1046:	8e d3       	rcall	.+1820   	; 0x1764 <_ZN8SPIClass8transferEh>
    1048:	61 2f       	mov	r22, r17
    104a:	85 e7       	ldi	r24, 0x75	; 117
    104c:	94 e0       	ldi	r25, 0x04	; 4
    104e:	8a d3       	rcall	.+1812   	; 0x1764 <_ZN8SPIClass8transferEh>
    1050:	ff 20       	and	r15, r15
    1052:	99 f0       	breq	.+38     	; 0x107a <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh+0x80>
    1054:	86 01       	movw	r16, r12
    1056:	fa 94       	dec	r15
    1058:	ef 2c       	mov	r14, r15
    105a:	f1 2c       	mov	r15, r1
    105c:	8f ef       	ldi	r24, 0xFF	; 255
    105e:	e8 1a       	sub	r14, r24
    1060:	f8 0a       	sbc	r15, r24
    1062:	ec 0c       	add	r14, r12
    1064:	fd 1c       	adc	r15, r13
    1066:	60 e0       	ldi	r22, 0x00	; 0
    1068:	85 e7       	ldi	r24, 0x75	; 117
    106a:	94 e0       	ldi	r25, 0x04	; 4
    106c:	7b d3       	rcall	.+1782   	; 0x1764 <_ZN8SPIClass8transferEh>
    106e:	f8 01       	movw	r30, r16
    1070:	81 93       	st	Z+, r24
    1072:	8f 01       	movw	r16, r30
    1074:	ee 15       	cp	r30, r14
    1076:	ff 05       	cpc	r31, r15
    1078:	b1 f7       	brne	.-20     	; 0x1066 <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh+0x6c>
    107a:	eb e0       	ldi	r30, 0x0B	; 11
    107c:	f1 e0       	ldi	r31, 0x01	; 1
    107e:	80 81       	ld	r24, Z
    1080:	84 60       	ori	r24, 0x04	; 4
    1082:	80 83       	st	Z, r24
    1084:	0f 90       	pop	r0
    1086:	0f 90       	pop	r0
    1088:	df 91       	pop	r29
    108a:	cf 91       	pop	r28
    108c:	1f 91       	pop	r17
    108e:	0f 91       	pop	r16
    1090:	ff 90       	pop	r15
    1092:	ef 90       	pop	r14
    1094:	df 90       	pop	r13
    1096:	cf 90       	pop	r12
    1098:	08 95       	ret

0000109a <_ZN7MCP_CAN19mcp2515_setRegisterEhh>:
    109a:	ef 92       	push	r14
    109c:	ff 92       	push	r15
    109e:	0f 93       	push	r16
    10a0:	1f 93       	push	r17
    10a2:	cf 93       	push	r28
    10a4:	df 93       	push	r29
    10a6:	1f 92       	push	r1
    10a8:	1f 92       	push	r1
    10aa:	cd b7       	in	r28, 0x3d	; 61
    10ac:	de b7       	in	r29, 0x3e	; 62
    10ae:	e6 2e       	mov	r14, r22
    10b0:	f4 2e       	mov	r15, r20
    10b2:	00 e0       	ldi	r16, 0x00	; 0
    10b4:	21 e0       	ldi	r18, 0x01	; 1
    10b6:	40 e8       	ldi	r20, 0x80	; 128
    10b8:	56 e9       	ldi	r21, 0x96	; 150
    10ba:	68 e9       	ldi	r22, 0x98	; 152
    10bc:	70 e0       	ldi	r23, 0x00	; 0
    10be:	ce 01       	movw	r24, r28
    10c0:	01 96       	adiw	r24, 0x01	; 1
    10c2:	26 d3       	rcall	.+1612   	; 0x1710 <_ZN11SPISettingsC1Emhh>
    10c4:	be 01       	movw	r22, r28
    10c6:	6f 5f       	subi	r22, 0xFF	; 255
    10c8:	7f 4f       	sbci	r23, 0xFF	; 255
    10ca:	85 e7       	ldi	r24, 0x75	; 117
    10cc:	94 e0       	ldi	r25, 0x04	; 4
    10ce:	44 d3       	rcall	.+1672   	; 0x1758 <_ZN8SPIClass16beginTransactionE11SPISettings>
    10d0:	0b e0       	ldi	r16, 0x0B	; 11
    10d2:	11 e0       	ldi	r17, 0x01	; 1
    10d4:	f8 01       	movw	r30, r16
    10d6:	80 81       	ld	r24, Z
    10d8:	8b 7f       	andi	r24, 0xFB	; 251
    10da:	80 83       	st	Z, r24
    10dc:	62 e0       	ldi	r22, 0x02	; 2
    10de:	85 e7       	ldi	r24, 0x75	; 117
    10e0:	94 e0       	ldi	r25, 0x04	; 4
    10e2:	40 d3       	rcall	.+1664   	; 0x1764 <_ZN8SPIClass8transferEh>
    10e4:	6e 2d       	mov	r22, r14
    10e6:	85 e7       	ldi	r24, 0x75	; 117
    10e8:	94 e0       	ldi	r25, 0x04	; 4
    10ea:	3c d3       	rcall	.+1656   	; 0x1764 <_ZN8SPIClass8transferEh>
    10ec:	6f 2d       	mov	r22, r15
    10ee:	85 e7       	ldi	r24, 0x75	; 117
    10f0:	94 e0       	ldi	r25, 0x04	; 4
    10f2:	38 d3       	rcall	.+1648   	; 0x1764 <_ZN8SPIClass8transferEh>
    10f4:	f8 01       	movw	r30, r16
    10f6:	80 81       	ld	r24, Z
    10f8:	84 60       	ori	r24, 0x04	; 4
    10fa:	80 83       	st	Z, r24
    10fc:	0f 90       	pop	r0
    10fe:	0f 90       	pop	r0
    1100:	df 91       	pop	r29
    1102:	cf 91       	pop	r28
    1104:	1f 91       	pop	r17
    1106:	0f 91       	pop	r16
    1108:	ff 90       	pop	r15
    110a:	ef 90       	pop	r14
    110c:	08 95       	ret

0000110e <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh>:
    110e:	cf 92       	push	r12
    1110:	df 92       	push	r13
    1112:	ef 92       	push	r14
    1114:	ff 92       	push	r15
    1116:	0f 93       	push	r16
    1118:	1f 93       	push	r17
    111a:	cf 93       	push	r28
    111c:	df 93       	push	r29
    111e:	1f 92       	push	r1
    1120:	1f 92       	push	r1
    1122:	cd b7       	in	r28, 0x3d	; 61
    1124:	de b7       	in	r29, 0x3e	; 62
    1126:	16 2f       	mov	r17, r22
    1128:	6a 01       	movw	r12, r20
    112a:	f2 2e       	mov	r15, r18
    112c:	00 e0       	ldi	r16, 0x00	; 0
    112e:	21 e0       	ldi	r18, 0x01	; 1
    1130:	40 e8       	ldi	r20, 0x80	; 128
    1132:	56 e9       	ldi	r21, 0x96	; 150
    1134:	68 e9       	ldi	r22, 0x98	; 152
    1136:	70 e0       	ldi	r23, 0x00	; 0
    1138:	ce 01       	movw	r24, r28
    113a:	01 96       	adiw	r24, 0x01	; 1
    113c:	e9 d2       	rcall	.+1490   	; 0x1710 <_ZN11SPISettingsC1Emhh>
    113e:	be 01       	movw	r22, r28
    1140:	6f 5f       	subi	r22, 0xFF	; 255
    1142:	7f 4f       	sbci	r23, 0xFF	; 255
    1144:	85 e7       	ldi	r24, 0x75	; 117
    1146:	94 e0       	ldi	r25, 0x04	; 4
    1148:	07 d3       	rcall	.+1550   	; 0x1758 <_ZN8SPIClass16beginTransactionE11SPISettings>
    114a:	eb e0       	ldi	r30, 0x0B	; 11
    114c:	f1 e0       	ldi	r31, 0x01	; 1
    114e:	80 81       	ld	r24, Z
    1150:	8b 7f       	andi	r24, 0xFB	; 251
    1152:	80 83       	st	Z, r24
    1154:	62 e0       	ldi	r22, 0x02	; 2
    1156:	85 e7       	ldi	r24, 0x75	; 117
    1158:	94 e0       	ldi	r25, 0x04	; 4
    115a:	04 d3       	rcall	.+1544   	; 0x1764 <_ZN8SPIClass8transferEh>
    115c:	61 2f       	mov	r22, r17
    115e:	85 e7       	ldi	r24, 0x75	; 117
    1160:	94 e0       	ldi	r25, 0x04	; 4
    1162:	00 d3       	rcall	.+1536   	; 0x1764 <_ZN8SPIClass8transferEh>
    1164:	ff 20       	and	r15, r15
    1166:	91 f0       	breq	.+36     	; 0x118c <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh+0x7e>
    1168:	86 01       	movw	r16, r12
    116a:	fa 94       	dec	r15
    116c:	ef 2c       	mov	r14, r15
    116e:	f1 2c       	mov	r15, r1
    1170:	8f ef       	ldi	r24, 0xFF	; 255
    1172:	e8 1a       	sub	r14, r24
    1174:	f8 0a       	sbc	r15, r24
    1176:	ec 0c       	add	r14, r12
    1178:	fd 1c       	adc	r15, r13
    117a:	f8 01       	movw	r30, r16
    117c:	61 91       	ld	r22, Z+
    117e:	8f 01       	movw	r16, r30
    1180:	85 e7       	ldi	r24, 0x75	; 117
    1182:	94 e0       	ldi	r25, 0x04	; 4
    1184:	ef d2       	rcall	.+1502   	; 0x1764 <_ZN8SPIClass8transferEh>
    1186:	0e 15       	cp	r16, r14
    1188:	1f 05       	cpc	r17, r15
    118a:	b9 f7       	brne	.-18     	; 0x117a <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh+0x6c>
    118c:	eb e0       	ldi	r30, 0x0B	; 11
    118e:	f1 e0       	ldi	r31, 0x01	; 1
    1190:	80 81       	ld	r24, Z
    1192:	84 60       	ori	r24, 0x04	; 4
    1194:	80 83       	st	Z, r24
    1196:	0f 90       	pop	r0
    1198:	0f 90       	pop	r0
    119a:	df 91       	pop	r29
    119c:	cf 91       	pop	r28
    119e:	1f 91       	pop	r17
    11a0:	0f 91       	pop	r16
    11a2:	ff 90       	pop	r15
    11a4:	ef 90       	pop	r14
    11a6:	df 90       	pop	r13
    11a8:	cf 90       	pop	r12
    11aa:	08 95       	ret

000011ac <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>:
    11ac:	df 92       	push	r13
    11ae:	ef 92       	push	r14
    11b0:	ff 92       	push	r15
    11b2:	0f 93       	push	r16
    11b4:	1f 93       	push	r17
    11b6:	cf 93       	push	r28
    11b8:	df 93       	push	r29
    11ba:	1f 92       	push	r1
    11bc:	1f 92       	push	r1
    11be:	cd b7       	in	r28, 0x3d	; 61
    11c0:	de b7       	in	r29, 0x3e	; 62
    11c2:	d6 2e       	mov	r13, r22
    11c4:	e4 2e       	mov	r14, r20
    11c6:	f2 2e       	mov	r15, r18
    11c8:	00 e0       	ldi	r16, 0x00	; 0
    11ca:	21 e0       	ldi	r18, 0x01	; 1
    11cc:	40 e8       	ldi	r20, 0x80	; 128
    11ce:	56 e9       	ldi	r21, 0x96	; 150
    11d0:	68 e9       	ldi	r22, 0x98	; 152
    11d2:	70 e0       	ldi	r23, 0x00	; 0
    11d4:	ce 01       	movw	r24, r28
    11d6:	01 96       	adiw	r24, 0x01	; 1
    11d8:	9b d2       	rcall	.+1334   	; 0x1710 <_ZN11SPISettingsC1Emhh>
    11da:	be 01       	movw	r22, r28
    11dc:	6f 5f       	subi	r22, 0xFF	; 255
    11de:	7f 4f       	sbci	r23, 0xFF	; 255
    11e0:	85 e7       	ldi	r24, 0x75	; 117
    11e2:	94 e0       	ldi	r25, 0x04	; 4
    11e4:	b9 d2       	rcall	.+1394   	; 0x1758 <_ZN8SPIClass16beginTransactionE11SPISettings>
    11e6:	0b e0       	ldi	r16, 0x0B	; 11
    11e8:	11 e0       	ldi	r17, 0x01	; 1
    11ea:	f8 01       	movw	r30, r16
    11ec:	80 81       	ld	r24, Z
    11ee:	8b 7f       	andi	r24, 0xFB	; 251
    11f0:	80 83       	st	Z, r24
    11f2:	65 e0       	ldi	r22, 0x05	; 5
    11f4:	85 e7       	ldi	r24, 0x75	; 117
    11f6:	94 e0       	ldi	r25, 0x04	; 4
    11f8:	b5 d2       	rcall	.+1386   	; 0x1764 <_ZN8SPIClass8transferEh>
    11fa:	6d 2d       	mov	r22, r13
    11fc:	85 e7       	ldi	r24, 0x75	; 117
    11fe:	94 e0       	ldi	r25, 0x04	; 4
    1200:	b1 d2       	rcall	.+1378   	; 0x1764 <_ZN8SPIClass8transferEh>
    1202:	6e 2d       	mov	r22, r14
    1204:	85 e7       	ldi	r24, 0x75	; 117
    1206:	94 e0       	ldi	r25, 0x04	; 4
    1208:	ad d2       	rcall	.+1370   	; 0x1764 <_ZN8SPIClass8transferEh>
    120a:	6f 2d       	mov	r22, r15
    120c:	85 e7       	ldi	r24, 0x75	; 117
    120e:	94 e0       	ldi	r25, 0x04	; 4
    1210:	a9 d2       	rcall	.+1362   	; 0x1764 <_ZN8SPIClass8transferEh>
    1212:	f8 01       	movw	r30, r16
    1214:	80 81       	ld	r24, Z
    1216:	84 60       	ori	r24, 0x04	; 4
    1218:	80 83       	st	Z, r24
    121a:	0f 90       	pop	r0
    121c:	0f 90       	pop	r0
    121e:	df 91       	pop	r29
    1220:	cf 91       	pop	r28
    1222:	1f 91       	pop	r17
    1224:	0f 91       	pop	r16
    1226:	ff 90       	pop	r15
    1228:	ef 90       	pop	r14
    122a:	df 90       	pop	r13
    122c:	08 95       	ret

0000122e <_ZN7MCP_CAN18mcp2515_readStatusEv>:
    122e:	0f 93       	push	r16
    1230:	1f 93       	push	r17
    1232:	cf 93       	push	r28
    1234:	df 93       	push	r29
    1236:	1f 92       	push	r1
    1238:	1f 92       	push	r1
    123a:	cd b7       	in	r28, 0x3d	; 61
    123c:	de b7       	in	r29, 0x3e	; 62
    123e:	00 e0       	ldi	r16, 0x00	; 0
    1240:	21 e0       	ldi	r18, 0x01	; 1
    1242:	40 e8       	ldi	r20, 0x80	; 128
    1244:	56 e9       	ldi	r21, 0x96	; 150
    1246:	68 e9       	ldi	r22, 0x98	; 152
    1248:	70 e0       	ldi	r23, 0x00	; 0
    124a:	ce 01       	movw	r24, r28
    124c:	01 96       	adiw	r24, 0x01	; 1
    124e:	60 d2       	rcall	.+1216   	; 0x1710 <_ZN11SPISettingsC1Emhh>
    1250:	be 01       	movw	r22, r28
    1252:	6f 5f       	subi	r22, 0xFF	; 255
    1254:	7f 4f       	sbci	r23, 0xFF	; 255
    1256:	85 e7       	ldi	r24, 0x75	; 117
    1258:	94 e0       	ldi	r25, 0x04	; 4
    125a:	7e d2       	rcall	.+1276   	; 0x1758 <_ZN8SPIClass16beginTransactionE11SPISettings>
    125c:	0b e0       	ldi	r16, 0x0B	; 11
    125e:	11 e0       	ldi	r17, 0x01	; 1
    1260:	f8 01       	movw	r30, r16
    1262:	80 81       	ld	r24, Z
    1264:	8b 7f       	andi	r24, 0xFB	; 251
    1266:	80 83       	st	Z, r24
    1268:	60 ea       	ldi	r22, 0xA0	; 160
    126a:	85 e7       	ldi	r24, 0x75	; 117
    126c:	94 e0       	ldi	r25, 0x04	; 4
    126e:	7a d2       	rcall	.+1268   	; 0x1764 <_ZN8SPIClass8transferEh>
    1270:	60 e0       	ldi	r22, 0x00	; 0
    1272:	85 e7       	ldi	r24, 0x75	; 117
    1274:	94 e0       	ldi	r25, 0x04	; 4
    1276:	76 d2       	rcall	.+1260   	; 0x1764 <_ZN8SPIClass8transferEh>
    1278:	f8 01       	movw	r30, r16
    127a:	90 81       	ld	r25, Z
    127c:	94 60       	ori	r25, 0x04	; 4
    127e:	90 83       	st	Z, r25
    1280:	0f 90       	pop	r0
    1282:	0f 90       	pop	r0
    1284:	df 91       	pop	r29
    1286:	cf 91       	pop	r28
    1288:	1f 91       	pop	r17
    128a:	0f 91       	pop	r16
    128c:	08 95       	ret

0000128e <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>:
    128e:	0f 93       	push	r16
    1290:	1f 93       	push	r17
    1292:	cf 93       	push	r28
    1294:	8c 01       	movw	r16, r24
    1296:	c6 2f       	mov	r28, r22
    1298:	26 2f       	mov	r18, r22
    129a:	40 ee       	ldi	r20, 0xE0	; 224
    129c:	6f e0       	ldi	r22, 0x0F	; 15
    129e:	86 df       	rcall	.-244    	; 0x11ac <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    12a0:	6f e0       	ldi	r22, 0x0F	; 15
    12a2:	c8 01       	movw	r24, r16
    12a4:	73 de       	rcall	.-794    	; 0xf8c <_ZN7MCP_CAN20mcp2515_readRegisterEh>
    12a6:	98 2f       	mov	r25, r24
    12a8:	90 7e       	andi	r25, 0xE0	; 224
    12aa:	81 e0       	ldi	r24, 0x01	; 1
    12ac:	9c 13       	cpse	r25, r28
    12ae:	01 c0       	rjmp	.+2      	; 0x12b2 <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh+0x24>
    12b0:	80 e0       	ldi	r24, 0x00	; 0
    12b2:	cf 91       	pop	r28
    12b4:	1f 91       	pop	r17
    12b6:	0f 91       	pop	r16
    12b8:	08 95       	ret

000012ba <_ZN7MCP_CAN7setModeEh>:
    12ba:	fc 01       	movw	r30, r24
    12bc:	61 8b       	std	Z+17, r22	; 0x11
    12be:	e7 cf       	rjmp	.-50     	; 0x128e <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>
    12c0:	08 95       	ret

000012c2 <_ZN7MCP_CAN18mcp2515_configRateEhh>:
    12c2:	cf 93       	push	r28
    12c4:	df 93       	push	r29
    12c6:	ec 01       	movw	r28, r24
    12c8:	40 e4       	ldi	r20, 0x40	; 64
    12ca:	6a e2       	ldi	r22, 0x2A	; 42
    12cc:	e6 de       	rcall	.-564    	; 0x109a <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    12ce:	45 ee       	ldi	r20, 0xE5	; 229
    12d0:	69 e2       	ldi	r22, 0x29	; 41
    12d2:	ce 01       	movw	r24, r28
    12d4:	e2 de       	rcall	.-572    	; 0x109a <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    12d6:	43 e8       	ldi	r20, 0x83	; 131
    12d8:	68 e2       	ldi	r22, 0x28	; 40
    12da:	ce 01       	movw	r24, r28
    12dc:	de de       	rcall	.-580    	; 0x109a <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    12de:	80 e0       	ldi	r24, 0x00	; 0
    12e0:	df 91       	pop	r29
    12e2:	cf 91       	pop	r28
    12e4:	08 95       	ret

000012e6 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>:

/*********************************************************************************************************
** Function name:           mcp2515_write_mf
** Descriptions:            Write Masks and Filters
*********************************************************************************************************/
void MCP_CAN::mcp2515_write_mf( const uint8_t mcp_addr, const uint8_t ext, const uint32_t id ){
    12e6:	0f 93       	push	r16
    12e8:	1f 93       	push	r17
    12ea:	cf 93       	push	r28
    12ec:	df 93       	push	r29
    12ee:	00 d0       	rcall	.+0      	; 0x12f0 <_ZN7MCP_CAN16mcp2515_write_mfEhhm+0xa>
    12f0:	1f 92       	push	r1
    12f2:	cd b7       	in	r28, 0x3d	; 61
    12f4:	de b7       	in	r29, 0x3e	; 62
	uint16_t canid;
	uint8_t tbufdata[4];
	canid = (uint16_t)(id & 0x0FFFF);
	if ( ext == 1){
    12f6:	41 30       	cpi	r20, 0x01	; 1
    12f8:	c9 f4       	brne	.+50     	; 0x132c <_ZN7MCP_CAN16mcp2515_write_mfEhhm+0x46>
		tbufdata[MCP_EID0] = (uint8_t) (canid & 0xFF);
    12fa:	0c 83       	std	Y+4, r16	; 0x04
		tbufdata[MCP_EID8] = (uint8_t) (canid >> 8);
    12fc:	1b 83       	std	Y+3, r17	; 0x03
		canid = (uint16_t)(id >> 16);
    12fe:	89 01       	movw	r16, r18
    1300:	22 27       	eor	r18, r18
    1302:	33 27       	eor	r19, r19
		tbufdata[MCP_SIDL] = (uint8_t) (canid & 0x03);
		tbufdata[MCP_SIDL] += (uint8_t) ((canid & 0x1C) << 3);
		tbufdata[MCP_SIDL] |= MCP_TXB_EXIDE_M;
    1304:	40 2f       	mov	r20, r16
    1306:	4c 71       	andi	r20, 0x1C	; 28
    1308:	44 0f       	add	r20, r20
    130a:	44 0f       	add	r20, r20
    130c:	44 0f       	add	r20, r20
    130e:	50 2f       	mov	r21, r16
    1310:	53 70       	andi	r21, 0x03	; 3
    1312:	45 0f       	add	r20, r21
    1314:	48 60       	ori	r20, 0x08	; 8
    1316:	4a 83       	std	Y+2, r20	; 0x02
		tbufdata[MCP_SIDH] = (uint8_t) (canid >> 5 );
    1318:	16 95       	lsr	r17
    131a:	07 95       	ror	r16
    131c:	12 95       	swap	r17
    131e:	02 95       	swap	r16
    1320:	0f 70       	andi	r16, 0x0F	; 15
    1322:	01 27       	eor	r16, r17
    1324:	1f 70       	andi	r17, 0x0F	; 15
    1326:	01 27       	eor	r16, r17
    1328:	09 83       	std	Y+1, r16	; 0x01
    132a:	11 c0       	rjmp	.+34     	; 0x134e <_ZN7MCP_CAN16mcp2515_write_mfEhhm+0x68>
	} else {
		tbufdata[MCP_EID0] = (uint8_t) (canid & 0xFF);
    132c:	0c 83       	std	Y+4, r16	; 0x04
		tbufdata[MCP_EID8] = (uint8_t) (canid >> 8);
    132e:	1b 83       	std	Y+3, r17	; 0x03
		canid = (uint16_t)(id >> 16);
    1330:	89 01       	movw	r16, r18
    1332:	22 27       	eor	r18, r18
    1334:	33 27       	eor	r19, r19
		tbufdata[MCP_SIDL] = (uint8_t) ((canid & 0x07) << 5);
    1336:	40 2f       	mov	r20, r16
    1338:	42 95       	swap	r20
    133a:	44 0f       	add	r20, r20
    133c:	40 7e       	andi	r20, 0xE0	; 224
    133e:	4a 83       	std	Y+2, r20	; 0x02
		tbufdata[MCP_SIDH] = (uint8_t) (canid >> 3 );
    1340:	16 95       	lsr	r17
    1342:	07 95       	ror	r16
    1344:	16 95       	lsr	r17
    1346:	07 95       	ror	r16
    1348:	16 95       	lsr	r17
    134a:	07 95       	ror	r16
    134c:	09 83       	std	Y+1, r16	; 0x01
	}
	mcp2515_setRegisterS( mcp_addr, tbufdata, 4 );
    134e:	24 e0       	ldi	r18, 0x04	; 4
    1350:	ae 01       	movw	r20, r28
    1352:	4f 5f       	subi	r20, 0xFF	; 255
    1354:	5f 4f       	sbci	r21, 0xFF	; 255
    1356:	db de       	rcall	.-586    	; 0x110e <_ZN7MCP_CAN20mcp2515_setRegisterSEhPKhh>
}
    1358:	0f 90       	pop	r0
    135a:	0f 90       	pop	r0
    135c:	0f 90       	pop	r0
    135e:	0f 90       	pop	r0
    1360:	df 91       	pop	r29
    1362:	cf 91       	pop	r28
    1364:	1f 91       	pop	r17
    1366:	0f 91       	pop	r16
    1368:	08 95       	ret

0000136a <_ZN7MCP_CAN22mcp2515_initCANBuffersEv>:

/*********************************************************************************************************
** Function name:           mcp2515_initCANBuffers
** Descriptions:            Initialize Buffers, Masks, and Filters
*********************************************************************************************************/
void MCP_CAN::mcp2515_initCANBuffers(void){
    136a:	ef 92       	push	r14
    136c:	ff 92       	push	r15
    136e:	0f 93       	push	r16
    1370:	1f 93       	push	r17
    1372:	cf 93       	push	r28
    1374:	7c 01       	movw	r14, r24
	uint8_t std = 0;
	uint8_t ext = 1;
	uint32_t ulMask = 0x00, ulFilt = 0x00;


	mcp2515_write_mf(MCP_RXM0SIDH, ext, ulMask);			/*Set both masks to 0           */
    1376:	00 e0       	ldi	r16, 0x00	; 0
    1378:	10 e0       	ldi	r17, 0x00	; 0
    137a:	98 01       	movw	r18, r16
    137c:	41 e0       	ldi	r20, 0x01	; 1
    137e:	60 e2       	ldi	r22, 0x20	; 32
    1380:	b2 df       	rcall	.-156    	; 0x12e6 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXM1SIDH, ext, ulMask);			/*Mask register ignores ext bit */
    1382:	00 e0       	ldi	r16, 0x00	; 0
    1384:	10 e0       	ldi	r17, 0x00	; 0
    1386:	98 01       	movw	r18, r16
    1388:	41 e0       	ldi	r20, 0x01	; 1
    138a:	64 e2       	ldi	r22, 0x24	; 36
    138c:	c7 01       	movw	r24, r14
    138e:	ab df       	rcall	.-170    	; 0x12e6 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	
	/* Set all filters to 0         */
	mcp2515_write_mf(MCP_RXF0SIDH, ext, ulFilt);			/* RXB0: extended               */
    1390:	00 e0       	ldi	r16, 0x00	; 0
    1392:	10 e0       	ldi	r17, 0x00	; 0
    1394:	98 01       	movw	r18, r16
    1396:	41 e0       	ldi	r20, 0x01	; 1
    1398:	60 e0       	ldi	r22, 0x00	; 0
    139a:	c7 01       	movw	r24, r14
    139c:	a4 df       	rcall	.-184    	; 0x12e6 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF1SIDH, std, ulFilt);			/* RXB1: standard               */
    139e:	00 e0       	ldi	r16, 0x00	; 0
    13a0:	10 e0       	ldi	r17, 0x00	; 0
    13a2:	98 01       	movw	r18, r16
    13a4:	40 e0       	ldi	r20, 0x00	; 0
    13a6:	64 e0       	ldi	r22, 0x04	; 4
    13a8:	c7 01       	movw	r24, r14
    13aa:	9d df       	rcall	.-198    	; 0x12e6 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF2SIDH, ext, ulFilt);			/* RXB2: extended               */
    13ac:	00 e0       	ldi	r16, 0x00	; 0
    13ae:	10 e0       	ldi	r17, 0x00	; 0
    13b0:	98 01       	movw	r18, r16
    13b2:	41 e0       	ldi	r20, 0x01	; 1
    13b4:	68 e0       	ldi	r22, 0x08	; 8
    13b6:	c7 01       	movw	r24, r14
    13b8:	96 df       	rcall	.-212    	; 0x12e6 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF3SIDH, std, ulFilt);			/* RXB3: standard               */
    13ba:	00 e0       	ldi	r16, 0x00	; 0
    13bc:	10 e0       	ldi	r17, 0x00	; 0
    13be:	98 01       	movw	r18, r16
    13c0:	40 e0       	ldi	r20, 0x00	; 0
    13c2:	60 e1       	ldi	r22, 0x10	; 16
    13c4:	c7 01       	movw	r24, r14
    13c6:	8f df       	rcall	.-226    	; 0x12e6 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF4SIDH, ext, ulFilt);
    13c8:	00 e0       	ldi	r16, 0x00	; 0
    13ca:	10 e0       	ldi	r17, 0x00	; 0
    13cc:	98 01       	movw	r18, r16
    13ce:	41 e0       	ldi	r20, 0x01	; 1
    13d0:	64 e1       	ldi	r22, 0x14	; 20
    13d2:	c7 01       	movw	r24, r14
    13d4:	88 df       	rcall	.-240    	; 0x12e6 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>
	mcp2515_write_mf(MCP_RXF5SIDH, std, ulFilt);
    13d6:	00 e0       	ldi	r16, 0x00	; 0
    13d8:	10 e0       	ldi	r17, 0x00	; 0
    13da:	98 01       	movw	r18, r16
    13dc:	40 e0       	ldi	r20, 0x00	; 0
    13de:	68 e1       	ldi	r22, 0x18	; 24
    13e0:	c7 01       	movw	r24, r14
    13e2:	81 df       	rcall	.-254    	; 0x12e6 <_ZN7MCP_CAN16mcp2515_write_mfEhhm>

	/* Clear, deactivate the three  */
	/* transmit buffers             */
	/* TXBnCTRL -> TXBnD7           */
	a1 = MCP_TXB0CTRL;
    13e4:	c0 e3       	ldi	r28, 0x30	; 48
	a2 = MCP_TXB1CTRL;
	a3 = MCP_TXB2CTRL;
	for (i = 0; i < 14; i++) {                                          /* in-buffer loop               */
		mcp2515_setRegister(a1, 0);
    13e6:	40 e0       	ldi	r20, 0x00	; 0
    13e8:	6c 2f       	mov	r22, r28
    13ea:	c7 01       	movw	r24, r14
    13ec:	56 de       	rcall	.-852    	; 0x109a <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		mcp2515_setRegister(a2, 0);
    13ee:	60 e1       	ldi	r22, 0x10	; 16
    13f0:	6c 0f       	add	r22, r28
    13f2:	40 e0       	ldi	r20, 0x00	; 0
    13f4:	c7 01       	movw	r24, r14
    13f6:	51 de       	rcall	.-862    	; 0x109a <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		mcp2515_setRegister(a3, 0);
    13f8:	60 e2       	ldi	r22, 0x20	; 32
    13fa:	6c 0f       	add	r22, r28
    13fc:	40 e0       	ldi	r20, 0x00	; 0
    13fe:	c7 01       	movw	r24, r14
    1400:	4c de       	rcall	.-872    	; 0x109a <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		a1++;
    1402:	cf 5f       	subi	r28, 0xFF	; 255
	/* transmit buffers             */
	/* TXBnCTRL -> TXBnD7           */
	a1 = MCP_TXB0CTRL;
	a2 = MCP_TXB1CTRL;
	a3 = MCP_TXB2CTRL;
	for (i = 0; i < 14; i++) {                                          /* in-buffer loop               */
    1404:	ce 33       	cpi	r28, 0x3E	; 62
    1406:	79 f7       	brne	.-34     	; 0x13e6 <_ZN7MCP_CAN22mcp2515_initCANBuffersEv+0x7c>
		mcp2515_setRegister(a3, 0);
		a1++;
		a2++;
		a3++;
	}
	mcp2515_setRegister(MCP_RXB0CTRL, 0);
    1408:	40 e0       	ldi	r20, 0x00	; 0
    140a:	60 e6       	ldi	r22, 0x60	; 96
    140c:	c7 01       	movw	r24, r14
    140e:	45 de       	rcall	.-886    	; 0x109a <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1410:	40 e0       	ldi	r20, 0x00	; 0
	mcp2515_setRegister(MCP_RXB1CTRL, 0);
    1412:	60 e7       	ldi	r22, 0x70	; 112
    1414:	c7 01       	movw	r24, r14
    1416:	41 de       	rcall	.-894    	; 0x109a <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1418:	cf 91       	pop	r28
    141a:	1f 91       	pop	r17
}
    141c:	0f 91       	pop	r16
    141e:	ff 90       	pop	r15
    1420:	ef 90       	pop	r14
    1422:	08 95       	ret

00001424 <_ZN7MCP_CAN12mcp2515_initEhhh>:
    1424:	ff 92       	push	r15
    1426:	0f 93       	push	r16

/*********************************************************************************************************
** Function name:           mcp2515_init
** Descriptions:            Initialize the controller
*********************************************************************************************************/
uint8_t MCP_CAN::mcp2515_init(const uint8_t canIDMode, const uint8_t canSpeed, const uint8_t canClock){
    1428:	1f 93       	push	r17
    142a:	cf 93       	push	r28
    142c:	df 93       	push	r29
    142e:	ec 01       	movw	r28, r24
    1430:	f6 2e       	mov	r15, r22
    1432:	14 2f       	mov	r17, r20
    1434:	02 2f       	mov	r16, r18
	uint8_t res;
	mcp2515_reset();
    1436:	78 dd       	rcall	.-1296   	; 0xf28 <_ZN7MCP_CAN13mcp2515_resetEv>
	mcpMode = MCP_LOOPBACK;
    1438:	80 e4       	ldi	r24, 0x40	; 64
    143a:	89 8b       	std	Y+17, r24	; 0x11
	res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
    143c:	60 e8       	ldi	r22, 0x80	; 128
    143e:	ce 01       	movw	r24, r28
    1440:	26 df       	rcall	.-436    	; 0x128e <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>
	if(res > 0)
    1442:	81 11       	cpse	r24, r1
    1444:	35 c0       	rjmp	.+106    	; 0x14b0 <_ZN7MCP_CAN12mcp2515_initEhhh+0x8c>
	return res;
	// Set Baudrate
	if(mcp2515_configRate(canSpeed, canClock))
    1446:	40 2f       	mov	r20, r16
    1448:	61 2f       	mov	r22, r17
    144a:	ce 01       	movw	r24, r28
    144c:	3a df       	rcall	.-396    	; 0x12c2 <_ZN7MCP_CAN18mcp2515_configRateEhh>
    144e:	81 11       	cpse	r24, r1
	return res;
	if ( res == MCP2515_OK ) {
		mcp2515_initCANBuffers();											//init canbuffers
    1450:	2c c0       	rjmp	.+88     	; 0x14aa <_ZN7MCP_CAN12mcp2515_initEhhh+0x86>
    1452:	ce 01       	movw	r24, r28
		mcp2515_setRegister(MCP_CANINTE, MCP_RX0IF | MCP_RX1IF);			//interrupt mode
    1454:	8a df       	rcall	.-236    	; 0x136a <_ZN7MCP_CAN22mcp2515_initCANBuffersEv>
    1456:	43 e0       	ldi	r20, 0x03	; 3
    1458:	6b e2       	ldi	r22, 0x2B	; 43
    145a:	ce 01       	movw	r24, r28
		mcp2515_setRegister(MCP_BFPCTRL,MCP_BxBFS_MASK | MCP_BxBFE_MASK);	//Sets BF pins as GPO
    145c:	1e de       	rcall	.-964    	; 0x109a <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    145e:	4c e3       	ldi	r20, 0x3C	; 60
    1460:	6c e0       	ldi	r22, 0x0C	; 12
    1462:	ce 01       	movw	r24, r28
		mcp2515_setRegister(MCP_TXRTSCTRL,0x00);							//Sets RTS pins as GPI
    1464:	1a de       	rcall	.-972    	; 0x109a <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
    1466:	40 e0       	ldi	r20, 0x00	; 0
    1468:	6d e0       	ldi	r22, 0x0D	; 13
    146a:	ce 01       	movw	r24, r28
    146c:	16 de       	rcall	.-980    	; 0x109a <_ZN7MCP_CAN19mcp2515_setRegisterEhh>
		switch(canIDMode){
    146e:	ff 20       	and	r15, r15
    1470:	71 f0       	breq	.+28     	; 0x148e <_ZN7MCP_CAN12mcp2515_initEhhh+0x6a>
    1472:	83 e0       	ldi	r24, 0x03	; 3
    1474:	f8 12       	cpse	r15, r24
			case (MCP_ANY):
			mcp2515_modifyRegister(MCP_RXB0CTRL,
			MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
			MCP_RXB_RX_ANY | MCP_RXB_BUKT_MASK);
    1476:	1b c0       	rjmp	.+54     	; 0x14ae <_ZN7MCP_CAN12mcp2515_initEhhh+0x8a>
    1478:	24 e6       	ldi	r18, 0x64	; 100
    147a:	44 e6       	ldi	r20, 0x64	; 100
    147c:	60 e6       	ldi	r22, 0x60	; 96
    147e:	ce 01       	movw	r24, r28
			mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
			MCP_RXB_RX_ANY);
    1480:	95 de       	rcall	.-726    	; 0x11ac <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    1482:	20 e6       	ldi	r18, 0x60	; 96
    1484:	40 e6       	ldi	r20, 0x60	; 96
    1486:	60 e7       	ldi	r22, 0x70	; 112
    1488:	ce 01       	movw	r24, r28
			break;
    148a:	90 de       	rcall	.-736    	; 0x11ac <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
			case (MCP_STDEXT):
			mcp2515_modifyRegister(MCP_RXB0CTRL,
			MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK,
			MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK );
    148c:	0a c0       	rjmp	.+20     	; 0x14a2 <_ZN7MCP_CAN12mcp2515_initEhhh+0x7e>
    148e:	24 e0       	ldi	r18, 0x04	; 4
    1490:	44 e6       	ldi	r20, 0x64	; 100
    1492:	60 e6       	ldi	r22, 0x60	; 96
			mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
			MCP_RXB_RX_STDEXT);
    1494:	ce 01       	movw	r24, r28
    1496:	8a de       	rcall	.-748    	; 0x11ac <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    1498:	20 e0       	ldi	r18, 0x00	; 0
    149a:	40 e6       	ldi	r20, 0x60	; 96
    149c:	60 e7       	ldi	r22, 0x70	; 112
    149e:	ce 01       	movw	r24, r28
			break;
			default:
			return MCP2515_FAIL;
			break;
		}
		res = mcp2515_setCANCTRL_Mode(mcpMode);
    14a0:	85 de       	rcall	.-758    	; 0x11ac <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
    14a2:	69 89       	ldd	r22, Y+17	; 0x11
    14a4:	ce 01       	movw	r24, r28
    14a6:	f3 de       	rcall	.-538    	; 0x128e <_ZN7MCP_CAN23mcp2515_setCANCTRL_ModeEh>
    14a8:	03 c0       	rjmp	.+6      	; 0x14b0 <_ZN7MCP_CAN12mcp2515_initEhhh+0x8c>
	res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
	if(res > 0)
	return res;
	// Set Baudrate
	if(mcp2515_configRate(canSpeed, canClock))
	return res;
    14aa:	80 e0       	ldi	r24, 0x00	; 0
    14ac:	01 c0       	rjmp	.+2      	; 0x14b0 <_ZN7MCP_CAN12mcp2515_initEhhh+0x8c>
			MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK );
			mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK,
			MCP_RXB_RX_STDEXT);
			break;
			default:
			return MCP2515_FAIL;
    14ae:	81 e0       	ldi	r24, 0x01	; 1
		res = mcp2515_setCANCTRL_Mode(mcpMode);
		if(res)
		return res;
	}
	return res;
}
    14b0:	df 91       	pop	r29
    14b2:	cf 91       	pop	r28
    14b4:	1f 91       	pop	r17
    14b6:	0f 91       	pop	r16
    14b8:	ff 90       	pop	r15
    14ba:	08 95       	ret

000014bc <_ZN7MCP_CAN15mcp2515_read_idEhPhPm>:

/*********************************************************************************************************
** Function name:           mcp2515_read_id
** Descriptions:            Read CAN ID
*********************************************************************************************************/
void MCP_CAN::mcp2515_read_id( const uint8_t mcp_addr, uint8_t* ext, uint32_t* id ){
    14bc:	ef 92       	push	r14
    14be:	ff 92       	push	r15
    14c0:	0f 93       	push	r16
    14c2:	1f 93       	push	r17
    14c4:	cf 93       	push	r28
    14c6:	df 93       	push	r29
    14c8:	00 d0       	rcall	.+0      	; 0x14ca <_ZN7MCP_CAN15mcp2515_read_idEhPhPm+0xe>
    14ca:	1f 92       	push	r1
    14cc:	cd b7       	in	r28, 0x3d	; 61
    14ce:	de b7       	in	r29, 0x3e	; 62
    14d0:	7a 01       	movw	r14, r20
    14d2:	89 01       	movw	r16, r18
	uint8_t tbufdata[4];
	*ext = 0;
    14d4:	fa 01       	movw	r30, r20
    14d6:	10 82       	st	Z, r1
	*id = 0;
    14d8:	f9 01       	movw	r30, r18
    14da:	10 82       	st	Z, r1
    14dc:	11 82       	std	Z+1, r1	; 0x01
    14de:	12 82       	std	Z+2, r1	; 0x02
    14e0:	13 82       	std	Z+3, r1	; 0x03
	mcp2515_readRegisterS( mcp_addr, tbufdata, 4 );
    14e2:	24 e0       	ldi	r18, 0x04	; 4
    14e4:	ae 01       	movw	r20, r28
    14e6:	4f 5f       	subi	r20, 0xFF	; 255
    14e8:	5f 4f       	sbci	r21, 0xFF	; 255
    14ea:	87 dd       	rcall	.-1266   	; 0xffa <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh>
	*id = (tbufdata[MCP_SIDH]<<3) + (tbufdata[MCP_SIDL]>>5);
    14ec:	2a 81       	ldd	r18, Y+2	; 0x02
    14ee:	39 81       	ldd	r19, Y+1	; 0x01
    14f0:	82 2f       	mov	r24, r18
    14f2:	90 e0       	ldi	r25, 0x00	; 0
    14f4:	95 95       	asr	r25
    14f6:	87 95       	ror	r24
    14f8:	95 95       	asr	r25
    14fa:	87 95       	ror	r24
    14fc:	95 95       	asr	r25
    14fe:	87 95       	ror	r24
    1500:	95 95       	asr	r25
    1502:	87 95       	ror	r24
    1504:	95 95       	asr	r25
    1506:	87 95       	ror	r24
    1508:	f8 e0       	ldi	r31, 0x08	; 8
    150a:	3f 9f       	mul	r19, r31
    150c:	80 0d       	add	r24, r0
    150e:	91 1d       	adc	r25, r1
    1510:	11 24       	eor	r1, r1
    1512:	09 2e       	mov	r0, r25
    1514:	00 0c       	add	r0, r0
    1516:	aa 0b       	sbc	r26, r26
    1518:	bb 0b       	sbc	r27, r27
    151a:	f8 01       	movw	r30, r16
    151c:	80 83       	st	Z, r24
    151e:	91 83       	std	Z+1, r25	; 0x01
    1520:	a2 83       	std	Z+2, r26	; 0x02
    1522:	b3 83       	std	Z+3, r27	; 0x03
	if ( (tbufdata[MCP_SIDL] & MCP_TXB_EXIDE_M) ==  MCP_TXB_EXIDE_M ){
    1524:	23 ff       	sbrs	r18, 3
    1526:	26 c0       	rjmp	.+76     	; 0x1574 <_ZN7MCP_CAN15mcp2515_read_idEhPhPm+0xb8>
		/* extended id                  */
		*id = (*id<<2) + (tbufdata[MCP_SIDL] & 0x03);
		*id = (*id<<8) + tbufdata[MCP_EID8];
		*id = (*id<<8) + tbufdata[MCP_EID0];
    1528:	88 0f       	add	r24, r24
    152a:	99 1f       	adc	r25, r25
    152c:	aa 1f       	adc	r26, r26
    152e:	bb 1f       	adc	r27, r27
    1530:	88 0f       	add	r24, r24
    1532:	99 1f       	adc	r25, r25
    1534:	aa 1f       	adc	r26, r26
    1536:	bb 1f       	adc	r27, r27
    1538:	23 70       	andi	r18, 0x03	; 3
    153a:	82 0f       	add	r24, r18
    153c:	91 1d       	adc	r25, r1
    153e:	a1 1d       	adc	r26, r1
    1540:	b1 1d       	adc	r27, r1
    1542:	ba 2f       	mov	r27, r26
    1544:	a9 2f       	mov	r26, r25
    1546:	98 2f       	mov	r25, r24
    1548:	88 27       	eor	r24, r24
    154a:	2b 81       	ldd	r18, Y+3	; 0x03
    154c:	82 0f       	add	r24, r18
    154e:	91 1d       	adc	r25, r1
    1550:	a1 1d       	adc	r26, r1
    1552:	b1 1d       	adc	r27, r1
    1554:	ba 2f       	mov	r27, r26
    1556:	a9 2f       	mov	r26, r25
    1558:	98 2f       	mov	r25, r24
    155a:	88 27       	eor	r24, r24
    155c:	2c 81       	ldd	r18, Y+4	; 0x04
    155e:	82 0f       	add	r24, r18
    1560:	91 1d       	adc	r25, r1
    1562:	a1 1d       	adc	r26, r1
    1564:	b1 1d       	adc	r27, r1
    1566:	80 83       	st	Z, r24
    1568:	91 83       	std	Z+1, r25	; 0x01
    156a:	a2 83       	std	Z+2, r26	; 0x02
    156c:	b3 83       	std	Z+3, r27	; 0x03
		*ext = 1;
    156e:	81 e0       	ldi	r24, 0x01	; 1
    1570:	f7 01       	movw	r30, r14
    1572:	80 83       	st	Z, r24
	}
}
    1574:	0f 90       	pop	r0
    1576:	0f 90       	pop	r0
    1578:	0f 90       	pop	r0
    157a:	0f 90       	pop	r0
    157c:	df 91       	pop	r29
    157e:	cf 91       	pop	r28
    1580:	1f 91       	pop	r17
    1582:	0f 91       	pop	r16
    1584:	ff 90       	pop	r15
    1586:	ef 90       	pop	r14
    1588:	08 95       	ret

0000158a <_ZN7MCP_CAN19mcp2515_read_canMsgEh>:

/*********************************************************************************************************
** Function name:           mcp2515_read_canMsg
** Descriptions:            Read message
*********************************************************************************************************/
void MCP_CAN::mcp2515_read_canMsg( const uint8_t buffer_sidh_addr){        /* read can msg                 */
    158a:	0f 93       	push	r16
    158c:	1f 93       	push	r17
    158e:	cf 93       	push	r28
    1590:	df 93       	push	r29
    1592:	ec 01       	movw	r28, r24
    1594:	16 2f       	mov	r17, r22
	uint8_t mcp_addr, ctrl;
	mcp_addr = buffer_sidh_addr;
	mcp2515_read_id( mcp_addr, &m_nExtFlg,&m_nID );
    1596:	9c 01       	movw	r18, r24
    1598:	2f 5f       	subi	r18, 0xFF	; 255
    159a:	3f 4f       	sbci	r19, 0xFF	; 255
    159c:	ac 01       	movw	r20, r24
    159e:	8e df       	rcall	.-228    	; 0x14bc <_ZN7MCP_CAN15mcp2515_read_idEhPhPm>
	ctrl = mcp2515_readRegister( mcp_addr-1 );
    15a0:	6f ef       	ldi	r22, 0xFF	; 255
    15a2:	61 0f       	add	r22, r17
    15a4:	ce 01       	movw	r24, r28
    15a6:	f2 dc       	rcall	.-1564   	; 0xf8c <_ZN7MCP_CAN20mcp2515_readRegisterEh>
    15a8:	08 2f       	mov	r16, r24
	m_nDlc = mcp2515_readRegister( mcp_addr+4 );
    15aa:	64 e0       	ldi	r22, 0x04	; 4
    15ac:	61 0f       	add	r22, r17
    15ae:	ce 01       	movw	r24, r28
    15b0:	ed dc       	rcall	.-1574   	; 0xf8c <_ZN7MCP_CAN20mcp2515_readRegisterEh>
    15b2:	8d 83       	std	Y+5, r24	; 0x05
	if (ctrl & 0x08)
    15b4:	03 ff       	sbrs	r16, 3
    15b6:	03 c0       	rjmp	.+6      	; 0x15be <_ZN7MCP_CAN19mcp2515_read_canMsgEh+0x34>
		m_nRtr = 1;
    15b8:	91 e0       	ldi	r25, 0x01	; 1
    15ba:	9e 87       	std	Y+14, r25	; 0x0e
    15bc:	01 c0       	rjmp	.+2      	; 0x15c0 <_ZN7MCP_CAN19mcp2515_read_canMsgEh+0x36>
	else
		m_nRtr = 0;
    15be:	1e 86       	std	Y+14, r1	; 0x0e
	m_nDlc &= MCP_DLC_MASK;
    15c0:	28 2f       	mov	r18, r24
    15c2:	2f 70       	andi	r18, 0x0F	; 15
    15c4:	2d 83       	std	Y+5, r18	; 0x05
	mcp2515_readRegisterS( mcp_addr+5, &(m_nDta[0]), m_nDlc );
    15c6:	ae 01       	movw	r20, r28
    15c8:	4a 5f       	subi	r20, 0xFA	; 250
    15ca:	5f 4f       	sbci	r21, 0xFF	; 255
    15cc:	65 e0       	ldi	r22, 0x05	; 5
    15ce:	61 0f       	add	r22, r17
    15d0:	ce 01       	movw	r24, r28
    15d2:	13 dd       	rcall	.-1498   	; 0xffa <_ZN7MCP_CAN21mcp2515_readRegisterSEhPhh>
}
    15d4:	df 91       	pop	r29
    15d6:	cf 91       	pop	r28
    15d8:	1f 91       	pop	r17
    15da:	0f 91       	pop	r16
    15dc:	08 95       	ret

000015de <_ZN7MCP_CANC1Eh>:
** Function name:           MCP_CAN
** Descriptions:            Public function to declare CAN class and the /CS pin.
*********************************************************************************************************/
MCP_CAN::MCP_CAN(uint8_t _CS)
{
	MCPCS = _CS;
    15de:	fc 01       	movw	r30, r24
    15e0:	60 8b       	std	Z+16, r22	; 0x10
	MCP2515_UNSELECT();
    15e2:	eb e0       	ldi	r30, 0x0B	; 11
    15e4:	f1 e0       	ldi	r31, 0x01	; 1
    15e6:	80 81       	ld	r24, Z
    15e8:	84 60       	ori	r24, 0x04	; 4
    15ea:	80 83       	st	Z, r24
	DDRL |= (1 << PL2);		//????
    15ec:	ea e0       	ldi	r30, 0x0A	; 10
    15ee:	f1 e0       	ldi	r31, 0x01	; 1
    15f0:	80 81       	ld	r24, Z
    15f2:	84 60       	ori	r24, 0x04	; 4
    15f4:	80 83       	st	Z, r24
    15f6:	08 95       	ret

000015f8 <_ZN7MCP_CAN5beginEhhh>:
/*********************************************************************************************************
** Function name:           begin
** Descriptions:            Public function to declare controller initialization parameters.
*********************************************************************************************************/
uint8_t MCP_CAN::begin(uint8_t idmodeset, uint8_t speedset, uint8_t clockset)
{
    15f8:	ff 92       	push	r15
    15fa:	0f 93       	push	r16
    15fc:	1f 93       	push	r17
    15fe:	cf 93       	push	r28
    1600:	df 93       	push	r29
    1602:	ec 01       	movw	r28, r24
    1604:	16 2f       	mov	r17, r22
    1606:	04 2f       	mov	r16, r20
    1608:	f2 2e       	mov	r15, r18
	uint8_t res;

	SPI.begin();
    160a:	90 d0       	rcall	.+288    	; 0x172c <_ZN8SPIClass5beginEv>
	res = mcp2515_init(idmodeset, speedset, clockset);
    160c:	2f 2d       	mov	r18, r15
    160e:	40 2f       	mov	r20, r16
    1610:	61 2f       	mov	r22, r17
    1612:	ce 01       	movw	r24, r28
    1614:	07 df       	rcall	.-498    	; 0x1424 <_ZN7MCP_CAN12mcp2515_initEhhh>
    1616:	91 e0       	ldi	r25, 0x01	; 1
    1618:	81 11       	cpse	r24, r1
    161a:	01 c0       	rjmp	.+2      	; 0x161e <_ZN7MCP_CAN5beginEhhh+0x26>
    161c:	90 e0       	ldi	r25, 0x00	; 0
	if (res == MCP2515_OK)
	return CAN_OK;
	
	return CAN_FAILINIT;
}
    161e:	89 2f       	mov	r24, r25
    1620:	df 91       	pop	r29
    1622:	cf 91       	pop	r28
    1624:	1f 91       	pop	r17
    1626:	0f 91       	pop	r16
    1628:	ff 90       	pop	r15
    162a:	08 95       	ret

0000162c <_ZN7MCP_CAN7readMsgEv>:

/*********************************************************************************************************
** Function name:           readMsg
** Descriptions:            Read message
*********************************************************************************************************/
uint8_t MCP_CAN::readMsg(){
    162c:	cf 93       	push	r28
    162e:	df 93       	push	r29
    1630:	ec 01       	movw	r28, r24
	uint8_t stat, res;
	stat = mcp2515_readStatus();
    1632:	fd dd       	rcall	.-1030   	; 0x122e <_ZN7MCP_CAN18mcp2515_readStatusEv>

	if ( stat & MCP_STAT_RX0IF )                                        /* Msg in Buffer 0              */
    1634:	80 ff       	sbrs	r24, 0
    1636:	0a c0       	rjmp	.+20     	; 0x164c <_ZN7MCP_CAN7readMsgEv+0x20>
	{
		mcp2515_read_canMsg( MCP_RXBUF_0);
    1638:	61 e6       	ldi	r22, 0x61	; 97
    163a:	ce 01       	movw	r24, r28
    163c:	a6 df       	rcall	.-180    	; 0x158a <_ZN7MCP_CAN19mcp2515_read_canMsgEh>
		mcp2515_modifyRegister(MCP_CANINTF, MCP_RX0IF, 0);
    163e:	20 e0       	ldi	r18, 0x00	; 0
    1640:	41 e0       	ldi	r20, 0x01	; 1
    1642:	6c e2       	ldi	r22, 0x2C	; 44
    1644:	ce 01       	movw	r24, r28
    1646:	b2 dd       	rcall	.-1180   	; 0x11ac <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
		res = CAN_OK;
    1648:	80 e0       	ldi	r24, 0x00	; 0
    164a:	0d c0       	rjmp	.+26     	; 0x1666 <_ZN7MCP_CAN7readMsgEv+0x3a>
	}
	else if ( stat & MCP_STAT_RX1IF )                                   /* Msg in Buffer 1              */
    164c:	81 ff       	sbrs	r24, 1
	{
		mcp2515_read_canMsg( MCP_RXBUF_1);
    164e:	0a c0       	rjmp	.+20     	; 0x1664 <_ZN7MCP_CAN7readMsgEv+0x38>
    1650:	61 e7       	ldi	r22, 0x71	; 113
    1652:	ce 01       	movw	r24, r28
    1654:	9a df       	rcall	.-204    	; 0x158a <_ZN7MCP_CAN19mcp2515_read_canMsgEh>
		mcp2515_modifyRegister(MCP_CANINTF, MCP_RX1IF, 0);
    1656:	20 e0       	ldi	r18, 0x00	; 0
    1658:	42 e0       	ldi	r20, 0x02	; 2
    165a:	6c e2       	ldi	r22, 0x2C	; 44
    165c:	ce 01       	movw	r24, r28
    165e:	a6 dd       	rcall	.-1204   	; 0x11ac <_ZN7MCP_CAN22mcp2515_modifyRegisterEhhh>
		res = CAN_OK;
    1660:	80 e0       	ldi	r24, 0x00	; 0
    1662:	01 c0       	rjmp	.+2      	; 0x1666 <_ZN7MCP_CAN7readMsgEv+0x3a>
	}
	else
	res = CAN_NOMSG;
    1664:	84 e0       	ldi	r24, 0x04	; 4
	
	return res;
}
    1666:	df 91       	pop	r29
    1668:	cf 91       	pop	r28
    166a:	08 95       	ret

0000166c <_ZN7MCP_CAN10readMsgBufEPmPhS1_>:

/*********************************************************************************************************
** Function name:           readMsgBuf
** Descriptions:            Public function, Reads message from receive buffer.
*********************************************************************************************************/
uint8_t MCP_CAN::readMsgBuf(uint32_t *id, uint8_t *len, uint8_t buf[]){
    166c:	cf 92       	push	r12
    166e:	df 92       	push	r13
    1670:	ef 92       	push	r14
    1672:	ff 92       	push	r15
    1674:	0f 93       	push	r16
    1676:	1f 93       	push	r17
    1678:	cf 93       	push	r28
    167a:	df 93       	push	r29
    167c:	ec 01       	movw	r28, r24
    167e:	7b 01       	movw	r14, r22
    1680:	8a 01       	movw	r16, r20
    1682:	c2 2e       	mov	r12, r18
    1684:	d3 2e       	mov	r13, r19
	if(readMsg() == CAN_NOMSG)
    1686:	d2 df       	rcall	.-92     	; 0x162c <_ZN7MCP_CAN7readMsgEv>
    1688:	84 30       	cpi	r24, 0x04	; 4
    168a:	c9 f1       	breq	.+114    	; 0x16fe <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x92>
	return CAN_NOMSG;

	if (m_nExtFlg)
    168c:	88 81       	ld	r24, Y
    168e:	88 23       	and	r24, r24
    1690:	49 f0       	breq	.+18     	; 0x16a4 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x38>
	m_nID |= 0x80000000;
    1692:	89 81       	ldd	r24, Y+1	; 0x01
    1694:	9a 81       	ldd	r25, Y+2	; 0x02
    1696:	ab 81       	ldd	r26, Y+3	; 0x03
    1698:	bc 81       	ldd	r27, Y+4	; 0x04
    169a:	b0 68       	ori	r27, 0x80	; 128
    169c:	89 83       	std	Y+1, r24	; 0x01
    169e:	9a 83       	std	Y+2, r25	; 0x02
    16a0:	ab 83       	std	Y+3, r26	; 0x03
    16a2:	bc 83       	std	Y+4, r27	; 0x04

	if (m_nRtr)
    16a4:	8e 85       	ldd	r24, Y+14	; 0x0e
    16a6:	88 23       	and	r24, r24
    16a8:	49 f0       	breq	.+18     	; 0x16bc <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x50>
	m_nID |= 0x40000000;
    16aa:	89 81       	ldd	r24, Y+1	; 0x01
    16ac:	9a 81       	ldd	r25, Y+2	; 0x02
    16ae:	ab 81       	ldd	r26, Y+3	; 0x03
    16b0:	bc 81       	ldd	r27, Y+4	; 0x04
    16b2:	b0 64       	ori	r27, 0x40	; 64
    16b4:	89 83       	std	Y+1, r24	; 0x01
    16b6:	9a 83       	std	Y+2, r25	; 0x02
    16b8:	ab 83       	std	Y+3, r26	; 0x03
    16ba:	bc 83       	std	Y+4, r27	; 0x04
	*id  = m_nID;
    16bc:	89 81       	ldd	r24, Y+1	; 0x01
    16be:	9a 81       	ldd	r25, Y+2	; 0x02
    16c0:	ab 81       	ldd	r26, Y+3	; 0x03
    16c2:	bc 81       	ldd	r27, Y+4	; 0x04
    16c4:	f7 01       	movw	r30, r14
    16c6:	80 83       	st	Z, r24
    16c8:	91 83       	std	Z+1, r25	; 0x01
    16ca:	a2 83       	std	Z+2, r26	; 0x02
    16cc:	b3 83       	std	Z+3, r27	; 0x03
	*len = m_nDlc;
    16ce:	8d 81       	ldd	r24, Y+5	; 0x05
    16d0:	f8 01       	movw	r30, r16
    16d2:	80 83       	st	Z, r24
	for(int i = 0; i<m_nDlc; i++)
    16d4:	8d 81       	ldd	r24, Y+5	; 0x05
    16d6:	88 23       	and	r24, r24
    16d8:	89 f0       	breq	.+34     	; 0x16fc <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x90>
    16da:	de 01       	movw	r26, r28
    16dc:	16 96       	adiw	r26, 0x06	; 6
    16de:	ec 2d       	mov	r30, r12
    16e0:	fd 2d       	mov	r31, r13
    16e2:	20 e0       	ldi	r18, 0x00	; 0
    16e4:	30 e0       	ldi	r19, 0x00	; 0
	buf[i] = m_nDta[i];
    16e6:	8d 91       	ld	r24, X+
    16e8:	81 93       	st	Z+, r24

	if (m_nRtr)
	m_nID |= 0x40000000;
	*id  = m_nID;
	*len = m_nDlc;
	for(int i = 0; i<m_nDlc; i++)
    16ea:	2f 5f       	subi	r18, 0xFF	; 255
    16ec:	3f 4f       	sbci	r19, 0xFF	; 255
    16ee:	8d 81       	ldd	r24, Y+5	; 0x05
    16f0:	90 e0       	ldi	r25, 0x00	; 0
    16f2:	28 17       	cp	r18, r24
    16f4:	39 07       	cpc	r19, r25
    16f6:	bc f3       	brlt	.-18     	; 0x16e6 <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x7a>
	buf[i] = m_nDta[i];
	return CAN_OK;
    16f8:	80 e0       	ldi	r24, 0x00	; 0
    16fa:	01 c0       	rjmp	.+2      	; 0x16fe <_ZN7MCP_CAN10readMsgBufEPmPhS1_+0x92>
    16fc:	80 e0       	ldi	r24, 0x00	; 0
}
    16fe:	df 91       	pop	r29
    1700:	cf 91       	pop	r28
    1702:	1f 91       	pop	r17
    1704:	0f 91       	pop	r16
    1706:	ff 90       	pop	r15
    1708:	ef 90       	pop	r14
    170a:	df 90       	pop	r13
    170c:	cf 90       	pop	r12
    170e:	08 95       	ret

00001710 <_ZN11SPISettingsC1Emhh>:
void SPIClass::end() {
	cli();							// Protect from a scheduler and prevent transactionBegin
	if (initialized)					// Decrease the reference counter
		initialized--;
	if (!initialized)				
		SPCR &= ~(1 << SPE);
    1710:	0f 93       	push	r16
    1712:	fc 01       	movw	r30, r24
    1714:	22 23       	and	r18, r18
    1716:	11 f0       	breq	.+4      	; 0x171c <_ZN11SPISettingsC1Emhh+0xc>
    1718:	90 e5       	ldi	r25, 0x50	; 80
    171a:	01 c0       	rjmp	.+2      	; 0x171e <_ZN11SPISettingsC1Emhh+0xe>
    171c:	90 e7       	ldi	r25, 0x70	; 112
    171e:	0c 70       	andi	r16, 0x0C	; 12
    1720:	09 2b       	or	r16, r25
    1722:	00 83       	st	Z, r16
    1724:	81 e0       	ldi	r24, 0x01	; 1
    1726:	81 83       	std	Z+1, r24	; 0x01
    1728:	0f 91       	pop	r16
    172a:	08 95       	ret

0000172c <_ZN8SPIClass5beginEv>:
    172c:	f8 94       	cli
    172e:	80 91 74 04 	lds	r24, 0x0474	; 0x800474 <_ZN8SPIClass11initializedE>
    1732:	81 11       	cpse	r24, r1
    1734:	0b c0       	rjmp	.+22     	; 0x174c <_ZN8SPIClass5beginEv+0x20>
    1736:	58 9a       	sbi	0x0b, 0	; 11
    1738:	20 9a       	sbi	0x04, 0	; 4
    173a:	84 b1       	in	r24, 0x04	; 4
    173c:	86 60       	ori	r24, 0x06	; 6
    173e:	84 b9       	out	0x04, r24	; 4
    1740:	8c b5       	in	r24, 0x2c	; 44
    1742:	80 61       	ori	r24, 0x10	; 16
    1744:	8c bd       	out	0x2c, r24	; 44
    1746:	8c b5       	in	r24, 0x2c	; 44
    1748:	80 64       	ori	r24, 0x40	; 64
    174a:	8c bd       	out	0x2c, r24	; 44
    174c:	80 91 74 04 	lds	r24, 0x0474	; 0x800474 <_ZN8SPIClass11initializedE>
    1750:	8f 5f       	subi	r24, 0xFF	; 255
    1752:	80 93 74 04 	sts	0x0474, r24	; 0x800474 <_ZN8SPIClass11initializedE>
    1756:	08 95       	ret

00001758 <_ZN8SPIClass16beginTransactionE11SPISettings>:
}

void SPIClass::beginTransaction(SPISettings settings) {
	SPCR = settings.spcr;
    1758:	fb 01       	movw	r30, r22
    175a:	80 81       	ld	r24, Z
    175c:	8c bd       	out	0x2c, r24	; 44
	SPSR = settings.spsr;
    175e:	81 81       	ldd	r24, Z+1	; 0x01
    1760:	8d bd       	out	0x2d, r24	; 45
    1762:	08 95       	ret

00001764 <_ZN8SPIClass8transferEh>:
}

uint8_t SPIClass::transfer(uint8_t data) {
SPDR = data;
    1764:	6e bd       	out	0x2e, r22	; 46
while (!(SPSR & (1 << SPIF))) ; // wait
    1766:	0d b4       	in	r0, 0x2d	; 45
    1768:	07 fe       	sbrs	r0, 7
    176a:	fd cf       	rjmp	.-6      	; 0x1766 <_ZN8SPIClass8transferEh+0x2>
return SPDR;
    176c:	8e b5       	in	r24, 0x2e	; 46
}
    176e:	08 95       	ret

00001770 <_ZN5USARTC1Ev>:
#include "USART.h"

//constructor with setup

USART::USART(){
	UCSR0B = (1 << TXEN0);						// Enable de USART Transmitter
    1770:	88 e0       	ldi	r24, 0x08	; 8
    1772:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);		// 8 data bits, 1 stop bit
    1776:	96 e0       	ldi	r25, 0x06	; 6
    1778:	90 93 c2 00 	sts	0x00C2, r25	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
	UBRR0H=0;									//write the baudrate (76800)
    177c:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
	UBRR0L=8;									// "
    1780:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    1784:	08 95       	ret

00001786 <_ZN5USART5printEPKc>:
}



//write a string in the Serial
void USART::print(const char st[]) {
    1786:	cf 93       	push	r28
    1788:	df 93       	push	r29
	for(uint8_t i = 0 ; st[i] != 0 ; i++) {		//iterate over every char in the string
    178a:	fb 01       	movw	r30, r22
    178c:	90 81       	ld	r25, Z
    178e:	99 23       	and	r25, r25
    1790:	81 f0       	breq	.+32     	; 0x17b2 <_ZN5USART5printEPKc+0x2c>
    1792:	20 e0       	ldi	r18, 0x00	; 0
		while(~UCSR0A & (1 << UDRE0));			//wait till the transmit buffer is empty
    1794:	e0 ec       	ldi	r30, 0xC0	; 192
    1796:	f0 e0       	ldi	r31, 0x00	; 0
		UDR0 = (int)st[i];						//write the char in the transmit buffer
    1798:	c6 ec       	ldi	r28, 0xC6	; 198
    179a:	d0 e0       	ldi	r29, 0x00	; 0


//write a string in the Serial
void USART::print(const char st[]) {
	for(uint8_t i = 0 ; st[i] != 0 ; i++) {		//iterate over every char in the string
		while(~UCSR0A & (1 << UDRE0));			//wait till the transmit buffer is empty
    179c:	80 81       	ld	r24, Z
    179e:	85 ff       	sbrs	r24, 5
    17a0:	fd cf       	rjmp	.-6      	; 0x179c <_ZN5USART5printEPKc+0x16>
		UDR0 = (int)st[i];						//write the char in the transmit buffer
    17a2:	98 83       	st	Y, r25



//write a string in the Serial
void USART::print(const char st[]) {
	for(uint8_t i = 0 ; st[i] != 0 ; i++) {		//iterate over every char in the string
    17a4:	2f 5f       	subi	r18, 0xFF	; 255
    17a6:	db 01       	movw	r26, r22
    17a8:	a2 0f       	add	r26, r18
    17aa:	b1 1d       	adc	r27, r1
    17ac:	9c 91       	ld	r25, X
    17ae:	91 11       	cpse	r25, r1
    17b0:	f5 cf       	rjmp	.-22     	; 0x179c <_ZN5USART5printEPKc+0x16>
		while(~UCSR0A & (1 << UDRE0));			//wait till the transmit buffer is empty
		UDR0 = (int)st[i];						//write the char in the transmit buffer
	}
}
    17b2:	df 91       	pop	r29
    17b4:	cf 91       	pop	r28
    17b6:	08 95       	ret

000017b8 <_ZN5USART7printlnEPKc>:

void USART::println(const char st[]){
    17b8:	cf 93       	push	r28
    17ba:	df 93       	push	r29
    17bc:	ec 01       	movw	r28, r24
	this->print(st);
    17be:	e3 df       	rcall	.-58     	; 0x1786 <_ZN5USART5printEPKc>
	this->print("\n\r");
    17c0:	60 e2       	ldi	r22, 0x20	; 32
    17c2:	74 e0       	ldi	r23, 0x04	; 4
    17c4:	ce 01       	movw	r24, r28
    17c6:	df df       	rcall	.-66     	; 0x1786 <_ZN5USART5printEPKc>
}
    17c8:	df 91       	pop	r29
    17ca:	cf 91       	pop	r28
    17cc:	08 95       	ret

000017ce <_ZN5USART5printEi>:

//write an integer in the Serial
void USART::print(int i) {
    17ce:	0f 93       	push	r16
    17d0:	1f 93       	push	r17
    17d2:	cf 93       	push	r28
    17d4:	df 93       	push	r29
    17d6:	cd b7       	in	r28, 0x3d	; 61
    17d8:	de b7       	in	r29, 0x3e	; 62
    17da:	60 97       	sbiw	r28, 0x10	; 16
    17dc:	0f b6       	in	r0, 0x3f	; 63
    17de:	f8 94       	cli
    17e0:	de bf       	out	0x3e, r29	; 62
    17e2:	0f be       	out	0x3f, r0	; 63
    17e4:	cd bf       	out	0x3d, r28	; 61
    17e6:	8c 01       	movw	r16, r24
    17e8:	cb 01       	movw	r24, r22
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    17ea:	4a e0       	ldi	r20, 0x0A	; 10
    17ec:	be 01       	movw	r22, r28
    17ee:	6f 5f       	subi	r22, 0xFF	; 255
    17f0:	7f 4f       	sbci	r23, 0xFF	; 255
    17f2:	71 d1       	rcall	.+738    	; 0x1ad6 <__itoa_ncheck>
	char buffer[16];							//create a string
	itoa(i,buffer,10);							//parse the integer into the string
	print(buffer);						//print the string
    17f4:	be 01       	movw	r22, r28
    17f6:	6f 5f       	subi	r22, 0xFF	; 255
    17f8:	7f 4f       	sbci	r23, 0xFF	; 255
    17fa:	c8 01       	movw	r24, r16
    17fc:	c4 df       	rcall	.-120    	; 0x1786 <_ZN5USART5printEPKc>
}
    17fe:	60 96       	adiw	r28, 0x10	; 16
    1800:	0f b6       	in	r0, 0x3f	; 63
    1802:	f8 94       	cli
    1804:	de bf       	out	0x3e, r29	; 62
    1806:	0f be       	out	0x3f, r0	; 63
    1808:	cd bf       	out	0x3d, r28	; 61
    180a:	df 91       	pop	r29
    180c:	cf 91       	pop	r28
    180e:	1f 91       	pop	r17
    1810:	0f 91       	pop	r16
    1812:	08 95       	ret

00001814 <_ZN5USART7printlnEi>:

void USART::println(int i){
    1814:	cf 93       	push	r28
    1816:	df 93       	push	r29
    1818:	ec 01       	movw	r28, r24
	this->print(i);
    181a:	d9 df       	rcall	.-78     	; 0x17ce <_ZN5USART5printEi>
	this->print("\n\r");
    181c:	60 e2       	ldi	r22, 0x20	; 32
    181e:	74 e0       	ldi	r23, 0x04	; 4
    1820:	ce 01       	movw	r24, r28
    1822:	b1 df       	rcall	.-158    	; 0x1786 <_ZN5USART5printEPKc>
}
    1824:	df 91       	pop	r29
    1826:	cf 91       	pop	r28
    1828:	08 95       	ret

0000182a <__divmodsi4>:
    182a:	05 2e       	mov	r0, r21
    182c:	97 fb       	bst	r25, 7
    182e:	16 f4       	brtc	.+4      	; 0x1834 <__divmodsi4+0xa>
    1830:	00 94       	com	r0
    1832:	0f d0       	rcall	.+30     	; 0x1852 <__negsi2>
    1834:	57 fd       	sbrc	r21, 7
    1836:	05 d0       	rcall	.+10     	; 0x1842 <__divmodsi4_neg2>
    1838:	1d d1       	rcall	.+570    	; 0x1a74 <__udivmodsi4>
    183a:	07 fc       	sbrc	r0, 7
    183c:	02 d0       	rcall	.+4      	; 0x1842 <__divmodsi4_neg2>
    183e:	46 f4       	brtc	.+16     	; 0x1850 <__divmodsi4_exit>
    1840:	08 c0       	rjmp	.+16     	; 0x1852 <__negsi2>

00001842 <__divmodsi4_neg2>:
    1842:	50 95       	com	r21
    1844:	40 95       	com	r20
    1846:	30 95       	com	r19
    1848:	21 95       	neg	r18
    184a:	3f 4f       	sbci	r19, 0xFF	; 255
    184c:	4f 4f       	sbci	r20, 0xFF	; 255
    184e:	5f 4f       	sbci	r21, 0xFF	; 255

00001850 <__divmodsi4_exit>:
    1850:	08 95       	ret

00001852 <__negsi2>:
    1852:	90 95       	com	r25
    1854:	80 95       	com	r24
    1856:	70 95       	com	r23
    1858:	61 95       	neg	r22
    185a:	7f 4f       	sbci	r23, 0xFF	; 255
    185c:	8f 4f       	sbci	r24, 0xFF	; 255
    185e:	9f 4f       	sbci	r25, 0xFF	; 255
    1860:	08 95       	ret

00001862 <__tablejump2__>:
    1862:	ee 0f       	add	r30, r30
    1864:	ff 1f       	adc	r31, r31
    1866:	88 1f       	adc	r24, r24
    1868:	8b bf       	out	0x3b, r24	; 59
    186a:	07 90       	elpm	r0, Z+
    186c:	f6 91       	elpm	r31, Z
    186e:	e0 2d       	mov	r30, r0
    1870:	19 94       	eijmp

00001872 <__usmulhisi3>:
    1872:	22 d1       	rcall	.+580    	; 0x1ab8 <__umulhisi3>

00001874 <__usmulhisi3_tail>:
    1874:	b7 ff       	sbrs	r27, 7
    1876:	08 95       	ret
    1878:	82 1b       	sub	r24, r18
    187a:	93 0b       	sbc	r25, r19
    187c:	08 95       	ret

0000187e <__moddi3>:
    187e:	68 94       	set
    1880:	01 c0       	rjmp	.+2      	; 0x1884 <__divdi3_moddi3>

00001882 <__divdi3>:
    1882:	e8 94       	clt

00001884 <__divdi3_moddi3>:
    1884:	f9 2f       	mov	r31, r25
    1886:	f1 2b       	or	r31, r17
    1888:	0a f0       	brmi	.+2      	; 0x188c <__divdi3_moddi3+0x8>
    188a:	27 c0       	rjmp	.+78     	; 0x18da <__udivdi3_umoddi3>
    188c:	a0 e0       	ldi	r26, 0x00	; 0
    188e:	b0 e0       	ldi	r27, 0x00	; 0
    1890:	eb e4       	ldi	r30, 0x4B	; 75
    1892:	fc e0       	ldi	r31, 0x0C	; 12
    1894:	93 c0       	rjmp	.+294    	; 0x19bc <__prologue_saves__+0xc>
    1896:	09 2e       	mov	r0, r25
    1898:	05 94       	asr	r0
    189a:	1a f4       	brpl	.+6      	; 0x18a2 <__divdi3_moddi3+0x1e>
    189c:	79 d0       	rcall	.+242    	; 0x1990 <__negdi2>
    189e:	11 23       	and	r17, r17
    18a0:	92 f4       	brpl	.+36     	; 0x18c6 <__divdi3_moddi3+0x42>
    18a2:	f0 e8       	ldi	r31, 0x80	; 128
    18a4:	0f 26       	eor	r0, r31
    18a6:	ff ef       	ldi	r31, 0xFF	; 255
    18a8:	e0 94       	com	r14
    18aa:	f0 94       	com	r15
    18ac:	00 95       	com	r16
    18ae:	10 95       	com	r17
    18b0:	b0 94       	com	r11
    18b2:	c0 94       	com	r12
    18b4:	d0 94       	com	r13
    18b6:	a1 94       	neg	r10
    18b8:	bf 0a       	sbc	r11, r31
    18ba:	cf 0a       	sbc	r12, r31
    18bc:	df 0a       	sbc	r13, r31
    18be:	ef 0a       	sbc	r14, r31
    18c0:	ff 0a       	sbc	r15, r31
    18c2:	0f 0b       	sbc	r16, r31
    18c4:	1f 0b       	sbc	r17, r31
    18c6:	13 d0       	rcall	.+38     	; 0x18ee <__udivmod64>
    18c8:	07 fc       	sbrc	r0, 7
    18ca:	62 d0       	rcall	.+196    	; 0x1990 <__negdi2>
    18cc:	cd b7       	in	r28, 0x3d	; 61
    18ce:	de b7       	in	r29, 0x3e	; 62
    18d0:	ec e0       	ldi	r30, 0x0C	; 12
    18d2:	90 c0       	rjmp	.+288    	; 0x19f4 <__epilogue_restores__+0xc>

000018d4 <__umoddi3>:
    18d4:	68 94       	set
    18d6:	01 c0       	rjmp	.+2      	; 0x18da <__udivdi3_umoddi3>

000018d8 <__udivdi3>:
    18d8:	e8 94       	clt

000018da <__udivdi3_umoddi3>:
    18da:	8f 92       	push	r8
    18dc:	9f 92       	push	r9
    18de:	cf 93       	push	r28
    18e0:	df 93       	push	r29
    18e2:	05 d0       	rcall	.+10     	; 0x18ee <__udivmod64>
    18e4:	df 91       	pop	r29
    18e6:	cf 91       	pop	r28
    18e8:	9f 90       	pop	r9
    18ea:	8f 90       	pop	r8
    18ec:	08 95       	ret

000018ee <__udivmod64>:
    18ee:	88 24       	eor	r8, r8
    18f0:	99 24       	eor	r9, r9
    18f2:	f4 01       	movw	r30, r8
    18f4:	e4 01       	movw	r28, r8
    18f6:	b0 e4       	ldi	r27, 0x40	; 64
    18f8:	9f 93       	push	r25
    18fa:	aa 27       	eor	r26, r26
    18fc:	9a 15       	cp	r25, r10
    18fe:	8b 04       	cpc	r8, r11
    1900:	9c 04       	cpc	r9, r12
    1902:	ed 05       	cpc	r30, r13
    1904:	fe 05       	cpc	r31, r14
    1906:	cf 05       	cpc	r28, r15
    1908:	d0 07       	cpc	r29, r16
    190a:	a1 07       	cpc	r26, r17
    190c:	98 f4       	brcc	.+38     	; 0x1934 <__udivmod64+0x46>
    190e:	ad 2f       	mov	r26, r29
    1910:	dc 2f       	mov	r29, r28
    1912:	cf 2f       	mov	r28, r31
    1914:	fe 2f       	mov	r31, r30
    1916:	e9 2d       	mov	r30, r9
    1918:	98 2c       	mov	r9, r8
    191a:	89 2e       	mov	r8, r25
    191c:	98 2f       	mov	r25, r24
    191e:	87 2f       	mov	r24, r23
    1920:	76 2f       	mov	r23, r22
    1922:	65 2f       	mov	r22, r21
    1924:	54 2f       	mov	r21, r20
    1926:	43 2f       	mov	r20, r19
    1928:	32 2f       	mov	r19, r18
    192a:	22 27       	eor	r18, r18
    192c:	b8 50       	subi	r27, 0x08	; 8
    192e:	31 f7       	brne	.-52     	; 0x18fc <__udivmod64+0xe>
    1930:	bf 91       	pop	r27
    1932:	27 c0       	rjmp	.+78     	; 0x1982 <__udivmod64+0x94>
    1934:	1b 2e       	mov	r1, r27
    1936:	bf 91       	pop	r27
    1938:	bb 27       	eor	r27, r27
    193a:	22 0f       	add	r18, r18
    193c:	33 1f       	adc	r19, r19
    193e:	44 1f       	adc	r20, r20
    1940:	55 1f       	adc	r21, r21
    1942:	66 1f       	adc	r22, r22
    1944:	77 1f       	adc	r23, r23
    1946:	88 1f       	adc	r24, r24
    1948:	99 1f       	adc	r25, r25
    194a:	88 1c       	adc	r8, r8
    194c:	99 1c       	adc	r9, r9
    194e:	ee 1f       	adc	r30, r30
    1950:	ff 1f       	adc	r31, r31
    1952:	cc 1f       	adc	r28, r28
    1954:	dd 1f       	adc	r29, r29
    1956:	aa 1f       	adc	r26, r26
    1958:	bb 1f       	adc	r27, r27
    195a:	8a 14       	cp	r8, r10
    195c:	9b 04       	cpc	r9, r11
    195e:	ec 05       	cpc	r30, r12
    1960:	fd 05       	cpc	r31, r13
    1962:	ce 05       	cpc	r28, r14
    1964:	df 05       	cpc	r29, r15
    1966:	a0 07       	cpc	r26, r16
    1968:	b1 07       	cpc	r27, r17
    196a:	48 f0       	brcs	.+18     	; 0x197e <__udivmod64+0x90>
    196c:	8a 18       	sub	r8, r10
    196e:	9b 08       	sbc	r9, r11
    1970:	ec 09       	sbc	r30, r12
    1972:	fd 09       	sbc	r31, r13
    1974:	ce 09       	sbc	r28, r14
    1976:	df 09       	sbc	r29, r15
    1978:	a0 0b       	sbc	r26, r16
    197a:	b1 0b       	sbc	r27, r17
    197c:	21 60       	ori	r18, 0x01	; 1
    197e:	1a 94       	dec	r1
    1980:	e1 f6       	brne	.-72     	; 0x193a <__udivmod64+0x4c>
    1982:	2e f4       	brtc	.+10     	; 0x198e <__udivmod64+0xa0>
    1984:	94 01       	movw	r18, r8
    1986:	af 01       	movw	r20, r30
    1988:	be 01       	movw	r22, r28
    198a:	cd 01       	movw	r24, r26
    198c:	00 0c       	add	r0, r0
    198e:	08 95       	ret

00001990 <__negdi2>:
    1990:	60 95       	com	r22
    1992:	70 95       	com	r23
    1994:	80 95       	com	r24
    1996:	90 95       	com	r25
    1998:	30 95       	com	r19
    199a:	40 95       	com	r20
    199c:	50 95       	com	r21
    199e:	21 95       	neg	r18
    19a0:	3f 4f       	sbci	r19, 0xFF	; 255
    19a2:	4f 4f       	sbci	r20, 0xFF	; 255
    19a4:	5f 4f       	sbci	r21, 0xFF	; 255
    19a6:	6f 4f       	sbci	r22, 0xFF	; 255
    19a8:	7f 4f       	sbci	r23, 0xFF	; 255
    19aa:	8f 4f       	sbci	r24, 0xFF	; 255
    19ac:	9f 4f       	sbci	r25, 0xFF	; 255
    19ae:	08 95       	ret

000019b0 <__prologue_saves__>:
    19b0:	2f 92       	push	r2
    19b2:	3f 92       	push	r3
    19b4:	4f 92       	push	r4
    19b6:	5f 92       	push	r5
    19b8:	6f 92       	push	r6
    19ba:	7f 92       	push	r7
    19bc:	8f 92       	push	r8
    19be:	9f 92       	push	r9
    19c0:	af 92       	push	r10
    19c2:	bf 92       	push	r11
    19c4:	cf 92       	push	r12
    19c6:	df 92       	push	r13
    19c8:	ef 92       	push	r14
    19ca:	ff 92       	push	r15
    19cc:	0f 93       	push	r16
    19ce:	1f 93       	push	r17
    19d0:	cf 93       	push	r28
    19d2:	df 93       	push	r29
    19d4:	cd b7       	in	r28, 0x3d	; 61
    19d6:	de b7       	in	r29, 0x3e	; 62
    19d8:	ca 1b       	sub	r28, r26
    19da:	db 0b       	sbc	r29, r27
    19dc:	0f b6       	in	r0, 0x3f	; 63
    19de:	f8 94       	cli
    19e0:	de bf       	out	0x3e, r29	; 62
    19e2:	0f be       	out	0x3f, r0	; 63
    19e4:	cd bf       	out	0x3d, r28	; 61
    19e6:	19 94       	eijmp

000019e8 <__epilogue_restores__>:
    19e8:	2a 88       	ldd	r2, Y+18	; 0x12
    19ea:	39 88       	ldd	r3, Y+17	; 0x11
    19ec:	48 88       	ldd	r4, Y+16	; 0x10
    19ee:	5f 84       	ldd	r5, Y+15	; 0x0f
    19f0:	6e 84       	ldd	r6, Y+14	; 0x0e
    19f2:	7d 84       	ldd	r7, Y+13	; 0x0d
    19f4:	8c 84       	ldd	r8, Y+12	; 0x0c
    19f6:	9b 84       	ldd	r9, Y+11	; 0x0b
    19f8:	aa 84       	ldd	r10, Y+10	; 0x0a
    19fa:	b9 84       	ldd	r11, Y+9	; 0x09
    19fc:	c8 84       	ldd	r12, Y+8	; 0x08
    19fe:	df 80       	ldd	r13, Y+7	; 0x07
    1a00:	ee 80       	ldd	r14, Y+6	; 0x06
    1a02:	fd 80       	ldd	r15, Y+5	; 0x05
    1a04:	0c 81       	ldd	r16, Y+4	; 0x04
    1a06:	1b 81       	ldd	r17, Y+3	; 0x03
    1a08:	aa 81       	ldd	r26, Y+2	; 0x02
    1a0a:	b9 81       	ldd	r27, Y+1	; 0x01
    1a0c:	ce 0f       	add	r28, r30
    1a0e:	d1 1d       	adc	r29, r1
    1a10:	0f b6       	in	r0, 0x3f	; 63
    1a12:	f8 94       	cli
    1a14:	de bf       	out	0x3e, r29	; 62
    1a16:	0f be       	out	0x3f, r0	; 63
    1a18:	cd bf       	out	0x3d, r28	; 61
    1a1a:	ed 01       	movw	r28, r26
    1a1c:	08 95       	ret

00001a1e <__ashldi3>:
    1a1e:	0f 93       	push	r16
    1a20:	08 30       	cpi	r16, 0x08	; 8
    1a22:	90 f0       	brcs	.+36     	; 0x1a48 <__ashldi3+0x2a>
    1a24:	98 2f       	mov	r25, r24
    1a26:	87 2f       	mov	r24, r23
    1a28:	76 2f       	mov	r23, r22
    1a2a:	65 2f       	mov	r22, r21
    1a2c:	54 2f       	mov	r21, r20
    1a2e:	43 2f       	mov	r20, r19
    1a30:	32 2f       	mov	r19, r18
    1a32:	22 27       	eor	r18, r18
    1a34:	08 50       	subi	r16, 0x08	; 8
    1a36:	f4 cf       	rjmp	.-24     	; 0x1a20 <__ashldi3+0x2>
    1a38:	22 0f       	add	r18, r18
    1a3a:	33 1f       	adc	r19, r19
    1a3c:	44 1f       	adc	r20, r20
    1a3e:	55 1f       	adc	r21, r21
    1a40:	66 1f       	adc	r22, r22
    1a42:	77 1f       	adc	r23, r23
    1a44:	88 1f       	adc	r24, r24
    1a46:	99 1f       	adc	r25, r25
    1a48:	0a 95       	dec	r16
    1a4a:	b2 f7       	brpl	.-20     	; 0x1a38 <__ashldi3+0x1a>
    1a4c:	0f 91       	pop	r16
    1a4e:	08 95       	ret

00001a50 <__adddi3>:
    1a50:	2a 0d       	add	r18, r10
    1a52:	3b 1d       	adc	r19, r11
    1a54:	4c 1d       	adc	r20, r12
    1a56:	5d 1d       	adc	r21, r13
    1a58:	6e 1d       	adc	r22, r14
    1a5a:	7f 1d       	adc	r23, r15
    1a5c:	80 1f       	adc	r24, r16
    1a5e:	91 1f       	adc	r25, r17
    1a60:	08 95       	ret

00001a62 <__subdi3>:
    1a62:	2a 19       	sub	r18, r10
    1a64:	3b 09       	sbc	r19, r11
    1a66:	4c 09       	sbc	r20, r12
    1a68:	5d 09       	sbc	r21, r13
    1a6a:	6e 09       	sbc	r22, r14
    1a6c:	7f 09       	sbc	r23, r15
    1a6e:	80 0b       	sbc	r24, r16
    1a70:	91 0b       	sbc	r25, r17
    1a72:	08 95       	ret

00001a74 <__udivmodsi4>:
    1a74:	a1 e2       	ldi	r26, 0x21	; 33
    1a76:	1a 2e       	mov	r1, r26
    1a78:	aa 1b       	sub	r26, r26
    1a7a:	bb 1b       	sub	r27, r27
    1a7c:	fd 01       	movw	r30, r26
    1a7e:	0d c0       	rjmp	.+26     	; 0x1a9a <__udivmodsi4_ep>

00001a80 <__udivmodsi4_loop>:
    1a80:	aa 1f       	adc	r26, r26
    1a82:	bb 1f       	adc	r27, r27
    1a84:	ee 1f       	adc	r30, r30
    1a86:	ff 1f       	adc	r31, r31
    1a88:	a2 17       	cp	r26, r18
    1a8a:	b3 07       	cpc	r27, r19
    1a8c:	e4 07       	cpc	r30, r20
    1a8e:	f5 07       	cpc	r31, r21
    1a90:	20 f0       	brcs	.+8      	; 0x1a9a <__udivmodsi4_ep>
    1a92:	a2 1b       	sub	r26, r18
    1a94:	b3 0b       	sbc	r27, r19
    1a96:	e4 0b       	sbc	r30, r20
    1a98:	f5 0b       	sbc	r31, r21

00001a9a <__udivmodsi4_ep>:
    1a9a:	66 1f       	adc	r22, r22
    1a9c:	77 1f       	adc	r23, r23
    1a9e:	88 1f       	adc	r24, r24
    1aa0:	99 1f       	adc	r25, r25
    1aa2:	1a 94       	dec	r1
    1aa4:	69 f7       	brne	.-38     	; 0x1a80 <__udivmodsi4_loop>
    1aa6:	60 95       	com	r22
    1aa8:	70 95       	com	r23
    1aaa:	80 95       	com	r24
    1aac:	90 95       	com	r25
    1aae:	9b 01       	movw	r18, r22
    1ab0:	ac 01       	movw	r20, r24
    1ab2:	bd 01       	movw	r22, r26
    1ab4:	cf 01       	movw	r24, r30
    1ab6:	08 95       	ret

00001ab8 <__umulhisi3>:
    1ab8:	a2 9f       	mul	r26, r18
    1aba:	b0 01       	movw	r22, r0
    1abc:	b3 9f       	mul	r27, r19
    1abe:	c0 01       	movw	r24, r0
    1ac0:	a3 9f       	mul	r26, r19
    1ac2:	70 0d       	add	r23, r0
    1ac4:	81 1d       	adc	r24, r1
    1ac6:	11 24       	eor	r1, r1
    1ac8:	91 1d       	adc	r25, r1
    1aca:	b2 9f       	mul	r27, r18
    1acc:	70 0d       	add	r23, r0
    1ace:	81 1d       	adc	r24, r1
    1ad0:	11 24       	eor	r1, r1
    1ad2:	91 1d       	adc	r25, r1
    1ad4:	08 95       	ret

00001ad6 <__itoa_ncheck>:
    1ad6:	bb 27       	eor	r27, r27
    1ad8:	4a 30       	cpi	r20, 0x0A	; 10
    1ada:	31 f4       	brne	.+12     	; 0x1ae8 <__itoa_ncheck+0x12>
    1adc:	99 23       	and	r25, r25
    1ade:	22 f4       	brpl	.+8      	; 0x1ae8 <__itoa_ncheck+0x12>
    1ae0:	bd e2       	ldi	r27, 0x2D	; 45
    1ae2:	90 95       	com	r25
    1ae4:	81 95       	neg	r24
    1ae6:	9f 4f       	sbci	r25, 0xFF	; 255
    1ae8:	01 c0       	rjmp	.+2      	; 0x1aec <__utoa_common>

00001aea <__utoa_ncheck>:
    1aea:	bb 27       	eor	r27, r27

00001aec <__utoa_common>:
    1aec:	fb 01       	movw	r30, r22
    1aee:	55 27       	eor	r21, r21
    1af0:	aa 27       	eor	r26, r26
    1af2:	88 0f       	add	r24, r24
    1af4:	99 1f       	adc	r25, r25
    1af6:	aa 1f       	adc	r26, r26
    1af8:	a4 17       	cp	r26, r20
    1afa:	10 f0       	brcs	.+4      	; 0x1b00 <__utoa_common+0x14>
    1afc:	a4 1b       	sub	r26, r20
    1afe:	83 95       	inc	r24
    1b00:	50 51       	subi	r21, 0x10	; 16
    1b02:	b9 f7       	brne	.-18     	; 0x1af2 <__utoa_common+0x6>
    1b04:	a0 5d       	subi	r26, 0xD0	; 208
    1b06:	aa 33       	cpi	r26, 0x3A	; 58
    1b08:	08 f0       	brcs	.+2      	; 0x1b0c <__utoa_common+0x20>
    1b0a:	a9 5d       	subi	r26, 0xD9	; 217
    1b0c:	a1 93       	st	Z+, r26
    1b0e:	00 97       	sbiw	r24, 0x00	; 0
    1b10:	79 f7       	brne	.-34     	; 0x1af0 <__utoa_common+0x4>
    1b12:	b1 11       	cpse	r27, r1
    1b14:	b1 93       	st	Z+, r27
    1b16:	11 92       	st	Z+, r1
    1b18:	cb 01       	movw	r24, r22
    1b1a:	00 c0       	rjmp	.+0      	; 0x1b1c <strrev>

00001b1c <strrev>:
    1b1c:	dc 01       	movw	r26, r24
    1b1e:	fc 01       	movw	r30, r24
    1b20:	67 2f       	mov	r22, r23
    1b22:	71 91       	ld	r23, Z+
    1b24:	77 23       	and	r23, r23
    1b26:	e1 f7       	brne	.-8      	; 0x1b20 <strrev+0x4>
    1b28:	32 97       	sbiw	r30, 0x02	; 2
    1b2a:	04 c0       	rjmp	.+8      	; 0x1b34 <strrev+0x18>
    1b2c:	7c 91       	ld	r23, X
    1b2e:	6d 93       	st	X+, r22
    1b30:	70 83       	st	Z, r23
    1b32:	62 91       	ld	r22, -Z
    1b34:	ae 17       	cp	r26, r30
    1b36:	bf 07       	cpc	r27, r31
    1b38:	c8 f3       	brcs	.-14     	; 0x1b2c <strrev+0x10>
    1b3a:	08 95       	ret

00001b3c <_exit>:
    1b3c:	f8 94       	cli

00001b3e <__stop_program>:
    1b3e:	ff cf       	rjmp	.-2      	; 0x1b3e <__stop_program>
